var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var graphql_1 = require("graphql");
var index_1 = require("../polyfills/index");
var each_1 = __importDefault(require("./each"));
var updateEachKey_1 = __importDefault(require("./updateEachKey"));
var stub_1 = require("./stub");
var graphqlVersion_1 = require("./graphqlVersion");
var hasOwn = Object.prototype.hasOwnProperty;
/**
 * Update any references to named schema types that disagree with the named
 * types found in schema.getTypeMap().
 * @category Schema Utility
 */
function healSchema(schema) {
    var typeMap = schema.getTypeMap();
    var directives = schema.getDirectives();
    var queryType = schema.getQueryType();
    var mutationType = schema.getMutationType();
    var subscriptionType = schema.getSubscriptionType();
    var newQueryTypeName = queryType != null
        ? typeMap[queryType.name] != null
            ? typeMap[queryType.name].name
            : undefined
        : undefined;
    var newMutationTypeName = mutationType != null
        ? typeMap[mutationType.name] != null
            ? typeMap[mutationType.name].name
            : undefined
        : undefined;
    var newSubscriptionTypeName = subscriptionType != null
        ? typeMap[subscriptionType.name] != null
            ? typeMap[subscriptionType.name].name
            : undefined
        : undefined;
    healTypes(typeMap, directives);
    var filteredTypeMap = {};
    Object.keys(typeMap).forEach(function (typeName) {
        if (!typeName.startsWith('__')) {
            filteredTypeMap[typeName] = typeMap[typeName];
        }
    });
    var healedSchema = new graphql_1.GraphQLSchema(__assign(__assign({}, index_1.toConfig(schema)), { query: newQueryTypeName ? filteredTypeMap[newQueryTypeName] : undefined, mutation: newMutationTypeName
            ? filteredTypeMap[newMutationTypeName]
            : undefined, subscription: newSubscriptionTypeName
            ? filteredTypeMap[newSubscriptionTypeName]
            : undefined, types: Object.keys(filteredTypeMap).map(function (typeName) { return filteredTypeMap[typeName]; }), directives: directives.slice() }));
    // Reconstruct the schema to reinitialize private variables
    // e.g. the stored implementation map and the proper root types.
    Object.assign(schema, healedSchema);
    return schema;
}
exports.healSchema = healSchema;
/**
 * @category Schema Utility
 */
function healTypes(originalTypeMap, directives, config) {
    if (config === void 0) { config = {
        skipPruning: false,
    }; }
    var actualNamedTypeMap = Object.create(null);
    // If any of the .name properties of the GraphQLNamedType objects in
    // schema.getTypeMap() have changed, the keys of the type map need to
    // be updated accordingly.
    each_1.default(originalTypeMap, function (namedType, typeName) {
        if (namedType == null || typeName.startsWith('__')) {
            return;
        }
        var actualName = namedType.name;
        if (actualName.startsWith('__')) {
            return;
        }
        if (hasOwn.call(actualNamedTypeMap, actualName)) {
            throw new Error("Duplicate schema type name " + actualName);
        }
        actualNamedTypeMap[actualName] = namedType;
        // Note: we are deliberately leaving namedType in the schema by its
        // original name (which might be different from actualName), so that
        // references by that name can be healed.
    });
    // Now add back every named type by its actual name.
    each_1.default(actualNamedTypeMap, function (namedType, typeName) {
        originalTypeMap[typeName] = namedType;
    });
    // Directive declaration argument types can refer to named types.
    each_1.default(directives, function (decl) {
        updateEachKey_1.default(decl.args, function (arg) {
            arg.type = healType(arg.type);
            return arg.type === null ? null : arg;
        });
    });
    each_1.default(originalTypeMap, function (namedType, typeName) {
        // Heal all named types, except for dangling references, kept only to redirect.
        if (!typeName.startsWith('__') &&
            hasOwn.call(actualNamedTypeMap, typeName)) {
            if (namedType != null) {
                healNamedType(namedType);
            }
        }
    });
    updateEachKey_1.default(originalTypeMap, function (_namedType, typeName) {
        // Dangling references to renamed types should remain in the schema
        // during healing, but must be removed now, so that the following
        // invariant holds for all names: schema.getType(name).name === name
        if (!typeName.startsWith('__') &&
            !hasOwn.call(actualNamedTypeMap, typeName)) {
            return null;
        }
    });
    if (!config.skipPruning) {
        pruneTypes(originalTypeMap, directives);
    }
    function healNamedType(type) {
        if (graphql_1.isObjectType(type)) {
            healFields(type);
            healInterfaces(type);
            return;
        }
        else if (graphql_1.isInterfaceType(type)) {
            healFields(type);
            if (graphqlVersion_1.graphqlVersion() >= 15) {
                healInterfaces(type);
            }
            return;
        }
        else if (graphql_1.isUnionType(type)) {
            healUnderlyingTypes(type);
            return;
        }
        else if (graphql_1.isInputObjectType(type)) {
            healInputFields(type);
            return;
        }
        else if (graphql_1.isLeafType(type)) {
            return;
        }
        throw new Error("Unexpected schema type: " + type);
    }
    function healFields(type) {
        updateEachKey_1.default(type.getFields(), function (field) {
            updateEachKey_1.default(field.args, function (arg) {
                arg.type = healType(arg.type);
                return arg.type === null ? null : arg;
            });
            field.type = healType(field.type);
            return field.type === null ? null : field;
        });
    }
    function healInterfaces(type) {
        updateEachKey_1.default(type.getInterfaces(), function (iface) {
            var healedType = healType(iface);
            return healedType;
        });
    }
    function healInputFields(type) {
        updateEachKey_1.default(type.getFields(), function (field) {
            field.type = healType(field.type);
            return field.type === null ? null : field;
        });
    }
    function healUnderlyingTypes(type) {
        updateEachKey_1.default(type.getTypes(), function (t) {
            var healedType = healType(t);
            return healedType;
        });
    }
    function healType(type) {
        // Unwrap the two known wrapper types
        if (graphql_1.isListType(type)) {
            var healedType = healType(type.ofType);
            return healedType != null ? new graphql_1.GraphQLList(healedType) : null;
        }
        else if (graphql_1.isNonNullType(type)) {
            var healedType = healType(type.ofType);
            return healedType != null ? new graphql_1.GraphQLNonNull(healedType) : null;
        }
        else if (graphql_1.isNamedType(type)) {
            // If a type annotation on a field or an argument or a union member is
            // any `GraphQLNamedType` with a `name`, then it must end up identical
            // to `schema.getType(name)`, since `schema.getTypeMap()` is the source
            // of truth for all named schema types.
            // Note that new types can still be simply added by adding a field, as
            // the official type will be undefined, not null.
            var officialType = originalTypeMap[type.name];
            if (officialType === undefined) {
                if (stub_1.isStub(type)) {
                    officialType = stub_1.getBuiltInForStub(type);
                }
                else {
                    officialType = type;
                }
                originalTypeMap[type.name] = officialType;
            }
            return officialType;
        }
        return null;
    }
}
exports.healTypes = healTypes;
function pruneTypes(typeMap, directives) {
    var implementedInterfaces = {};
    each_1.default(typeMap, function (namedType) {
        if (graphql_1.isObjectType(namedType) ||
            (graphqlVersion_1.graphqlVersion() >= 15 && graphql_1.isInterfaceType(namedType))) {
            each_1.default(namedType.getInterfaces(), function (iface) {
                implementedInterfaces[iface.name] = true;
            });
        }
    });
    var prunedTypeMap = false;
    var typeNames = Object.keys(typeMap);
    for (var i = 0; i < typeNames.length; i++) {
        var typeName = typeNames[i];
        var type = typeMap[typeName];
        if (graphql_1.isObjectType(type) || graphql_1.isInputObjectType(type)) {
            // prune types with no fields
            if (!Object.keys(type.getFields()).length) {
                typeMap[typeName] = null;
                prunedTypeMap = true;
            }
        }
        else if (graphql_1.isUnionType(type)) {
            // prune unions without underlying types
            if (!type.getTypes().length) {
                typeMap[typeName] = null;
                prunedTypeMap = true;
            }
        }
        else if (graphql_1.isInterfaceType(type)) {
            // prune interfaces without fields or without implementations
            if (!Object.keys(type.getFields()).length ||
                !implementedInterfaces[type.name]) {
                typeMap[typeName] = null;
                prunedTypeMap = true;
            }
        }
    }
    // every prune requires another round of healing
    if (prunedTypeMap) {
        healTypes(typeMap, directives);
    }
}
//# sourceMappingURL=heal.js.map
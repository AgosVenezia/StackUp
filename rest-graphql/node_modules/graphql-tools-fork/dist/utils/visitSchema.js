var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var graphql_1 = require("graphql");
var Interfaces_1 = require("../Interfaces");
var updateEachKey_1 = __importDefault(require("./updateEachKey"));
var heal_1 = require("./heal");
var SchemaVisitor_1 = require("./SchemaVisitor");
var each_1 = __importDefault(require("./each"));
/**
 * Generic function for visiting GraphQLSchema objects.
 * @category Schema Utility
 */
function visitSchema(schema, 
// To accommodate as many different visitor patterns as possible, the
// visitSchema function does not simply accept a single instance of the
// SchemaVisitor class, but instead accepts a function that takes the
// current VisitableSchemaType object and the name of a visitor method and
// returns an array of SchemaVisitor instances that implement the visitor
// method and have an interest in handling the given VisitableSchemaType
// object. In the simplest case, this function can always return an array
// containing a single visitor object, without even looking at the type or
// methodName parameters. In other cases, this function might sometimes
// return an empty array to indicate there are no visitors that should be
// applied to the given VisitableSchemaType object. For an example of a
// visitor pattern that benefits from this abstraction, see the
// SchemaDirectiveVisitor class below.
visitorOrVisitorSelector) {
    var visitorSelector = typeof visitorOrVisitorSelector === 'function'
        ? visitorOrVisitorSelector
        : function () { return visitorOrVisitorSelector; };
    // Helper function that calls visitorSelector and applies the resulting
    // visitors to the given type, with arguments [type, ...args].
    function callMethod(methodName, type) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        var visitors = visitorSelector(type, methodName);
        visitors = Array.isArray(visitors) ? visitors : [visitors];
        var finalType = type;
        visitors.every(function (visitorOrVisitorDef) {
            var newType;
            if (visitorOrVisitorDef instanceof SchemaVisitor_1.SchemaVisitor) {
                newType = visitorOrVisitorDef[methodName].apply(visitorOrVisitorDef, __spreadArrays([finalType], args));
            }
            else if (graphql_1.isNamedType(finalType) &&
                (methodName === 'visitScalar' ||
                    methodName === 'visitEnum' ||
                    methodName === 'visitObject' ||
                    methodName === 'visitInputObject' ||
                    methodName === 'visitUnion' ||
                    methodName === 'visitInterface')) {
                var specifiers = getTypeSpecifiers(finalType, schema);
                var typeVisitor = getVisitor(visitorOrVisitorDef, specifiers);
                newType =
                    typeVisitor != null ? typeVisitor(finalType, schema) : undefined;
            }
            if (typeof newType === 'undefined') {
                // Keep going without modifying type.
                return true;
            }
            if (methodName === 'visitSchema' || graphql_1.isSchema(finalType)) {
                throw new Error("Method " + methodName + " cannot replace schema with " + newType);
            }
            if (newType === null) {
                // Stop the loop and return null form callMethod, which will cause
                // the type to be removed from the schema.
                finalType = null;
                return false;
            }
            // Update type to the new type returned by the visitor method, so that
            // later directives will see the new type, and callMethod will return
            // the final type.
            finalType = newType;
            return true;
        });
        // If there were no directives for this type object, or if all visitor
        // methods returned nothing, type will be returned unmodified.
        return finalType;
    }
    // Recursive helper function that calls any appropriate visitor methods for
    // each object in the schema, then traverses the object's children (if any).
    function visit(type) {
        if (graphql_1.isSchema(type)) {
            // Unlike the other types, the root GraphQLSchema object cannot be
            // replaced by visitor methods, because that would make life very hard
            // for SchemaVisitor subclasses that rely on the original schema object.
            callMethod('visitSchema', type);
            var typeMap_1 = type.getTypeMap();
            each_1.default(typeMap_1, function (namedType, typeName) {
                if (!typeName.startsWith('__') && namedType != null) {
                    // Call visit recursively to let it determine which concrete
                    // subclass of GraphQLNamedType we found in the type map.
                    // We do not use updateEachKey because we want to preserve
                    // deleted types in the typeMap so that other types that reference
                    // the deleted types can be healed.
                    typeMap_1[typeName] = visit(namedType);
                }
            });
            return type;
        }
        if (graphql_1.isObjectType(type)) {
            // Note that callMethod('visitObject', type) may not actually call any
            // methods, if there are no @directive annotations associated with this
            // type, or if this SchemaDirectiveVisitor subclass does not override
            // the visitObject method.
            var newObject = callMethod('visitObject', type);
            if (newObject != null) {
                visitFields(newObject);
            }
            return newObject;
        }
        if (graphql_1.isInterfaceType(type)) {
            var newInterface = callMethod('visitInterface', type);
            if (newInterface != null) {
                visitFields(newInterface);
            }
            return newInterface;
        }
        if (graphql_1.isInputObjectType(type)) {
            var newInputObject_1 = callMethod('visitInputObject', type);
            if (newInputObject_1 != null) {
                var fieldMap = newInputObject_1.getFields();
                updateEachKey_1.default(fieldMap, function (field) {
                    return callMethod('visitInputFieldDefinition', field, {
                        // Since we call a different method for input object fields, we
                        // can't reuse the visitFields function here.
                        objectType: newInputObject_1,
                    });
                });
            }
            return newInputObject_1;
        }
        if (graphql_1.isScalarType(type)) {
            return callMethod('visitScalar', type);
        }
        if (graphql_1.isUnionType(type)) {
            return callMethod('visitUnion', type);
        }
        if (graphql_1.isEnumType(type)) {
            var newEnum_1 = callMethod('visitEnum', type);
            if (newEnum_1 != null) {
                updateEachKey_1.default(newEnum_1.getValues(), function (value) {
                    return callMethod('visitEnumValue', value, {
                        enumType: newEnum_1,
                    });
                });
            }
            return newEnum_1;
        }
        throw new Error("Unexpected schema type: " + type);
    }
    function visitFields(type) {
        updateEachKey_1.default(type.getFields(), function (field) {
            // It would be nice if we could call visit(field) recursively here, but
            // GraphQLField is merely a type, not a value that can be detected using
            // an instanceof check, so we have to visit the fields in this lexical
            // context, so that TypeScript can validate the call to
            // visitFieldDefinition.
            var newField = callMethod('visitFieldDefinition', field, {
                // While any field visitor needs a reference to the field object, some
                // field visitors may also need to know the enclosing (parent) type,
                // perhaps to determine if the parent is a GraphQLObjectType or a
                // GraphQLInterfaceType. To obtain a reference to the parent, a
                // visitor method can have a second parameter, which will be an object
                // with an .objectType property referring to the parent.
                objectType: type,
            });
            if (newField.args != null) {
                updateEachKey_1.default(newField.args, function (arg) {
                    return callMethod('visitArgumentDefinition', arg, {
                        // Like visitFieldDefinition, visitArgumentDefinition takes a
                        // second parameter that provides additional context, namely the
                        // parent .field and grandparent .objectType. Remember that the
                        // current GraphQLSchema is always available via this.schema.
                        field: newField,
                        objectType: type,
                    });
                });
            }
            return newField;
        });
    }
    visit(schema);
    // Automatically update any references to named schema types replaced
    // during the traversal, so implementors don't have to worry about that.
    heal_1.healSchema(schema);
    // Return schema for convenience, even though schema parameter has all updated types.
    return schema;
}
exports.visitSchema = visitSchema;
function getTypeSpecifiers(type, schema) {
    var specifiers = [Interfaces_1.VisitSchemaKind.TYPE];
    if (graphql_1.isObjectType(type)) {
        specifiers.push(Interfaces_1.VisitSchemaKind.COMPOSITE_TYPE, Interfaces_1.VisitSchemaKind.OBJECT_TYPE);
        var query = schema.getQueryType();
        var mutation = schema.getMutationType();
        var subscription = schema.getSubscriptionType();
        if (type === query) {
            specifiers.push(Interfaces_1.VisitSchemaKind.ROOT_OBJECT, Interfaces_1.VisitSchemaKind.QUERY);
        }
        else if (type === mutation) {
            specifiers.push(Interfaces_1.VisitSchemaKind.ROOT_OBJECT, Interfaces_1.VisitSchemaKind.MUTATION);
        }
        else if (type === subscription) {
            specifiers.push(Interfaces_1.VisitSchemaKind.ROOT_OBJECT, Interfaces_1.VisitSchemaKind.SUBSCRIPTION);
        }
    }
    else if (graphql_1.isInputType(type)) {
        specifiers.push(Interfaces_1.VisitSchemaKind.INPUT_OBJECT_TYPE);
    }
    else if (graphql_1.isInterfaceType(type)) {
        specifiers.push(Interfaces_1.VisitSchemaKind.COMPOSITE_TYPE, Interfaces_1.VisitSchemaKind.ABSTRACT_TYPE, Interfaces_1.VisitSchemaKind.INTERFACE_TYPE);
    }
    else if (graphql_1.isUnionType(type)) {
        specifiers.push(Interfaces_1.VisitSchemaKind.COMPOSITE_TYPE, Interfaces_1.VisitSchemaKind.ABSTRACT_TYPE, Interfaces_1.VisitSchemaKind.UNION_TYPE);
    }
    else if (graphql_1.isEnumType(type)) {
        specifiers.push(Interfaces_1.VisitSchemaKind.ENUM_TYPE);
    }
    else if (graphql_1.isScalarType(type)) {
        specifiers.push(Interfaces_1.VisitSchemaKind.SCALAR_TYPE);
    }
    return specifiers;
}
function getVisitor(visitorDef, specifiers) {
    var typeVisitor;
    var stack = __spreadArrays(specifiers);
    while (!typeVisitor && stack.length > 0) {
        var next = stack.pop();
        typeVisitor = visitorDef[next];
    }
    return typeVisitor != null ? typeVisitor : null;
}
//# sourceMappingURL=visitSchema.js.map
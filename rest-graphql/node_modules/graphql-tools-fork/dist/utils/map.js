var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var graphql_1 = require("graphql");
var index_1 = require("../polyfills/index");
var index_2 = require("../utils/index");
var Interfaces_1 = require("../Interfaces");
/**
 * @category Schema Utility
 */
function mapSchema(schema, schemaMapper) {
    if (schemaMapper === void 0) { schemaMapper = {}; }
    var originalTypeMap = schema.getTypeMap();
    var newTypeMap = {};
    Object.keys(originalTypeMap).forEach(function (typeName) {
        if (!typeName.startsWith('__')) {
            var typeMapper = getMapper(schema, schemaMapper, originalTypeMap[typeName]);
            if (typeMapper != null) {
                var newType = typeMapper(originalTypeMap[typeName], schema);
                newTypeMap[typeName] =
                    newType !== undefined ? newType : originalTypeMap[typeName];
            }
            else {
                newTypeMap[typeName] = originalTypeMap[typeName];
            }
        }
    });
    var queryType = schema.getQueryType();
    var mutationType = schema.getMutationType();
    var subscriptionType = schema.getSubscriptionType();
    var newQueryTypeName = queryType != null
        ? newTypeMap[queryType.name] != null
            ? newTypeMap[queryType.name].name
            : undefined
        : undefined;
    var newMutationTypeName = mutationType != null
        ? newTypeMap[mutationType.name] != null
            ? newTypeMap[mutationType.name].name
            : undefined
        : undefined;
    var newSubscriptionTypeName = subscriptionType != null
        ? newTypeMap[subscriptionType.name] != null
            ? newTypeMap[subscriptionType.name].name
            : undefined
        : undefined;
    var originalDirectives = schema.getDirectives();
    var newDirectives = [];
    originalDirectives.forEach(function (directive) {
        var directiveMapper = getMapper(schema, schemaMapper, directive);
        if (directiveMapper != null) {
            var newDirective = directiveMapper(directive, schema);
            if (newDirective != null) {
                newDirectives.push(newDirective);
            }
        }
        else {
            newDirectives.push(directive);
        }
    });
    var _a = rewireTypes(newTypeMap, newDirectives), typeMap = _a.typeMap, directives = _a.directives;
    return new graphql_1.GraphQLSchema(__assign(__assign({}, index_1.toConfig(schema)), { query: newQueryTypeName
            ? typeMap[newQueryTypeName]
            : undefined, mutation: newMutationTypeName
            ? typeMap[newMutationTypeName]
            : undefined, subscription: newSubscriptionTypeName != null
            ? typeMap[newSubscriptionTypeName]
            : undefined, types: Object.keys(typeMap).map(function (typeName) { return typeMap[typeName]; }), directives: directives }));
}
exports.mapSchema = mapSchema;
function getTypeSpecifiers(type, schema) {
    var specifiers = [Interfaces_1.MapperKind.TYPE];
    if (graphql_1.isObjectType(type)) {
        specifiers.push(Interfaces_1.MapperKind.COMPOSITE_TYPE, Interfaces_1.MapperKind.OBJECT_TYPE);
        var query = schema.getQueryType();
        var mutation = schema.getMutationType();
        var subscription = schema.getSubscriptionType();
        if (type === query) {
            specifiers.push(Interfaces_1.MapperKind.ROOT_OBJECT, Interfaces_1.MapperKind.QUERY);
        }
        else if (type === mutation) {
            specifiers.push(Interfaces_1.MapperKind.ROOT_OBJECT, Interfaces_1.MapperKind.MUTATION);
        }
        else if (type === subscription) {
            specifiers.push(Interfaces_1.MapperKind.ROOT_OBJECT, Interfaces_1.MapperKind.SUBSCRIPTION);
        }
    }
    else if (graphql_1.isInputType(type)) {
        specifiers.push(Interfaces_1.MapperKind.INPUT_OBJECT_TYPE);
    }
    else if (graphql_1.isInterfaceType(type)) {
        specifiers.push(Interfaces_1.MapperKind.COMPOSITE_TYPE, Interfaces_1.MapperKind.ABSTRACT_TYPE, Interfaces_1.MapperKind.INTERFACE_TYPE);
    }
    else if (graphql_1.isUnionType(type)) {
        specifiers.push(Interfaces_1.MapperKind.COMPOSITE_TYPE, Interfaces_1.MapperKind.ABSTRACT_TYPE, Interfaces_1.MapperKind.UNION_TYPE);
    }
    else if (graphql_1.isEnumType(type)) {
        specifiers.push(Interfaces_1.MapperKind.ENUM_TYPE);
    }
    else if (graphql_1.isScalarType(type)) {
        specifiers.push(Interfaces_1.MapperKind.SCALAR_TYPE);
    }
    return specifiers;
}
function getMapper(schema, schemaMapper, typeOrDirective) {
    if (graphql_1.isNamedType(typeOrDirective)) {
        var specifiers = getTypeSpecifiers(typeOrDirective, schema);
        var typeMapper = void 0;
        var stack = __spreadArrays(specifiers);
        while (!typeMapper && stack.length > 0) {
            var next = stack.pop();
            typeMapper = schemaMapper[next];
        }
        return typeMapper != null ? typeMapper : null;
    }
    else if (graphql_1.isDirective(typeOrDirective)) {
        var directiveMapper = schemaMapper[Interfaces_1.MapperKind.DIRECTIVE];
        return directiveMapper != null ? directiveMapper : null;
    }
}
function rewireTypes(originalTypeMap, directives) {
    var newTypeMap = Object.create(null);
    Object.keys(originalTypeMap).forEach(function (typeName) {
        var namedType = originalTypeMap[typeName];
        if (namedType == null || typeName.startsWith('__')) {
            return;
        }
        var newName = namedType.name;
        if (newName.startsWith('__')) {
            return;
        }
        if (newTypeMap[newName] != null) {
            throw new Error("Duplicate schema type name " + newName);
        }
        newTypeMap[newName] = namedType;
    });
    Object.keys(newTypeMap).forEach(function (typeName) {
        newTypeMap[typeName] = rewireNamedType(newTypeMap[typeName]);
    });
    var newDirectives = directives.map(function (directive) {
        return rewireDirective(directive);
    });
    return pruneTypes(newTypeMap, newDirectives);
    function rewireDirective(directive) {
        var directiveConfig = index_1.toConfig(directive);
        directiveConfig.args = rewireArgs(directiveConfig.args);
        return new graphql_1.GraphQLDirective(directiveConfig);
    }
    function rewireArgs(args) {
        var rewiredArgs = {};
        Object.keys(args).forEach(function (argName) {
            var arg = args[argName];
            var rewiredArgType = rewireType(arg.type);
            if (rewiredArgType != null) {
                arg.type = rewiredArgType;
                rewiredArgs[argName] = arg;
            }
        });
        return rewiredArgs;
    }
    function rewireNamedType(type) {
        if (graphql_1.isObjectType(type)) {
            var config_1 = index_1.toConfig(type);
            var newConfig = __assign(__assign({}, config_1), { fields: function () { return rewireFields(config_1.fields); }, interfaces: function () { return rewireNamedTypes(config_1.interfaces); } });
            return new graphql_1.GraphQLObjectType(newConfig);
        }
        else if (graphql_1.isInterfaceType(type)) {
            var config_2 = index_1.toConfig(type);
            var newConfig = __assign(__assign({}, config_2), { fields: function () { return rewireFields(config_2.fields); } });
            if (index_2.graphqlVersion() >= 15) {
                newConfig.interfaces = function () {
                    return rewireNamedTypes(config_2
                        .interfaces);
                };
            }
            return new graphql_1.GraphQLInterfaceType(newConfig);
        }
        else if (graphql_1.isUnionType(type)) {
            var config_3 = index_1.toConfig(type);
            var newConfig = __assign(__assign({}, config_3), { types: function () { return rewireNamedTypes(config_3.types); } });
            return new graphql_1.GraphQLUnionType(newConfig);
        }
        else if (graphql_1.isInputObjectType(type)) {
            var config_4 = index_1.toConfig(type);
            var newConfig = __assign(__assign({}, config_4), { fields: function () { return rewireInputFields(config_4.fields); } });
            return new graphql_1.GraphQLInputObjectType(newConfig);
        }
        else if (graphql_1.isEnumType(type)) {
            var enumConfig = index_1.toConfig(type);
            return new graphql_1.GraphQLEnumType(enumConfig);
        }
        else if (graphql_1.isScalarType(type)) {
            if (index_1.isSpecifiedScalarType(type)) {
                return type;
            }
            var scalarConfig = index_1.toConfig(type);
            return new graphql_1.GraphQLScalarType(scalarConfig);
        }
        throw new Error("Unexpected schema type: " + type);
    }
    function rewireFields(fields) {
        var rewiredFields = {};
        Object.keys(fields).forEach(function (fieldName) {
            var field = fields[fieldName];
            var rewiredFieldType = rewireType(field.type);
            if (rewiredFieldType != null) {
                field.type = rewiredFieldType;
                field.args = rewireArgs(field.args);
                rewiredFields[fieldName] = field;
            }
        });
        return rewiredFields;
    }
    function rewireInputFields(fields) {
        var rewiredFields = {};
        Object.keys(fields).forEach(function (fieldName) {
            var field = fields[fieldName];
            var rewiredFieldType = rewireType(field.type);
            if (rewiredFieldType != null) {
                field.type = rewiredFieldType;
                rewiredFields[fieldName] = field;
            }
        });
        return rewiredFields;
    }
    function rewireNamedTypes(namedTypes) {
        var rewiredTypes = [];
        namedTypes.forEach(function (namedType) {
            var rewiredType = rewireType(namedType);
            if (rewiredType != null) {
                rewiredTypes.push(rewiredType);
            }
        });
        return rewiredTypes;
    }
    function rewireType(type) {
        if (graphql_1.isListType(type)) {
            var rewiredType = rewireType(type.ofType);
            return rewiredType != null ? new graphql_1.GraphQLList(rewiredType) : null;
        }
        else if (graphql_1.isNonNullType(type)) {
            var rewiredType = rewireType(type.ofType);
            return rewiredType != null
                ? new graphql_1.GraphQLNonNull(rewiredType)
                : null;
        }
        else if (graphql_1.isNamedType(type)) {
            var originalType = originalTypeMap[type.name];
            return originalType != null ? newTypeMap[originalType.name] : null;
        }
        return null;
    }
}
exports.rewireTypes = rewireTypes;
function pruneTypes(typeMap, directives) {
    var newTypeMap = {};
    var implementedInterfaces = {};
    Object.keys(typeMap).forEach(function (typeName) {
        var namedType = typeMap[typeName];
        if (graphql_1.isObjectType(namedType) ||
            (index_2.graphqlVersion() >= 15 && graphql_1.isInterfaceType(namedType))) {
            namedType.getInterfaces().forEach(function (iface) {
                implementedInterfaces[iface.name] = true;
            });
        }
    });
    var prunedTypeMap = false;
    var typeNames = Object.keys(typeMap);
    for (var i = 0; i < typeNames.length; i++) {
        var typeName = typeNames[i];
        var type = typeMap[typeName];
        if (graphql_1.isObjectType(type) || graphql_1.isInputObjectType(type)) {
            // prune types with no fields
            if (Object.keys(type.getFields()).length) {
                newTypeMap[typeName] = type;
            }
            else {
                prunedTypeMap = true;
            }
        }
        else if (graphql_1.isUnionType(type)) {
            // prune unions without underlying types
            if (type.getTypes().length) {
                newTypeMap[typeName] = type;
            }
            else {
                prunedTypeMap = true;
            }
        }
        else if (graphql_1.isInterfaceType(type)) {
            // prune interfaces without fields or without implementations
            if (Object.keys(type.getFields()).length &&
                implementedInterfaces[type.name]) {
                newTypeMap[typeName] = type;
            }
            else {
                prunedTypeMap = true;
            }
        }
        else {
            newTypeMap[typeName] = type;
        }
    }
    // every prune requires another round of healing
    return prunedTypeMap
        ? rewireTypes(newTypeMap, directives)
        : { typeMap: typeMap, directives: directives };
}
//# sourceMappingURL=map.js.map
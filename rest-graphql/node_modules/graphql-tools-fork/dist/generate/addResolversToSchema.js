var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var graphql_1 = require("graphql");
var index_1 = require("../utils/index");
var index_2 = require("../polyfills/index");
var SchemaError_1 = __importDefault(require("./SchemaError"));
var checkForResolveTypeResolver_1 = __importDefault(require("./checkForResolveTypeResolver"));
var extendResolversFromInterfaces_1 = __importDefault(require("./extendResolversFromInterfaces"));
function addResolversToSchema(schemaOrOptions, legacyInputResolvers, legacyInputValidationOptions) {
    var options = graphql_1.isSchema(schemaOrOptions)
        ? {
            schema: schemaOrOptions,
            resolvers: legacyInputResolvers,
            resolverValidationOptions: legacyInputValidationOptions,
        }
        : schemaOrOptions;
    var schema = options.schema, inputResolvers = options.resolvers, defaultFieldResolver = options.defaultFieldResolver, _a = options.resolverValidationOptions, resolverValidationOptions = _a === void 0 ? {} : _a, _b = options.inheritResolversFromInterfaces, inheritResolversFromInterfaces = _b === void 0 ? false : _b;
    var _c = resolverValidationOptions.allowResolversNotInSchema, allowResolversNotInSchema = _c === void 0 ? false : _c, requireResolversForResolveType = resolverValidationOptions.requireResolversForResolveType;
    var resolvers = inheritResolversFromInterfaces
        ? extendResolversFromInterfaces_1.default(schema, inputResolvers)
        : inputResolvers;
    var typeMap = schema.getTypeMap();
    Object.keys(resolvers).forEach(function (typeName) {
        var resolverValue = resolvers[typeName];
        var resolverType = typeof resolverValue;
        if (resolverType !== 'object' && resolverType !== 'function') {
            throw new SchemaError_1.default("\"" + typeName + "\" defined in resolvers, but has invalid value \"" + resolverValue + "\". A resolver's value must be of type object or function.");
        }
        var type = schema.getType(typeName);
        if (!type && typeName !== '__schema') {
            if (allowResolversNotInSchema) {
                return;
            }
            throw new SchemaError_1.default("\"" + typeName + "\" defined in resolvers, but not in schema");
        }
        if (graphql_1.isScalarType(type)) {
            // Support -- without recommending -- overriding default scalar types
            Object.keys(resolverValue).forEach(function (fieldName) {
                if (fieldName.startsWith('__')) {
                    type[fieldName.substring(2)] = resolverValue[fieldName];
                }
                else {
                    type[fieldName] = resolverValue[fieldName];
                }
            });
        }
        else if (graphql_1.isEnumType(type)) {
            // We've encountered an enum resolver that is being used to provide an
            // internal enum value.
            // Reference: https://www.apollographql.com/docs/graphql-tools/scalars.html#internal-values
            Object.keys(resolverValue).forEach(function (fieldName) {
                if (!type.getValue(fieldName)) {
                    if (allowResolversNotInSchema) {
                        return;
                    }
                    throw new SchemaError_1.default(typeName + "." + fieldName + " was defined in resolvers, but enum is not in schema");
                }
            });
            var config = index_2.toConfig(type);
            var values = type.getValues();
            var newValues_1 = {};
            values.forEach(function (value) {
                var newValue = Object.keys(resolverValue).includes(value.name)
                    ? resolverValue[value.name]
                    : value.name;
                newValues_1[value.name] = {
                    value: newValue,
                    deprecationReason: value.deprecationReason,
                    description: value.description,
                    astNode: value.astNode,
                };
            });
            // healSchema called later to update all fields to new type
            typeMap[typeName] = new graphql_1.GraphQLEnumType(__assign(__assign({}, config), { values: newValues_1 }));
        }
        else if (graphql_1.isUnionType(type)) {
            Object.keys(resolverValue).forEach(function (fieldName) {
                if (fieldName.startsWith('__')) {
                    // this is for isTypeOf and resolveType and all the other stuff.
                    type[fieldName.substring(2)] = resolverValue[fieldName];
                    return;
                }
                if (allowResolversNotInSchema) {
                    return;
                }
                throw new SchemaError_1.default(typeName + " was defined in resolvers, but it's not an object");
            });
        }
        else if (graphql_1.isObjectType(type) || graphql_1.isInterfaceType(type)) {
            Object.keys(resolverValue).forEach(function (fieldName) {
                if (fieldName.startsWith('__')) {
                    // this is for isTypeOf and resolveType and all the other stuff.
                    type[fieldName.substring(2)] = resolverValue[fieldName];
                    return;
                }
                var fields = type.getFields();
                var field = fields[fieldName];
                if (field == null) {
                    if (allowResolversNotInSchema) {
                        return;
                    }
                    throw new SchemaError_1.default(typeName + "." + fieldName + " defined in resolvers, but not in schema");
                }
                var fieldResolve = resolverValue[fieldName];
                if (typeof fieldResolve === 'function') {
                    // for convenience. Allows shorter syntax in resolver definition file
                    field.resolve = fieldResolve;
                }
                else {
                    if (typeof fieldResolve !== 'object') {
                        throw new SchemaError_1.default("Resolver " + typeName + "." + fieldName + " must be object or function");
                    }
                    setFieldProperties(field, fieldResolve);
                }
            });
        }
    });
    checkForResolveTypeResolver_1.default(schema, requireResolversForResolveType);
    // serialize all default values prior to healing fields with new scalar/enum types.
    index_1.forEachDefaultValue(schema, index_1.serializeInputValue);
    // schema may have new scalar/enum types that require healing
    index_1.healSchema(schema);
    // reparse all default values with new parsing functions.
    index_1.forEachDefaultValue(schema, index_1.parseInputValue);
    if (defaultFieldResolver != null) {
        index_1.forEachField(schema, function (field) {
            if (!field.resolve) {
                field.resolve = defaultFieldResolver;
            }
        });
    }
    return schema;
}
function setFieldProperties(field, propertiesObj) {
    Object.keys(propertiesObj).forEach(function (propertyName) {
        field[propertyName] = propertiesObj[propertyName];
    });
}
exports.default = addResolversToSchema;
//# sourceMappingURL=addResolversToSchema.js.map
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var graphql_1 = require("graphql");
var extensionDefinitions_1 = require("./extensionDefinitions");
var concatenateTypeDefs_1 = __importDefault(require("./concatenateTypeDefs"));
var SchemaError_1 = __importDefault(require("./SchemaError"));
function buildSchemaFromTypeDefinitions(typeDefinitions, parseOptions) {
    // TODO: accept only array here, otherwise interfaces get confusing.
    var myDefinitions = typeDefinitions;
    var astDocument;
    if (isDocumentNode(typeDefinitions)) {
        astDocument = typeDefinitions;
    }
    else if (typeof myDefinitions !== 'string') {
        if (!Array.isArray(myDefinitions)) {
            var type = typeof myDefinitions;
            throw new SchemaError_1.default("typeDefs must be a string, array or schema AST, got " + type);
        }
        myDefinitions = concatenateTypeDefs_1.default(myDefinitions);
    }
    if (typeof myDefinitions === 'string') {
        astDocument = graphql_1.parse(myDefinitions, parseOptions);
    }
    var typesAst = extensionDefinitions_1.filterExtensionDefinitions(astDocument);
    var backcompatOptions = { commentDescriptions: true };
    var schema = graphql_1.buildASTSchema(typesAst, backcompatOptions);
    var extensionsAst = extensionDefinitions_1.extractExtensionDefinitions(astDocument);
    if (extensionsAst.definitions.length > 0) {
        schema = graphql_1.extendSchema(schema, extensionsAst, backcompatOptions);
    }
    return schema;
}
function isDocumentNode(typeDefinitions) {
    return typeDefinitions.kind !== undefined;
}
exports.default = buildSchemaFromTypeDefinitions;
//# sourceMappingURL=buildSchemaFromTypeDefinitions.js.map
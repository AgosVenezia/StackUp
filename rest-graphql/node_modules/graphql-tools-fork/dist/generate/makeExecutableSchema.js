var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var graphql_1 = require("graphql");
var index_1 = require("../utils/index");
var attachDirectiveResolvers_1 = __importDefault(require("./attachDirectiveResolvers"));
var assertResolversPresent_1 = __importDefault(require("./assertResolversPresent"));
var addResolversToSchema_1 = __importDefault(require("./addResolversToSchema"));
var attachConnectorsToContext_1 = __importDefault(require("./attachConnectorsToContext"));
var addSchemaLevelResolver_1 = __importDefault(require("./addSchemaLevelResolver"));
var buildSchemaFromTypeDefinitions_1 = __importDefault(require("./buildSchemaFromTypeDefinitions"));
var decorateWithLogger_1 = __importDefault(require("./decorateWithLogger"));
var SchemaError_1 = __importDefault(require("./SchemaError"));
function makeExecutableSchema(_a) {
    var typeDefs = _a.typeDefs, _b = _a.resolvers, resolvers = _b === void 0 ? {} : _b, connectors = _a.connectors, logger = _a.logger, _c = _a.allowUndefinedInResolve, allowUndefinedInResolve = _c === void 0 ? true : _c, _d = _a.resolverValidationOptions, resolverValidationOptions = _d === void 0 ? {} : _d, directiveResolvers = _a.directiveResolvers, schemaDirectives = _a.schemaDirectives, _e = _a.parseOptions, parseOptions = _e === void 0 ? {} : _e, _f = _a.inheritResolversFromInterfaces, inheritResolversFromInterfaces = _f === void 0 ? false : _f;
    // Validate and clean up arguments
    if (typeof resolverValidationOptions !== 'object') {
        throw new SchemaError_1.default('Expected `resolverValidationOptions` to be an object');
    }
    if (!typeDefs) {
        throw new SchemaError_1.default('Must provide typeDefs');
    }
    // We allow passing in an array of resolver maps, in which case we merge them
    var resolverMap = Array.isArray(resolvers)
        ? resolvers
            .filter(function (resolverObj) { return typeof resolverObj === 'object'; })
            .reduce(index_1.mergeDeep, {})
        : resolvers;
    // Arguments are now validated and cleaned up
    var schema = buildSchemaFromTypeDefinitions_1.default(typeDefs, parseOptions);
    addResolversToSchema_1.default({
        schema: schema,
        resolvers: resolverMap,
        resolverValidationOptions: resolverValidationOptions,
        inheritResolversFromInterfaces: inheritResolversFromInterfaces,
    });
    assertResolversPresent_1.default(schema, resolverValidationOptions);
    if (!allowUndefinedInResolve) {
        addCatchUndefinedToSchema(schema);
    }
    if (logger != null) {
        addErrorLoggingToSchema(schema, logger);
    }
    if (typeof resolvers['__schema'] === 'function') {
        // TODO a bit of a hack now, better rewrite generateSchema to attach it there.
        // not doing that now, because I'd have to rewrite a lot of tests.
        addSchemaLevelResolver_1.default(schema, resolvers['__schema']);
    }
    if (connectors != null) {
        // connectors are optional, at least for now. That means you can just import them in the resolve
        // function if you want.
        attachConnectorsToContext_1.default(schema, connectors);
    }
    if (directiveResolvers != null) {
        attachDirectiveResolvers_1.default(schema, directiveResolvers);
    }
    if (schemaDirectives != null) {
        index_1.SchemaDirectiveVisitor.visitSchemaDirectives(schema, schemaDirectives);
    }
    return schema;
}
exports.makeExecutableSchema = makeExecutableSchema;
function decorateToCatchUndefined(fn, hint) {
    var resolve = fn == null ? graphql_1.defaultFieldResolver : fn;
    return function (root, args, ctx, info) {
        var result = resolve(root, args, ctx, info);
        if (typeof result === 'undefined') {
            throw new Error("Resolver for \"" + hint + "\" returned undefined");
        }
        return result;
    };
}
function addCatchUndefinedToSchema(schema) {
    index_1.forEachField(schema, function (field, typeName, fieldName) {
        var errorHint = typeName + "." + fieldName;
        field.resolve = decorateToCatchUndefined(field.resolve, errorHint);
    });
}
exports.addCatchUndefinedToSchema = addCatchUndefinedToSchema;
function addErrorLoggingToSchema(schema, logger) {
    if (!logger) {
        throw new Error('Must provide a logger');
    }
    if (typeof logger.log !== 'function') {
        throw new Error('Logger.log must be a function');
    }
    index_1.forEachField(schema, function (field, typeName, fieldName) {
        var errorHint = typeName + "." + fieldName;
        field.resolve = decorateWithLogger_1.default(field.resolve, logger, errorHint);
    });
}
exports.addErrorLoggingToSchema = addErrorLoggingToSchema;
//# sourceMappingURL=makeExecutableSchema.js.map
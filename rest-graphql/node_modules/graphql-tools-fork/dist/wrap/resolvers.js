var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var delegateToSchema_1 = __importDefault(require("../delegate/delegateToSchema"));
var checkResultAndHandleErrors_1 = require("../delegate/checkResultAndHandleErrors");
var makeMergedType_1 = require("../stitch/makeMergedType");
var getResponseKeyFromInfo_1 = require("../stitch/getResponseKeyFromInfo");
var proxiedResult_1 = require("../stitch/proxiedResult");
function generateProxyingResolvers(_a) {
    var subschemaConfig = _a.subschemaConfig, transforms = _a.transforms, _b = _a.createProxyingResolver, createProxyingResolver = _b === void 0 ? defaultCreateProxyingResolver : _b;
    var targetSchema = subschemaConfig.schema;
    var mapping = generateSimpleMapping(targetSchema);
    var result = {};
    Object.keys(mapping).forEach(function (name) {
        result[name] = {};
        var innerMapping = mapping[name];
        Object.keys(innerMapping).forEach(function (from) {
            var _a;
            var to = innerMapping[from];
            var resolverType = to.operation === 'subscription' ? 'subscribe' : 'resolve';
            result[name][from] = (_a = {},
                _a[resolverType] = createProxyingResolver({
                    schema: subschemaConfig,
                    transforms: transforms,
                    operation: to.operation,
                    fieldName: to.name,
                }),
                _a);
        });
    });
    return result;
}
exports.generateProxyingResolvers = generateProxyingResolvers;
function generateSimpleMapping(targetSchema) {
    var query = targetSchema.getQueryType();
    var mutation = targetSchema.getMutationType();
    var subscription = targetSchema.getSubscriptionType();
    var result = {};
    if (query != null) {
        result[query.name] = generateMappingFromObjectType(query, 'query');
    }
    if (mutation != null) {
        result[mutation.name] = generateMappingFromObjectType(mutation, 'mutation');
    }
    if (subscription != null) {
        result[subscription.name] = generateMappingFromObjectType(subscription, 'subscription');
    }
    return result;
}
exports.generateSimpleMapping = generateSimpleMapping;
function generateMappingFromObjectType(type, operation) {
    var result = {};
    var fields = type.getFields();
    Object.keys(fields).forEach(function (fieldName) {
        result[fieldName] = {
            name: fieldName,
            operation: operation,
        };
    });
    return result;
}
exports.generateMappingFromObjectType = generateMappingFromObjectType;
function defaultCreateProxyingResolver(_a) {
    var schema = _a.schema, transforms = _a.transforms;
    return function (parent, _args, context, info) {
        if (parent != null) {
            var responseKey = getResponseKeyFromInfo_1.getResponseKeyFromInfo(info);
            var errors = proxiedResult_1.getErrors(parent, responseKey);
            if (errors != null) {
                var subschema = proxiedResult_1.getSubschema(parent, responseKey);
                // if parent contains a proxied result from this subschema, can return that result
                if (schema === subschema) {
                    var result = parent[responseKey];
                    return checkResultAndHandleErrors_1.handleResult(result, errors, subschema, context, info);
                }
            }
        }
        return delegateToSchema_1.default({
            schema: schema,
            context: context,
            info: info,
            transforms: transforms,
        });
    };
}
function stripResolvers(schema) {
    var typeMap = schema.getTypeMap();
    Object.keys(typeMap).forEach(function (typeName) {
        if (!typeName.startsWith('__')) {
            makeMergedType_1.makeMergedType(typeMap[typeName]);
        }
    });
}
exports.stripResolvers = stripResolvers;
//# sourceMappingURL=resolvers.js.map
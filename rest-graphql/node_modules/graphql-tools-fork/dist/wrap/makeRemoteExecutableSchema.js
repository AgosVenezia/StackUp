var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var graphql_1 = require("graphql");
var index_1 = require("../generate/index");
var index_2 = require("../utils/index");
var index_3 = require("../polyfills/index");
var addTypenameToAbstract_1 = require("../delegate/addTypenameToAbstract");
var checkResultAndHandleErrors_1 = require("../delegate/checkResultAndHandleErrors");
var linkToFetcher_1 = __importStar(require("../stitch/linkToFetcher"));
var observableToAsyncIterable_1 = require("../stitch/observableToAsyncIterable");
var mapAsyncIterator_1 = __importDefault(require("../stitch/mapAsyncIterator"));
var resolvers_1 = require("./resolvers");
/**
 * It can be valuable to be able to treat remote GraphQL endpoints as if they were local executable schemas. This is especially useful for [schema stitching](/schema-stitching/), but there may be other use cases.
 *
 * Generally, to create a remote schema, you need three steps:
 *
 * 1. Create a [link](#creating-a-link) that can retrieve results from that schema
 * 2. Use [`introspectSchema`](#introspectschemafetcher-context) to get the schema of the remote server
 * 3. Use [`makeRemoteExecutableSchema`](#makeremoteexecutableschemaoptions) to create a schema that uses the link to delegate requests to the underlying service
 *
 * We've chosen to split this functionality up to give you the flexibility to choose when to do the introspection step. For example, you might already have the remote schema information, allowing you to skip the `introspectSchema` step entirely. Here's a complete example:
 *
 * ```
 * import { HttpLink } from 'apollo-link-http';
 * import fetch from 'node-fetch';
 *
 * const link = new HttpLink({ uri: 'http://api.githunt.com/graphql', fetch });
 *
 * export default async () => {
 *   const schema = await introspectSchema(link);
 *
 *   const executableSchema = makeRemoteExecutableSchema({
 *     schema,
 *     link,
 *   });
 *
 *   return executableSchema
 * }
 *
 * ```
 *
 * Now, let's look at all the parts separately.
 *
 * ## Creating a Link
 *
 * A link is a function capable of retrieving GraphQL results. It is the same way that Apollo Client handles fetching data and is used by several `graphql-tools` features to do introspection or fetch results during execution. Using an Apollo Link brings with it a large feature set for common use cases. For instance, adding error handling to your request is super easy using the `apollo-link-error` package. You can set headers, batch requests, and even configure your app to retry on failed attempts all by including new links into your request chain.
 *
 * ### Link API
 *
 * Since graphql-tools supports using a link for the network layer, the API is the same as you would write on the client. To learn more about how Apollo Link works, check out the [docs](https://www.apollographql.com/docs/link/); Both GraphQL and Apollo Links have slightly varying concepts of what `context` is used for. To make it easy to use your GraphQL context to create your Apollo Link context, `makeRemoteExecutableSchema` attaches the context from the graphql resolver onto the link context under `graphqlContext`.
 *
 * Basic usage
 *
 * ```
 * import { HttpLink } from 'apollo-link-http';
 * import fetch from 'node-fetch';
 *
 * const link = new HttpLink({ uri: 'http://api.githunt.com/graphql', fetch });
 *
 * export default async () => {
 *   const schema = await introspectSchema(link);
 *
 *   const executableSchema = makeRemoteExecutableSchema({
 *     schema,
 *     link,
 *   });
 *
 *   return executableSchema
 * }
 * ```
 *
 * Authentication headers from context
 *
 * ```
 * import { setContext } from 'apollo-link-context';
 * import { HttpLink } from 'apollo-link-http';
 * import fetch from 'node-fetch';
 *
 * const http = new HttpLink({ uri: 'http://api.githunt.com/graphql', fetch });
 *
 * const link = setContext((request, previousContext) => ({
 *   headers: {
 *     'Authorization': `Bearer ${previousContext.graphqlContext.authKey}`,
 *   }
 * })).concat(http);
 *
 *
 * export default async () => {
 *   const schema = await introspectSchema(link);
 *
 *   const executableSchema = makeRemoteExecutableSchema({
 *     schema,
 *     link,
 *   });
 *
 *   return executableSchema
 * }
 * ```
 *
 * ### Fetcher API
 *
 * You can also use a fetcher (like apollo-fetch or node-fetch) instead of a link. A fetcher is a function that takes one argument, an object that describes an operation:
 *
 * ```
 * type Fetcher = (operation: Operation) => Promise<ExecutionResult>;
 *
 * type Operation {
 *   query: DocumentNode;
 *   operationName?: string;
 *   variables?: Object;
 *   context?: Object;
 * }
 * ```
 *
 * <h3 id="fetcher-apollo-fetch" title="Using apollo-fetch">
 *   Using <a href="https://github.com/apollographql/apollo-fetch">apollo-fetch</a>
 *
 * Basic usage
 *
 * ```
 * import { createApolloFetch } from 'apollo-fetch';
 *
 * const fetcher = createApolloFetch({ uri: 'http://api.githunt.com/graphql'});
 *
 * export const createSchema =  async () => {
 *   const schema = makeRemoteExecutableSchema({
 *     schema: await introspectSchema(fetcher),
 *     fetcher,
 *   });
 *   return schema
 * }
 * ```
 *
 * Authentication headers from context
 *
 * ```
 * const fetcher = createApolloFetch({ uri: 'http://api.githunt.com/graphql'});
 * fetcher.use(({ request, options }, next) => {
 *   if (!options.headers) {
 *     options.headers = {};
 *   }
 *   options.headers['Authorization'] = `Bearer ${request.context.authKey}`;
 *
 *   next();
 * });
 *
 * export default async () => {
 *   const schema = makeRemoteExecutableSchema({
 *     schema: await introspectSchema(fetcher),
 *     fetcher,
 *   });
 *   return schema
 * }
 * ```
 *
 * ### Using node-fetch
 *
 * Basic usage
 *
 * ```
 * import fetch from 'node-fetch';
 * import { print } from 'graphql';
 *
 * const fetcher = async ({ query: queryDocument, variables, operationName, context }) => {
 *   const query = print(queryDocument);
 *   const fetchResult = await fetch('http://api.githunt.com/graphql', {
 *     method: 'POST',
 *     headers: {
 *       'Content-Type': 'application/json',
 *     },
 *     body: JSON.stringify({ query, variables, operationName })
 *   });
 *   return fetchResult.json();
 * };
 *
 * export default async () => {
 *   const schema = makeRemoteExecutableSchema({
 *     schema: await introspectSchema(fetcher),
 *     fetcher,
 *   });
 *   return schema
 * }
 * ```
 *
 * Authentication headers from context
 *
 * ```
 * import fetch from 'node-fetch';
 * import { print } from 'graphql':
 *
 * const fetcher = async ({ query: queryDocument, variables, operationName, context }) => {
 *   const query = print(queryDocument);
 *   const fetchResult = await fetch('http://api.githunt.com/graphql', {
 *     method: 'POST',
 *     headers: {
 *       'Content-Type': 'application/json',
 *       'Authorization': `Bearer ${context.authKey}`,
 *     },
 *     body: JSON.stringify({ query, variables, operationName })
 *   });
 *   return fetchResult.json();
 * };
 *
 * export default async () => {
 *   const schema = makeRemoteExecutableSchema({
 *     schema: await introspectSchema(fetcher),
 *     fetcher,
 *   });
 *
 *   return schema
 * }
 * ```
 *
 * ## API
 *
 * ### makeRemoteExecutableSchema(options)
 *
 * `makeExecutableSchema` takes a single argument: an object of options. The `schema` and either a `fetcher` or a `link` options are required.
 *
 * ```
 * import { makeRemoteExecutableSchema } from 'graphql-tools';
 *
 * const schema = makeRemoteExecutableSchema({
 *   schema,
 *   link,
 *   // fetcher, you can pass a fetcher instead of a link
 * });
 * ```
 *
 * Given a GraphQL.js schema (can be a non-executable client schema made by `buildClientSchema`) and a [Link](#link-api) or [Fetcher](#fetcher-api), produce a GraphQL Schema that routes all requests to the link or fetcher.
 *
 * You can also pass a `createResolver` function to `makeRemoteExecutableSchema` to override how the fetch resolvers are created and executed. The `createResolver` param accepts a `Fetcher` as its first argument and returns a resolver function. This opens up the possibility for users to create batching mechanisms for fetches.
 * ```
 * const createResolver: (fetcher: Fetcher) => GraphQLFieldResolver<any, any> = // . . .
 *
 * const schema = makeRemoteExecutableSchema({
 *   schema,
 *   link,
 *   createResolver
 * });
 * ```
 *
 * ### introspectSchema(fetcher, [context])
 *
 * Use `link` to build a client schema using introspection query. This function makes it easier to use `makeRemoteExecutableSchema`. As a result, you get a promise to a non-executable GraphQL.js schema object. Accepts optional second argument `context`, which is passed to the link; see the docs about links above for more details.
 *
 * ```
 * import { introspectSchema } from 'graphql-tools';
 *
 * introspectSchema(link).then((schema) => {
 *   // use the schema
 * });
 *
 * // or, with async/await:
 * const schema = await introspectSchema(link);
 * ```
 */
function makeRemoteExecutableSchema(_a) {
    var schemaOrTypeDefs = _a.schema, link = _a.link, fetcher = _a.fetcher, _b = _a.createResolver, customCreateResolver = _b === void 0 ? createResolver : _b, buildSchemaOptions = _a.buildSchemaOptions;
    var finalFetcher = fetcher;
    if (finalFetcher == null && link != null) {
        finalFetcher = linkToFetcher_1.default(link);
    }
    var targetSchema = typeof schemaOrTypeDefs === 'string'
        ? index_3.buildSchema(schemaOrTypeDefs, buildSchemaOptions)
        : schemaOrTypeDefs;
    var remoteSchema = index_2.cloneSchema(targetSchema);
    resolvers_1.stripResolvers(remoteSchema);
    function createProxyingResolver(_a) {
        var operation = _a.operation;
        if (operation === 'query' || operation === 'mutation') {
            return customCreateResolver(finalFetcher);
        }
        return createSubscriptionResolver(link);
    }
    index_1.addResolversToSchema({
        schema: remoteSchema,
        resolvers: resolvers_1.generateProxyingResolvers({
            subschemaConfig: { schema: remoteSchema },
            createProxyingResolver: createProxyingResolver,
        }),
        resolverValidationOptions: {
            allowResolversNotInSchema: true,
        },
    });
    return remoteSchema;
}
exports.default = makeRemoteExecutableSchema;
function createResolver(fetcher) {
    var _this = this;
    return function (_root, _args, context, info) { return __awaiter(_this, void 0, void 0, function () {
        var fragments, query, result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    fragments = Object.keys(info.fragments).map(function (fragment) { return info.fragments[fragment]; });
                    query = {
                        kind: graphql_1.Kind.DOCUMENT,
                        definitions: __spreadArrays([info.operation], fragments),
                    };
                    query = addTypenameToAbstract_1.addTypenameToAbstract(info.schema, query);
                    return [4 /*yield*/, fetcher({
                            query: query,
                            variables: info.variableValues,
                            context: { graphqlContext: context },
                        })];
                case 1:
                    result = _a.sent();
                    return [2 /*return*/, checkResultAndHandleErrors_1.checkResultAndHandleErrors(result, context, info)];
            }
        });
    }); };
}
exports.createResolver = createResolver;
function createSubscriptionResolver(link) {
    return function (_root, _args, context, info) {
        var fragments = Object.keys(info.fragments).map(function (fragment) { return info.fragments[fragment]; });
        var query = {
            kind: graphql_1.Kind.DOCUMENT,
            definitions: __spreadArrays([info.operation], fragments),
        };
        query = addTypenameToAbstract_1.addTypenameToAbstract(info.schema, query);
        var operation = {
            query: query,
            variables: info.variableValues,
            context: { graphqlContext: context },
        };
        var observable = linkToFetcher_1.execute(link, operation);
        var originalAsyncIterator = observableToAsyncIterable_1.observableToAsyncIterable(observable);
        return mapAsyncIterator_1.default(originalAsyncIterator, function (result) {
            var _a;
            return (_a = {},
                _a[info.fieldName] = checkResultAndHandleErrors_1.checkResultAndHandleErrors(result, context, info),
                _a);
        });
    };
}
//# sourceMappingURL=makeRemoteExecutableSchema.js.map
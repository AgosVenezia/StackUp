var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var graphql_1 = require("graphql");
var index_1 = require("../utils/index");
var checkResultAndHandleErrors_1 = require("../delegate/checkResultAndHandleErrors");
var errors_1 = require("./errors");
var hasSymbol = (typeof global !== 'undefined' && 'Symbol' in global) ||
    // eslint-disable-next-line no-undef
    (typeof window !== 'undefined' && 'Symbol' in window);
exports.OBJECT_SUBSCHEMA_SYMBOL = hasSymbol
    ? Symbol('initialSubschema')
    : '@@__initialSubschema';
exports.FIELD_SUBSCHEMA_MAP_SYMBOL = hasSymbol
    ? Symbol('subschemaMap')
    : '@@__subschemaMap';
exports.ERROR_SYMBOL = hasSymbol
    ? Symbol('subschemaErrors')
    : '@@__subschemaErrors';
function isProxiedResult(result) {
    return result != null ? result[exports.ERROR_SYMBOL] : result;
}
exports.isProxiedResult = isProxiedResult;
function getSubschema(result, responseKey) {
    var subschema = result[exports.FIELD_SUBSCHEMA_MAP_SYMBOL] &&
        result[exports.FIELD_SUBSCHEMA_MAP_SYMBOL][responseKey];
    return subschema ? subschema : result[exports.OBJECT_SUBSCHEMA_SYMBOL];
}
exports.getSubschema = getSubschema;
function setObjectSubschema(result, subschema) {
    result[exports.OBJECT_SUBSCHEMA_SYMBOL] = subschema;
}
exports.setObjectSubschema = setObjectSubschema;
function setErrors(result, errors) {
    result[exports.ERROR_SYMBOL] = errors;
}
exports.setErrors = setErrors;
function getErrors(result, pathSegment) {
    var errors = result != null ? result[exports.ERROR_SYMBOL] : result;
    if (!Array.isArray(errors)) {
        return null;
    }
    var fieldErrors = [];
    for (var _i = 0, errors_2 = errors; _i < errors_2.length; _i++) {
        var error = errors_2[_i];
        if (!error.path || error.path[0] === pathSegment) {
            fieldErrors.push(error);
        }
    }
    return fieldErrors;
}
exports.getErrors = getErrors;
function unwrapResult(parent, info, path) {
    var newParent = parent;
    var pathLength = path.length;
    for (var i = 0; i < pathLength; i++) {
        var responseKey = path[i];
        var errors = getErrors(newParent, responseKey);
        var subschema = getSubschema(newParent, responseKey);
        var object = newParent[responseKey];
        if (object == null) {
            return checkResultAndHandleErrors_1.handleNull(info.fieldNodes, graphql_1.responsePathAsArray(info.path), errors);
        }
        setErrors(object, errors.map(function (error) {
            return errors_1.relocatedError(error, error.nodes, error.path != null ? error.path.slice(1) : undefined);
        }));
        setObjectSubschema(object, subschema);
        newParent = object;
    }
    return newParent;
}
exports.unwrapResult = unwrapResult;
function dehoistResult(parent, delimeter) {
    if (delimeter === void 0) { delimeter = '__gqltf__'; }
    var result = Object.create(null);
    Object.keys(parent).forEach(function (alias) {
        var obj = result;
        var fieldNames = alias.split(delimeter);
        var fieldName = fieldNames.pop();
        fieldNames.forEach(function (key) {
            obj = obj[key] = obj[key] || Object.create(null);
        });
        obj[fieldName] = parent[alias];
    });
    result[exports.ERROR_SYMBOL] = parent[exports.ERROR_SYMBOL].map(function (error) {
        if (error.path != null) {
            var path = error.path.slice();
            var pathSegment = path.shift();
            var expandedPathSegment = pathSegment.split(delimeter);
            return errors_1.relocatedError(error, error.nodes, expandedPathSegment.concat(path));
        }
        return error;
    });
    result[exports.OBJECT_SUBSCHEMA_SYMBOL] = parent[exports.OBJECT_SUBSCHEMA_SYMBOL];
    return result;
}
exports.dehoistResult = dehoistResult;
function mergeProxiedResults(target) {
    var sources = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        sources[_i - 1] = arguments[_i];
    }
    var errors = target[exports.ERROR_SYMBOL].concat(sources.map(function (source) { return source[exports.ERROR_SYMBOL]; }));
    var fieldSubschemaMap = sources.reduce(function (acc, source) {
        var subschema = source[exports.OBJECT_SUBSCHEMA_SYMBOL];
        Object.keys(source).forEach(function (key) {
            acc[key] = subschema;
        });
        return acc;
    }, {});
    var result = index_1.mergeDeep.apply(void 0, __spreadArrays([target], sources));
    result[exports.ERROR_SYMBOL] = errors;
    result[exports.FIELD_SUBSCHEMA_MAP_SYMBOL] = target[exports.FIELD_SUBSCHEMA_MAP_SYMBOL]
        ? index_1.mergeDeep(target[exports.FIELD_SUBSCHEMA_MAP_SYMBOL], fieldSubschemaMap)
        : fieldSubschemaMap;
    return result;
}
exports.mergeProxiedResults = mergeProxiedResults;
//# sourceMappingURL=proxiedResult.js.map
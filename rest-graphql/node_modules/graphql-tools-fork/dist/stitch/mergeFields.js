var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var graphql_1 = require("graphql");
var proxiedResult_1 = require("./proxiedResult");
function buildDelegationPlan(mergedTypeInfo, originalSelections, sourceSubschemas, targetSubschemas) {
    // 1.  calculate if possible to delegate to given subschema
    //    TODO: change logic so that required selection set can be spread across multiple subschemas?
    var proxiableSubschemas = [];
    var nonProxiableSubschemas = [];
    targetSubschemas.forEach(function (t) {
        if (sourceSubschemas.some(function (s) {
            var selectionSet = mergedTypeInfo.selectionSets.get(t);
            return mergedTypeInfo.containsSelectionSet.get(s).get(selectionSet);
        })) {
            proxiableSubschemas.push(t);
        }
        else {
            nonProxiableSubschemas.push(t);
        }
    });
    var uniqueFields = mergedTypeInfo.uniqueFields, nonUniqueFields = mergedTypeInfo.nonUniqueFields;
    var unproxiableSelections = [];
    // 2. for each selection:
    var delegationMap = new Map();
    originalSelections.forEach(function (selection) {
        // 2a. use uniqueFields map to assign fields to subschema if one of possible subschemas
        var uniqueSubschema = uniqueFields[selection.name.value];
        if (uniqueSubschema != null) {
            if (proxiableSubschemas.includes(uniqueSubschema)) {
                var existingSubschema = delegationMap.get(uniqueSubschema);
                if (existingSubschema != null) {
                    existingSubschema.push(selection);
                }
                else {
                    delegationMap.set(uniqueSubschema, [selection]);
                }
            }
            else {
                unproxiableSelections.push(selection);
            }
        }
        else {
            // 2b. use nonUniqueFields to assign to a possible subschema,
            //     preferring one of the subschemas already targets of delegation
            var nonUniqueSubschemas = nonUniqueFields[selection.name.value];
            nonUniqueSubschemas = nonUniqueSubschemas.filter(function (s) {
                return proxiableSubschemas.includes(s);
            });
            if (nonUniqueSubschemas != null) {
                var subschemas_1 = Array.from(delegationMap.keys());
                var existingSubschema = nonUniqueSubschemas.find(function (s) {
                    return subschemas_1.includes(s);
                });
                if (existingSubschema != null) {
                    delegationMap.get(existingSubschema).push(selection);
                }
                else {
                    delegationMap.set(nonUniqueSubschemas[0], [selection]);
                }
            }
            else {
                unproxiableSelections.push(selection);
            }
        }
    });
    return {
        delegationMap: delegationMap,
        unproxiableSelections: unproxiableSelections,
        proxiableSubschemas: proxiableSubschemas,
        nonProxiableSubschemas: nonProxiableSubschemas,
    };
}
function mergeFields(mergedTypeInfo, typeName, object, originalSelections, sourceSubschemas, targetSubschemas, context, info) {
    if (!originalSelections.length) {
        return object;
    }
    var _a = buildDelegationPlan(mergedTypeInfo, originalSelections, sourceSubschemas, targetSubschemas), delegationMap = _a.delegationMap, unproxiableSelections = _a.unproxiableSelections, proxiableSubschemas = _a.proxiableSubschemas, nonProxiableSubschemas = _a.nonProxiableSubschemas;
    if (!delegationMap.size) {
        return object;
    }
    var maybePromises = [];
    delegationMap.forEach(function (selections, s) {
        var maybePromise = s.merge[typeName].resolve(object, context, info, s, {
            kind: graphql_1.Kind.SELECTION_SET,
            selections: selections,
        });
        maybePromises.push(maybePromise);
    });
    var containsPromises = false;
    for (var _i = 0, maybePromises_1 = maybePromises; _i < maybePromises_1.length; _i++) {
        var maybePromise = maybePromises_1[_i];
        if (maybePromise instanceof Promise) {
            containsPromises = true;
            break;
        }
    }
    return containsPromises
        ? Promise.all(maybePromises).then(function (results) {
            return mergeFields(mergedTypeInfo, typeName, proxiedResult_1.mergeProxiedResults.apply(void 0, __spreadArrays([object], results)), unproxiableSelections, sourceSubschemas.concat(proxiableSubschemas), nonProxiableSubschemas, context, info);
        })
        : mergeFields(mergedTypeInfo, typeName, proxiedResult_1.mergeProxiedResults.apply(void 0, __spreadArrays([object], maybePromises)), unproxiableSelections, sourceSubschemas.concat(proxiableSubschemas), nonProxiableSubschemas, context, info);
}
exports.mergeFields = mergeFields;
//# sourceMappingURL=mergeFields.js.map
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var graphql_1 = require("graphql");
var Interfaces_1 = require("../Interfaces");
var index_1 = require("../wrap/index");
var index_2 = require("../utils/index");
var delegateToSchema_1 = __importDefault(require("../delegate/delegateToSchema"));
function createMergeInfo(allSchemas, typeCandidates, mergeTypes) {
    return {
        delegate: function (operation, fieldName, args, context, info, transforms) {
            if (transforms === void 0) { transforms = []; }
            var schema = guessSchemaByRootField(allSchemas, operation, fieldName);
            var expandTransforms = new index_1.ExpandAbstractTypes(info.schema, schema);
            var fragmentTransform = new index_1.AddReplacementFragments(schema, info.mergeInfo.replacementFragments);
            return delegateToSchema_1.default({
                schema: schema,
                operation: operation,
                fieldName: fieldName,
                args: args,
                context: context,
                info: info,
                transforms: __spreadArrays(transforms, [expandTransforms, fragmentTransform]),
            });
        },
        delegateToSchema: function (options) {
            return delegateToSchema_1.default(__assign(__assign({}, options), { transforms: options.transforms }));
        },
        fragments: [],
        replacementSelectionSets: undefined,
        replacementFragments: undefined,
        mergedTypes: createMergedTypes(typeCandidates, mergeTypes),
    };
}
exports.createMergeInfo = createMergeInfo;
function createMergedTypes(typeCandidates, mergeTypes) {
    var mergedTypes = {};
    Object.keys(typeCandidates).forEach(function (typeName) {
        if (graphql_1.isObjectType(typeCandidates[typeName][0].type)) {
            var mergedTypeCandidates = typeCandidates[typeName].filter(function (typeCandidate) {
                return typeCandidate.subschema != null &&
                    Interfaces_1.isSubschemaConfig(typeCandidate.subschema) &&
                    typeCandidate.subschema.merge != null &&
                    typeCandidate.subschema.merge[typeName] != null;
            });
            if (mergeTypes === true ||
                (typeof mergeTypes === 'function' &&
                    mergeTypes(typeName, typeCandidates[typeName])) ||
                (Array.isArray(mergeTypes) && mergeTypes.includes(typeName)) ||
                mergedTypeCandidates.length) {
                var subschemas_1 = [];
                var requiredSelections_1 = [
                    index_2.parseSelectionSet('{ __typename }').selections[0],
                ];
                var fields_1 = Object.create({});
                var typeMaps_1 = new Map();
                var selectionSets_1 = new Map();
                mergedTypeCandidates.forEach(function (typeCandidate) {
                    var subschemaConfig = typeCandidate.subschema;
                    var transformedSubschema = typeCandidate.transformedSubschema;
                    typeMaps_1.set(subschemaConfig, transformedSubschema.getTypeMap());
                    var type = transformedSubschema.getType(typeName);
                    var fieldMap = type.getFields();
                    Object.keys(fieldMap).forEach(function (fieldName) {
                        if (fields_1[fieldName] == null) {
                            fields_1[fieldName] = [];
                        }
                        fields_1[fieldName].push(subschemaConfig);
                    });
                    var mergedTypeConfig = subschemaConfig.merge[typeName];
                    if (mergedTypeConfig.selectionSet) {
                        var selectionSet = index_2.parseSelectionSet(mergedTypeConfig.selectionSet);
                        requiredSelections_1 = requiredSelections_1.concat(selectionSet.selections);
                        selectionSets_1.set(subschemaConfig, selectionSet);
                    }
                    if (!mergedTypeConfig.resolve) {
                        mergedTypeConfig.resolve = function (originalResult, context, info, subschema, selectionSet) {
                            return delegateToSchema_1.default({
                                schema: subschema,
                                operation: 'query',
                                fieldName: mergedTypeConfig.fieldName,
                                args: mergedTypeConfig.args(originalResult),
                                selectionSet: selectionSet,
                                context: context,
                                info: info,
                                skipTypeMerging: true,
                            });
                        };
                    }
                    subschemas_1.push(subschemaConfig);
                });
                mergedTypes[typeName] = {
                    subschemas: subschemas_1,
                    typeMaps: typeMaps_1,
                    selectionSets: selectionSets_1,
                    containsSelectionSet: new Map(),
                    uniqueFields: Object.create({}),
                    nonUniqueFields: Object.create({}),
                };
                subschemas_1.forEach(function (subschema) {
                    var type = typeMaps_1.get(subschema)[typeName];
                    var subschemaMap = new Map();
                    subschemas_1
                        .filter(function (s) { return s !== subschema; })
                        .forEach(function (s) {
                        var selectionSet = selectionSets_1.get(s);
                        if (selectionSet != null &&
                            index_2.typeContainsSelectionSet(type, selectionSet)) {
                            subschemaMap.set(selectionSet, true);
                        }
                    });
                    mergedTypes[typeName].containsSelectionSet.set(subschema, subschemaMap);
                });
                Object.keys(fields_1).forEach(function (fieldName) {
                    var supportedBySubschemas = fields_1[fieldName];
                    if (supportedBySubschemas.length === 1) {
                        mergedTypes[typeName].uniqueFields[fieldName] =
                            supportedBySubschemas[0];
                    }
                    else {
                        mergedTypes[typeName].nonUniqueFields[fieldName] = supportedBySubschemas;
                    }
                });
                mergedTypes[typeName].selectionSet = {
                    kind: graphql_1.Kind.SELECTION_SET,
                    selections: requiredSelections_1,
                };
            }
        }
    });
    return mergedTypes;
}
function completeMergeInfo(mergeInfo, resolvers) {
    var replacementSelectionSets = Object.create(null);
    Object.keys(resolvers).forEach(function (typeName) {
        var type = resolvers[typeName];
        if (graphql_1.isScalarType(type)) {
            return;
        }
        Object.keys(type).forEach(function (fieldName) {
            var field = type[fieldName];
            if (field.selectionSet) {
                var selectionSet = index_2.parseSelectionSet(field.selectionSet);
                if (replacementSelectionSets[typeName] == null) {
                    replacementSelectionSets[typeName] = {};
                }
                if (replacementSelectionSets[typeName][fieldName] == null) {
                    replacementSelectionSets[typeName][fieldName] = {
                        kind: graphql_1.Kind.SELECTION_SET,
                        selections: [],
                    };
                }
                replacementSelectionSets[typeName][fieldName].selections = replacementSelectionSets[typeName][fieldName].selections.concat(selectionSet.selections);
            }
            if (field.fragment) {
                mergeInfo.fragments.push({
                    field: fieldName,
                    fragment: field.fragment,
                });
            }
        });
    });
    var mapping = {};
    mergeInfo.fragments.forEach(function (_a) {
        var field = _a.field, fragment = _a.fragment;
        var parsedFragment = index_2.parseFragmentToInlineFragment(fragment);
        var actualTypeName = parsedFragment.typeCondition.name.value;
        if (mapping[actualTypeName] == null) {
            mapping[actualTypeName] = {};
        }
        if (mapping[actualTypeName][field] == null) {
            mapping[actualTypeName][field] = [];
        }
        mapping[actualTypeName][field].push(parsedFragment);
    });
    var replacementFragments = Object.create(null);
    Object.keys(mapping).forEach(function (typeName) {
        Object.keys(mapping[typeName]).forEach(function (field) {
            if (replacementFragments[typeName] == null) {
                replacementFragments[typeName] = {};
            }
            replacementFragments[typeName][field] = index_2.concatInlineFragments(typeName, mapping[typeName][field]);
        });
    });
    mergeInfo.replacementSelectionSets = replacementSelectionSets;
    mergeInfo.replacementFragments = replacementFragments;
    return mergeInfo;
}
exports.completeMergeInfo = completeMergeInfo;
function operationToRootType(operation, schema) {
    if (operation === 'subscription') {
        return schema.getSubscriptionType();
    }
    else if (operation === 'mutation') {
        return schema.getMutationType();
    }
    return schema.getQueryType();
}
function guessSchemaByRootField(schemas, operation, fieldName) {
    for (var _i = 0, schemas_1 = schemas; _i < schemas_1.length; _i++) {
        var schema = schemas_1[_i];
        var rootObject = operationToRootType(operation, schema);
        if (rootObject != null) {
            var fields = rootObject.getFields();
            if (fields[fieldName] != null) {
                return schema;
            }
        }
    }
    throw new Error("Could not find subschema with field `" + operation + "." + fieldName + "`");
}
//# sourceMappingURL=mergeInfo.js.map
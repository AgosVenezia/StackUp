var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var graphql_1 = require("graphql");
var Interfaces_1 = require("../Interfaces");
var index_1 = require("../generate/index");
var index_2 = require("../wrap/index");
var index_3 = require("../utils/index");
var index_4 = require("../polyfills/index");
var typeFromAST_1 = __importDefault(require("./typeFromAST"));
var mergeInfo_1 = require("./mergeInfo");
function mergeSchemas(_a) {
    var _b = _a.subschemas, subschemas = _b === void 0 ? [] : _b, _c = _a.types, types = _c === void 0 ? [] : _c, typeDefs = _a.typeDefs, _d = _a.schemas, schemaLikeObjects = _d === void 0 ? [] : _d, onTypeConflict = _a.onTypeConflict, _e = _a.resolvers, resolvers = _e === void 0 ? {} : _e, schemaDirectives = _a.schemaDirectives, inheritResolversFromInterfaces = _a.inheritResolversFromInterfaces, _f = _a.mergeTypes, mergeTypes = _f === void 0 ? false : _f, mergeDirectives = _a.mergeDirectives, _g = _a.queryTypeName, queryTypeName = _g === void 0 ? 'Query' : _g, _h = _a.mutationTypeName, mutationTypeName = _h === void 0 ? 'Mutation' : _h, _j = _a.subscriptionTypeName, subscriptionTypeName = _j === void 0 ? 'Subscription' : _j;
    var allSchemas = [];
    var typeCandidates = {};
    var typeMap = {};
    var extensions = [];
    var directives = [];
    var schemas = __spreadArrays(subschemas);
    if (typeDefs) {
        schemas.push(typeDefs);
    }
    if (types != null) {
        schemas.push(types);
    }
    schemas = __spreadArrays(schemas, schemaLikeObjects);
    schemas.forEach(function (schemaLikeObject) {
        var _a;
        if (graphql_1.isSchema(schemaLikeObject) || Interfaces_1.isSubschemaConfig(schemaLikeObject)) {
            var schema_1 = index_2.wrapSchema(schemaLikeObject);
            allSchemas.push(schema_1);
            var operationTypes_1 = (_a = {},
                _a[queryTypeName] = schema_1.getQueryType(),
                _a[mutationTypeName] = schema_1.getMutationType(),
                _a[subscriptionTypeName] = schema_1.getSubscriptionType(),
                _a);
            Object.keys(operationTypes_1).forEach(function (typeName) {
                if (operationTypes_1[typeName] != null) {
                    addTypeCandidate(typeCandidates, typeName, {
                        schema: schema_1,
                        type: operationTypes_1[typeName],
                        subschema: schemaLikeObject,
                        transformedSubschema: schema_1,
                    });
                }
            });
            if (mergeDirectives) {
                var directiveInstances = schema_1.getDirectives();
                directiveInstances.forEach(function (directive) {
                    directives.push(directive);
                });
            }
            var originalTypeMap_1 = schema_1.getTypeMap();
            Object.keys(originalTypeMap_1).forEach(function (typeName) {
                var type = originalTypeMap_1[typeName];
                if (graphql_1.isNamedType(type) &&
                    graphql_1.getNamedType(type).name.slice(0, 2) !== '__' &&
                    type !== operationTypes_1.Query &&
                    type !== operationTypes_1.Mutation &&
                    type !== operationTypes_1.Subscription) {
                    addTypeCandidate(typeCandidates, type.name, {
                        schema: schema_1,
                        type: type,
                        subschema: schemaLikeObject,
                        transformedSubschema: schema_1,
                    });
                }
            });
        }
        else if (typeof schemaLikeObject === 'string' ||
            (schemaLikeObject != null &&
                schemaLikeObject.kind === graphql_1.Kind.DOCUMENT)) {
            var parsedSchemaDocument = typeof schemaLikeObject === 'string'
                ? graphql_1.parse(schemaLikeObject)
                : schemaLikeObject;
            parsedSchemaDocument.definitions.forEach(function (def) {
                var type = typeFromAST_1.default(def);
                if (graphql_1.isDirective(type) && mergeDirectives) {
                    directives.push(type);
                }
                else if (type != null && !graphql_1.isDirective(type)) {
                    addTypeCandidate(typeCandidates, type.name, {
                        type: type,
                    });
                }
            });
            var extensionsDocument = index_1.extractExtensionDefinitions(parsedSchemaDocument);
            if (extensionsDocument.definitions.length > 0) {
                extensions.push(extensionsDocument);
            }
        }
        else if (Array.isArray(schemaLikeObject)) {
            schemaLikeObject.forEach(function (type) {
                addTypeCandidate(typeCandidates, type.name, {
                    type: type,
                });
            });
        }
        else {
            throw new Error('Invalid schema passed');
        }
    });
    var mergeInfo = mergeInfo_1.createMergeInfo(allSchemas, typeCandidates, mergeTypes);
    var finalResolvers;
    if (typeof resolvers === 'function') {
        finalResolvers = resolvers(mergeInfo);
    }
    else if (Array.isArray(resolvers)) {
        finalResolvers = resolvers.reduce(function (left, right) {
            return index_3.mergeDeep(left, typeof right === 'function' ? right(mergeInfo) : right);
        }, {});
        if (Array.isArray(resolvers)) {
            finalResolvers = resolvers.reduce(index_3.mergeDeep, {});
        }
    }
    else {
        finalResolvers = resolvers;
    }
    if (finalResolvers == null) {
        finalResolvers = {};
    }
    mergeInfo = mergeInfo_1.completeMergeInfo(mergeInfo, finalResolvers);
    Object.keys(typeCandidates).forEach(function (typeName) {
        if (typeName === queryTypeName ||
            typeName === mutationTypeName ||
            typeName === subscriptionTypeName ||
            (mergeTypes === true &&
                !graphql_1.isScalarType(typeCandidates[typeName][0].type)) ||
            (typeof mergeTypes === 'function' &&
                mergeTypes(typeName, typeCandidates[typeName])) ||
            (Array.isArray(mergeTypes) && mergeTypes.includes(typeName)) ||
            mergeInfo.mergedTypes[typeName] != null) {
            typeMap[typeName] = merge(typeName, typeCandidates[typeName]);
        }
        else {
            var candidateSelector = onTypeConflict != null
                ? onTypeConflictToCandidateSelector(onTypeConflict)
                : function (cands) { return cands[cands.length - 1]; };
            typeMap[typeName] = candidateSelector(typeCandidates[typeName]).type;
        }
    });
    index_3.healTypes(typeMap, directives, { skipPruning: true });
    var mergedSchema = new graphql_1.GraphQLSchema({
        query: typeMap[queryTypeName],
        mutation: typeMap[mutationTypeName],
        subscription: typeMap[subscriptionTypeName],
        types: Object.keys(typeMap).map(function (key) { return typeMap[key]; }),
        directives: directives.length
            ? directives.map(function (directive) { return index_3.cloneDirective(directive); })
            : undefined,
    });
    extensions.forEach(function (extension) {
        mergedSchema = index_4.extendSchema(mergedSchema, extension, {
            commentDescriptions: true,
        });
    });
    index_1.addResolversToSchema({
        schema: mergedSchema,
        resolvers: finalResolvers,
        inheritResolversFromInterfaces: inheritResolversFromInterfaces,
    });
    index_3.forEachField(mergedSchema, function (field) {
        if (field.resolve != null) {
            var fieldResolver_1 = field.resolve;
            field.resolve = function (parent, args, context, info) {
                var newInfo = __assign(__assign({}, info), { mergeInfo: mergeInfo });
                return fieldResolver_1(parent, args, context, newInfo);
            };
        }
        if (field.subscribe != null) {
            var fieldResolver_2 = field.subscribe;
            field.subscribe = function (parent, args, context, info) {
                var newInfo = __assign(__assign({}, info), { mergeInfo: mergeInfo });
                return fieldResolver_2(parent, args, context, newInfo);
            };
        }
    });
    if (schemaDirectives != null) {
        index_3.SchemaDirectiveVisitor.visitSchemaDirectives(mergedSchema, schemaDirectives);
    }
    return mergedSchema;
}
exports.default = mergeSchemas;
function addTypeCandidate(typeCandidates, name, typeCandidate) {
    if (!typeCandidates[name]) {
        typeCandidates[name] = [];
    }
    typeCandidates[name].push(typeCandidate);
}
function onTypeConflictToCandidateSelector(onTypeConflict) {
    return function (cands) {
        return cands.reduce(function (prev, next) {
            var type = onTypeConflict(prev.type, next.type, {
                left: {
                    schema: prev.schema,
                },
                right: {
                    schema: next.schema,
                },
            });
            if (prev.type === type) {
                return prev;
            }
            else if (next.type === type) {
                return next;
            }
            return {
                schemaName: 'unknown',
                type: type,
            };
        });
    };
}
function merge(typeName, candidates) {
    var initialCandidateType = candidates[0].type;
    if (candidates.some(function (candidate) {
        return candidate.type.constructor !== initialCandidateType.constructor;
    })) {
        throw new Error("Cannot merge different type categories into common type " + typeName + ".");
    }
    if (graphql_1.isObjectType(initialCandidateType)) {
        return new graphql_1.GraphQLObjectType({
            name: typeName,
            fields: candidates.reduce(function (acc, candidate) { return (__assign(__assign({}, acc), index_4.toConfig(candidate.type).fields)); }, {}),
            interfaces: candidates.reduce(function (acc, candidate) {
                var interfaces = index_4.toConfig(candidate.type).interfaces;
                return interfaces != null ? acc.concat(interfaces) : acc;
            }, []),
        });
    }
    else if (graphql_1.isInterfaceType(initialCandidateType)) {
        var config = {
            name: typeName,
            fields: candidates.reduce(function (acc, candidate) { return (__assign(__assign({}, acc), index_4.toConfig(candidate.type).fields)); }, {}),
            interfaces: index_3.graphqlVersion() >= 15
                ? candidates.reduce(function (acc, candidate) {
                    var interfaces = index_4.toConfig(candidate.type).interfaces;
                    return interfaces != null ? acc.concat(interfaces) : acc;
                }, [])
                : undefined,
        };
        return new graphql_1.GraphQLInterfaceType(config);
    }
    else if (graphql_1.isUnionType(initialCandidateType)) {
        return new graphql_1.GraphQLUnionType({
            name: typeName,
            types: candidates.reduce(function (acc, candidate) { return acc.concat(index_4.toConfig(candidate.type).types); }, []),
        });
    }
    else if (graphql_1.isEnumType(initialCandidateType)) {
        return new graphql_1.GraphQLEnumType({
            name: typeName,
            values: candidates.reduce(function (acc, candidate) { return (__assign(__assign({}, acc), index_4.toConfig(candidate.type).values)); }, {}),
        });
    }
    else if (graphql_1.isScalarType(initialCandidateType)) {
        throw new Error("Cannot merge type " + typeName + ". Merging not supported for GraphQLScalarType.");
    }
    else {
        // not reachable.
        throw new Error("Type " + typeName + " has unknown GraphQL type.");
    }
}
//# sourceMappingURL=mergeSchemas.js.map
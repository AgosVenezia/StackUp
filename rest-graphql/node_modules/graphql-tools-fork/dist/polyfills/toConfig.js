// graphql <v14.2 does not support toConfig
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var graphql_1 = require("graphql");
var graphqlVersion_1 = require("../utils/graphqlVersion");
/**
 * @category toConfig Polyfill
 */
function schemaToConfig(schema) {
    if (schema.toConfig != null) {
        return schema.toConfig();
    }
    var newTypes = [];
    var types = schema.getTypeMap();
    Object.keys(types).forEach(function (typeName) {
        newTypes.push(types[typeName]);
    });
    var schemaConfig = {
        query: schema.getQueryType(),
        mutation: schema.getMutationType(),
        subscription: schema.getSubscriptionType(),
        types: newTypes,
        directives: schema.getDirectives().slice(),
        extensions: schema.extensions,
        astNode: schema.astNode,
        extensionASTNodes: schema.extensionASTNodes != null ? schema.extensionASTNodes : [],
        assumeValid: schema.__validationErrors !==
            undefined,
    };
    if (graphqlVersion_1.graphqlVersion() >= 15) {
        schemaConfig.description = schema.description;
    }
    return schemaConfig;
}
exports.schemaToConfig = schemaToConfig;
function toConfig(graphqlObject) {
    if (graphql_1.isSchema(graphqlObject)) {
        return schemaToConfig(graphqlObject);
    }
    else if (graphql_1.isDirective(graphqlObject)) {
        return directiveToConfig(graphqlObject);
    }
    else if (graphql_1.isNamedType(graphqlObject)) {
        return typeToConfig(graphqlObject);
    }
    // Input and output fields do not have predicates defined, but using duck typing,
    // type is defined for input and output fields
    if (graphqlObject.type != null) {
        if (graphqlObject.args != null ||
            graphqlObject.resolve != null ||
            graphqlObject.subscribe != null) {
            return fieldToConfig(graphqlObject);
        }
        else if (graphqlObject.defaultValue !== undefined) {
            return inputFieldToConfig(graphqlObject);
        }
        // Not all input and output fields can be checked by above in older versions
        // of graphql, but almost all properties on the field and config are identical.
        // In particular, just name and isDeprecated should be removed.
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        var name_1 = graphqlObject.name, isDeprecated = graphqlObject.isDeprecated, rest = __rest(graphqlObject, ["name", "isDeprecated"]);
        return __assign({}, rest);
    }
    throw new Error("Unknown graphql object " + graphqlObject);
}
exports.toConfig = toConfig;
function typeToConfig(type) {
    if (graphql_1.isObjectType(type)) {
        return objectTypeToConfig(type);
    }
    else if (graphql_1.isInterfaceType(type)) {
        return interfaceTypeToConfig(type);
    }
    else if (graphql_1.isUnionType(type)) {
        return unionTypeToConfig(type);
    }
    else if (graphql_1.isEnumType(type)) {
        return enumTypeToConfig(type);
    }
    else if (graphql_1.isScalarType(type)) {
        return scalarTypeToConfig(type);
    }
    else if (graphql_1.isInputObjectType(type)) {
        return inputObjectTypeToConfig(type);
    }
    throw new Error("Unknown type " + type);
}
exports.typeToConfig = typeToConfig;
/**
 * @category toConfig Polyfill
 */
function objectTypeToConfig(type) {
    if (type.toConfig != null) {
        return type.toConfig();
    }
    var typeConfig = {
        name: type.name,
        description: type.description,
        interfaces: type.getInterfaces(),
        fields: fieldMapToConfig(type.getFields()),
        isTypeOf: type.isTypeOf,
        extensions: type.extensions,
        astNode: type.astNode,
        extensionASTNodes: type.extensionASTNodes != null ? type.extensionASTNodes : [],
    };
    return typeConfig;
}
exports.objectTypeToConfig = objectTypeToConfig;
/**
 * @category toConfig Polyfill
 */
function interfaceTypeToConfig(type) {
    if (type.toConfig != null) {
        return type.toConfig();
    }
    var typeConfig = {
        name: type.name,
        description: type.description,
        fields: fieldMapToConfig(type.getFields()),
        resolveType: type.resolveType,
        extensions: type.extensions,
        astNode: type.astNode,
        extensionASTNodes: type.extensionASTNodes != null ? type.extensionASTNodes : [],
    };
    if (graphqlVersion_1.graphqlVersion() >= 15) {
        typeConfig.interfaces = type.getInterfaces();
    }
    return typeConfig;
}
exports.interfaceTypeToConfig = interfaceTypeToConfig;
/**
 * @category toConfig Polyfill
 */
function unionTypeToConfig(type) {
    if (type.toConfig != null) {
        return type.toConfig();
    }
    var typeConfig = {
        name: type.name,
        description: type.description,
        types: type.getTypes(),
        resolveType: type.resolveType,
        extensions: type.extensions,
        astNode: type.astNode,
        extensionASTNodes: type.extensionASTNodes != null ? type.extensionASTNodes : [],
    };
    return typeConfig;
}
exports.unionTypeToConfig = unionTypeToConfig;
/**
 * @category toConfig Polyfill
 */
function enumTypeToConfig(type) {
    if (type.toConfig != null) {
        return type.toConfig();
    }
    var newValues = {};
    type.getValues().forEach(function (value) {
        newValues[value.name] = {
            description: value.description,
            value: value.value,
            deprecationReason: value.deprecationReason,
            extensions: value.extensions,
            astNode: value.astNode,
        };
    });
    var typeConfig = {
        name: type.name,
        description: type.description,
        values: newValues,
        extensions: type.extensions,
        astNode: type.astNode,
        extensionASTNodes: type.extensionASTNodes != null ? type.extensionASTNodes : [],
    };
    return typeConfig;
}
exports.enumTypeToConfig = enumTypeToConfig;
var hasOwn = Object.prototype.hasOwnProperty;
/**
 * @category toConfig Polyfill
 */
function scalarTypeToConfig(type) {
    if (type.toConfig != null) {
        return type.toConfig();
    }
    var typeConfig = {
        name: type.name,
        description: type.description,
        serialize: graphqlVersion_1.graphqlVersion() >= 14 || hasOwn.call(type, 'serialize')
            ? type.serialize
            : type._scalarConfig.serialize,
        parseValue: graphqlVersion_1.graphqlVersion() >= 14 || hasOwn.call(type, 'parseValue')
            ? type.parseValue
            : type._scalarConfig.parseValue,
        parseLiteral: graphqlVersion_1.graphqlVersion() >= 14 || hasOwn.call(type, 'parseLiteral')
            ? type.parseLiteral
            : type._scalarConfig.parseLiteral,
        extensions: type.extensions,
        astNode: type.astNode,
        extensionASTNodes: type.extensionASTNodes != null ? type.extensionASTNodes : [],
    };
    return typeConfig;
}
exports.scalarTypeToConfig = scalarTypeToConfig;
/**
 * @category toConfig Polyfill
 */
function inputObjectTypeToConfig(type) {
    if (type.toConfig != null) {
        return type.toConfig();
    }
    var typeConfig = {
        name: type.name,
        description: type.description,
        fields: inputFieldMapToConfig(type.getFields()),
        extensions: type.extensions,
        astNode: type.astNode,
        extensionASTNodes: type.extensionASTNodes != null ? type.extensionASTNodes : [],
    };
    return typeConfig;
}
exports.inputObjectTypeToConfig = inputObjectTypeToConfig;
function inputFieldMapToConfig(fields) {
    var newFields = {};
    Object.keys(fields).forEach(function (fieldName) {
        var field = fields[fieldName];
        newFields[fieldName] = toConfig(field);
    });
    return newFields;
}
exports.inputFieldMapToConfig = inputFieldMapToConfig;
function inputFieldToConfig(field) {
    return {
        description: field.description,
        type: field.type,
        defaultValue: field.defaultValue,
        extensions: field.extensions,
        astNode: field.astNode,
    };
}
exports.inputFieldToConfig = inputFieldToConfig;
/**
 * @category toConfig Polyfill
 */
function directiveToConfig(directive) {
    if (directive.toConfig != null) {
        return directive.toConfig();
    }
    var directiveConfig = {
        name: directive.name,
        description: directive.description,
        locations: directive.locations,
        args: argumentMapToConfig(directive.args),
        isRepeatable: directive
            .isRepeatable,
        extensions: directive.extensions,
        astNode: directive.astNode,
    };
    return directiveConfig;
}
exports.directiveToConfig = directiveToConfig;
function fieldMapToConfig(fields) {
    var newFields = {};
    Object.keys(fields).forEach(function (fieldName) {
        var field = fields[fieldName];
        newFields[fieldName] = toConfig(field);
    });
    return newFields;
}
exports.fieldMapToConfig = fieldMapToConfig;
function fieldToConfig(field) {
    return {
        description: field.description,
        type: field.type,
        args: argumentMapToConfig(field.args),
        resolve: field.resolve,
        subscribe: field.subscribe,
        deprecationReason: field.deprecationReason,
        extensions: field.extensions,
        astNode: field.astNode,
    };
}
exports.fieldToConfig = fieldToConfig;
function argumentMapToConfig(args) {
    var newArguments = {};
    args.forEach(function (arg) {
        newArguments[arg.name] = argumentToConfig(arg);
    });
    return newArguments;
}
exports.argumentMapToConfig = argumentMapToConfig;
function argumentToConfig(arg) {
    return {
        description: arg.description,
        type: arg.type,
        defaultValue: arg.defaultValue,
        extensions: arg.extensions,
        astNode: arg.astNode,
    };
}
exports.argumentToConfig = argumentToConfig;
//# sourceMappingURL=toConfig.js.map
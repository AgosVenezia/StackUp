var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var graphql_1 = require("graphql");
var execute_1 = require("graphql/execution/execute");
var Interfaces_1 = require("../Interfaces");
var errors_1 = require("../stitch/errors");
var getResponseKeyFromInfo_1 = require("../stitch/getResponseKeyFromInfo");
var resolveFromParentTypename_1 = __importDefault(require("../stitch/resolveFromParentTypename"));
var proxiedResult_1 = require("../stitch/proxiedResult");
var mergeFields_1 = require("../stitch/mergeFields");
function checkResultAndHandleErrors(result, context, info, responseKey, subschema, returnType, skipTypeMerging) {
    if (responseKey === void 0) { responseKey = getResponseKeyFromInfo_1.getResponseKeyFromInfo(info); }
    if (returnType === void 0) { returnType = info.returnType; }
    var errors = result.errors != null ? result.errors : [];
    var data = result.data != null ? result.data[responseKey] : undefined;
    return handleResult(data, errors, subschema, context, info, returnType, skipTypeMerging);
}
exports.checkResultAndHandleErrors = checkResultAndHandleErrors;
function handleResult(result, errors, subschema, context, info, returnType, skipTypeMerging) {
    if (returnType === void 0) { returnType = info.returnType; }
    var type = graphql_1.getNullableType(returnType);
    if (result == null) {
        return handleNull(info.fieldNodes, graphql_1.responsePathAsArray(info.path), errors);
    }
    if (graphql_1.isLeafType(type)) {
        return type.parseValue(result);
    }
    else if (graphql_1.isCompositeType(type)) {
        return handleObject(type, result, errors, subschema, context, info, skipTypeMerging);
    }
    else if (graphql_1.isListType(type)) {
        return handleList(type, result, errors, subschema, context, info, skipTypeMerging);
    }
}
exports.handleResult = handleResult;
function handleList(type, list, errors, subschema, context, info, skipTypeMerging) {
    var childErrors = errors_1.getErrorsByPathSegment(errors);
    return list.map(function (listMember, index) {
        return handleListMember(graphql_1.getNullableType(type.ofType), listMember, index, childErrors[index] != null ? childErrors[index] : [], subschema, context, info, skipTypeMerging);
    });
}
function handleListMember(type, listMember, index, errors, subschema, context, info, skipTypeMerging) {
    if (listMember == null) {
        return handleNull(info.fieldNodes, __spreadArrays(graphql_1.responsePathAsArray(info.path), [index]), errors);
    }
    if (graphql_1.isLeafType(type)) {
        return type.parseValue(listMember);
    }
    else if (graphql_1.isCompositeType(type)) {
        return handleObject(type, listMember, errors, subschema, context, info, skipTypeMerging);
    }
    else if (graphql_1.isListType(type)) {
        return handleList(type, listMember, errors, subschema, context, info, skipTypeMerging);
    }
}
function handleObject(type, object, errors, subschema, context, info, skipTypeMerging) {
    proxiedResult_1.setErrors(object, errors.map(function (error) {
        return errors_1.relocatedError(error, error.nodes, error.path != null ? error.path.slice(1) : undefined);
    }));
    proxiedResult_1.setObjectSubschema(object, subschema);
    if (skipTypeMerging || !info.mergeInfo) {
        return object;
    }
    var typeName = graphql_1.isAbstractType(type)
        ? info.schema.getTypeMap()[resolveFromParentTypename_1.default(object)].name
        : type.name;
    var mergedTypeInfo = info.mergeInfo.mergedTypes[typeName];
    var targetSubschemas;
    if (mergedTypeInfo != null) {
        targetSubschemas = mergedTypeInfo.subschemas;
    }
    if (!targetSubschemas) {
        return object;
    }
    targetSubschemas = targetSubschemas.filter(function (s) { return s !== subschema; });
    if (!targetSubschemas.length) {
        return object;
    }
    var subFields = collectSubFields(info, object.__typename);
    var selections = getFieldsNotInSubschema(subFields, subschema, mergedTypeInfo, object.__typename);
    return mergeFields_1.mergeFields(mergedTypeInfo, typeName, object, selections, [subschema], targetSubschemas, context, info);
}
exports.handleObject = handleObject;
function collectSubFields(info, typeName) {
    var subFieldNodes = Object.create(null);
    var visitedFragmentNames = Object.create(null);
    info.fieldNodes.forEach(function (fieldNode) {
        subFieldNodes = execute_1.collectFields({
            schema: info.schema,
            variableValues: info.variableValues,
            fragments: info.fragments,
        }, info.schema.getType(typeName), fieldNode.selectionSet, subFieldNodes, visitedFragmentNames);
    });
    return subFieldNodes;
}
function getFieldsNotInSubschema(subFieldNodes, subschema, mergedTypeInfo, typeName) {
    var typeMap = Interfaces_1.isSubschemaConfig(subschema)
        ? mergedTypeInfo.typeMaps.get(subschema)
        : subschema.getTypeMap();
    var fields = typeMap[typeName].getFields();
    var fieldsNotInSchema = [];
    Object.keys(subFieldNodes).forEach(function (responseName) {
        subFieldNodes[responseName].forEach(function (subFieldNode) {
            if (!fields[subFieldNode.name.value]) {
                fieldsNotInSchema.push(subFieldNode);
            }
        });
    });
    return fieldsNotInSchema;
}
function handleNull(fieldNodes, path, errors) {
    if (errors.length) {
        if (errors.some(function (error) { return !error.path || error.path.length < 2; })) {
            return errors_1.relocatedError(errors_1.combineErrors(errors), fieldNodes, path);
        }
        else if (errors.some(function (error) { return typeof error.path[1] === 'string'; })) {
            var childErrors_1 = errors_1.getErrorsByPathSegment(errors);
            var result_1 = Object.create(null);
            Object.keys(childErrors_1).forEach(function (pathSegment) {
                result_1[pathSegment] = handleNull(fieldNodes, __spreadArrays(path, [pathSegment]), childErrors_1[pathSegment]);
            });
            return result_1;
        }
        var childErrors_2 = errors_1.getErrorsByPathSegment(errors);
        var result_2 = [];
        Object.keys(childErrors_2).forEach(function (pathSegment) {
            result_2.push(handleNull(fieldNodes, __spreadArrays(path, [parseInt(pathSegment, 10)]), childErrors_2[pathSegment]));
        });
        return result_2;
    }
    return null;
}
exports.handleNull = handleNull;
//# sourceMappingURL=checkResultAndHandleErrors.js.map
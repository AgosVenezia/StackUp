"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RESTDataSource = exports.Request = void 0;
const apollo_server_env_1 = require("apollo-server-env");
Object.defineProperty(exports, "Request", { enumerable: true, get: function () { return apollo_server_env_1.Request; } });
const apollo_datasource_1 = require("apollo-datasource");
const HTTPCache_1 = require("./HTTPCache");
const apollo_server_errors_1 = require("apollo-server-errors");
const NODE_ENV = process.env.NODE_ENV;
class RESTDataSource extends apollo_datasource_1.DataSource {
    constructor(httpFetch) {
        super();
        this.httpFetch = httpFetch;
        this.memoizedResults = new Map();
        this.memoizeGetRequests = true;
    }
    initialize(config) {
        this.context = config.context;
        this.httpCache = new HTTPCache_1.HTTPCache(config.cache, this.httpFetch);
    }
    cacheKeyFor(request) {
        return request.url;
    }
    resolveURL(request) {
        let path = request.path;
        if (path.startsWith('/')) {
            path = path.slice(1);
        }
        const baseURL = this.baseURL;
        if (baseURL) {
            const normalizedBaseURL = baseURL.endsWith('/')
                ? baseURL
                : baseURL.concat('/');
            return new apollo_server_env_1.URL(path, normalizedBaseURL);
        }
        else {
            return new apollo_server_env_1.URL(path);
        }
    }
    async didReceiveResponse(response, _request) {
        if (response.ok) {
            return this.parseBody(response);
        }
        else {
            throw await this.errorFromResponse(response);
        }
    }
    didEncounterError(error, _request) {
        throw error;
    }
    parseBody(response) {
        const contentType = response.headers.get('Content-Type');
        const contentLength = response.headers.get('Content-Length');
        if (response.status !== 204 &&
            contentLength !== '0' &&
            contentType &&
            (contentType.startsWith('application/json') ||
                contentType.endsWith('+json'))) {
            return response.json();
        }
        else {
            return response.text();
        }
    }
    async errorFromResponse(response) {
        const message = `${response.status}: ${response.statusText}`;
        let error;
        if (response.status === 401) {
            error = new apollo_server_errors_1.AuthenticationError(message);
        }
        else if (response.status === 403) {
            error = new apollo_server_errors_1.ForbiddenError(message);
        }
        else {
            error = new apollo_server_errors_1.ApolloError(message);
        }
        const body = await this.parseBody(response);
        Object.assign(error.extensions, {
            response: {
                url: response.url,
                status: response.status,
                statusText: response.statusText,
                body,
            },
        });
        return error;
    }
    async get(path, params, init) {
        return this.fetch(Object.assign({ method: 'GET', path, params }, init));
    }
    async post(path, body, init) {
        return this.fetch(Object.assign({ method: 'POST', path, body }, init));
    }
    async patch(path, body, init) {
        return this.fetch(Object.assign({ method: 'PATCH', path, body }, init));
    }
    async put(path, body, init) {
        return this.fetch(Object.assign({ method: 'PUT', path, body }, init));
    }
    async delete(path, params, init) {
        return this.fetch(Object.assign({ method: 'DELETE', path, params }, init));
    }
    async fetch(init) {
        if (!(init.params instanceof apollo_server_env_1.URLSearchParams)) {
            init.params = new apollo_server_env_1.URLSearchParams(init.params);
        }
        if (!(init.headers instanceof apollo_server_env_1.Headers)) {
            init.headers = new apollo_server_env_1.Headers(init.headers || Object.create(null));
        }
        const options = init;
        if (this.willSendRequest) {
            await this.willSendRequest(options);
        }
        const url = await this.resolveURL(options);
        for (const [name, value] of options.params) {
            url.searchParams.append(name, value);
        }
        if (options.body !== undefined &&
            options.body !== null &&
            (options.body.constructor === Object ||
                Array.isArray(options.body) ||
                (options.body.toJSON &&
                    typeof options.body.toJSON === 'function'))) {
            options.body = JSON.stringify(options.body);
            if (!options.headers.get('Content-Type')) {
                options.headers.set('Content-Type', 'application/json');
            }
        }
        const request = new apollo_server_env_1.Request(String(url), options);
        const cacheKey = this.cacheKeyFor(request);
        const performRequest = async () => {
            return this.trace(request, async () => {
                var _a;
                const cacheOptions = options.cacheOptions
                    ? options.cacheOptions
                    : (_a = this.cacheOptionsFor) === null || _a === void 0 ? void 0 : _a.bind(this);
                try {
                    const response = await this.httpCache.fetch(request, {
                        cacheKey,
                        cacheOptions,
                    });
                    return await this.didReceiveResponse(response, request);
                }
                catch (error) {
                    this.didEncounterError(error, request);
                }
            });
        };
        if (this.memoizeGetRequests) {
            if (request.method === 'GET') {
                let promise = this.memoizedResults.get(cacheKey);
                if (promise)
                    return promise;
                promise = performRequest();
                this.memoizedResults.set(cacheKey, promise);
                return promise;
            }
            else {
                this.memoizedResults.delete(cacheKey);
                return performRequest();
            }
        }
        else {
            return performRequest();
        }
    }
    async trace(request, fn) {
        if (NODE_ENV === 'development') {
            const startTime = Date.now();
            try {
                return await fn();
            }
            finally {
                const duration = Date.now() - startTime;
                const label = `${request.method || 'GET'} ${request.url}`;
                console.log(`${label} (${duration}ms)`);
            }
        }
        else {
            return fn();
        }
    }
}
exports.RESTDataSource = RESTDataSource;
//# sourceMappingURL=RESTDataSource.js.map
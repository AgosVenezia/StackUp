"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HTTPCache = void 0;
const apollo_server_env_1 = require("apollo-server-env");
const CachePolicy = require("http-cache-semantics");
const utils_keyvaluecache_1 = require("@apollo/utils.keyvaluecache");
class HTTPCache {
    constructor(keyValueCache = new utils_keyvaluecache_1.InMemoryLRUCache(), httpFetch = apollo_server_env_1.fetch) {
        this.keyValueCache = new utils_keyvaluecache_1.PrefixingKeyValueCache(keyValueCache, 'httpcache:');
        this.httpFetch = httpFetch;
    }
    async fetch(request, options = {}) {
        const cacheKey = options.cacheKey ? options.cacheKey : request.url;
        const entry = await this.keyValueCache.get(cacheKey);
        if (!entry) {
            const response = await this.httpFetch(request);
            const policy = new CachePolicy(policyRequestFrom(request), policyResponseFrom(response));
            return this.storeResponseAndReturnClone(response, request, policy, cacheKey, options.cacheOptions);
        }
        const { policy: policyRaw, ttlOverride, body } = JSON.parse(entry);
        const policy = CachePolicy.fromObject(policyRaw);
        policy._url = undefined;
        if ((ttlOverride && policy.age() < ttlOverride) ||
            (!ttlOverride &&
                policy.satisfiesWithoutRevalidation(policyRequestFrom(request)))) {
            const headers = policy.responseHeaders();
            return new apollo_server_env_1.Response(body, {
                url: policy._url,
                status: policy._status,
                headers,
            });
        }
        else {
            const revalidationHeaders = policy.revalidationHeaders(policyRequestFrom(request));
            const revalidationRequest = new apollo_server_env_1.Request(request, {
                headers: revalidationHeaders,
            });
            const revalidationResponse = await this.httpFetch(revalidationRequest);
            const { policy: revalidatedPolicy, modified } = policy.revalidatedPolicy(policyRequestFrom(revalidationRequest), policyResponseFrom(revalidationResponse));
            return this.storeResponseAndReturnClone(new apollo_server_env_1.Response(modified ? await revalidationResponse.text() : body, {
                url: revalidatedPolicy._url,
                status: revalidatedPolicy._status,
                headers: revalidatedPolicy.responseHeaders(),
            }), request, revalidatedPolicy, cacheKey, options.cacheOptions);
        }
    }
    async storeResponseAndReturnClone(response, request, policy, cacheKey, cacheOptions) {
        if (typeof cacheOptions === 'function') {
            cacheOptions = cacheOptions(response, request);
        }
        let ttlOverride = cacheOptions === null || cacheOptions === void 0 ? void 0 : cacheOptions.ttl;
        if (!(ttlOverride && policy._status >= 200 && policy._status <= 299) &&
            !(request.method === 'GET' && policy.storable())) {
            return response;
        }
        let ttl = ttlOverride === undefined
            ? Math.round(policy.timeToLive() / 1000)
            : ttlOverride;
        if (ttl <= 0)
            return response;
        if (canBeRevalidated(response)) {
            ttl *= 2;
        }
        const body = await response.text();
        const entry = JSON.stringify({
            policy: policy.toObject(),
            ttlOverride,
            body,
        });
        await this.keyValueCache.set(cacheKey, entry, {
            ttl,
        });
        return new apollo_server_env_1.Response(body, {
            url: response.url,
            status: response.status,
            statusText: response.statusText,
            headers: response.headers,
        });
    }
}
exports.HTTPCache = HTTPCache;
function canBeRevalidated(response) {
    return response.headers.has('ETag');
}
function policyRequestFrom(request) {
    return {
        url: request.url,
        method: request.method,
        headers: headersToObject(request.headers),
    };
}
function policyResponseFrom(response) {
    return {
        status: response.status,
        headers: headersToObject(response.headers),
    };
}
function headersToObject(headers) {
    const object = Object.create(null);
    for (const [name, value] of headers) {
        object[name] = value;
    }
    return object;
}
//# sourceMappingURL=HTTPCache.js.map
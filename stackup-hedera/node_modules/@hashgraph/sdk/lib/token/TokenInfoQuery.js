"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenInfoQuery = void 0;
const QueryBuilder_1 = require("../QueryBuilder");
const QueryHeader_pb_1 = require("../generated/QueryHeader_pb");
const Hbar_1 = require("../Hbar");
const TokenId_1 = require("./TokenId");
const TokenGetInfo_pb_1 = require("../generated/TokenGetInfo_pb");
const TokenService_pb_service_1 = require("../generated/TokenService_pb_service");
const AccountId_1 = require("../account/AccountId");
const PublicKey_1 = require("../crypto/PublicKey");
const Timestamp_1 = require("../Timestamp");
const bignumber_js_1 = require("bignumber.js");
/**
 * Get all the information about an token, including the balance.
 * This does not get the list of token records.
 */
class TokenInfoQuery extends QueryBuilder_1.QueryBuilder {
    constructor() {
        super();
        this._builder = new TokenGetInfo_pb_1.TokenGetInfoQuery();
        this._builder.setHeader(new QueryHeader_pb_1.QueryHeader());
        this._inner.setTokengetinfo(this._builder);
    }
    /**
     * The token ID for which information is requested.
     */
    setTokenId(tokenId) {
        this._builder.setToken(new TokenId_1.TokenId(tokenId)._toProto());
        return this;
    }
    /**
     * Wrapper around `QueryBuilder.getCost()`. This must exist because the cost returned
     * `QueryBuilder.getCost()` and therein the Hedera Network doesn't work for any
     * acocuntns that have been deleted. In that case we want the minimum
     * cost to be ~25 Tinybar as this seems to succeed most of the time.
     */
    getCost(client) {
        const _super = Object.create(null, {
            getCost: { get: () => super.getCost }
        });
        return __awaiter(this, void 0, void 0, function* () {
            // deleted tokens return a COST_ANSWER of zero which triggers `INSUFFICIENT_TX_FEE`
            // if you set that as the query payment; 25 tinybar seems to be enough to get
            // `TOKEN_DELETED` back instead.
            const min = Hbar_1.Hbar.fromTinybar(25);
            const cost = yield _super.getCost.call(this, client);
            return cost.isGreaterThan(min) ? cost : min;
        });
    }
    _doLocalValidate(_) { }
    _getMethod() {
        return TokenService_pb_service_1.TokenService.getTokenInfo;
    }
    _getHeader() {
        return this._builder.getHeader();
    }
    _mapResponseHeader(response) {
        return response.getTokengetinfo().getHeader();
    }
    _mapResponse(response) {
        const info = response.getTokengetinfo().getTokeninfo();
        return {
            tokenId: TokenId_1.TokenId._fromProto(info.getTokenid()),
            name: info.getName(),
            symbol: info.getSymbol(),
            decimals: info.getDecimals(),
            totalSupply: new bignumber_js_1.default(info.getTotalsupply()),
            treasury: AccountId_1.AccountId._fromProto(info.getTreasury()),
            adminKey: info.hasAdminkey() ? PublicKey_1._fromProtoKey(info.getAdminkey()) : null,
            kycKey: info.hasKyckey() ? PublicKey_1._fromProtoKey(info.getKyckey()) : null,
            freezeKey: info.hasFreezekey() ? PublicKey_1._fromProtoKey(info.getFreezekey()) : null,
            wipeKey: info.hasWipekey() ? PublicKey_1._fromProtoKey(info.getWipekey()) : null,
            supplyKey: info.hasSupplykey() ? PublicKey_1._fromProtoKey(info.getSupplykey()) : null,
            defaultFreezeStatus: info.getDefaultfreezestatus() === 0 ?
                null :
                info.getDefaultfreezestatus() === 1,
            defaultKycStatus: info.getDefaultkycstatus() === 0 ?
                null :
                info.getDefaultkycstatus() === 1,
            isDeleted: info.getDeleted(),
            autoRenewAccount: info.hasAutorenewaccount() ?
                AccountId_1.AccountId._fromProto(info.getAutorenewaccount()) :
                null,
            autoRenewPeriod: info.getAutorenewperiod().getSeconds(),
            expirationTime: info.hasExpiry() ?
                Timestamp_1.timestampToDate(info.getExpiry()) :
                null
        };
    }
}
exports.TokenInfoQuery = TokenInfoQuery;

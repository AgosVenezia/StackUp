"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenBalanceQuery = exports.TokenBalanceMap = void 0;
const QueryBuilder_1 = require("../QueryBuilder");
const CryptoService_pb_service_1 = require("../generated/CryptoService_pb_service");
const QueryHeader_pb_1 = require("../generated/QueryHeader_pb");
const AccountId_1 = require("../account/AccountId");
const CryptoGetAccountBalance_pb_1 = require("../generated/CryptoGetAccountBalance_pb");
const TokenId_1 = require("./TokenId");
const bignumber_js_1 = require("bignumber.js");
class TokenBalanceMap {
    constructor(balances) {
        this._balances = new Map();
        for (const balance of balances) {
            const tokenId = TokenId_1.TokenId._fromProto(balance.getTokenid());
            this._balances.set(tokenId.toString(), new bignumber_js_1.default(balance.getBalance()));
        }
    }
    get(tokenId) {
        const token = new TokenId_1.TokenId(tokenId).toString();
        return this._balances.get(token);
    }
    values() {
        return this._balances.values();
    }
    keys() {
        const keys = [];
        for (const key of this._balances.keys()) {
            keys.push(TokenId_1.TokenId.fromString(key));
        }
        return keys[Symbol.iterator]();
    }
    [Symbol.iterator]() {
        const map = new Map();
        for (const [key, value] of this._balances) {
            map.set(TokenId_1.TokenId.fromString(key), value);
        }
        return map[Symbol.iterator]();
    }
    toString() {
        let s = "{\n";
        for (const [key, value] of this._balances) {
            s += `\t{\n\t\ttokenId: ${key.toString()},\n\t\tbalance: ${value.toString()}\n\t},\n`;
        }
        s += "}\n";
        return s;
    }
}
exports.TokenBalanceMap = TokenBalanceMap;
/**
 * Get the balance of a cryptocurrency token. This returns only the balance, so it is a smaller
 * and faster reply than CryptoGetInfo, which returns the balance plus additional information.
 */
class TokenBalanceQuery extends QueryBuilder_1.QueryBuilder {
    constructor() {
        super();
        this._builder = new CryptoGetAccountBalance_pb_1.CryptoGetAccountBalanceQuery();
        this._builder.setHeader(new QueryHeader_pb_1.QueryHeader());
        this._inner.setCryptogetaccountbalance(this._builder);
    }
    /**
     * The account ID for which information is requested.
     */
    setAccountId(id) {
        this._builder.setAccountid(new AccountId_1.AccountId(id)._toProto());
        return this;
    }
    _doLocalValidate(_) {
    }
    _getMethod() {
        return CryptoService_pb_service_1.CryptoService.cryptoGetBalance;
    }
    _getHeader() {
        return this._builder.getHeader();
    }
    _mapResponseHeader(response) {
        return response.getCryptogetaccountbalance().getHeader();
    }
    _mapResponse(response) {
        const accountBalance = response.getCryptogetaccountbalance();
        return new TokenBalanceMap(accountBalance.getTokenbalancesList());
    }
    _isPaymentRequired() {
        return false;
    }
}
exports.TokenBalanceQuery = TokenBalanceQuery;

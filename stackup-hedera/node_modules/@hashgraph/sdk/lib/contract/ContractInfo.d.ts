/**
 * @typedef {import("../StakingInfo.js").StakingInfoJson} StakingInfoJson
 */
/**
 * Response when the client sends the node CryptoGetInfoQuery.
 */
export default class ContractInfo {
    /**
     * @internal
     * @param {HashgraphProto.proto.ContractGetInfoResponse.IContractInfo} info
     * @returns {ContractInfo}
     */
    static _fromProtobuf(info: HashgraphProto.proto.ContractGetInfoResponse.IContractInfo): ContractInfo;
    /**
     * @param {Uint8Array} bytes
     * @returns {ContractInfo}
     */
    static fromBytes(bytes: Uint8Array): ContractInfo;
    /**
     * @private
     * @param {object} props
     * @param {ContractId} props.contractId
     * @param {AccountId} props.accountId
     * @param {string} props.contractAccountId
     * @param {?Key} props.adminKey
     * @param {Timestamp} props.expirationTime
     * @param {Duration} props.autoRenewPeriod
     * @param {?AccountId} props.autoRenewAccountId
     * @param {Long} props.storage
     * @param {string} props.contractMemo
     * @param {Hbar} props.balance
     * @param {boolean} props.isDeleted
     * @param {TokenRelationshipMap} props.tokenRelationships
     * @param {LedgerId|null} props.ledgerId
     * @param {?StakingInfo} props.stakingInfo
     */
    private constructor();
    /**
     * ID of the contract instance, in the format used in transactions.
     *
     * @readonly
     */
    readonly contractId: ContractId;
    /**
     * ID of the cryptocurrency account owned by the contract instance,
     * in the format used in transactions.
     *
     * @readonly
     */
    readonly accountId: AccountId;
    /**
     * ID of both the contract instance and the cryptocurrency account owned by the contract
     * instance, in the format used by Solidity.
     *
     * @readonly
     */
    readonly contractAccountId: string;
    /**
     * The state of the instance and its fields can be modified arbitrarily if this key signs a
     * transaction to modify it. If this is null, then such modifications are not possible,
     * and there is no administrator that can override the normal operation of this smart
     * contract instance. Note that if it is created with no admin keys, then there is no
     * administrator to authorize changing the admin keys, so there can never be any admin keys
     * for that instance.
     *
     * @readonly
     */
    readonly adminKey: Key | null;
    /**
     * The current time at which this contract instance (and its account) is set to expire.
     *
     * @readonly
     */
    readonly expirationTime: Timestamp;
    /**
     * The expiration time will extend every this many seconds. If there are insufficient funds,
     * then it extends as long as possible. If the account is empty when it expires,
     * then it is deleted.
     *
     * @readonly
     */
    readonly autoRenewPeriod: Duration;
    /**
     * ID of the an account to charge for auto-renewal of this contract. If not set, or set
     * to an account with zero hbar balance, the contract's own hbar balance will be used
     * to cover auto-renewal fees.
     *
     * @readonly
     */
    readonly autoRenewAccountId: AccountId | null;
    /**
     * Number of bytes of storage being used by this instance (which affects the cost to
     * extend the expiration time).
     *
     * @readonly
     */
    readonly storage: Long.Long;
    /**
     * The memo associated with the contract (max 100 bytes).
     *
     * @readonly
     */
    readonly contractMemo: string;
    /**
     * The current balance of the contract.
     *
     * @readonly
     */
    readonly balance: Hbar;
    /**
     * Whether the contract has been deleted
     *
     * @readonly
     */
    readonly isDeleted: boolean;
    /**
     * The tokens associated to the contract
     *
     * @readonly
     */
    readonly tokenRelationships: TokenRelationshipMap;
    /**
     * The ledger ID the response was returned from; please see <a href="https://github.com/hashgraph/hedera-improvement-proposal/blob/master/HIP/hip-198.md">HIP-198</a> for the network-specific IDs.
     */
    ledgerId: LedgerId | null;
    /**
     * Staking metadata for this account.
     */
    stakingInfo: StakingInfo | null;
    /**
     * @internal
     * @returns {HashgraphProto.proto.ContractGetInfoResponse.IContractInfo}
     */
    _toProtobuf(): HashgraphProto.proto.ContractGetInfoResponse.IContractInfo;
    /**
     * @returns {Uint8Array}
     */
    toBytes(): Uint8Array;
}
export type StakingInfoJson = import("../StakingInfo.js").StakingInfoJson;
import ContractId from "./ContractId.js";
import AccountId from "../account/AccountId.js";
import Key from "../Key.js";
import Timestamp from "../Timestamp.js";
import Duration from "../Duration.js";
import Long from "long";
import Hbar from "../Hbar.js";
import TokenRelationshipMap from "../account/TokenRelationshipMap.js";
import LedgerId from "../LedgerId.js";
import StakingInfo from "../StakingInfo.js";
import * as HashgraphProto from "@hashgraph/proto";
declare const proto: typeof HashgraphProto.proto;
export {};

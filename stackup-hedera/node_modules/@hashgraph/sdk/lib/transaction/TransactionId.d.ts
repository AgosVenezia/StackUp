/**
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("./TransactionReceipt.js").default} TransactionReceipt
 * @typedef {import("./TransactionRecord.js").default} TransactionRecord
 */
/**
 * The client-generated ID for a transaction.
 *
 * This is used for retrieving receipts and records for a transaction, for appending to a file
 * right after creating it, for instantiating a smart contract with bytecode in a file just created,
 * and internally by the network for detecting when duplicate transactions are submitted.
 */
export default class TransactionId {
    /**
     * @param {AccountId} accountId
     * @param {Timestamp} validStart
     * @returns {TransactionId}
     */
    static withValidStart(accountId: AccountId, validStart: Timestamp): TransactionId;
    /**
     * Generates a new transaction ID for the given account ID.
     *
     * Note that transaction IDs are made of the valid start of the transaction and the account
     * that will be charged the transaction fees for the transaction.
     *
     * @param {AccountId | string} id
     * @returns {TransactionId}
     */
    static generate(id: AccountId | string): TransactionId;
    /**
     * @param {string} wholeId
     * @returns {TransactionId}
     */
    static fromString(wholeId: string): TransactionId;
    /**
     * @internal
     * @param {HashgraphProto.proto.ITransactionID} id
     * @returns {TransactionId}
     */
    static _fromProtobuf(id: HashgraphProto.proto.ITransactionID): TransactionId;
    /**
     * @param {Uint8Array} bytes
     * @returns {TransactionId}
     */
    static fromBytes(bytes: Uint8Array): TransactionId;
    /**
     * Don't use this method directly.
     * Use `TransactionId.[generate|withNonce|withValidStart]()` instead.
     *
     * @param {?AccountId} accountId
     * @param {?Timestamp} validStart
     * @param {?boolean} scheduled
     * @param {?Long | number} nonce
     */
    constructor(accountId: AccountId | null, validStart: Timestamp | null, scheduled?: boolean | null, nonce?: (Long | number) | null);
    /**
     * The Account ID that paid for this transaction.
     *
     * @readonly
     */
    readonly accountId: AccountId | null;
    /**
     * The time from when this transaction is valid.
     *
     * When a transaction is submitted there is additionally a validDuration (defaults to 120s)
     * and together they define a time window that a transaction may be processed in.
     *
     * @readonly
     */
    readonly validStart: Timestamp | null;
    scheduled: boolean | null;
    nonce: Long.Long | null;
    /**
     * @param {Long | number} nonce
     * @returns {TransactionId}
     */
    setNonce(nonce: Long | number): TransactionId;
    /**
     * @param {boolean} scheduled
     * @returns {this}
     */
    setScheduled(scheduled: boolean): this;
    /**
     * @returns {string}
     */
    toString(): string;
    /**
     * @internal
     * @returns {HashgraphProto.proto.ITransactionID}
     */
    _toProtobuf(): HashgraphProto.proto.ITransactionID;
    /**
     * @returns {Uint8Array}
     */
    toBytes(): Uint8Array;
    /**
     * @returns {TransactionId}
     */
    clone(): TransactionId;
    /**
     * @param {TransactionId} other
     * @returns {number}
     */
    compare(other: TransactionId): number;
    /**
     * @param {Client} client
     * @returns {Promise<TransactionReceipt>}
     */
    getReceipt(client: import("../client/Client.js").default<any, any>): Promise<TransactionReceipt>;
    /**
     * @param {Client} client
     * @returns {Promise<TransactionRecord>}
     */
    getRecord(client: import("../client/Client.js").default<any, any>): Promise<TransactionRecord>;
}
export type Client = import("../client/Client.js").default<any, any>;
export type TransactionReceipt = import("./TransactionReceipt.js").default;
export type TransactionRecord = import("./TransactionRecord.js").default;
import AccountId from "../account/AccountId.js";
import Timestamp from "../Timestamp.js";
import Long from "long";
import * as HashgraphProto from "@hashgraph/proto";

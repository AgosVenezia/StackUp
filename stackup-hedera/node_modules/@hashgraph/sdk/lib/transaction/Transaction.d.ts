/**
 * @typedef {import("bignumber.js").default} BigNumber
 */
/**
 * @typedef {import("../schedule/ScheduleCreateTransaction.js").default} ScheduleCreateTransaction
 * @typedef {import("../PrivateKey.js").default} PrivateKey
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../Signer.js").Signer} Signer
 */
export const DEFAULT_AUTO_RENEW_PERIOD: Long.Long;
export const DEFAULT_RECORD_THRESHOLD: Hbar;
export const CHUNK_SIZE: 1024;
/**
 * @type {Map<NonNullable<HashgraphProto.proto.TransactionBody["data"]>, (transactions: HashgraphProto.proto.ITransaction[], signedTransactions: HashgraphProto.proto.ISignedTransaction[], transactionIds: TransactionId[], nodeIds: AccountId[], bodies: HashgraphProto.proto.TransactionBody[]) => Transaction>}
 */
export const TRANSACTION_REGISTRY: Map<NonNullable<"contractCall" | "contractCreateInstance" | "contractUpdateInstance" | "contractDeleteInstance" | "ethereumTransaction" | "cryptoAddLiveHash" | "cryptoApproveAllowance" | "cryptoDeleteAllowance" | "cryptoCreateAccount" | "cryptoDelete" | "cryptoDeleteLiveHash" | "cryptoTransfer" | "cryptoUpdateAccount" | "fileAppend" | "fileCreate" | "fileDelete" | "fileUpdate" | "systemDelete" | "systemUndelete" | "freeze" | "consensusCreateTopic" | "consensusUpdateTopic" | "consensusDeleteTopic" | "consensusSubmitMessage" | "uncheckedSubmit" | "tokenCreation" | "tokenFreeze" | "tokenUnfreeze" | "tokenGrantKyc" | "tokenRevokeKyc" | "tokenDeletion" | "tokenUpdate" | "tokenMint" | "tokenBurn" | "tokenWipe" | "tokenAssociate" | "tokenDissociate" | "tokenFeeScheduleUpdate" | "tokenPause" | "tokenUnpause" | "scheduleCreate" | "scheduleDelete" | "scheduleSign" | "nodeStakeUpdate" | "utilPrng" | undefined>, (transactions: HashgraphProto.proto.ITransaction[], signedTransactions: HashgraphProto.proto.ISignedTransaction[], transactionIds: TransactionId[], nodeIds: AccountId[], bodies: HashgraphProto.proto.TransactionBody[]) => Transaction>;
/**
 * Base class for all transactions that may be submitted to Hedera.
 *
 * @abstract
 * @augments {Executable<HashgraphProto.proto.ITransaction, HashgraphProto.proto.ITransactionResponse, TransactionResponse>}
 */
export default class Transaction extends Executable<HashgraphProto.proto.ITransaction, HashgraphProto.proto.ITransactionResponse, TransactionResponse> {
    /**
     * Deserialize a transaction from bytes. The bytes can either be a `proto.Transaction` or
     * `proto.TransactionList`.
     *
     * @param {Uint8Array} bytes
     * @returns {Transaction}
     */
    static fromBytes(bytes: Uint8Array): Transaction;
    /**
     * This method is called by each `*Transaction._fromProtobuf()` method. It does
     * all the finalization before the user gets hold of a complete `Transaction`
     *
     * @template {Transaction} TransactionT
     * @param {TransactionT} transaction
     * @param {HashgraphProto.proto.ITransaction[]} transactions
     * @param {HashgraphProto.proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {HashgraphProto.proto.ITransactionBody[]} bodies
     * @returns {TransactionT}
     */
    static _fromProtobufTransactions<TransactionT extends Transaction>(transaction: TransactionT, transactions: HashgraphProto.proto.ITransaction[], signedTransactions: HashgraphProto.proto.ISignedTransaction[], transactionIds: TransactionId[], nodeIds: AccountId[], bodies: HashgraphProto.proto.ITransactionBody[]): TransactionT;
    constructor();
    /**
     * List of proto transactions that have been built from this SDK
     * transaction.
     *
     * This is a 2-D array built into one, meaning to
     * get to the next row you'd index into this array `row * rowLength + column`
     * where `rowLength` is `nodeAccountIds.length`
     *
     * @internal
     * @type {List<HashgraphProto.proto.ITransaction | null>}
     */
    _transactions: List<HashgraphProto.proto.ITransaction | null>;
    /**
     * List of proto transactions that have been built from this SDK
     * transaction.
     *
     * This is a 2-D array built into one, meaning to
     * get to the next row you'd index into this array `row * rowLength + column`
     * where `rowLength` is `nodeAccountIds.length`
     *
     * @internal
     * @type {List<HashgraphProto.proto.ISignedTransaction>}
     */
    _signedTransactions: List<HashgraphProto.proto.ISignedTransaction>;
    /**
     * Set of public keys (as string) who have signed this transaction so
     * we do not allow them to sign it again.
     *
     * @internal
     * @type {Set<string>}
     */
    _signerPublicKeys: Set<string>;
    /**
     * The transaction valid duration
     *
     * @private
     * @type {number}
     */
    private _transactionValidDuration;
    /**
     * The default max transaction fee for this particular transaction type.
     * Most transactions use the default of 2 Hbars, but some requests such
     * as `TokenCreateTransaction` need to use a different default value.
     *
     * @protected
     * @type {Hbar}
     */
    protected _defaultMaxTransactionFee: Hbar;
    /**
     * The max transaction fee on the request. This field is what users are able
     * to set, not the `defaultMaxTransactionFee`. The purpose of this field is
     * to allow us to determine if the user set the field explicitly, or if we're
     * using the default max transation fee for the request.
     *
     * @private
     * @type {Hbar | null}
     */
    private _maxTransactionFee;
    /**
     * The transaction's memo
     *
     * @private
     * @type {string}
     */
    private _transactionMemo;
    /**
     * The list of transaction IDs. This list will almost always be of length 1.
     * The only time this list will be a different length is for chunked transactions.
     * The only two chunked transactions supported right now are `FileAppendTransaction`
     * and `TopicMessageSubmitTransaction`
     *
     * @protected
     * @type {List<TransactionId>}
     */
    protected _transactionIds: List<TransactionId>;
    /**
     * A list of public keys that will be added to the requests signatures
     *
     * @private
     * @type {PublicKey[]}
     */
    private _publicKeys;
    /**
     * The list of signing function 1-1 with `_publicKeys` which sign the request.
     * The reason this list allows `null` is because if we go from bytes into
     * a transaction, then we know the public key, but we don't have the signing function.
     *
     * @private
     * @type {(((message: Uint8Array) => Promise<Uint8Array>) | null)[]}
     */
    private _transactionSigners;
    /**
     * Determine if we should regenerate transaction IDs when we receive `TRANSACITON_EXPIRED`
     *
     * @private
     * @type {?boolean}
     */
    private _regenerateTransactionId;
    /**
     * Convert this transaction a `ScheduleCreateTransaction`
     *
     * @returns {ScheduleCreateTransaction}
     */
    schedule(): ScheduleCreateTransaction;
    /**
     * Set the node account IDs
     *
     * @override
     * @param {AccountId[]} nodeIds
     * @returns {this}
     */
    override setNodeAccountIds(nodeIds: AccountId[]): this;
    /**
     * Get the transaction valid duration
     *
     * @returns {number}
     */
    get transactionValidDuration(): number;
    /**
     * Sets the duration (in seconds) that this transaction is valid for.
     *
     * This is defaulted to 120 seconds (from the time its executed).
     *
     * @param {number} validDuration
     * @returns {this}
     */
    setTransactionValidDuration(validDuration: number): this;
    /**
     * Get the max transaction fee
     *
     * @returns {?Hbar}
     */
    get maxTransactionFee(): Hbar | null;
    /**
     * Set the maximum transaction fee the operator (paying account)
     * is willing to pay.
     *
     * @param {number | string | Long | BigNumber | Hbar} maxTransactionFee
     * @returns {this}
     */
    setMaxTransactionFee(maxTransactionFee: number | string | Long | BigNumber | Hbar): this;
    /**
     * Is transaction ID regeneration enabled
     *
     * @returns {?boolean}
     */
    get regenerateTransactionId(): boolean | null;
    /**
     * Set the maximum transaction fee the operator (paying account)
     * is willing to pay.
     *
     * @param {boolean} regenerateTransactionId
     * @returns {this}
     */
    setRegenerateTransactionId(regenerateTransactionId: boolean): this;
    /**
     * Get the transaction memo
     *
     * @returns {string}
     */
    get transactionMemo(): string;
    /**
     * Set a note or description to be recorded in the transaction
     * record (maximum length of 100 bytes).
     *
     * @param {string} transactionMemo
     * @returns {this}
     */
    setTransactionMemo(transactionMemo: string): this;
    /**
     * Get the curent transaction ID
     *
     * @returns {?TransactionId}
     */
    get transactionId(): TransactionId | null;
    /**
     * Set the ID for this transaction.
     *
     * The transaction ID includes the operator's account ( the account paying the transaction
     * fee). If two transactions have the same transaction ID, they won't both have an effect. One
     * will complete normally and the other will fail with a duplicate transaction status.
     *
     * Normally, you should not use this method. Just before a transaction is executed, a
     * transaction ID will be generated from the operator on the client.
     *
     * @param {TransactionId} transactionId
     * @returns {this}
     */
    setTransactionId(transactionId: TransactionId): this;
    /**
     * Sign the transaction with the private key
     * **NOTE**: This is a thin wrapper around `.signWith()`
     *
     * @param {PrivateKey} privateKey
     * @returns {Promise<this>}
     */
    sign(privateKey: PrivateKey): Promise<Transaction>;
    /**
     * Sign the transaction with the public key and signer function
     *
     * If sign on demand is enabled no signing will be done immediately, instead
     * the private key signing function and public key are saved to be used when
     * a user calls an exit condition method (not sure what a better name for this is)
     * such as `toBytes[Async]()`, `getTransactionHash[PerNode]()` or `execute()`.
     *
     * @param {PublicKey} publicKey
     * @param {(message: Uint8Array) => Promise<Uint8Array>} transactionSigner
     * @returns {Promise<this>}
     */
    signWith(publicKey: PublicKey, transactionSigner: (message: Uint8Array) => Promise<Uint8Array>): Promise<Transaction>;
    /**
     * Sign the transaction with the client operator. This is a thin wrapper
     * around `.signWith()`
     *
     * **NOTE**: If client does not have an operator set, this method will throw
     *
     * @param {import("../client/Client.js").default<Channel, *>} client
     * @returns {Promise<this>}
     */
    signWithOperator(client: import("../client/Client.js").default<Channel, any>): Promise<Transaction>;
    /**
     * Add a signature explicitly
     *
     * This method requires the transaction to have exactly 1 node account ID set
     * since different node account IDs have different byte representations and
     * hence the same signature would not work for all transactions that are the same
     * except for node account ID being different.
     *
     * @param {PublicKey} publicKey
     * @param {Uint8Array} signature
     * @returns {this}
     */
    addSignature(publicKey: PublicKey, signature: Uint8Array): this;
    /**
     * Get the current signatures on the request
     *
     * **NOTE**: Does NOT support sign on demand
     *
     * @returns {SignatureMap}
     */
    getSignatures(): SignatureMap;
    /**
     * Get the current signatures on the request
     *
     * **NOTE**: Supports sign on demand
     *
     * @returns {Promise<SignatureMap>}
     */
    getSignaturesAsync(): Promise<SignatureMap>;
    /**
     * Not sure why this is called `setTransactionId()` when it doesn't set anything...
     * FIXME: Remove this?
     */
    _setTransactionId(): void;
    /**
     * Set the node account IDs using the client
     *
     * @param {?import("../client/Client.js").default<Channel, *>} client
     */
    _setNodeAccountIds(client: import("../client/Client.js").default<Channel, any> | null): void;
    /**
     * Build all the signed transactions from the node account IDs
     *
     * @private
     */
    private _buildSignedTransactions;
    /**
     * Freeze this transaction from future modification to prepare for
     * signing or serialization.
     *
     * @returns {this}
     */
    freeze(): this;
    /**
     * @param {?AccountId} accountId
     */
    _freezeWithAccountId(accountId: AccountId | null): void;
    _operatorAccountId: AccountId | null | undefined;
    /**
     * Freeze this transaction from further modification to prepare for
     * signing or serialization.
     *
     * Will use the `Client`, if available, to generate a default Transaction ID and select 1/3
     * nodes to prepare this transaction for.
     *
     * @param {?import("../client/Client.js").default<Channel, *>} client
     * @returns {this}
     */
    freezeWith(client: import("../client/Client.js").default<Channel, any> | null): this;
    /**
     * Sign the transaction using a signer
     *
     * This is part of the signature provider feature
     *
     * @param {Signer} signer
     * @returns {Promise<this>}
     */
    signWithSigner(signer: Signer): Promise<Transaction>;
    /**
     * Freeze the transaction using a signer
     *
     * This is part of the signature provider feature.
     *
     * @param {Signer} signer
     * @returns {Promise<this>}
     */
    freezeWithSigner(signer: Signer): Promise<Transaction>;
    /**
     * Serialize the transaction into bytes
     *
     * **NOTE**: Supports sign on demand
     *
     * @returns {Promise<Uint8Array>}
     */
    toBytesAsync(): Promise<Uint8Array>;
    /**
     * Get the transaction hash
     *
     * @returns {Promise<Uint8Array>}
     */
    getTransactionHash(): Promise<Uint8Array>;
    /**
     * Get all the transaction hashes
     *
     * @returns {Promise<TransactionHashMap>}
     */
    getTransactionHashPerNode(): Promise<TransactionHashMap>;
    /**
     * Is transaction frozen
     *
     * @returns {boolean}
     */
    isFrozen(): boolean;
    /**
     * @param {Client} client
     */
    _validateChecksums(client: import("../client/Client.js").default<any, any>): void;
    /**
     * Sign a `proto.SignedTransaction` with all the keys
     *
     * @private
     * @returns {Promise<HashgraphProto.proto.ISignedTransaction>}
     */
    private _signTransaction;
    /**
     * Construct a new transaction ID at the current index
     *
     * @private
     */
    private _buildNewTransactionIdList;
    /**
     * Build each transaction in a loop
     *
     * @private
     */
    private _buildAllTransactions;
    /**
     * Build and and sign each transaction in a loop
     *
     * This method is primary used in the exist condition methods
     * which are not `execute()`, e.g. `toBytesAsync()` and `getSignaturesAsync()`
     *
     * @private
     */
    private _buildAllTransactionsAsync;
    /**
     * Build a transaction at a particular index
     *
     * @private
     * @param {number} index
     */
    private _buildTransaction;
    /**
     * Build a trransaction using the current index, where the current
     * index is determined by `this._nodeAccountIds.index` and
     * `this._transactionIds.index`
     *
     * @private
     * @returns {Promise<HashgraphProto.proto.ITransaction>}
     */
    private _buildTransactionAsync;
    /**
     * Make a signed tranaction given a node account ID
     *
     * @internal
     * @param {?AccountId} nodeId
     * @returns {HashgraphProto.proto.ISignedTransaction}
     */
    _makeSignedTransaction(nodeId: AccountId | null): HashgraphProto.proto.ISignedTransaction;
    /**
     * Make a protobuf transaction body
     *
     * @private
     * @param {?AccountId} nodeId
     * @returns {HashgraphProto.proto.ITransactionBody}
     */
    private _makeTransactionBody;
    /**
     * This method returns a key for the `data` field in a transaction body.
     * Each transaction overwrite this to make sure when we build the transaction body
     * we set the right data field.
     *
     * @abstract
     * @protected
     * @returns {NonNullable<HashgraphProto.proto.TransactionBody["data"]>}
     */
    protected _getTransactionDataCase(): NonNullable<HashgraphProto.proto.TransactionBody["data"]>;
    /**
     * Make a scheduled transaction body
     * FIXME: Should really call this `makeScheduledTransactionBody` to be consistent
     *
     * @internal
     * @returns {HashgraphProto.proto.ISchedulableTransactionBody}
     */
    _getScheduledTransactionBody(): HashgraphProto.proto.ISchedulableTransactionBody;
    /**
     * Make the transaction body data.
     *
     * @abstract
     * @protected
     * @returns {object}
     */
    protected _makeTransactionData(): object;
    /**
     * FIXME: Why do we have `isFrozen` and `_isFrozen()`?
     *
     * @protected
     * @returns {boolean}
     */
    protected _isFrozen(): boolean;
    /**
     * Require the transaction to NOT be frozen
     *
     * @internal
     */
    _requireNotFrozen(): void;
    /**
     * Require the transaction to have sign on demand disabled
     *
     * @internal
     */
    _requireNotSignOnDemand(): void;
    /**
     * Require the transaction to be frozen
     *
     * @internal
     */
    _requireFrozen(): void;
    /**
     * Require the transaction to have a single node account ID set
     *
     * @internal
     * @protected
     */
    protected _requireOneNodeAccountId(): void;
    /**
     * @param {HashgraphProto.proto.Transaction} request
     * @returns {Uint8Array}
     */
    _requestToBytes(request: HashgraphProto.proto.Transaction): Uint8Array;
    /**
     * @param {HashgraphProto.proto.TransactionResponse} response
     * @returns {Uint8Array}
     */
    _responseToBytes(response: HashgraphProto.proto.TransactionResponse): Uint8Array;
}
/**
 * This is essentially a registry/cache for a callback that creates a `ScheduleCreateTransaction`
 *
 * @type {(() => ScheduleCreateTransaction)[]}
 */
export const SCHEDULE_CREATE_TRANSACTION: (() => ScheduleCreateTransaction)[];
export type BigNumber = import("bignumber.js").default;
export type ScheduleCreateTransaction = import("../schedule/ScheduleCreateTransaction.js").default;
export type PrivateKey = import("../PrivateKey.js").default;
export type Channel = import("../channel/Channel.js").default;
export type Client = import("../client/Client.js").default<any, any>;
export type Signer = import("../Signer.js").Signer;
import Long from "long";
import Hbar from "../Hbar.js";
import * as HashgraphProto from "@hashgraph/proto";
import TransactionId from "./TransactionId.js";
import AccountId from "../account/AccountId.js";
import TransactionResponse from "./TransactionResponse.js";
import Executable from "../Executable.js";
import List from "./List.js";
import PublicKey from "../PublicKey.js";
import SignatureMap from "./SignatureMap.js";
import TransactionHashMap from "./TransactionHashMap.js";

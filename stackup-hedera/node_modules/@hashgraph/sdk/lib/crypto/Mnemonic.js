"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Mnemonic = void 0;
const bip39 = require("bip39");
const Ed25519PrivateKey_1 = require("./Ed25519PrivateKey");
const MnemonicValidationResult_1 = require("./MnemonicValidationResult");
const legacyWordList_1 = require("./legacyWordList");
const bignumber_js_1 = require("bignumber.js");
const Sha256_1 = require("./Sha256");
const util_1 = require("./util");
/** result of `generateMnemonic()` */
class Mnemonic {
    /**
     * Recover a mnemonic from a list of 24 words.
     *
     * @param words
     */
    constructor(words) {
        this._isLegacy = false;
        if (words.length === 22) {
            this._isLegacy = true;
        }
        this.words = words;
    }
    /** Lazily generate the key, providing an optional passphrase to protect it with */
    toPrivateKey(passphrase) {
        return Ed25519PrivateKey_1.Ed25519PrivateKey.fromMnemonic(this, passphrase);
    }
    /**
     * Legacy word mnemonic
     */
    toLegacyPrivateKey() {
        return __awaiter(this, void 0, void 0, function* () {
            const index = this._isLegacy ? -1 : 0;
            const entropy = this._isLegacy ? this._toLegacyEntropy() : yield this._toLegacyEntropy2();
            const keyBytes = yield util_1.legacyDeriveChildKey(entropy, index);
            return Ed25519PrivateKey_1.Ed25519PrivateKey.fromBytes(keyBytes);
        });
    }
    /**
     * Generate a random 24-word mnemonic.
     *
     * If you are happy with the mnemonic produced you can call {@link .toPrivateKey} on the
     * returned object.
     *
     * This mnemonics that are compatible with the Android and iOS mobile wallets.
     *
     * **NOTE:** Mnemonics must be saved separately as they cannot be later recovered from a given
     * key.
     */
    static generate() {
        // 256-bit entropy gives us 24 words
        return new Mnemonic(bip39.generateMnemonic(256).split(" "));
    }
    /**
     * Recover a mnemonic phrase from a string, splitting on spaces.
     *
     * @param mnemonic
     */
    static fromString(mnemonic) {
        return new Mnemonic(mnemonic.split(" "));
    }
    /**
     * Validate that this is a valid BIP-39 mnemonic as generated by BIP-39's rules.
     * <p>
     * Technically, invalid mnemonics can still be used to generate valid private keys,
     * but if they became invalid due to user error then it will be difficult for the user
     * to tell the difference unless they compare the generated keys.
     * <p>
     * During validation, the following conditions are checked in order:
     * <ol>
     *     <li>{@link this.words.length} == 24</li>
     *     <li>All strings in {@link this.words} exist in the BIP-39 standard English word list (no normalization is done).</li>
     *     <li>The calculated checksum for the mnemonic equals the checksum encoded in the mnemonic.</li>
     * </ol>
     * <p>
     *
     * @return the result of the validation.
     * @see {@link https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki | Bitcoin Improvement Project proposal 39 (BIP-39) }
     * @see {@link https://github.com/bitcoin/bips/blob/master/bip-0039/english.txt | BIP-39 English word list }
     */
    validate() {
        if (this._isLegacy) {
            return this._validateLegacy();
        }
        if (this.words.length !== 24) {
            return new MnemonicValidationResult_1.MnemonicValidationResult(1 /* BadLength */);
        }
        const unknownIndices = this.words.reduce((unknowns, word, index) => 
        // eslint-disable-next-line implicit-arrow-linebreak
        bip39.wordlists.english.includes(word.toLowerCase()) ?
            unknowns :
            [...unknowns, index], []);
        if (unknownIndices.length > 0) {
            return new MnemonicValidationResult_1.MnemonicValidationResult(2 /* UnknownWords */, unknownIndices);
        }
        // this would cover length and unknown words but it only gives us a `boolean`
        // we validate those first and then let `bip39` do the non-trivial checksum verification
        if (!bip39.validateMnemonic(this.words.map((word) => word.toLowerCase()).join(" "), bip39.wordlists.english)) {
            return new MnemonicValidationResult_1.MnemonicValidationResult(3 /* ChecksumMismatch */);
        }
        return new MnemonicValidationResult_1.MnemonicValidationResult(0 /* Ok */);
    }
    /**
     * Validate that this is a valid legacy mnemonic as generated by the Android and iOS wallets.
     * <p>
     * Technically, invalid mnemonics can still be used to generate valid private keys,
     * but if they became invalid due to user error then it will be difficult for the user
     * to tell the difference unless they compare the generated keys.
     * <p>
     * During validation, the following conditions are checked in order:
     * <ol>
     *     <li>{@link this.words.length} == 22</li>
     *     <li>All strings in {@link this.words} exist in the legacy word list (no normalization is done).</li>
     *     <li>The calculated checksum for the mnemonic equals the checksum encoded in the mnemonic.</li>
     * </ol>
     * <p>
     *
     * @return the result of the validation.
     */
    _validateLegacy() {
        if (!this._isLegacy) {
            throw new Error("`validateLegacy` cannot be called on non-legacy mnemonics");
        }
        const unknownIndices = this.words.reduce((unknowns, word, index) => 
        // eslint-disable-next-line implicit-arrow-linebreak
        legacyWordList_1.default.includes(word) ? unknowns : [...unknowns, index], []);
        if (unknownIndices.length > 0) {
            return new MnemonicValidationResult_1.MnemonicValidationResult(4 /* UnknownLegacyWords */, unknownIndices);
        }
        // Checksum validation
        // We already made sure all the words are valid so if this is null we know it was due to the checksum
        try {
            this._toLegacyEntropy();
        }
        catch (_a) {
            return new MnemonicValidationResult_1.MnemonicValidationResult(3 /* ChecksumMismatch */);
        }
        return new MnemonicValidationResult_1.MnemonicValidationResult(0 /* Ok */);
    }
    _toLegacyEntropy() {
        const numWords = this.words.length;
        const len256Bits = Math.ceil((256 + 8) / Math.log2(legacyWordList_1.default.length));
        if (numWords !== len256Bits) {
            throw new Error(`there should be ${len256Bits} words, not ${numWords}`);
        }
        const indicies = this.words.map((word) => legacyWordList_1.default.indexOf(word.toLowerCase()));
        const data = _convertRadix(indicies, legacyWordList_1.default.length, 256, 33);
        const crc = data[data.length - 1];
        const result = new Uint8Array(data.length - 1);
        for (let i = 0; i < data.length - 1; i += 1) {
            result[i] = data[i] ^ crc;
        }
        const crc2 = _crc8(result);
        if (crc !== crc2) {
            throw new Error("Invalid legacy mnemonic: fails the cyclic redundency check");
        }
        return result;
    }
    _toLegacyEntropy2() {
        return __awaiter(this, void 0, void 0, function* () {
            const concatBitsLen = this.words.length * 11;
            const concatBits = [];
            concatBits.fill(false, 0, concatBitsLen);
            for (const [wordIndex, word] of this.words.entries()) {
                const index = bip39.wordlists.english.indexOf(word.toLowerCase());
                if (index < 0) {
                    throw new Error(`Word not found in wordlist: ${word}`);
                }
                for (let i = 0; i < 11; i += 1) {
                    concatBits[(wordIndex * 11) + i] = (index & (1 << (10 - i))) !== 0;
                }
            }
            const checksumBitsLen = concatBitsLen / 33;
            const entropyBitsLen = concatBitsLen - checksumBitsLen;
            const entropy = new Uint8Array(entropyBitsLen / 8);
            for (let i = 0; i < entropy.length; i += 1) {
                for (let j = 0; j < 8; j += 1) {
                    if (concatBits[(i * 8) + j]) {
                        entropy[i] |= 1 << (7 - j);
                    }
                }
            }
            // Checksum validation
            const hash = yield Sha256_1.Sha256.hash(entropy);
            const hashBits = bytesToBits(hash);
            for (let i = 0; i < checksumBitsLen; i += 1) {
                if (concatBits[entropyBitsLen + i] !== hashBits[i]) {
                    throw new Error("Checksum mismatch");
                }
            }
            return entropy;
        });
    }
    toString() {
        return this.words.join(" ");
    }
}
exports.Mnemonic = Mnemonic;
function _crc8(data) {
    let crc = 0xFF;
    for (let i = 0; i < data.length - 1; i += 1) {
        crc ^= data[i];
        for (let j = 0; j < 8; j += 1) {
            crc = (crc >>> 1) ^ ((crc & 1) === 0 ? 0 : 0xB2);
        }
    }
    return crc ^ 0xFF;
}
function _convertRadix(nums, fromRadix, toRadix, toLength) {
    let num = new bignumber_js_1.default(0);
    for (const element of nums) {
        num = num.times(fromRadix);
        num = num.plus(element);
    }
    const result = new Uint8Array(toLength);
    for (let i = toLength - 1; i >= 0; i -= 1) {
        const tem = num.dividedToIntegerBy(toRadix);
        const rem = num.modulo(toRadix);
        num = tem;
        result[i] = rem.toNumber();
    }
    return result;
}
function bytesToBits(data) {
    const bits = [];
    bits.fill(false, 0, data.length * 8);
    // eslint-disable-next-line unicorn/no-for-loop
    for (let i = 0; i < data.length; i += 1) {
        for (let j = 0; j < 8; j += 1) {
            bits[(i * 8) + j] = (data[i] & (1 << (7 - j))) !== 0;
        }
    }
    return bits;
}

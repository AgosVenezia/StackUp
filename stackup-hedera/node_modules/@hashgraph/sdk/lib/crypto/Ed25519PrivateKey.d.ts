import { Ed25519PublicKey } from "./Ed25519PublicKey";
import { Mnemonic } from "./Mnemonic";
export declare class Ed25519PrivateKey {
    readonly publicKey: Ed25519PublicKey;
    readonly _keyData: Uint8Array;
    private _asStringRaw?;
    private _chainCode?;
    private constructor();
    /**
     * Recover a private key from its raw bytes form.
     *
     * This key will _not_ support child key derivation.
     */
    static fromBytes(bytes: Uint8Array): Ed25519PrivateKey;
    /**
     * Recover a key from a hex-encoded string.
     *
     * This key will _not_ support child key derivation.
     */
    static fromString(keyStr: string): Ed25519PrivateKey;
    /**
     * Recover a key from a 24 or 22-word mnemonic.
     *
     * There is no corresponding `toMnemonic()` as the mnemonic cannot be recovered from the key.
     *
     * Instead, you must generate a mnemonic and a corresponding key in that order with
     * `generateMnemonic()`.
     *
     * This accepts mnemonics generated by the Android and iOS mobile wallets.
     *
     * This key *will* support deriving child keys with `.derive()`.
     *
     * If the mnemonic has 22 words, the resulting key will not support deriving child keys.
     *
     * @param mnemonic the mnemonic, either as a string separated by spaces or as a 24-element array
     * @param passphrase the passphrase to protect the private key with
     *
     * @link generateMnemonic
     */
    static fromMnemonic(mnemonic: Mnemonic, passphrase: string): Promise<Ed25519PrivateKey>;
    /**
     * Recover a private key from a keystore blob previously created by `.createKeystore()`.
     *
     * This key will _not_ support child key derivation.
     *
     * @param keystore the keystore blob
     * @param passphrase the passphrase used to create the keystore
     * @throws KeyMismatchError if the passphrase is incorrect or the hash fails to validate
     * @link createKeystore
     */
    static fromKeystore(keystore: Uint8Array, passphrase: string): Promise<Ed25519PrivateKey>;
    /**
     * Generate a new, cryptographically random private key.
     *
     * This key will _not_ support child key derivation.
     */
    static generate(): Promise<Ed25519PrivateKey>;
    /**
     * Derive a new private key at the given wallet index.
     *
     * Only currently supported for keys created with `fromMnemonic()`; other keys will throw
     * an error.
     *
     * You can check if a key supports derivation with `.supportsDerivation`
     *
     * @deprecated `Ed25519PrivateKey.derive()` is deprecated and will eventually be replaced with the async variant `Ed25519PrivateKey.derive2()`
     */
    derive(index: number): Ed25519PrivateKey;
    /**
     * Derive a new private key at the given wallet index.
     *
     * Only currently supported for keys created with `fromMnemonic()`; other keys will throw
     * an error.
     *
     * You can check if a key supports derivation with `.supportsDerivation`
     *
     * Will eventually replace `Ed25519PrivateKey.derive()`
     */
    derive2(index: number): Promise<Ed25519PrivateKey>;
    legacyDerive(index: number): Promise<Ed25519PrivateKey>;
    /** Check if this private key supports deriving child keys */
    get supportsDerivation(): boolean;
    toBytes(): Uint8Array;
    toString(raw?: boolean): string;
    /**
     * Create a keystore blob with a given passphrase.
     *
     * The key can be recovered later with `fromKeystore()`.
     *
     * Note that this will not retain the ancillary data used for deriving child keys,
     * thus `.derive()` on the restored key will throw even if this instance supports derivation.
     *
     * @link fromKeystore
     */
    toKeystore(passphrase: string): Promise<Uint8Array>;
    /**
     * Recover a private key from a pem string; the private key may be encrypted.
     *
     * This method assumes the .pem file has been converted to a string already.
     *
     * If `passphrase` is not null or empty, this looks for the first `ENCRYPTED PRIVATE KEY`
     * section and uses `passphrase` to decrypt it; otherwise, it looks for the first `PRIVATE KEY`
     * section and decodes that as a DER-encoded Ed25519 private key.
     */
    static fromPem(pem: string, passphrase?: string): Promise<Ed25519PrivateKey>;
}

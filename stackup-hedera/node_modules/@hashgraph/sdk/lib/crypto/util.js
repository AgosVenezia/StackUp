"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.arraysEqual = exports.deriveChildKey = exports.deriveChildKey2 = exports.legacyDeriveChildKey = exports.hmacAlgo = exports.ed25519PubKeyPrefix = exports.ed25519PrivKeyPrefix = void 0;
const crypto = require("crypto");
const Hmac_1 = require("./Hmac");
const Pbkdf2_1 = require("./Pbkdf2");
// we could go through the whole BS of producing a DER-encoded structure but it's quite simple
// for Ed25519 keys and we don't have to shell out to a potentially broken lib
// https://github.com/PeculiarVentures/pvutils/issues/8
exports.ed25519PrivKeyPrefix = "302e020100300506032b657004220420";
exports.ed25519PubKeyPrefix = "302a300506032b6570032100";
exports.hmacAlgo = "sha384";
/**
 * SLIP-10/BIP-32 child key derivation
 * without using chaincode
 */
function legacyDeriveChildKey(seed, index) {
    const password = new Uint8Array(seed.length + 8);
    password.set(seed, 0);
    const view = new DataView(password.buffer, password.byteOffset + seed.length, 8);
    view.setInt32(0, index);
    view.setInt32(4, index);
    const salt = Uint8Array.from([0xFF]);
    return Pbkdf2_1.Pbkdf2.deriveKey(Hmac_1.HashAlgorithm.Sha512, password, salt, 2048, 32);
}
exports.legacyDeriveChildKey = legacyDeriveChildKey;
/** SLIP-10/BIP-32 child key derivation */
function deriveChildKey2(parentKey, chainCode, index) {
    return __awaiter(this, void 0, void 0, function* () {
        // webpack version of crypto complains if input types are not `Buffer`
        const input = new Uint8Array(37);
        // 0x00 + parentKey + index(BE)
        input[0] = 0;
        input.set(parentKey, 1);
        new DataView(input.buffer).setUint32(33, index, false);
        // set the index to hardened
        input[33] |= 128;
        const digest = yield Hmac_1.Hmac.hash(Hmac_1.HashAlgorithm.Sha512, chainCode, input);
        return { keyBytes: digest.subarray(0, 32), chainCode: digest.subarray(32) };
    });
}
exports.deriveChildKey2 = deriveChildKey2;
/** SLIP-10/BIP-32 child key derivation */
function deriveChildKey(parentKey, chainCode, index) {
    // webpack version of crypto complains if input types are not `Buffer`
    const hmac = crypto.createHmac("SHA512", Buffer.from(chainCode));
    const input = new Uint8Array(37);
    // 0x00 + parentKey + index(BE)
    input[0] = 0;
    input.set(parentKey, 1);
    new DataView(input.buffer).setUint32(33, index, false);
    // set the index to hardened
    input[33] |= 128;
    hmac.update(input);
    const digest = hmac.digest();
    return { keyBytes: digest.subarray(0, 32), chainCode: digest.subarray(32) };
}
exports.deriveChildKey = deriveChildKey;
function arraysEqual(a, b) {
    if (a === b)
        return true;
    if (a == null || b == null)
        return false;
    if (a.length !== b.length)
        return false;
    for (const [i, element] of a.entries()) {
        if (element !== b[i])
            return false;
    }
    return true;
}
exports.arraysEqual = arraysEqual;

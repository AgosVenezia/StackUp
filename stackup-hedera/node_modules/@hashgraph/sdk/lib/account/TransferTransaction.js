"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransferTransaction = void 0;
const TransactionBuilder_1 = require("../TransactionBuilder");
const CryptoTransfer_pb_1 = require("../generated/CryptoTransfer_pb");
const CryptoService_pb_service_1 = require("../generated/CryptoService_pb_service");
const BasicTypes_pb_1 = require("../generated/BasicTypes_pb");
const TokenId_1 = require("../token/TokenId");
const Hbar_1 = require("../Hbar");
const AccountId_1 = require("./AccountId");
const bignumber_js_1 = require("bignumber.js");
/**
 * Transfer tokens from some accounts to other accounts. Each negative amount is withdrawn from the corresponding
 * account (a sender), and each positive one is added to the corresponding account (a receiver). All amounts must
 * have sum of zero.
 * Each amount is a number with the lowest denomination possible for a token. Example:
 * Token X has 2 decimals. Account A transfers amount of 100 tokens by providing 10000 as amount in the TransferList.
 * If Account A wants to send 100.55 tokens, he must provide 10055 as amount.
 *
 * If any sender account fails to have sufficient token balance, then the entire transaction fails and none of the
 * transfers occur, though transaction fee is still charged.
 */
class TransferTransaction extends TransactionBuilder_1.SingleTransactionBuilder {
    constructor() {
        super();
        this._body = new CryptoTransfer_pb_1.CryptoTransferTransactionBody();
        this._tokenIdIndexes = new Map();
        this._body.setTokentransfersList([]);
        this._body.setTransfers(new BasicTypes_pb_1.TransferList());
        this._inner.setCryptotransfer(this._body);
    }
    /**
     * addHbar a transfer to the list of transfers. Negative values are `senders` and
     * postitive values are `receivers`. Perfer using `CryptoTransferTransaction.addHbarSender()`
     * and `CryptoTransferTransaction.addHbarRecipient()` instead as those methods automatically
     * negate the values appropriately.
     */
    addHbarTransfer(accountId, amount) {
        const amountHbar = Hbar_1.hbarFromTinybarOrHbar(amount);
        amountHbar[Hbar_1.hbarCheck]({ allowNegative: true });
        const transfers = this._body.getTransfers() || new BasicTypes_pb_1.TransferList();
        this._body.setTransfers(transfers);
        const acctAmt = new BasicTypes_pb_1.AccountAmount();
        acctAmt.setAccountid(new AccountId_1.AccountId(accountId)._toProto());
        acctAmt.setAmount(amountHbar[Hbar_1.hbarToProto]());
        transfers.addAccountamounts(acctAmt);
        return this;
    }
    addTokenTransfer(tokenId, accountId, amount) {
        const index = this._tokenIdIndexes.get(new TokenId_1.TokenId(tokenId).toString());
        const token = new TokenId_1.TokenId(tokenId);
        if (index == null) {
            this._tokenIdIndexes.set(token.toString(), this._body.getTokentransfersList().length);
        }
        let list;
        if (index != null) {
            list = this._body.getTokentransfersList()[index];
        }
        else {
            list = new BasicTypes_pb_1.TokenTransferList();
            this._body.addTokentransfers(list);
        }
        list.setToken(token._toProto());
        const transfers = list.getTransfersList();
        const acctAmt = new BasicTypes_pb_1.AccountAmount();
        acctAmt.setAccountid(new AccountId_1.AccountId(accountId)._toProto());
        acctAmt.setAmount(amount instanceof bignumber_js_1.default ?
            amount.toString(10) :
            new bignumber_js_1.default(amount).toString(10));
        transfers.push(acctAmt);
        return this;
    }
    _doValidate(_) { }
    get _method() {
        return CryptoService_pb_service_1.CryptoService.cryptoTransfer;
    }
}
exports.TransferTransaction = TransferTransaction;

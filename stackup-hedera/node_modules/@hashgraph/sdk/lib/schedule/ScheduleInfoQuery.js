"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ScheduleInfoQuery = exports.ScheduleInfo = void 0;
const QueryBuilder_1 = require("../QueryBuilder");
const ScheduleService_pb_service_1 = require("../generated/ScheduleService_pb_service");
const ScheduleGetInfo_pb_1 = require("../generated/ScheduleGetInfo_pb");
const Transaction_1 = require("../Transaction");
const Transaction_pb_1 = require("../generated/Transaction_pb");
const QueryHeader_pb_1 = require("../generated/QueryHeader_pb");
const SchedulableTransactionBody_pb_1 = require("../generated/SchedulableTransactionBody_pb");
const ScheduleId_1 = require("../schedule/ScheduleId");
const AccountId_1 = require("../account/AccountId");
const Timestamp_1 = require("../Timestamp");
const Hbar_1 = require("../Hbar");
const PublicKey_1 = require("../crypto/PublicKey");
const TransactionBody_pb_1 = require("../generated/TransactionBody_pb");
const TransactionId_1 = require("../TransactionId");
const util_1 = require("../util");
/**
 * Response when the client sends the node ScheduleGetInfoQuery.
 */
class ScheduleInfo {
    constructor(scheduleInfo) {
        this.scheduleId = ScheduleId_1.ScheduleId._fromProto(scheduleInfo.getScheduleid());
        this.creatorAccountId = AccountId_1.AccountId._fromProto(scheduleInfo.getCreatoraccountid());
        this.payerAccountId = AccountId_1.AccountId._fromProto(scheduleInfo.getPayeraccountid());
        this.transactionBody = scheduleInfo.hasScheduledtransactionbody() ?
            scheduleInfo.getScheduledtransactionbody() :
            null;
        this.adminKey = PublicKey_1._fromProtoKey(scheduleInfo.getAdminkey());
        this.signatories = PublicKey_1._fromProtoKeyList(scheduleInfo.getSigners());
        this.memo = scheduleInfo.getMemo();
        this.expirationTime = scheduleInfo.hasExpirationtime() ?
            Timestamp_1.timestampToDate(scheduleInfo.getExpirationtime()) :
            null;
        this.executionTime = scheduleInfo.hasExecutionTime() ?
            Timestamp_1.timestampToDate(scheduleInfo.getExecutionTime()) :
            null;
        this.deletionTime = scheduleInfo.hasDeletionTime() ?
            Timestamp_1.timestampToDate(scheduleInfo.getDeletionTime()) :
            null;
        this.scheduledTransactionId = scheduleInfo.hasScheduledtransactionid() ?
            TransactionId_1.TransactionId._fromProto(scheduleInfo.getScheduledtransactionid()) :
            null;
    }
    getTransaction() {
        var _a;
        const protoTransaction = new Transaction_pb_1.Transaction();
        let scheduledB;
        if (this.transactionBody !== null) {
            scheduledB = this.transactionBody;
        }
        else {
            throw new Error("scheduled transaction body is empty");
        }
        const body = new TransactionBody_pb_1.TransactionBody();
        body.setMemo(this.transactionBody ? this.transactionBody.getMemo() : "");
        body.setTransactionfee(this.transactionBody ? this.transactionBody.getTransactionfee() : "");
        body.setNodeaccountid(new AccountId_1.AccountId(3)._toProto());
        body.setTransactionid((_a = this.scheduledTransactionId) === null || _a === void 0 ? void 0 : _a._toProto());
        body.setTransactionvalidduration(util_1.newDuration(2));
        switch (scheduledB.getDataCase()) {
            case SchedulableTransactionBody_pb_1.SchedulableTransactionBody.DataCase.CONTRACTCREATEINSTANCE:
                body.setContractcreateinstance(scheduledB.getContractcreateinstance());
                protoTransaction.setBodybytes(body.serializeBinary());
                return Transaction_1.Transaction.fromBytes(protoTransaction.serializeBinary());
            case SchedulableTransactionBody_pb_1.SchedulableTransactionBody.DataCase.CONTRACTDELETEINSTANCE:
                body.setContractdeleteinstance(scheduledB.getContractdeleteinstance());
                protoTransaction.setBodybytes(body.serializeBinary());
                return Transaction_1.Transaction.fromBytes(protoTransaction.serializeBinary());
            case SchedulableTransactionBody_pb_1.SchedulableTransactionBody.DataCase.CONTRACTUPDATEINSTANCE:
                body.setContractupdateinstance(scheduledB.getContractupdateinstance());
                protoTransaction.setBodybytes(body.serializeBinary());
                return Transaction_1.Transaction.fromBytes(protoTransaction.serializeBinary());
            case SchedulableTransactionBody_pb_1.SchedulableTransactionBody.DataCase.CONTRACTCALL:
                body.setContractcall(scheduledB.getContractcall());
                protoTransaction.setBodybytes(body.serializeBinary());
                return Transaction_1.Transaction.fromBytes(protoTransaction.serializeBinary());
            case SchedulableTransactionBody_pb_1.SchedulableTransactionBody.DataCase.CONSENSUSCREATETOPIC:
                body.setConsensuscreatetopic(scheduledB.getConsensuscreatetopic());
                protoTransaction.setBodybytes(body.serializeBinary());
                return Transaction_1.Transaction.fromBytes(protoTransaction.serializeBinary());
            case SchedulableTransactionBody_pb_1.SchedulableTransactionBody.DataCase.CONSENSUSDELETETOPIC:
                body.setConsensusdeletetopic(scheduledB.getConsensusdeletetopic());
                protoTransaction.setBodybytes(body.serializeBinary());
                return Transaction_1.Transaction.fromBytes(protoTransaction.serializeBinary());
            case SchedulableTransactionBody_pb_1.SchedulableTransactionBody.DataCase.CONSENSUSSUBMITMESSAGE:
                body.setConsensussubmitmessage(scheduledB.getConsensussubmitmessage());
                protoTransaction.setBodybytes(body.serializeBinary());
                return Transaction_1.Transaction.fromBytes(protoTransaction.serializeBinary());
            case SchedulableTransactionBody_pb_1.SchedulableTransactionBody.DataCase.CONSENSUSUPDATETOPIC:
                body.setConsensusupdatetopic(scheduledB.getConsensusupdatetopic());
                protoTransaction.setBodybytes(body.serializeBinary());
                return Transaction_1.Transaction.fromBytes(protoTransaction.serializeBinary());
            case SchedulableTransactionBody_pb_1.SchedulableTransactionBody.DataCase.CRYPTOCREATEACCOUNT:
                body.setCryptocreateaccount(scheduledB.getCryptocreateaccount());
                protoTransaction.setBodybytes(body.serializeBinary());
                return Transaction_1.Transaction.fromBytes(protoTransaction.serializeBinary());
            case SchedulableTransactionBody_pb_1.SchedulableTransactionBody.DataCase.CRYPTODELETE:
                body.setCryptodelete(scheduledB.getCryptodelete());
                protoTransaction.setBodybytes(body.serializeBinary());
                return Transaction_1.Transaction.fromBytes(protoTransaction.serializeBinary());
            case SchedulableTransactionBody_pb_1.SchedulableTransactionBody.DataCase.CRYPTOUPDATEACCOUNT:
                body.setCryptoupdateaccount(scheduledB.getCryptoupdateaccount());
                protoTransaction.setBodybytes(body.serializeBinary());
                return Transaction_1.Transaction.fromBytes(protoTransaction.serializeBinary());
            case SchedulableTransactionBody_pb_1.SchedulableTransactionBody.DataCase.CRYPTOTRANSFER:
                body.setCryptotransfer(scheduledB.getCryptotransfer());
                protoTransaction.setBodybytes(body.serializeBinary());
                return Transaction_1.Transaction.fromBytes(protoTransaction.serializeBinary());
            case SchedulableTransactionBody_pb_1.SchedulableTransactionBody.DataCase.TOKENASSOCIATE:
                body.setTokenassociate(scheduledB.getTokenassociate());
                protoTransaction.setBodybytes(body.serializeBinary());
                return Transaction_1.Transaction.fromBytes(protoTransaction.serializeBinary());
            case SchedulableTransactionBody_pb_1.SchedulableTransactionBody.DataCase.TOKENBURN:
                body.setTokenburn(scheduledB.getTokenburn());
                protoTransaction.setBodybytes(body.serializeBinary());
                return Transaction_1.Transaction.fromBytes(protoTransaction.serializeBinary());
            case SchedulableTransactionBody_pb_1.SchedulableTransactionBody.DataCase.TOKENCREATION:
                body.setTokencreation(scheduledB.getTokencreation());
                protoTransaction.setBodybytes(body.serializeBinary());
                return Transaction_1.Transaction.fromBytes(protoTransaction.serializeBinary());
            case SchedulableTransactionBody_pb_1.SchedulableTransactionBody.DataCase.TOKENDELETION:
                body.setTokendeletion(scheduledB.getTokendeletion());
                protoTransaction.setBodybytes(body.serializeBinary());
                return Transaction_1.Transaction.fromBytes(protoTransaction.serializeBinary());
            case SchedulableTransactionBody_pb_1.SchedulableTransactionBody.DataCase.TOKENDISSOCIATE:
                body.setTokendissociate(scheduledB.getTokendissociate());
                protoTransaction.setBodybytes(body.serializeBinary());
                return Transaction_1.Transaction.fromBytes(protoTransaction.serializeBinary());
            case SchedulableTransactionBody_pb_1.SchedulableTransactionBody.DataCase.TOKENFREEZE:
                body.setTokenfreeze(scheduledB.getTokenfreeze());
                protoTransaction.setBodybytes(body.serializeBinary());
                return Transaction_1.Transaction.fromBytes(protoTransaction.serializeBinary());
            case SchedulableTransactionBody_pb_1.SchedulableTransactionBody.DataCase.TOKENGRANTKYC:
                body.setTokengrantkyc(scheduledB.getTokengrantkyc());
                protoTransaction.setBodybytes(body.serializeBinary());
                return Transaction_1.Transaction.fromBytes(protoTransaction.serializeBinary());
            case SchedulableTransactionBody_pb_1.SchedulableTransactionBody.DataCase.TOKENMINT:
                body.setTokenmint(scheduledB.getTokenmint());
                protoTransaction.setBodybytes(body.serializeBinary());
                return Transaction_1.Transaction.fromBytes(protoTransaction.serializeBinary());
            case SchedulableTransactionBody_pb_1.SchedulableTransactionBody.DataCase.TOKENREVOKEKYC:
                body.setTokenrevokekyc(scheduledB.getTokenrevokekyc());
                protoTransaction.setBodybytes(body.serializeBinary());
                return Transaction_1.Transaction.fromBytes(protoTransaction.serializeBinary());
            case SchedulableTransactionBody_pb_1.SchedulableTransactionBody.DataCase.TOKENUNFREEZE:
                body.setTokenunfreeze(scheduledB.getTokenunfreeze());
                protoTransaction.setBodybytes(body.serializeBinary());
                return Transaction_1.Transaction.fromBytes(protoTransaction.serializeBinary());
            case SchedulableTransactionBody_pb_1.SchedulableTransactionBody.DataCase.TOKENWIPE:
                body.setTokenwipe(scheduledB.getTokenwipe());
                protoTransaction.setBodybytes(body.serializeBinary());
                return Transaction_1.Transaction.fromBytes(protoTransaction.serializeBinary());
            case SchedulableTransactionBody_pb_1.SchedulableTransactionBody.DataCase.TOKENUPDATE:
                body.setTokenupdate(scheduledB.getTokenupdate());
                protoTransaction.setBodybytes(body.serializeBinary());
                return Transaction_1.Transaction.fromBytes(protoTransaction.serializeBinary());
            case SchedulableTransactionBody_pb_1.SchedulableTransactionBody.DataCase.SCHEDULEDELETE:
                body.setScheduledelete(scheduledB.getScheduledelete());
                protoTransaction.setBodybytes(body.serializeBinary());
                return Transaction_1.Transaction.fromBytes(protoTransaction.serializeBinary());
            default:
                throw new Error(`unsupported scheduled transaction:${body.getDataCase().toString()}`);
        }
    }
}
exports.ScheduleInfo = ScheduleInfo;
class ScheduleInfoQuery extends QueryBuilder_1.QueryBuilder {
    constructor() {
        super();
        this._builder = new ScheduleGetInfo_pb_1.ScheduleGetInfoQuery();
        this._builder.setHeader(new QueryHeader_pb_1.QueryHeader());
        this._inner.setSchedulegetinfo(this._builder);
    }
    /**
     * The schedule ID of the schedule for which information is requested.
     */
    setScheduleId(scheduleId) {
        this._builder.setScheduleid(new ScheduleId_1.ScheduleId(scheduleId)._toProto());
        return this;
    }
    getCost(client) {
        const _super = Object.create(null, {
            getCost: { get: () => super.getCost }
        });
        return __awaiter(this, void 0, void 0, function* () {
            // deleted schedules return a COST_ANSWER of zero which triggers `INSUFFICIENT_TX_FEE`
            // if you set that as the query payment; 25 tinybar seems to be the minimum to get
            // `SCHEDULE_DELETED` back instead.
            const min = Hbar_1.Hbar.fromTinybar(25);
            const cost = yield _super.getCost.call(this, client);
            return cost.isGreaterThan(min) ? cost : min;
        });
    }
    _doLocalValidate(errors) {
        if (!this._builder.hasScheduleid()) {
            errors.push(".setScheduleId() required");
        }
    }
    _getMethod() {
        return ScheduleService_pb_service_1.ScheduleService.getScheduleInfo;
    }
    _getHeader() {
        return this._builder.getHeader();
    }
    _mapResponseHeader(response) {
        return response.getSchedulegetinfo().getHeader();
    }
    _mapResponse(response) {
        const scheduleInfo = response.getSchedulegetinfo().getScheduleinfo();
        return new ScheduleInfo(scheduleInfo);
    }
}
exports.ScheduleInfoQuery = ScheduleInfoQuery;

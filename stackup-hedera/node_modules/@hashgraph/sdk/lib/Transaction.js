"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Transaction = exports.SCHEDULE_CREATE_TRANSACTION = exports.transactionCall = exports.transactionCreate = void 0;
const nacl = require("tweetnacl");
const Transaction_pb_1 = require("./generated/Transaction_pb");
const TransactionBody_pb_1 = require("./generated/TransactionBody_pb");
const BasicTypes_pb_1 = require("./generated/BasicTypes_pb");
const util_1 = require("./util");
const google_protobuf_1 = require("google-protobuf");
const CryptoService_pb_service_1 = require("./generated/CryptoService_pb_service");
const ScheduleService_pb_service_1 = require("./generated/ScheduleService_pb_service");
const SmartContractService_pb_service_1 = require("./generated/SmartContractService_pb_service");
const FileService_pb_service_1 = require("./generated/FileService_pb_service");
const FreezeService_pb_service_1 = require("./generated/FreezeService_pb_service");
const SchedulableTransactionBody_pb_1 = require("./generated/SchedulableTransactionBody_pb");
const ConsensusService_pb_service_1 = require("./generated/ConsensusService_pb_service");
const AccountId_1 = require("./account/AccountId");
const TransactionId_1 = require("./TransactionId");
const Status_1 = require("./Status");
const base64 = require("@stablelib/base64");
const sha384_1 = require("@stablelib/sha384");
const HederaPrecheckStatusError_1 = require("./errors/HederaPrecheckStatusError");
const receiptRetryDelayMs = 500;
/** internal method to create a new transaction from its discrete parts */
exports.transactionCreate = Symbol("transactionCreate");
/** execute the transaction directly and return the protobuf response */
exports.transactionCall = Symbol("transactionCall");
exports.SCHEDULE_CREATE_TRANSACTION = [];
class Transaction {
    constructor() {
        throw new Error("the constructor of Transaction is private; please construct through TransactionBuilder");
    }
    static [exports.transactionCreate](node, inner, body, method) {
        const tx = Object.create(this.prototype);
        tx._node = node;
        tx._inner = inner;
        tx._txnId = util_1.orThrow(body.getTransactionid());
        tx._validDurationSeconds = util_1.orThrow(body.getTransactionvalidduration()).getSeconds();
        tx._method = method;
        return tx;
    }
    static fromBytes(bytes) {
        const inner = Transaction_pb_1.Transaction.deserializeBinary(bytes);
        const body = TransactionBody_pb_1.TransactionBody.deserializeBinary(inner.getBodybytes_asU8());
        const nodeId = AccountId_1.AccountId._fromProto(util_1.orThrow(body.getNodeaccountid(), "transaction missing node account ID"));
        const method = methodFromTxn(body);
        return Transaction[exports.transactionCreate](nodeId, inner, body, method);
    }
    get id() {
        return TransactionId_1.TransactionId._fromProto(this._txnId);
    }
    schedule() {
        if (exports.SCHEDULE_CREATE_TRANSACTION.length !== 1) {
            throw new Error("ScheduleCreateTransaction has not been loaded yet");
        }
        const scheduled = exports.SCHEDULE_CREATE_TRANSACTION[0]()
            .setNodeAccountId(this._node);
        scheduled._body.setScheduledtransactionbody(this._getScheduledTransactionBody());
        return scheduled;
    }
    _getScheduledTransactionBody() {
        const scheduledBody = new SchedulableTransactionBody_pb_1.SchedulableTransactionBody();
        const body = TransactionBody_pb_1.TransactionBody.deserializeBinary(this._inner.getBodybytes_asU8());
        scheduledBody.setMemo(body.getMemo());
        scheduledBody.setTransactionfee(body.getTransactionfee());
        switch (body.getDataCase()) {
            case TransactionBody_pb_1.TransactionBody.DataCase.CONTRACTCREATEINSTANCE:
                scheduledBody.setContractcreateinstance(body.getContractcreateinstance());
                return scheduledBody;
            case TransactionBody_pb_1.TransactionBody.DataCase.CONTRACTDELETEINSTANCE:
                scheduledBody.setContractdeleteinstance(body.getContractdeleteinstance());
                return scheduledBody;
            case TransactionBody_pb_1.TransactionBody.DataCase.CONTRACTUPDATEINSTANCE:
                scheduledBody.setContractupdateinstance(body.getContractupdateinstance());
                return scheduledBody;
            case TransactionBody_pb_1.TransactionBody.DataCase.CONTRACTCALL:
                scheduledBody.setContractcall(body.getContractcall());
                return scheduledBody;
            case TransactionBody_pb_1.TransactionBody.DataCase.CONSENSUSCREATETOPIC:
                scheduledBody.setConsensuscreatetopic(body.getConsensuscreatetopic());
                return scheduledBody;
            case TransactionBody_pb_1.TransactionBody.DataCase.CONSENSUSDELETETOPIC:
                scheduledBody.setConsensusdeletetopic(body.getConsensusdeletetopic());
                return scheduledBody;
            case TransactionBody_pb_1.TransactionBody.DataCase.CONSENSUSSUBMITMESSAGE:
                scheduledBody.setConsensussubmitmessage(body.getConsensussubmitmessage());
                return scheduledBody;
            case TransactionBody_pb_1.TransactionBody.DataCase.CONSENSUSUPDATETOPIC:
                scheduledBody.setConsensusupdatetopic(body.getConsensusupdatetopic());
                return scheduledBody;
            case TransactionBody_pb_1.TransactionBody.DataCase.CRYPTOCREATEACCOUNT:
                scheduledBody.setCryptocreateaccount(body.getCryptocreateaccount());
                return scheduledBody;
            case TransactionBody_pb_1.TransactionBody.DataCase.CRYPTODELETE:
                scheduledBody.setCryptodelete(body.getCryptodelete());
                return scheduledBody;
            case TransactionBody_pb_1.TransactionBody.DataCase.CRYPTOUPDATEACCOUNT:
                scheduledBody.setCryptoupdateaccount(body.getCryptoupdateaccount());
                return scheduledBody;
            case TransactionBody_pb_1.TransactionBody.DataCase.CRYPTOTRANSFER:
                scheduledBody.setCryptotransfer(body.getCryptotransfer());
                return scheduledBody;
            case TransactionBody_pb_1.TransactionBody.DataCase.TOKENASSOCIATE:
                scheduledBody.setTokenassociate(body.getTokenassociate());
                return scheduledBody;
            case TransactionBody_pb_1.TransactionBody.DataCase.TOKENBURN:
                scheduledBody.setTokenburn(body.getTokenburn());
                return scheduledBody;
            case TransactionBody_pb_1.TransactionBody.DataCase.TOKENCREATION:
                scheduledBody.setTokencreation(body.getTokencreation());
                return scheduledBody;
            case TransactionBody_pb_1.TransactionBody.DataCase.TOKENDELETION:
                scheduledBody.setTokendeletion(body.getTokendeletion());
                return scheduledBody;
            case TransactionBody_pb_1.TransactionBody.DataCase.TOKENDISSOCIATE:
                scheduledBody.setTokendissociate(body.getTokendissociate());
                return scheduledBody;
            case TransactionBody_pb_1.TransactionBody.DataCase.TOKENFREEZE:
                scheduledBody.setTokenfreeze(body.getTokenfreeze());
                return scheduledBody;
            case TransactionBody_pb_1.TransactionBody.DataCase.TOKENGRANTKYC:
                scheduledBody.setTokengrantkyc(body.getTokengrantkyc());
                return scheduledBody;
            case TransactionBody_pb_1.TransactionBody.DataCase.TOKENMINT:
                scheduledBody.setTokenmint(body.getTokenmint());
                return scheduledBody;
            case TransactionBody_pb_1.TransactionBody.DataCase.TOKENREVOKEKYC:
                scheduledBody.setTokenrevokekyc(body.getTokenrevokekyc());
                return scheduledBody;
            case TransactionBody_pb_1.TransactionBody.DataCase.TOKENUNFREEZE:
                scheduledBody.setTokenunfreeze(body.getTokenunfreeze());
                return scheduledBody;
            case TransactionBody_pb_1.TransactionBody.DataCase.TOKENWIPE:
                scheduledBody.setTokenwipe(body.getTokenwipe());
                return scheduledBody;
            case TransactionBody_pb_1.TransactionBody.DataCase.TOKENUPDATE:
                scheduledBody.setTokenupdate(body.getTokenupdate());
                return scheduledBody;
            case TransactionBody_pb_1.TransactionBody.DataCase.SCHEDULEDELETE:
                scheduledBody.setScheduledelete(body.getScheduledelete());
                return scheduledBody;
            default:
                throw new Error(`unsupported scheduled transaction:${body.getDataCase().toString()}`);
        }
    }
    _getTransactionDataCase() {
        throw new Error("not implemented");
    }
    _checkPubKey(publicKey) {
        if (this._inner.hasSigmap()) {
            for (const sig of this._inner.getSigmap().getSigpairList()) {
                if (publicKey._bytesEqual(sig.getPubkeyprefix_asU8())) {
                    throw new Error(`transaction ${this._txnId} already signed with public key ${publicKey.toString()}`);
                }
            }
        }
    }
    _addSignature({ signature, publicKey }) {
        const pubKeyBytes = publicKey.toBytes();
        const sigMap = this._inner.getSigmap() || new BasicTypes_pb_1.SignatureMap();
        sigMap.getSigpairList().forEach((sigPair) => {
            const sigPairBytes = base64.decode(sigPair.getPubkeyprefix_asB64());
            if (pubKeyBytes.toString() === sigPairBytes.toString()) {
                throw new Error(`transaction already signed with key ${publicKey.toString()}`);
            }
        });
        const sigPair = new BasicTypes_pb_1.SignaturePair();
        sigPair.setPubkeyprefix(publicKey.toBytes());
        sigPair.setEd25519(signature);
        sigMap.addSigpair(sigPair);
        this._inner.setSigmap(sigMap);
        return this;
    }
    sign(privateKey) {
        this._checkPubKey(privateKey.publicKey);
        return this._addSignature({
            signature: nacl.sign.detached(this._inner.getBodybytes_asU8(), privateKey._keyData),
            publicKey: privateKey.publicKey
        });
    }
    /**
     * Given the transaction body bytes, asynchronously return a signature and associated public
     * key.
     *
     * @param publicKey the public key that can be used to verify the returned signature
     * @param signer
     */
    signWith(publicKey, signer) {
        return __awaiter(this, void 0, void 0, function* () {
            this._checkPubKey(publicKey);
            const signResult = signer(this._inner.getBodybytes_asU8());
            const signature = signResult instanceof Promise ?
                yield signResult :
                signResult;
            this._addSignature({ signature, publicKey });
            return this;
        });
    }
    hash() {
        var _a, _b;
        const body = TransactionBody_pb_1.TransactionBody.deserializeBinary(this._inner.getBodybytes_asU8());
        if (!body.hasNodeaccountid()) {
            throw new Error("transaction must have node id set");
        }
        if (((_b = (_a = this._inner.getSigmap()) === null || _a === void 0 ? void 0 : _a.getSigpairList().length) !== null && _b !== void 0 ? _b : 0) === 0) {
            throw new Error("transaction must be signed");
        }
        return sha384_1.hash(this.toBytes());
    }
    [exports.transactionCall](client) {
        return __awaiter(this, void 0, void 0, function* () {
            // If client is supplied make sure to sign transaction if we have not already
            if (client._getOperatorKey() && client._getOperatorSigner()) {
                try {
                    yield this.signWith(client._getOperatorKey(), client._getOperatorSigner());
                }
                catch (_a) {
                    // ignored. This means the operator has already signed the transaction
                }
            }
            const node = client._getNode(this._node);
            const validUntilMs = Date.now() + (this._validDurationSeconds * 1000);
            /* eslint-disable no-await-in-loop */
            // we want to wait in a loop, that's the whole point here
            for (let attempt = 0; /* loop will exit when transaction expires */; attempt += 1) {
                if (attempt > 0) {
                    const delay = Math.floor(receiptRetryDelayMs *
                        Math.random() * ((Math.pow(2, attempt)) - 1));
                    if (Date.now() + delay > validUntilMs) {
                        throw new Error(`timed out waiting to send transaction ID: ${this._txnId.toString()}`);
                    }
                    yield util_1.setTimeoutAwaitable(delay);
                }
                const response = yield client._unaryCall(node.url, this._inner, this._method);
                const status = Status_1.Status._fromCode(response.getNodetransactionprecheckcode());
                // If response code is BUSY we need to timeout and retry
                if (status._isBusy()) {
                    continue;
                }
                return response;
            }
            /* eslint-enable no-await-in-loop */
        });
    }
    execute(client) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this[exports.transactionCall](client);
            const status = Status_1.Status._fromCode(response.getNodetransactionprecheckcode());
            HederaPrecheckStatusError_1.HederaPrecheckStatusError._throwIfError(status.code, this.id);
            return this.id;
        });
    }
    /** @deprecate `Transaction.getReceipt()` is deprecrated. Use `(await Transaction.execute()).getReceipt()` instead. */
    getReceipt(client) {
        console.warn("`Transaction.getReceipt()` is deprecrated. Use `(await Transaction.execute()).getReceipt()` instead.");
        return this.id.getReceipt(client);
    }
    /** @deprecate `Transaction.getRecord()` is deprecrated. Use `(await Transaction.execute()).getRecord()` instead. */
    getRecord(client) {
        console.warn("`Transaction.getRecord()` is deprecrated. Use `(await Transaction.execute()).getRecord()` instead.");
        return this.id.getRecord(client);
    }
    _toProto() {
        return google_protobuf_1.Message.cloneMessage(this._inner);
    }
    toBytes() {
        return this._inner.serializeBinary();
    }
    toString() {
        const tx = this._toProto().toObject();
        return JSON.stringify(tx, null, 4);
    }
}
exports.Transaction = Transaction;
/* eslint-disable-next-line max-len */
function methodFromTxn(inner) {
    switch (inner.getDataCase()) {
        case TransactionBody_pb_1.TransactionBody.DataCase.CONTRACTCALL:
            return SmartContractService_pb_service_1.SmartContractService.contractCallMethod;
        case TransactionBody_pb_1.TransactionBody.DataCase.CONTRACTCREATEINSTANCE:
            return SmartContractService_pb_service_1.SmartContractService.createContract;
        case TransactionBody_pb_1.TransactionBody.DataCase.CONTRACTUPDATEINSTANCE:
            return SmartContractService_pb_service_1.SmartContractService.updateContract;
        case TransactionBody_pb_1.TransactionBody.DataCase.CONTRACTDELETEINSTANCE:
            return SmartContractService_pb_service_1.SmartContractService.deleteContract;
        case TransactionBody_pb_1.TransactionBody.DataCase.CRYPTOADDLIVEHASH:
            return CryptoService_pb_service_1.CryptoService.addLiveHash;
        case TransactionBody_pb_1.TransactionBody.DataCase.CRYPTOCREATEACCOUNT:
            return CryptoService_pb_service_1.CryptoService.createAccount;
        case TransactionBody_pb_1.TransactionBody.DataCase.CRYPTODELETE:
            return CryptoService_pb_service_1.CryptoService.cryptoDelete;
        case TransactionBody_pb_1.TransactionBody.DataCase.CRYPTODELETELIVEHASH:
            return CryptoService_pb_service_1.CryptoService.deleteLiveHash;
        case TransactionBody_pb_1.TransactionBody.DataCase.CRYPTOTRANSFER:
            return CryptoService_pb_service_1.CryptoService.cryptoTransfer;
        case TransactionBody_pb_1.TransactionBody.DataCase.CRYPTOUPDATEACCOUNT:
            return CryptoService_pb_service_1.CryptoService.updateAccount;
        case TransactionBody_pb_1.TransactionBody.DataCase.FILEAPPEND:
            return FileService_pb_service_1.FileService.appendContent;
        case TransactionBody_pb_1.TransactionBody.DataCase.FILECREATE:
            return FileService_pb_service_1.FileService.createFile;
        case TransactionBody_pb_1.TransactionBody.DataCase.FILEDELETE:
            return FileService_pb_service_1.FileService.deleteFile;
        case TransactionBody_pb_1.TransactionBody.DataCase.FILEUPDATE:
            return FileService_pb_service_1.FileService.updateFile;
        case TransactionBody_pb_1.TransactionBody.DataCase.SYSTEMDELETE:
            return SmartContractService_pb_service_1.SmartContractService.systemDelete;
        case TransactionBody_pb_1.TransactionBody.DataCase.SYSTEMUNDELETE:
            return SmartContractService_pb_service_1.SmartContractService.systemUndelete;
        case TransactionBody_pb_1.TransactionBody.DataCase.FREEZE:
            return FreezeService_pb_service_1.FreezeService.freeze;
        case TransactionBody_pb_1.TransactionBody.DataCase.CONSENSUSCREATETOPIC:
            return ConsensusService_pb_service_1.ConsensusService.createTopic;
        case TransactionBody_pb_1.TransactionBody.DataCase.CONSENSUSUPDATETOPIC:
            return ConsensusService_pb_service_1.ConsensusService.updateTopic;
        case TransactionBody_pb_1.TransactionBody.DataCase.CONSENSUSDELETETOPIC:
            return ConsensusService_pb_service_1.ConsensusService.deleteTopic;
        case TransactionBody_pb_1.TransactionBody.DataCase.CONSENSUSSUBMITMESSAGE:
            return ConsensusService_pb_service_1.ConsensusService.submitMessage;
        case TransactionBody_pb_1.TransactionBody.DataCase.SCHEDULECREATE:
            return ScheduleService_pb_service_1.ScheduleService.createSchedule;
        case TransactionBody_pb_1.TransactionBody.DataCase.SCHEDULEDELETE:
            return ScheduleService_pb_service_1.ScheduleService.deleteSchedule;
        case TransactionBody_pb_1.TransactionBody.DataCase.SCHEDULESIGN:
            return ScheduleService_pb_service_1.ScheduleService.signSchedule;
        case TransactionBody_pb_1.TransactionBody.DataCase.DATA_NOT_SET:
            throw new Error("transaction body missing");
        default:
            throw new Error(`unsupported body case:${inner.getDataCase().toString()}`);
    }
}

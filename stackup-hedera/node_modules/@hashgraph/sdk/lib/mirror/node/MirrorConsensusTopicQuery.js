"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MirrorConsensusTopicQuery = void 0;
const grpc = require("@grpc/grpc-js");
const MirrorConsensusService_pb_1 = require("../../generated/MirrorConsensusService_pb");
const TransactionId_1 = require("../../TransactionId");
const BaseMirrorConsensusTopicQuery_1 = require("../BaseMirrorConsensusTopicQuery");
const MirrorConsensusTopicResponse_1 = require("../MirrorConsensusTopicResponse");
const MirrorSubscriptionHandle_1 = require("../MirrorSubscriptionHandle");
class MirrorConsensusTopicQuery extends BaseMirrorConsensusTopicQuery_1.BaseMirrorConsensusTopicQuery {
    subscribe(client, listener, errorHandler) {
        this._validate();
        const handle = new MirrorSubscriptionHandle_1.MirrorSubscriptionHandle();
        this._makeServerStreamRequest(handle, 0, client, listener, errorHandler);
        return handle;
    }
    _makeServerStreamRequest(handle, attempt, client, listener, errorHandler) {
        const list = {};
        let shouldRetry = true;
        const response = client._client
            .makeServerStreamRequest(
        // `/${ConsensusService.serviceName}/${ConsensusService.subscribeTopic.methodName}`,
        "/com.hedera.mirror.api.proto.ConsensusService/subscribeTopic", (value) => Buffer.from(value), MirrorConsensusService_pb_1.ConsensusTopicResponse.deserializeBinary, this._builder.serializeBinary())
            .on("data", (message) => {
            shouldRetry = false;
            if (!message.hasChunkinfo()) {
                listener(new MirrorConsensusTopicResponse_1.MirrorConsensusTopicResponse(message));
            }
            else {
                // eslint-disable-next-line max-len
                const txId = TransactionId_1.TransactionId._fromProto(message.getChunkinfo().getInitialtransactionid()).toString();
                if (list[txId] == null) {
                    list[txId] = [];
                }
                list[txId].push(message);
                if (list[txId].length ===
                    message.getChunkinfo().getTotal()) {
                    const m = list[txId];
                    list[txId] = null;
                    listener(new MirrorConsensusTopicResponse_1.MirrorConsensusTopicResponse(m));
                }
            }
        })
            .on("status", (status) => {
            this._onStatus(handle, attempt + 1, client, listener, shouldRetry, status, errorHandler);
        })
            .on("error", () => {
            // Do nothing. `on("status")` will be called after this which has the retry loop
        });
        handle._setCall(response.cancel);
    }
    _onStatus(handle, attempt, client, listener, shouldRetry, status, errorHandler) {
        if (!shouldRetry || attempt > 10) {
            if (errorHandler != null) {
                errorHandler(new Error(`Received status code: ${status.code} and message: ${status.details}`));
            }
        }
        else if (attempt < 10 && shouldRetry) {
            console.log(status.code);
            switch (status.code) {
                case grpc.status.OK:
                    break;
                case grpc.status.NOT_FOUND:
                case grpc.status.UNAVAILABLE:
                case grpc.status.RESOURCE_EXHAUSTED:
                    setTimeout(() => {
                        this._makeServerStreamRequest(handle, attempt + 1, client, listener, errorHandler);
                    }, 250 * (Math.pow(2, (attempt + 1))));
                    break;
                default:
                    if (errorHandler != null) {
                        errorHandler(new Error(`Received unprocessable status code: ${status.code} and message: ${status.details}`));
                    }
            }
        }
    }
}
exports.MirrorConsensusTopicQuery = MirrorConsensusTopicQuery;

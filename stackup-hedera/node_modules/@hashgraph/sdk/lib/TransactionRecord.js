"use strict";
var _a, _b;
Object.defineProperty(exports, "__esModule", { value: true });
exports.transferListToSdk = exports.TransactionRecord = exports.TokenTransfersMap = exports.AccountTokenTransfersMap = void 0;
const TransactionReceipt_1 = require("./TransactionReceipt");
const ContractFunctionResult_1 = require("./contract/ContractFunctionResult");
const TransactionId_1 = require("./TransactionId");
const Time_1 = require("./Time");
const Hbar_1 = require("./Hbar");
const TokenId_1 = require("./token/TokenId");
const AccountId_1 = require("./account/AccountId");
const Transfer_1 = require("./Transfer");
const bignumber_js_1 = require("bignumber.js");
const callResult = Symbol("callResult");
const callResultIsCreate = Symbol("callResultIsCreate");
class AccountTokenTransfersMap {
    constructor(transfers) {
        this._transfers = new Map();
        for (const transfer of transfers) {
            const accountId = AccountId_1.AccountId._fromProto(transfer.getAccountid()).toString();
            let list = this._transfers.get(accountId);
            if (list == null) {
                list = [];
                this._transfers.set(accountId, list);
            }
            list.push(new bignumber_js_1.default(transfer.getAmount()));
        }
    }
    get(accountId) {
        const account = new AccountId_1.AccountId(accountId).toString();
        return this._transfers.get(account);
    }
    values() {
        return this._transfers.values();
    }
    keys() {
        const keys = [];
        for (const key of this._transfers.keys()) {
            keys.push(AccountId_1.AccountId.fromString(key));
        }
        return keys[Symbol.iterator]();
    }
    [Symbol.iterator]() {
        const map = new Map();
        for (const [key, value] of this._transfers) {
            map.set(AccountId_1.AccountId.fromString(key), value);
        }
        return map[Symbol.iterator]();
    }
}
exports.AccountTokenTransfersMap = AccountTokenTransfersMap;
class TokenTransfersMap {
    constructor(transfers) {
        this._transfers = new Map();
        for (const list of transfers) {
            const tokenId = TokenId_1.TokenId._fromProto(list.getToken());
            this._transfers.set(tokenId.toString(), new AccountTokenTransfersMap(list.getTransfersList()));
        }
    }
    get(tokenId) {
        const token = new TokenId_1.TokenId(tokenId).toString();
        return this._transfers.get(token);
    }
    values() {
        return this._transfers.values();
    }
    keys() {
        const keys = [];
        for (const key of this._transfers.keys()) {
            keys.push(TokenId_1.TokenId.fromString(key));
        }
        return keys[Symbol.iterator]();
    }
    [Symbol.iterator]() {
        const map = new Map();
        for (const [key, value] of this._transfers) {
            map.set(TokenId_1.TokenId.fromString(key), value);
        }
        return map[Symbol.iterator]();
    }
}
exports.TokenTransfersMap = TokenTransfersMap;
/**
 * Response when the client sends the node TransactionGetRecordResponse.
 */
class TransactionRecord {
    constructor(record) {
        this[_a] = null;
        this[_b] = false;
        this.receipt = TransactionReceipt_1.TransactionReceipt._fromProto(record.getReceipt());
        this.transactionHash = record.getTransactionhash_asU8();
        this.consensusTimestamp = Time_1.Time._fromProto(record.getConsensustimestamp());
        this.transactionId = TransactionId_1.TransactionId._fromProto(record.getTransactionid());
        this.transactionMemo = record.getMemo();
        this.transactionFee = Hbar_1.Hbar.fromTinybar(record.getTransactionfee());
        this.transfers = transferListToSdk(record.getTransferlist());
        if (record.hasContractcallresult()) {
            this[callResult] = new ContractFunctionResult_1.ContractFunctionResult(record.getContractcallresult());
            this[callResultIsCreate] = true;
        }
        else if (record.hasContractcreateresult()) {
            this[callResult] = new ContractFunctionResult_1.ContractFunctionResult(record.getContractcreateresult());
        }
        this.tokenTransfers = new TokenTransfersMap(record.getTokentransferlistsList());
    }
    static _fromProto(pb) {
        return new TransactionRecord(pb);
    }
    getContractCreateResult() {
        if (this[callResult] == null || this[callResultIsCreate]) {
            throw new Error("record does not contain a contract create result");
        }
        return this[callResult];
    }
    getContractExecuteResult() {
        if (this[callResult] == null || !this[callResultIsCreate]) {
            throw new Error("record does not contain a contract execute result");
        }
        return this[callResult];
    }
}
exports.TransactionRecord = TransactionRecord;
_a = callResult, _b = callResultIsCreate;
function transferListToSdk(transferList) {
    return transferList.getAccountamountsList().map(Transfer_1.transferFromProto);
}
exports.transferListToSdk = transferListToSdk;

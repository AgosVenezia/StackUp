/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
import * as $protobuf from "protobufjs/minimal";

// Common aliases
const $Reader = $protobuf.Reader,
    $Writer = $protobuf.Writer,
    $util = $protobuf.util;

// Exported root namespace
const $root = $protobuf.roots.hashgraph || ($protobuf.roots.hashgraph = {});

export const com = ($root.com = (() => {
    /**
     * Namespace com.
     * @exports com
     * @namespace
     */
    const com = {};

    com.hedera = (function () {
        /**
         * Namespace hedera.
         * @memberof com
         * @namespace
         */
        const hedera = {};

        hedera.mirror = (function () {
            /**
             * Namespace mirror.
             * @memberof com.hedera
             * @namespace
             */
            const mirror = {};

            mirror.api = (function () {
                /**
                 * Namespace api.
                 * @memberof com.hedera.mirror
                 * @namespace
                 */
                const api = {};

                api.proto = (function () {
                    /**
                     * Namespace proto.
                     * @memberof com.hedera.mirror.api
                     * @namespace
                     */
                    const proto = {};

                    proto.ConsensusTopicQuery = (function () {
                        /**
                         * Properties of a ConsensusTopicQuery.
                         * @memberof com.hedera.mirror.api.proto
                         * @interface IConsensusTopicQuery
                         * @property {proto.ITopicID|null} [topicID] A required topic ID to retrieve messages for.
                         * @property {proto.ITimestamp|null} [consensusStartTime] Include messages which reached consensus on or after this time. Defaults to current time if
                         * not set.
                         * @property {proto.ITimestamp|null} [consensusEndTime] Include messages which reached consensus before this time. If not set it will receive
                         * indefinitely.
                         * @property {Long|null} [limit] The maximum number of messages to receive before stopping. If not set or set to zero it will
                         * return messages indefinitely.
                         */

                        /**
                         * Constructs a new ConsensusTopicQuery.
                         * @memberof com.hedera.mirror.api.proto
                         * @classdesc Represents a ConsensusTopicQuery.
                         * @implements IConsensusTopicQuery
                         * @constructor
                         * @param {com.hedera.mirror.api.proto.IConsensusTopicQuery=} [p] Properties to set
                         */
                        function ConsensusTopicQuery(p) {
                            if (p)
                                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                    if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
                        }

                        /**
                         * A required topic ID to retrieve messages for.
                         * @member {proto.ITopicID|null|undefined} topicID
                         * @memberof com.hedera.mirror.api.proto.ConsensusTopicQuery
                         * @instance
                         */
                        ConsensusTopicQuery.prototype.topicID = null;

                        /**
                         * Include messages which reached consensus on or after this time. Defaults to current time if
                         * not set.
                         * @member {proto.ITimestamp|null|undefined} consensusStartTime
                         * @memberof com.hedera.mirror.api.proto.ConsensusTopicQuery
                         * @instance
                         */
                        ConsensusTopicQuery.prototype.consensusStartTime = null;

                        /**
                         * Include messages which reached consensus before this time. If not set it will receive
                         * indefinitely.
                         * @member {proto.ITimestamp|null|undefined} consensusEndTime
                         * @memberof com.hedera.mirror.api.proto.ConsensusTopicQuery
                         * @instance
                         */
                        ConsensusTopicQuery.prototype.consensusEndTime = null;

                        /**
                         * The maximum number of messages to receive before stopping. If not set or set to zero it will
                         * return messages indefinitely.
                         * @member {Long} limit
                         * @memberof com.hedera.mirror.api.proto.ConsensusTopicQuery
                         * @instance
                         */
                        ConsensusTopicQuery.prototype.limit = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

                        /**
                         * Creates a new ConsensusTopicQuery instance using the specified properties.
                         * @function create
                         * @memberof com.hedera.mirror.api.proto.ConsensusTopicQuery
                         * @static
                         * @param {com.hedera.mirror.api.proto.IConsensusTopicQuery=} [properties] Properties to set
                         * @returns {com.hedera.mirror.api.proto.ConsensusTopicQuery} ConsensusTopicQuery instance
                         */
                        ConsensusTopicQuery.create = function create(properties) {
                            return new ConsensusTopicQuery(properties);
                        };

                        /**
                         * Encodes the specified ConsensusTopicQuery message. Does not implicitly {@link com.hedera.mirror.api.proto.ConsensusTopicQuery.verify|verify} messages.
                         * @function encode
                         * @memberof com.hedera.mirror.api.proto.ConsensusTopicQuery
                         * @static
                         * @param {com.hedera.mirror.api.proto.IConsensusTopicQuery} m ConsensusTopicQuery message or plain object to encode
                         * @param {$protobuf.Writer} [w] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        ConsensusTopicQuery.encode = function encode(m, w) {
                            if (!w) w = $Writer.create();
                            if (m.topicID != null && Object.hasOwnProperty.call(m, "topicID"))
                                $root.proto.TopicID.encode(m.topicID, w.uint32(10).fork()).ldelim();
                            if (m.consensusStartTime != null && Object.hasOwnProperty.call(m, "consensusStartTime"))
                                $root.proto.Timestamp.encode(m.consensusStartTime, w.uint32(18).fork()).ldelim();
                            if (m.consensusEndTime != null && Object.hasOwnProperty.call(m, "consensusEndTime"))
                                $root.proto.Timestamp.encode(m.consensusEndTime, w.uint32(26).fork()).ldelim();
                            if (m.limit != null && Object.hasOwnProperty.call(m, "limit")) w.uint32(32).uint64(m.limit);
                            return w;
                        };

                        /**
                         * Decodes a ConsensusTopicQuery message from the specified reader or buffer.
                         * @function decode
                         * @memberof com.hedera.mirror.api.proto.ConsensusTopicQuery
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                         * @param {number} [l] Message length if known beforehand
                         * @returns {com.hedera.mirror.api.proto.ConsensusTopicQuery} ConsensusTopicQuery
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        ConsensusTopicQuery.decode = function decode(r, l) {
                            if (!(r instanceof $Reader)) r = $Reader.create(r);
                            var c = l === undefined ? r.len : r.pos + l,
                                m = new $root.com.hedera.mirror.api.proto.ConsensusTopicQuery();
                            while (r.pos < c) {
                                var t = r.uint32();
                                switch (t >>> 3) {
                                    case 1: {
                                        m.topicID = $root.proto.TopicID.decode(r, r.uint32());
                                        break;
                                    }
                                    case 2: {
                                        m.consensusStartTime = $root.proto.Timestamp.decode(r, r.uint32());
                                        break;
                                    }
                                    case 3: {
                                        m.consensusEndTime = $root.proto.Timestamp.decode(r, r.uint32());
                                        break;
                                    }
                                    case 4: {
                                        m.limit = r.uint64();
                                        break;
                                    }
                                    default:
                                        r.skipType(t & 7);
                                        break;
                                }
                            }
                            return m;
                        };

                        /**
                         * Gets the default type url for ConsensusTopicQuery
                         * @function getTypeUrl
                         * @memberof com.hedera.mirror.api.proto.ConsensusTopicQuery
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        ConsensusTopicQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/com.hedera.mirror.api.proto.ConsensusTopicQuery";
                        };

                        return ConsensusTopicQuery;
                    })();

                    proto.ConsensusTopicResponse = (function () {
                        /**
                         * Properties of a ConsensusTopicResponse.
                         * @memberof com.hedera.mirror.api.proto
                         * @interface IConsensusTopicResponse
                         * @property {proto.ITimestamp|null} [consensusTimestamp] The time at which the transaction reached consensus
                         * @property {Uint8Array|null} [message] The message body originally in the ConsensusSubmitMessageTransactionBody. Message size will
                         * be less than 6KiB.
                         * @property {Uint8Array|null} [runningHash] The running hash (SHA384) of every message.
                         * @property {Long|null} [sequenceNumber] Starts at 1 for first submitted message. Incremented on each submitted message.
                         * @property {Long|null} [runningHashVersion] Version of the SHA-384 digest used to update the running hash.
                         * @property {proto.IConsensusMessageChunkInfo|null} [chunkInfo] Optional information of the current chunk in a fragmented message.
                         */

                        /**
                         * Constructs a new ConsensusTopicResponse.
                         * @memberof com.hedera.mirror.api.proto
                         * @classdesc Represents a ConsensusTopicResponse.
                         * @implements IConsensusTopicResponse
                         * @constructor
                         * @param {com.hedera.mirror.api.proto.IConsensusTopicResponse=} [p] Properties to set
                         */
                        function ConsensusTopicResponse(p) {
                            if (p)
                                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                    if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
                        }

                        /**
                         * The time at which the transaction reached consensus
                         * @member {proto.ITimestamp|null|undefined} consensusTimestamp
                         * @memberof com.hedera.mirror.api.proto.ConsensusTopicResponse
                         * @instance
                         */
                        ConsensusTopicResponse.prototype.consensusTimestamp = null;

                        /**
                         * The message body originally in the ConsensusSubmitMessageTransactionBody. Message size will
                         * be less than 6KiB.
                         * @member {Uint8Array} message
                         * @memberof com.hedera.mirror.api.proto.ConsensusTopicResponse
                         * @instance
                         */
                        ConsensusTopicResponse.prototype.message = $util.newBuffer([]);

                        /**
                         * The running hash (SHA384) of every message.
                         * @member {Uint8Array} runningHash
                         * @memberof com.hedera.mirror.api.proto.ConsensusTopicResponse
                         * @instance
                         */
                        ConsensusTopicResponse.prototype.runningHash = $util.newBuffer([]);

                        /**
                         * Starts at 1 for first submitted message. Incremented on each submitted message.
                         * @member {Long} sequenceNumber
                         * @memberof com.hedera.mirror.api.proto.ConsensusTopicResponse
                         * @instance
                         */
                        ConsensusTopicResponse.prototype.sequenceNumber = $util.Long
                            ? $util.Long.fromBits(0, 0, true)
                            : 0;

                        /**
                         * Version of the SHA-384 digest used to update the running hash.
                         * @member {Long} runningHashVersion
                         * @memberof com.hedera.mirror.api.proto.ConsensusTopicResponse
                         * @instance
                         */
                        ConsensusTopicResponse.prototype.runningHashVersion = $util.Long
                            ? $util.Long.fromBits(0, 0, true)
                            : 0;

                        /**
                         * Optional information of the current chunk in a fragmented message.
                         * @member {proto.IConsensusMessageChunkInfo|null|undefined} chunkInfo
                         * @memberof com.hedera.mirror.api.proto.ConsensusTopicResponse
                         * @instance
                         */
                        ConsensusTopicResponse.prototype.chunkInfo = null;

                        /**
                         * Creates a new ConsensusTopicResponse instance using the specified properties.
                         * @function create
                         * @memberof com.hedera.mirror.api.proto.ConsensusTopicResponse
                         * @static
                         * @param {com.hedera.mirror.api.proto.IConsensusTopicResponse=} [properties] Properties to set
                         * @returns {com.hedera.mirror.api.proto.ConsensusTopicResponse} ConsensusTopicResponse instance
                         */
                        ConsensusTopicResponse.create = function create(properties) {
                            return new ConsensusTopicResponse(properties);
                        };

                        /**
                         * Encodes the specified ConsensusTopicResponse message. Does not implicitly {@link com.hedera.mirror.api.proto.ConsensusTopicResponse.verify|verify} messages.
                         * @function encode
                         * @memberof com.hedera.mirror.api.proto.ConsensusTopicResponse
                         * @static
                         * @param {com.hedera.mirror.api.proto.IConsensusTopicResponse} m ConsensusTopicResponse message or plain object to encode
                         * @param {$protobuf.Writer} [w] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        ConsensusTopicResponse.encode = function encode(m, w) {
                            if (!w) w = $Writer.create();
                            if (m.consensusTimestamp != null && Object.hasOwnProperty.call(m, "consensusTimestamp"))
                                $root.proto.Timestamp.encode(m.consensusTimestamp, w.uint32(10).fork()).ldelim();
                            if (m.message != null && Object.hasOwnProperty.call(m, "message"))
                                w.uint32(18).bytes(m.message);
                            if (m.runningHash != null && Object.hasOwnProperty.call(m, "runningHash"))
                                w.uint32(26).bytes(m.runningHash);
                            if (m.sequenceNumber != null && Object.hasOwnProperty.call(m, "sequenceNumber"))
                                w.uint32(32).uint64(m.sequenceNumber);
                            if (m.runningHashVersion != null && Object.hasOwnProperty.call(m, "runningHashVersion"))
                                w.uint32(40).uint64(m.runningHashVersion);
                            if (m.chunkInfo != null && Object.hasOwnProperty.call(m, "chunkInfo"))
                                $root.proto.ConsensusMessageChunkInfo.encode(m.chunkInfo, w.uint32(50).fork()).ldelim();
                            return w;
                        };

                        /**
                         * Decodes a ConsensusTopicResponse message from the specified reader or buffer.
                         * @function decode
                         * @memberof com.hedera.mirror.api.proto.ConsensusTopicResponse
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                         * @param {number} [l] Message length if known beforehand
                         * @returns {com.hedera.mirror.api.proto.ConsensusTopicResponse} ConsensusTopicResponse
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        ConsensusTopicResponse.decode = function decode(r, l) {
                            if (!(r instanceof $Reader)) r = $Reader.create(r);
                            var c = l === undefined ? r.len : r.pos + l,
                                m = new $root.com.hedera.mirror.api.proto.ConsensusTopicResponse();
                            while (r.pos < c) {
                                var t = r.uint32();
                                switch (t >>> 3) {
                                    case 1: {
                                        m.consensusTimestamp = $root.proto.Timestamp.decode(r, r.uint32());
                                        break;
                                    }
                                    case 2: {
                                        m.message = r.bytes();
                                        break;
                                    }
                                    case 3: {
                                        m.runningHash = r.bytes();
                                        break;
                                    }
                                    case 4: {
                                        m.sequenceNumber = r.uint64();
                                        break;
                                    }
                                    case 5: {
                                        m.runningHashVersion = r.uint64();
                                        break;
                                    }
                                    case 6: {
                                        m.chunkInfo = $root.proto.ConsensusMessageChunkInfo.decode(r, r.uint32());
                                        break;
                                    }
                                    default:
                                        r.skipType(t & 7);
                                        break;
                                }
                            }
                            return m;
                        };

                        /**
                         * Gets the default type url for ConsensusTopicResponse
                         * @function getTypeUrl
                         * @memberof com.hedera.mirror.api.proto.ConsensusTopicResponse
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        ConsensusTopicResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/com.hedera.mirror.api.proto.ConsensusTopicResponse";
                        };

                        return ConsensusTopicResponse;
                    })();

                    proto.ConsensusService = (function () {
                        /**
                         * Constructs a new ConsensusService service.
                         * @memberof com.hedera.mirror.api.proto
                         * @classdesc The Mirror Service provides the ability to query a stream of Hedera Consensus Service (HCS)
                         * messages for an HCS Topic via a specific (possibly open-ended) time range.
                         * @extends $protobuf.rpc.Service
                         * @constructor
                         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                         */
                        function ConsensusService(rpcImpl, requestDelimited, responseDelimited) {
                            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                        }

                        (ConsensusService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor =
                            ConsensusService;

                        /**
                         * Creates new ConsensusService service using the specified rpc implementation.
                         * @function create
                         * @memberof com.hedera.mirror.api.proto.ConsensusService
                         * @static
                         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                         * @returns {ConsensusService} RPC service. Useful where requests and/or responses are streamed.
                         */
                        ConsensusService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                            return new this(rpcImpl, requestDelimited, responseDelimited);
                        };

                        /**
                         * Callback as used by {@link com.hedera.mirror.api.proto.ConsensusService#subscribeTopic}.
                         * @memberof com.hedera.mirror.api.proto.ConsensusService
                         * @typedef subscribeTopicCallback
                         * @type {function}
                         * @param {Error|null} error Error, if any
                         * @param {com.hedera.mirror.api.proto.ConsensusTopicResponse} [response] ConsensusTopicResponse
                         */

                        /**
                         * Calls subscribeTopic.
                         * @function subscribeTopic
                         * @memberof com.hedera.mirror.api.proto.ConsensusService
                         * @instance
                         * @param {com.hedera.mirror.api.proto.IConsensusTopicQuery} request ConsensusTopicQuery message or plain object
                         * @param {com.hedera.mirror.api.proto.ConsensusService.subscribeTopicCallback} callback Node-style callback called with the error, if any, and ConsensusTopicResponse
                         * @returns {undefined}
                         * @variation 1
                         */
                        Object.defineProperty(
                            (ConsensusService.prototype.subscribeTopic = function subscribeTopic(request, callback) {
                                return this.rpcCall(
                                    subscribeTopic,
                                    $root.com.hedera.mirror.api.proto.ConsensusTopicQuery,
                                    $root.com.hedera.mirror.api.proto.ConsensusTopicResponse,
                                    request,
                                    callback
                                );
                            }),
                            "name",
                            { value: "subscribeTopic" }
                        );

                        /**
                         * Calls subscribeTopic.
                         * @function subscribeTopic
                         * @memberof com.hedera.mirror.api.proto.ConsensusService
                         * @instance
                         * @param {com.hedera.mirror.api.proto.IConsensusTopicQuery} request ConsensusTopicQuery message or plain object
                         * @returns {Promise<com.hedera.mirror.api.proto.ConsensusTopicResponse>} Promise
                         * @variation 2
                         */

                        return ConsensusService;
                    })();

                    proto.AddressBookQuery = (function () {
                        /**
                         * Properties of an AddressBookQuery.
                         * @memberof com.hedera.mirror.api.proto
                         * @interface IAddressBookQuery
                         * @property {proto.IFileID|null} [fileId] The ID of the address book file on the network. Can be either 0.0.101 or 0.0.102.
                         * @property {number|null} [limit] The maximum number of node addresses to receive before stopping. If not set or set to zero it will return all node addresses in the database.
                         */

                        /**
                         * Constructs a new AddressBookQuery.
                         * @memberof com.hedera.mirror.api.proto
                         * @classdesc Request object to query an address book for its list of nodes
                         * @implements IAddressBookQuery
                         * @constructor
                         * @param {com.hedera.mirror.api.proto.IAddressBookQuery=} [p] Properties to set
                         */
                        function AddressBookQuery(p) {
                            if (p)
                                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                    if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
                        }

                        /**
                         * The ID of the address book file on the network. Can be either 0.0.101 or 0.0.102.
                         * @member {proto.IFileID|null|undefined} fileId
                         * @memberof com.hedera.mirror.api.proto.AddressBookQuery
                         * @instance
                         */
                        AddressBookQuery.prototype.fileId = null;

                        /**
                         * The maximum number of node addresses to receive before stopping. If not set or set to zero it will return all node addresses in the database.
                         * @member {number} limit
                         * @memberof com.hedera.mirror.api.proto.AddressBookQuery
                         * @instance
                         */
                        AddressBookQuery.prototype.limit = 0;

                        /**
                         * Creates a new AddressBookQuery instance using the specified properties.
                         * @function create
                         * @memberof com.hedera.mirror.api.proto.AddressBookQuery
                         * @static
                         * @param {com.hedera.mirror.api.proto.IAddressBookQuery=} [properties] Properties to set
                         * @returns {com.hedera.mirror.api.proto.AddressBookQuery} AddressBookQuery instance
                         */
                        AddressBookQuery.create = function create(properties) {
                            return new AddressBookQuery(properties);
                        };

                        /**
                         * Encodes the specified AddressBookQuery message. Does not implicitly {@link com.hedera.mirror.api.proto.AddressBookQuery.verify|verify} messages.
                         * @function encode
                         * @memberof com.hedera.mirror.api.proto.AddressBookQuery
                         * @static
                         * @param {com.hedera.mirror.api.proto.IAddressBookQuery} m AddressBookQuery message or plain object to encode
                         * @param {$protobuf.Writer} [w] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        AddressBookQuery.encode = function encode(m, w) {
                            if (!w) w = $Writer.create();
                            if (m.fileId != null && Object.hasOwnProperty.call(m, "fileId"))
                                $root.proto.FileID.encode(m.fileId, w.uint32(10).fork()).ldelim();
                            if (m.limit != null && Object.hasOwnProperty.call(m, "limit")) w.uint32(16).int32(m.limit);
                            return w;
                        };

                        /**
                         * Decodes an AddressBookQuery message from the specified reader or buffer.
                         * @function decode
                         * @memberof com.hedera.mirror.api.proto.AddressBookQuery
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                         * @param {number} [l] Message length if known beforehand
                         * @returns {com.hedera.mirror.api.proto.AddressBookQuery} AddressBookQuery
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        AddressBookQuery.decode = function decode(r, l) {
                            if (!(r instanceof $Reader)) r = $Reader.create(r);
                            var c = l === undefined ? r.len : r.pos + l,
                                m = new $root.com.hedera.mirror.api.proto.AddressBookQuery();
                            while (r.pos < c) {
                                var t = r.uint32();
                                switch (t >>> 3) {
                                    case 1: {
                                        m.fileId = $root.proto.FileID.decode(r, r.uint32());
                                        break;
                                    }
                                    case 2: {
                                        m.limit = r.int32();
                                        break;
                                    }
                                    default:
                                        r.skipType(t & 7);
                                        break;
                                }
                            }
                            return m;
                        };

                        /**
                         * Gets the default type url for AddressBookQuery
                         * @function getTypeUrl
                         * @memberof com.hedera.mirror.api.proto.AddressBookQuery
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        AddressBookQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/com.hedera.mirror.api.proto.AddressBookQuery";
                        };

                        return AddressBookQuery;
                    })();

                    proto.NetworkService = (function () {
                        /**
                         * Constructs a new NetworkService service.
                         * @memberof com.hedera.mirror.api.proto
                         * @classdesc Provides cross network APIs like address book queries
                         * @extends $protobuf.rpc.Service
                         * @constructor
                         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                         */
                        function NetworkService(rpcImpl, requestDelimited, responseDelimited) {
                            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                        }

                        (NetworkService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor =
                            NetworkService;

                        /**
                         * Creates new NetworkService service using the specified rpc implementation.
                         * @function create
                         * @memberof com.hedera.mirror.api.proto.NetworkService
                         * @static
                         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                         * @returns {NetworkService} RPC service. Useful where requests and/or responses are streamed.
                         */
                        NetworkService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                            return new this(rpcImpl, requestDelimited, responseDelimited);
                        };

                        /**
                         * Callback as used by {@link com.hedera.mirror.api.proto.NetworkService#getNodes}.
                         * @memberof com.hedera.mirror.api.proto.NetworkService
                         * @typedef getNodesCallback
                         * @type {function}
                         * @param {Error|null} error Error, if any
                         * @param {proto.NodeAddress} [response] NodeAddress
                         */

                        /**
                         * Calls getNodes.
                         * @function getNodes
                         * @memberof com.hedera.mirror.api.proto.NetworkService
                         * @instance
                         * @param {com.hedera.mirror.api.proto.IAddressBookQuery} request AddressBookQuery message or plain object
                         * @param {com.hedera.mirror.api.proto.NetworkService.getNodesCallback} callback Node-style callback called with the error, if any, and NodeAddress
                         * @returns {undefined}
                         * @variation 1
                         */
                        Object.defineProperty(
                            (NetworkService.prototype.getNodes = function getNodes(request, callback) {
                                return this.rpcCall(
                                    getNodes,
                                    $root.com.hedera.mirror.api.proto.AddressBookQuery,
                                    $root.proto.NodeAddress,
                                    request,
                                    callback
                                );
                            }),
                            "name",
                            { value: "getNodes" }
                        );

                        /**
                         * Calls getNodes.
                         * @function getNodes
                         * @memberof com.hedera.mirror.api.proto.NetworkService
                         * @instance
                         * @param {com.hedera.mirror.api.proto.IAddressBookQuery} request AddressBookQuery message or plain object
                         * @returns {Promise<proto.NodeAddress>} Promise
                         * @variation 2
                         */

                        return NetworkService;
                    })();

                    return proto;
                })();

                return api;
            })();

            return mirror;
        })();

        return hedera;
    })();

    return com;
})());

export const proto = ($root.proto = (() => {
    /**
     * Namespace proto.
     * @exports proto
     * @namespace
     */
    const proto = {};

    proto.TransactionList = (function () {
        /**
         * Properties of a TransactionList.
         * @memberof proto
         * @interface ITransactionList
         * @property {Array.<proto.ITransaction>|null} [transactionList] TransactionList transactionList
         */

        /**
         * Constructs a new TransactionList.
         * @memberof proto
         * @classdesc A simple protobuf wrapper to store a list of transactions. This is used by
         * `Transaction.[from|to]Bytes()` in the SDKs. The reason the SDK needs a list of transactions is
         * because it holds onto a transaction per node. So if a transaction is to be submitted to nodes 3
         * and 4 the SDK Transaction type would contain a list of 2 protobuf transactions, one for node 3
         * and one for node 4.
         * @implements ITransactionList
         * @constructor
         * @param {proto.ITransactionList=} [p] Properties to set
         */
        function TransactionList(p) {
            this.transactionList = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * TransactionList transactionList.
         * @member {Array.<proto.ITransaction>} transactionList
         * @memberof proto.TransactionList
         * @instance
         */
        TransactionList.prototype.transactionList = $util.emptyArray;

        /**
         * Creates a new TransactionList instance using the specified properties.
         * @function create
         * @memberof proto.TransactionList
         * @static
         * @param {proto.ITransactionList=} [properties] Properties to set
         * @returns {proto.TransactionList} TransactionList instance
         */
        TransactionList.create = function create(properties) {
            return new TransactionList(properties);
        };

        /**
         * Encodes the specified TransactionList message. Does not implicitly {@link proto.TransactionList.verify|verify} messages.
         * @function encode
         * @memberof proto.TransactionList
         * @static
         * @param {proto.ITransactionList} m TransactionList message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionList.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.transactionList != null && m.transactionList.length) {
                for (var i = 0; i < m.transactionList.length; ++i)
                    $root.proto.Transaction.encode(m.transactionList[i], w.uint32(10).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a TransactionList message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TransactionList
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TransactionList} TransactionList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionList.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.TransactionList();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        if (!(m.transactionList && m.transactionList.length)) m.transactionList = [];
                        m.transactionList.push($root.proto.Transaction.decode(r, r.uint32()));
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TransactionList
         * @function getTypeUrl
         * @memberof proto.TransactionList
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TransactionList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TransactionList";
        };

        return TransactionList;
    })();

    proto.ShardID = (function () {
        /**
         * Properties of a ShardID.
         * @memberof proto
         * @interface IShardID
         * @property {Long|null} [shardNum] the shard number (nonnegative)
         */

        /**
         * Constructs a new ShardID.
         * @memberof proto
         * @classdesc Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative
         * realm number (that number might be reused in other shards). And each account, file, and smart
         * contract instance within a given realm has a nonnegative number (which might be reused in other
         * realms).  Every account, file, and smart contract instance is within exactly one realm. So a
         * FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.
         * Each realm maintains a single counter for assigning numbers,  so if there is a file with ID
         * 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.
         *
         * Everything is partitioned into realms so that each Solidity smart contract can  access everything
         * in just a single realm, locking all those entities while it's  running, but other smart contracts
         * could potentially run in other realms in  parallel. So realms allow Solidity to be parallelized
         * somewhat, even though the  language itself assumes everything is serial.
         * @implements IShardID
         * @constructor
         * @param {proto.IShardID=} [p] Properties to set
         */
        function ShardID(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * the shard number (nonnegative)
         * @member {Long} shardNum
         * @memberof proto.ShardID
         * @instance
         */
        ShardID.prototype.shardNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * Creates a new ShardID instance using the specified properties.
         * @function create
         * @memberof proto.ShardID
         * @static
         * @param {proto.IShardID=} [properties] Properties to set
         * @returns {proto.ShardID} ShardID instance
         */
        ShardID.create = function create(properties) {
            return new ShardID(properties);
        };

        /**
         * Encodes the specified ShardID message. Does not implicitly {@link proto.ShardID.verify|verify} messages.
         * @function encode
         * @memberof proto.ShardID
         * @static
         * @param {proto.IShardID} m ShardID message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShardID.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.shardNum != null && Object.hasOwnProperty.call(m, "shardNum")) w.uint32(8).int64(m.shardNum);
            return w;
        };

        /**
         * Decodes a ShardID message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ShardID
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ShardID} ShardID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShardID.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.ShardID();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.shardNum = r.int64();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ShardID
         * @function getTypeUrl
         * @memberof proto.ShardID
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ShardID.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ShardID";
        };

        return ShardID;
    })();

    proto.RealmID = (function () {
        /**
         * Properties of a RealmID.
         * @memberof proto
         * @interface IRealmID
         * @property {Long|null} [shardNum] The shard number (nonnegative)
         * @property {Long|null} [realmNum] The realm number (nonnegative)
         */

        /**
         * Constructs a new RealmID.
         * @memberof proto
         * @classdesc The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and
         * contract instance belongs to exactly one realm.
         * @implements IRealmID
         * @constructor
         * @param {proto.IRealmID=} [p] Properties to set
         */
        function RealmID(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The shard number (nonnegative)
         * @member {Long} shardNum
         * @memberof proto.RealmID
         * @instance
         */
        RealmID.prototype.shardNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * The realm number (nonnegative)
         * @member {Long} realmNum
         * @memberof proto.RealmID
         * @instance
         */
        RealmID.prototype.realmNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * Creates a new RealmID instance using the specified properties.
         * @function create
         * @memberof proto.RealmID
         * @static
         * @param {proto.IRealmID=} [properties] Properties to set
         * @returns {proto.RealmID} RealmID instance
         */
        RealmID.create = function create(properties) {
            return new RealmID(properties);
        };

        /**
         * Encodes the specified RealmID message. Does not implicitly {@link proto.RealmID.verify|verify} messages.
         * @function encode
         * @memberof proto.RealmID
         * @static
         * @param {proto.IRealmID} m RealmID message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RealmID.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.shardNum != null && Object.hasOwnProperty.call(m, "shardNum")) w.uint32(8).int64(m.shardNum);
            if (m.realmNum != null && Object.hasOwnProperty.call(m, "realmNum")) w.uint32(16).int64(m.realmNum);
            return w;
        };

        /**
         * Decodes a RealmID message from the specified reader or buffer.
         * @function decode
         * @memberof proto.RealmID
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.RealmID} RealmID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RealmID.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.RealmID();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.shardNum = r.int64();
                        break;
                    }
                    case 2: {
                        m.realmNum = r.int64();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for RealmID
         * @function getTypeUrl
         * @memberof proto.RealmID
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        RealmID.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.RealmID";
        };

        return RealmID;
    })();

    proto.AccountID = (function () {
        /**
         * Properties of an AccountID.
         * @memberof proto
         * @interface IAccountID
         * @property {Long|null} [shardNum] The shard number (nonnegative)
         * @property {Long|null} [realmNum] The realm number (nonnegative)
         * @property {Long|null} [accountNum] A non-negative account number unique within its realm
         * @property {Uint8Array|null} [alias] The public key bytes to be used as the account's alias. The public key bytes are the result of serializing
         * a protobuf Key message for any primitive key type. Currently only primitive key bytes are supported as an alias
         * (ThresholdKey, KeyList, ContractID, and delegatable_contract_id are not supported)
         *
         * May also be the ethereum account 20-byte EVM address to be used initially in place of the public key bytes. This EVM
         * address may be either the encoded form of the shard.realm.num or the keccak-256 hash of a ECDSA_SECP256K1 primitive key.
         *
         * At most one account can ever have a given alias and it is used for account creation if it
         * was automatically created using a crypto transfer. It will be null if an account is created normally.
         * It is immutable once it is set for an account.
         *
         * If a transaction auto-creates the account, any further transfers to that alias will simply be deposited
         * in that account, without creating anything, and with no creation fee being charged.
         *
         * If a transaction lazily-creates this account, a subsequent transaction will be required containing the public key bytes
         * that map to the EVM address bytes. The provided public key bytes will then serve as the final alias bytes.
         */

        /**
         * Constructs a new AccountID.
         * @memberof proto
         * @classdesc The ID for an a cryptocurrency account
         * @implements IAccountID
         * @constructor
         * @param {proto.IAccountID=} [p] Properties to set
         */
        function AccountID(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The shard number (nonnegative)
         * @member {Long} shardNum
         * @memberof proto.AccountID
         * @instance
         */
        AccountID.prototype.shardNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * The realm number (nonnegative)
         * @member {Long} realmNum
         * @memberof proto.AccountID
         * @instance
         */
        AccountID.prototype.realmNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * A non-negative account number unique within its realm
         * @member {Long|null|undefined} accountNum
         * @memberof proto.AccountID
         * @instance
         */
        AccountID.prototype.accountNum = null;

        /**
         * The public key bytes to be used as the account's alias. The public key bytes are the result of serializing
         * a protobuf Key message for any primitive key type. Currently only primitive key bytes are supported as an alias
         * (ThresholdKey, KeyList, ContractID, and delegatable_contract_id are not supported)
         *
         * May also be the ethereum account 20-byte EVM address to be used initially in place of the public key bytes. This EVM
         * address may be either the encoded form of the shard.realm.num or the keccak-256 hash of a ECDSA_SECP256K1 primitive key.
         *
         * At most one account can ever have a given alias and it is used for account creation if it
         * was automatically created using a crypto transfer. It will be null if an account is created normally.
         * It is immutable once it is set for an account.
         *
         * If a transaction auto-creates the account, any further transfers to that alias will simply be deposited
         * in that account, without creating anything, and with no creation fee being charged.
         *
         * If a transaction lazily-creates this account, a subsequent transaction will be required containing the public key bytes
         * that map to the EVM address bytes. The provided public key bytes will then serve as the final alias bytes.
         * @member {Uint8Array|null|undefined} alias
         * @memberof proto.AccountID
         * @instance
         */
        AccountID.prototype.alias = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * The account number unique within its realm which can be a non-negative integer, an alias public key or an EVM address.
         * For any AccountID fields in the query response, transaction record or transaction receipt only accountNum will
         * be populated.
         * @member {"accountNum"|"alias"|undefined} account
         * @memberof proto.AccountID
         * @instance
         */
        Object.defineProperty(AccountID.prototype, "account", {
            get: $util.oneOfGetter(($oneOfFields = ["accountNum", "alias"])),
            set: $util.oneOfSetter($oneOfFields),
        });

        /**
         * Creates a new AccountID instance using the specified properties.
         * @function create
         * @memberof proto.AccountID
         * @static
         * @param {proto.IAccountID=} [properties] Properties to set
         * @returns {proto.AccountID} AccountID instance
         */
        AccountID.create = function create(properties) {
            return new AccountID(properties);
        };

        /**
         * Encodes the specified AccountID message. Does not implicitly {@link proto.AccountID.verify|verify} messages.
         * @function encode
         * @memberof proto.AccountID
         * @static
         * @param {proto.IAccountID} m AccountID message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountID.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.shardNum != null && Object.hasOwnProperty.call(m, "shardNum")) w.uint32(8).int64(m.shardNum);
            if (m.realmNum != null && Object.hasOwnProperty.call(m, "realmNum")) w.uint32(16).int64(m.realmNum);
            if (m.accountNum != null && Object.hasOwnProperty.call(m, "accountNum")) w.uint32(24).int64(m.accountNum);
            if (m.alias != null && Object.hasOwnProperty.call(m, "alias")) w.uint32(34).bytes(m.alias);
            return w;
        };

        /**
         * Decodes an AccountID message from the specified reader or buffer.
         * @function decode
         * @memberof proto.AccountID
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.AccountID} AccountID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountID.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.AccountID();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.shardNum = r.int64();
                        break;
                    }
                    case 2: {
                        m.realmNum = r.int64();
                        break;
                    }
                    case 3: {
                        m.accountNum = r.int64();
                        break;
                    }
                    case 4: {
                        m.alias = r.bytes();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for AccountID
         * @function getTypeUrl
         * @memberof proto.AccountID
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AccountID.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.AccountID";
        };

        return AccountID;
    })();

    proto.FileID = (function () {
        /**
         * Properties of a FileID.
         * @memberof proto
         * @interface IFileID
         * @property {Long|null} [shardNum] The shard number (nonnegative)
         * @property {Long|null} [realmNum] The realm number (nonnegative)
         * @property {Long|null} [fileNum] A nonnegative File number unique within its realm
         */

        /**
         * Constructs a new FileID.
         * @memberof proto
         * @classdesc The ID for a file
         * @implements IFileID
         * @constructor
         * @param {proto.IFileID=} [p] Properties to set
         */
        function FileID(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The shard number (nonnegative)
         * @member {Long} shardNum
         * @memberof proto.FileID
         * @instance
         */
        FileID.prototype.shardNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * The realm number (nonnegative)
         * @member {Long} realmNum
         * @memberof proto.FileID
         * @instance
         */
        FileID.prototype.realmNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * A nonnegative File number unique within its realm
         * @member {Long} fileNum
         * @memberof proto.FileID
         * @instance
         */
        FileID.prototype.fileNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * Creates a new FileID instance using the specified properties.
         * @function create
         * @memberof proto.FileID
         * @static
         * @param {proto.IFileID=} [properties] Properties to set
         * @returns {proto.FileID} FileID instance
         */
        FileID.create = function create(properties) {
            return new FileID(properties);
        };

        /**
         * Encodes the specified FileID message. Does not implicitly {@link proto.FileID.verify|verify} messages.
         * @function encode
         * @memberof proto.FileID
         * @static
         * @param {proto.IFileID} m FileID message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FileID.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.shardNum != null && Object.hasOwnProperty.call(m, "shardNum")) w.uint32(8).int64(m.shardNum);
            if (m.realmNum != null && Object.hasOwnProperty.call(m, "realmNum")) w.uint32(16).int64(m.realmNum);
            if (m.fileNum != null && Object.hasOwnProperty.call(m, "fileNum")) w.uint32(24).int64(m.fileNum);
            return w;
        };

        /**
         * Decodes a FileID message from the specified reader or buffer.
         * @function decode
         * @memberof proto.FileID
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.FileID} FileID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FileID.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.FileID();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.shardNum = r.int64();
                        break;
                    }
                    case 2: {
                        m.realmNum = r.int64();
                        break;
                    }
                    case 3: {
                        m.fileNum = r.int64();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for FileID
         * @function getTypeUrl
         * @memberof proto.FileID
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        FileID.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.FileID";
        };

        return FileID;
    })();

    proto.ContractID = (function () {
        /**
         * Properties of a ContractID.
         * @memberof proto
         * @interface IContractID
         * @property {Long|null} [shardNum] The shard number (nonnegative)
         * @property {Long|null} [realmNum] The realm number (nonnegative)
         * @property {Long|null} [contractNum] A nonnegative number unique within a given shard and realm
         * @property {Uint8Array|null} [evmAddress] The 20-byte EVM address of the contract to call.
         *
         * Every contract has an EVM address determined by its <tt>shard.realm.num</tt> id.
         * This address is as follows:
         * <ol>
         * <li>The first 4 bytes are the big-endian representation of the shard.</li>
         * <li>The next 8 bytes are the big-endian representation of the realm.</li>
         * <li>The final 8 bytes are the big-endian representation of the number.</li>
         * </ol>
         *
         * Contracts created via CREATE2 have an <b>additional, primary address</b> that is
         * derived from the <a href="https://eips.ethereum.org/EIPS/eip-1014">EIP-1014</a>
         * specification, and does not have a simple relation to a <tt>shard.realm.num</tt> id.
         *
         * (Please do note that CREATE2 contracts can also be referenced by the three-part
         * EVM address described above.)
         */

        /**
         * Constructs a new ContractID.
         * @memberof proto
         * @classdesc The ID for a smart contract instance
         * @implements IContractID
         * @constructor
         * @param {proto.IContractID=} [p] Properties to set
         */
        function ContractID(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The shard number (nonnegative)
         * @member {Long} shardNum
         * @memberof proto.ContractID
         * @instance
         */
        ContractID.prototype.shardNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * The realm number (nonnegative)
         * @member {Long} realmNum
         * @memberof proto.ContractID
         * @instance
         */
        ContractID.prototype.realmNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * A nonnegative number unique within a given shard and realm
         * @member {Long|null|undefined} contractNum
         * @memberof proto.ContractID
         * @instance
         */
        ContractID.prototype.contractNum = null;

        /**
         * The 20-byte EVM address of the contract to call.
         *
         * Every contract has an EVM address determined by its <tt>shard.realm.num</tt> id.
         * This address is as follows:
         * <ol>
         * <li>The first 4 bytes are the big-endian representation of the shard.</li>
         * <li>The next 8 bytes are the big-endian representation of the realm.</li>
         * <li>The final 8 bytes are the big-endian representation of the number.</li>
         * </ol>
         *
         * Contracts created via CREATE2 have an <b>additional, primary address</b> that is
         * derived from the <a href="https://eips.ethereum.org/EIPS/eip-1014">EIP-1014</a>
         * specification, and does not have a simple relation to a <tt>shard.realm.num</tt> id.
         *
         * (Please do note that CREATE2 contracts can also be referenced by the three-part
         * EVM address described above.)
         * @member {Uint8Array|null|undefined} evmAddress
         * @memberof proto.ContractID
         * @instance
         */
        ContractID.prototype.evmAddress = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * ContractID contract.
         * @member {"contractNum"|"evmAddress"|undefined} contract
         * @memberof proto.ContractID
         * @instance
         */
        Object.defineProperty(ContractID.prototype, "contract", {
            get: $util.oneOfGetter(($oneOfFields = ["contractNum", "evmAddress"])),
            set: $util.oneOfSetter($oneOfFields),
        });

        /**
         * Creates a new ContractID instance using the specified properties.
         * @function create
         * @memberof proto.ContractID
         * @static
         * @param {proto.IContractID=} [properties] Properties to set
         * @returns {proto.ContractID} ContractID instance
         */
        ContractID.create = function create(properties) {
            return new ContractID(properties);
        };

        /**
         * Encodes the specified ContractID message. Does not implicitly {@link proto.ContractID.verify|verify} messages.
         * @function encode
         * @memberof proto.ContractID
         * @static
         * @param {proto.IContractID} m ContractID message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractID.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.shardNum != null && Object.hasOwnProperty.call(m, "shardNum")) w.uint32(8).int64(m.shardNum);
            if (m.realmNum != null && Object.hasOwnProperty.call(m, "realmNum")) w.uint32(16).int64(m.realmNum);
            if (m.contractNum != null && Object.hasOwnProperty.call(m, "contractNum"))
                w.uint32(24).int64(m.contractNum);
            if (m.evmAddress != null && Object.hasOwnProperty.call(m, "evmAddress")) w.uint32(34).bytes(m.evmAddress);
            return w;
        };

        /**
         * Decodes a ContractID message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ContractID
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ContractID} ContractID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractID.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.ContractID();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.shardNum = r.int64();
                        break;
                    }
                    case 2: {
                        m.realmNum = r.int64();
                        break;
                    }
                    case 3: {
                        m.contractNum = r.int64();
                        break;
                    }
                    case 4: {
                        m.evmAddress = r.bytes();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ContractID
         * @function getTypeUrl
         * @memberof proto.ContractID
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ContractID.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ContractID";
        };

        return ContractID;
    })();

    proto.TransactionID = (function () {
        /**
         * Properties of a TransactionID.
         * @memberof proto
         * @interface ITransactionID
         * @property {proto.ITimestamp|null} [transactionValidStart] The transaction is invalid if consensusTimestamp < transactionID.transactionStartValid
         * @property {proto.IAccountID|null} [accountID] The Account ID that paid for this transaction
         * @property {boolean|null} [scheduled] Whether the Transaction is of type Scheduled or no
         * @property {number|null} [nonce] The identifier for an internal transaction that was spawned as part
         * of handling a user transaction. (These internal transactions share the
         * transactionValidStart and accountID of the user transaction, so a
         * nonce is necessary to give them a unique TransactionID.)
         *
         * An example is when a "parent" ContractCreate or ContractCall transaction
         * calls one or more HTS precompiled contracts; each of the "child"
         * transactions spawned for a precompile has a id with a different nonce.
         */

        /**
         * Constructs a new TransactionID.
         * @memberof proto
         * @classdesc The ID for a transaction. This is used for retrieving receipts and records for a transaction, for
         * appending to a file right after creating it, for instantiating a smart contract with bytecode in
         * a file just created, and internally by the network for detecting when duplicate transactions are
         * submitted. A user might get a transaction processed faster by submitting it to N nodes, each with
         * a different node account, but all with the same TransactionID. Then, the transaction will take
         * effect when the first of all those nodes submits the transaction and it reaches consensus. The
         * other transactions will not take effect. So this could make the transaction take effect faster,
         * if any given node might be slow. However, the full transaction fee is charged for each
         * transaction, so the total fee is N times as much if the transaction is sent to N nodes.
         *
         * Applicable to Scheduled Transactions:
         * - The ID of a Scheduled Transaction has transactionValidStart and accountIDs inherited from the
         * ScheduleCreate transaction that created it. That is to say that they are equal
         * - The scheduled property is true for Scheduled Transactions
         * - transactionValidStart, accountID and scheduled properties should be omitted
         * @implements ITransactionID
         * @constructor
         * @param {proto.ITransactionID=} [p] Properties to set
         */
        function TransactionID(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The transaction is invalid if consensusTimestamp < transactionID.transactionStartValid
         * @member {proto.ITimestamp|null|undefined} transactionValidStart
         * @memberof proto.TransactionID
         * @instance
         */
        TransactionID.prototype.transactionValidStart = null;

        /**
         * The Account ID that paid for this transaction
         * @member {proto.IAccountID|null|undefined} accountID
         * @memberof proto.TransactionID
         * @instance
         */
        TransactionID.prototype.accountID = null;

        /**
         * Whether the Transaction is of type Scheduled or no
         * @member {boolean} scheduled
         * @memberof proto.TransactionID
         * @instance
         */
        TransactionID.prototype.scheduled = false;

        /**
         * The identifier for an internal transaction that was spawned as part
         * of handling a user transaction. (These internal transactions share the
         * transactionValidStart and accountID of the user transaction, so a
         * nonce is necessary to give them a unique TransactionID.)
         *
         * An example is when a "parent" ContractCreate or ContractCall transaction
         * calls one or more HTS precompiled contracts; each of the "child"
         * transactions spawned for a precompile has a id with a different nonce.
         * @member {number} nonce
         * @memberof proto.TransactionID
         * @instance
         */
        TransactionID.prototype.nonce = 0;

        /**
         * Creates a new TransactionID instance using the specified properties.
         * @function create
         * @memberof proto.TransactionID
         * @static
         * @param {proto.ITransactionID=} [properties] Properties to set
         * @returns {proto.TransactionID} TransactionID instance
         */
        TransactionID.create = function create(properties) {
            return new TransactionID(properties);
        };

        /**
         * Encodes the specified TransactionID message. Does not implicitly {@link proto.TransactionID.verify|verify} messages.
         * @function encode
         * @memberof proto.TransactionID
         * @static
         * @param {proto.ITransactionID} m TransactionID message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionID.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.transactionValidStart != null && Object.hasOwnProperty.call(m, "transactionValidStart"))
                $root.proto.Timestamp.encode(m.transactionValidStart, w.uint32(10).fork()).ldelim();
            if (m.accountID != null && Object.hasOwnProperty.call(m, "accountID"))
                $root.proto.AccountID.encode(m.accountID, w.uint32(18).fork()).ldelim();
            if (m.scheduled != null && Object.hasOwnProperty.call(m, "scheduled")) w.uint32(24).bool(m.scheduled);
            if (m.nonce != null && Object.hasOwnProperty.call(m, "nonce")) w.uint32(32).int32(m.nonce);
            return w;
        };

        /**
         * Decodes a TransactionID message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TransactionID
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TransactionID} TransactionID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionID.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.TransactionID();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.transactionValidStart = $root.proto.Timestamp.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.accountID = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    case 3: {
                        m.scheduled = r.bool();
                        break;
                    }
                    case 4: {
                        m.nonce = r.int32();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TransactionID
         * @function getTypeUrl
         * @memberof proto.TransactionID
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TransactionID.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TransactionID";
        };

        return TransactionID;
    })();

    proto.AccountAmount = (function () {
        /**
         * Properties of an AccountAmount.
         * @memberof proto
         * @interface IAccountAmount
         * @property {proto.IAccountID|null} [accountID] The Account ID that sends/receives cryptocurrency or tokens
         * @property {Long|null} [amount] The amount of tinybars (for Crypto transfers) or in the lowest
         * denomination (for Token transfers) that the account sends(negative) or
         * receives(positive)
         * @property {boolean|null} [isApproval] If true then the transfer is expected to be an approved allowance and the
         * accountID is expected to be the owner. The default is false (omitted).
         */

        /**
         * Constructs a new AccountAmount.
         * @memberof proto
         * @classdesc An account, and the amount that it sends or receives during a cryptocurrency or token transfer.
         * @implements IAccountAmount
         * @constructor
         * @param {proto.IAccountAmount=} [p] Properties to set
         */
        function AccountAmount(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The Account ID that sends/receives cryptocurrency or tokens
         * @member {proto.IAccountID|null|undefined} accountID
         * @memberof proto.AccountAmount
         * @instance
         */
        AccountAmount.prototype.accountID = null;

        /**
         * The amount of tinybars (for Crypto transfers) or in the lowest
         * denomination (for Token transfers) that the account sends(negative) or
         * receives(positive)
         * @member {Long} amount
         * @memberof proto.AccountAmount
         * @instance
         */
        AccountAmount.prototype.amount = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * If true then the transfer is expected to be an approved allowance and the
         * accountID is expected to be the owner. The default is false (omitted).
         * @member {boolean} isApproval
         * @memberof proto.AccountAmount
         * @instance
         */
        AccountAmount.prototype.isApproval = false;

        /**
         * Creates a new AccountAmount instance using the specified properties.
         * @function create
         * @memberof proto.AccountAmount
         * @static
         * @param {proto.IAccountAmount=} [properties] Properties to set
         * @returns {proto.AccountAmount} AccountAmount instance
         */
        AccountAmount.create = function create(properties) {
            return new AccountAmount(properties);
        };

        /**
         * Encodes the specified AccountAmount message. Does not implicitly {@link proto.AccountAmount.verify|verify} messages.
         * @function encode
         * @memberof proto.AccountAmount
         * @static
         * @param {proto.IAccountAmount} m AccountAmount message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountAmount.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.accountID != null && Object.hasOwnProperty.call(m, "accountID"))
                $root.proto.AccountID.encode(m.accountID, w.uint32(10).fork()).ldelim();
            if (m.amount != null && Object.hasOwnProperty.call(m, "amount")) w.uint32(16).sint64(m.amount);
            if (m.isApproval != null && Object.hasOwnProperty.call(m, "isApproval")) w.uint32(24).bool(m.isApproval);
            return w;
        };

        /**
         * Decodes an AccountAmount message from the specified reader or buffer.
         * @function decode
         * @memberof proto.AccountAmount
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.AccountAmount} AccountAmount
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountAmount.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.AccountAmount();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.accountID = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.amount = r.sint64();
                        break;
                    }
                    case 3: {
                        m.isApproval = r.bool();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for AccountAmount
         * @function getTypeUrl
         * @memberof proto.AccountAmount
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AccountAmount.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.AccountAmount";
        };

        return AccountAmount;
    })();

    proto.TransferList = (function () {
        /**
         * Properties of a TransferList.
         * @memberof proto
         * @interface ITransferList
         * @property {Array.<proto.IAccountAmount>|null} [accountAmounts] Multiple list of AccountAmount pairs, each of which has an account and
         * an amount to transfer into it (positive) or out of it (negative)
         */

        /**
         * Constructs a new TransferList.
         * @memberof proto
         * @classdesc A list of accounts and amounts to transfer out of each account (negative) or into it (positive).
         * @implements ITransferList
         * @constructor
         * @param {proto.ITransferList=} [p] Properties to set
         */
        function TransferList(p) {
            this.accountAmounts = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * Multiple list of AccountAmount pairs, each of which has an account and
         * an amount to transfer into it (positive) or out of it (negative)
         * @member {Array.<proto.IAccountAmount>} accountAmounts
         * @memberof proto.TransferList
         * @instance
         */
        TransferList.prototype.accountAmounts = $util.emptyArray;

        /**
         * Creates a new TransferList instance using the specified properties.
         * @function create
         * @memberof proto.TransferList
         * @static
         * @param {proto.ITransferList=} [properties] Properties to set
         * @returns {proto.TransferList} TransferList instance
         */
        TransferList.create = function create(properties) {
            return new TransferList(properties);
        };

        /**
         * Encodes the specified TransferList message. Does not implicitly {@link proto.TransferList.verify|verify} messages.
         * @function encode
         * @memberof proto.TransferList
         * @static
         * @param {proto.ITransferList} m TransferList message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransferList.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.accountAmounts != null && m.accountAmounts.length) {
                for (var i = 0; i < m.accountAmounts.length; ++i)
                    $root.proto.AccountAmount.encode(m.accountAmounts[i], w.uint32(10).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a TransferList message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TransferList
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TransferList} TransferList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransferList.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.TransferList();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        if (!(m.accountAmounts && m.accountAmounts.length)) m.accountAmounts = [];
                        m.accountAmounts.push($root.proto.AccountAmount.decode(r, r.uint32()));
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TransferList
         * @function getTypeUrl
         * @memberof proto.TransferList
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TransferList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TransferList";
        };

        return TransferList;
    })();

    proto.NftTransfer = (function () {
        /**
         * Properties of a NftTransfer.
         * @memberof proto
         * @interface INftTransfer
         * @property {proto.IAccountID|null} [senderAccountID] The accountID of the sender
         * @property {proto.IAccountID|null} [receiverAccountID] The accountID of the receiver
         * @property {Long|null} [serialNumber] The serial number of the NFT
         * @property {boolean|null} [isApproval] If true then the transfer is expected to be an approved allowance and the
         * senderAccountID is expected to be the owner. The default is false (omitted).
         */

        /**
         * Constructs a new NftTransfer.
         * @memberof proto
         * @classdesc A sender account, a receiver account, and the serial number of an NFT of a Token with
         * NON_FUNGIBLE_UNIQUE type. When minting NFTs the sender will be the default AccountID instance
         * (0.0.0) and when burning NFTs, the receiver will be the default AccountID instance.
         * @implements INftTransfer
         * @constructor
         * @param {proto.INftTransfer=} [p] Properties to set
         */
        function NftTransfer(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The accountID of the sender
         * @member {proto.IAccountID|null|undefined} senderAccountID
         * @memberof proto.NftTransfer
         * @instance
         */
        NftTransfer.prototype.senderAccountID = null;

        /**
         * The accountID of the receiver
         * @member {proto.IAccountID|null|undefined} receiverAccountID
         * @memberof proto.NftTransfer
         * @instance
         */
        NftTransfer.prototype.receiverAccountID = null;

        /**
         * The serial number of the NFT
         * @member {Long} serialNumber
         * @memberof proto.NftTransfer
         * @instance
         */
        NftTransfer.prototype.serialNumber = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * If true then the transfer is expected to be an approved allowance and the
         * senderAccountID is expected to be the owner. The default is false (omitted).
         * @member {boolean} isApproval
         * @memberof proto.NftTransfer
         * @instance
         */
        NftTransfer.prototype.isApproval = false;

        /**
         * Creates a new NftTransfer instance using the specified properties.
         * @function create
         * @memberof proto.NftTransfer
         * @static
         * @param {proto.INftTransfer=} [properties] Properties to set
         * @returns {proto.NftTransfer} NftTransfer instance
         */
        NftTransfer.create = function create(properties) {
            return new NftTransfer(properties);
        };

        /**
         * Encodes the specified NftTransfer message. Does not implicitly {@link proto.NftTransfer.verify|verify} messages.
         * @function encode
         * @memberof proto.NftTransfer
         * @static
         * @param {proto.INftTransfer} m NftTransfer message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NftTransfer.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.senderAccountID != null && Object.hasOwnProperty.call(m, "senderAccountID"))
                $root.proto.AccountID.encode(m.senderAccountID, w.uint32(10).fork()).ldelim();
            if (m.receiverAccountID != null && Object.hasOwnProperty.call(m, "receiverAccountID"))
                $root.proto.AccountID.encode(m.receiverAccountID, w.uint32(18).fork()).ldelim();
            if (m.serialNumber != null && Object.hasOwnProperty.call(m, "serialNumber"))
                w.uint32(24).int64(m.serialNumber);
            if (m.isApproval != null && Object.hasOwnProperty.call(m, "isApproval")) w.uint32(32).bool(m.isApproval);
            return w;
        };

        /**
         * Decodes a NftTransfer message from the specified reader or buffer.
         * @function decode
         * @memberof proto.NftTransfer
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.NftTransfer} NftTransfer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NftTransfer.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.NftTransfer();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.senderAccountID = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.receiverAccountID = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    case 3: {
                        m.serialNumber = r.int64();
                        break;
                    }
                    case 4: {
                        m.isApproval = r.bool();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for NftTransfer
         * @function getTypeUrl
         * @memberof proto.NftTransfer
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        NftTransfer.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.NftTransfer";
        };

        return NftTransfer;
    })();

    proto.TokenTransferList = (function () {
        /**
         * Properties of a TokenTransferList.
         * @memberof proto
         * @interface ITokenTransferList
         * @property {proto.ITokenID|null} [token] The ID of the token
         * @property {Array.<proto.IAccountAmount>|null} [transfers] Applicable to tokens of type FUNGIBLE_COMMON. Multiple list of AccountAmounts, each of which
         * has an account and amount
         * @property {Array.<proto.INftTransfer>|null} [nftTransfers] Applicable to tokens of type NON_FUNGIBLE_UNIQUE. Multiple list of NftTransfers, each of
         * which has a sender and receiver account, including the serial number of the NFT
         * @property {google.protobuf.IUInt32Value|null} [expectedDecimals] If present, the number of decimals this fungible token type is expected to have. The transfer
         * will fail with UNEXPECTED_TOKEN_DECIMALS if the actual decimals differ.
         */

        /**
         * Constructs a new TokenTransferList.
         * @memberof proto
         * @classdesc A list of token IDs and amounts representing the transferred out (negative) or into (positive)
         * amounts, represented in the lowest denomination of the token
         * @implements ITokenTransferList
         * @constructor
         * @param {proto.ITokenTransferList=} [p] Properties to set
         */
        function TokenTransferList(p) {
            this.transfers = [];
            this.nftTransfers = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The ID of the token
         * @member {proto.ITokenID|null|undefined} token
         * @memberof proto.TokenTransferList
         * @instance
         */
        TokenTransferList.prototype.token = null;

        /**
         * Applicable to tokens of type FUNGIBLE_COMMON. Multiple list of AccountAmounts, each of which
         * has an account and amount
         * @member {Array.<proto.IAccountAmount>} transfers
         * @memberof proto.TokenTransferList
         * @instance
         */
        TokenTransferList.prototype.transfers = $util.emptyArray;

        /**
         * Applicable to tokens of type NON_FUNGIBLE_UNIQUE. Multiple list of NftTransfers, each of
         * which has a sender and receiver account, including the serial number of the NFT
         * @member {Array.<proto.INftTransfer>} nftTransfers
         * @memberof proto.TokenTransferList
         * @instance
         */
        TokenTransferList.prototype.nftTransfers = $util.emptyArray;

        /**
         * If present, the number of decimals this fungible token type is expected to have. The transfer
         * will fail with UNEXPECTED_TOKEN_DECIMALS if the actual decimals differ.
         * @member {google.protobuf.IUInt32Value|null|undefined} expectedDecimals
         * @memberof proto.TokenTransferList
         * @instance
         */
        TokenTransferList.prototype.expectedDecimals = null;

        /**
         * Creates a new TokenTransferList instance using the specified properties.
         * @function create
         * @memberof proto.TokenTransferList
         * @static
         * @param {proto.ITokenTransferList=} [properties] Properties to set
         * @returns {proto.TokenTransferList} TokenTransferList instance
         */
        TokenTransferList.create = function create(properties) {
            return new TokenTransferList(properties);
        };

        /**
         * Encodes the specified TokenTransferList message. Does not implicitly {@link proto.TokenTransferList.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenTransferList
         * @static
         * @param {proto.ITokenTransferList} m TokenTransferList message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenTransferList.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.token != null && Object.hasOwnProperty.call(m, "token"))
                $root.proto.TokenID.encode(m.token, w.uint32(10).fork()).ldelim();
            if (m.transfers != null && m.transfers.length) {
                for (var i = 0; i < m.transfers.length; ++i)
                    $root.proto.AccountAmount.encode(m.transfers[i], w.uint32(18).fork()).ldelim();
            }
            if (m.nftTransfers != null && m.nftTransfers.length) {
                for (var i = 0; i < m.nftTransfers.length; ++i)
                    $root.proto.NftTransfer.encode(m.nftTransfers[i], w.uint32(26).fork()).ldelim();
            }
            if (m.expectedDecimals != null && Object.hasOwnProperty.call(m, "expectedDecimals"))
                $root.google.protobuf.UInt32Value.encode(m.expectedDecimals, w.uint32(34).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a TokenTransferList message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenTransferList
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenTransferList} TokenTransferList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenTransferList.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.TokenTransferList();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.token = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        if (!(m.transfers && m.transfers.length)) m.transfers = [];
                        m.transfers.push($root.proto.AccountAmount.decode(r, r.uint32()));
                        break;
                    }
                    case 3: {
                        if (!(m.nftTransfers && m.nftTransfers.length)) m.nftTransfers = [];
                        m.nftTransfers.push($root.proto.NftTransfer.decode(r, r.uint32()));
                        break;
                    }
                    case 4: {
                        m.expectedDecimals = $root.google.protobuf.UInt32Value.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenTransferList
         * @function getTypeUrl
         * @memberof proto.TokenTransferList
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenTransferList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenTransferList";
        };

        return TokenTransferList;
    })();

    proto.Fraction = (function () {
        /**
         * Properties of a Fraction.
         * @memberof proto
         * @interface IFraction
         * @property {Long|null} [numerator] The rational's numerator
         * @property {Long|null} [denominator] The rational's denominator; a zero value will result in FRACTION_DIVIDES_BY_ZERO
         */

        /**
         * Constructs a new Fraction.
         * @memberof proto
         * @classdesc A rational number, used to set the amount of a value transfer to collect as a custom fee
         * @implements IFraction
         * @constructor
         * @param {proto.IFraction=} [p] Properties to set
         */
        function Fraction(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The rational's numerator
         * @member {Long} numerator
         * @memberof proto.Fraction
         * @instance
         */
        Fraction.prototype.numerator = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * The rational's denominator; a zero value will result in FRACTION_DIVIDES_BY_ZERO
         * @member {Long} denominator
         * @memberof proto.Fraction
         * @instance
         */
        Fraction.prototype.denominator = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * Creates a new Fraction instance using the specified properties.
         * @function create
         * @memberof proto.Fraction
         * @static
         * @param {proto.IFraction=} [properties] Properties to set
         * @returns {proto.Fraction} Fraction instance
         */
        Fraction.create = function create(properties) {
            return new Fraction(properties);
        };

        /**
         * Encodes the specified Fraction message. Does not implicitly {@link proto.Fraction.verify|verify} messages.
         * @function encode
         * @memberof proto.Fraction
         * @static
         * @param {proto.IFraction} m Fraction message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Fraction.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.numerator != null && Object.hasOwnProperty.call(m, "numerator")) w.uint32(8).int64(m.numerator);
            if (m.denominator != null && Object.hasOwnProperty.call(m, "denominator"))
                w.uint32(16).int64(m.denominator);
            return w;
        };

        /**
         * Decodes a Fraction message from the specified reader or buffer.
         * @function decode
         * @memberof proto.Fraction
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.Fraction} Fraction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Fraction.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.Fraction();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.numerator = r.int64();
                        break;
                    }
                    case 2: {
                        m.denominator = r.int64();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for Fraction
         * @function getTypeUrl
         * @memberof proto.Fraction
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Fraction.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.Fraction";
        };

        return Fraction;
    })();

    proto.TopicID = (function () {
        /**
         * Properties of a TopicID.
         * @memberof proto
         * @interface ITopicID
         * @property {Long|null} [shardNum] The shard number (nonnegative)
         * @property {Long|null} [realmNum] The realm number (nonnegative)
         * @property {Long|null} [topicNum] Unique topic identifier within a realm (nonnegative).
         */

        /**
         * Constructs a new TopicID.
         * @memberof proto
         * @classdesc Unique identifier for a topic (used by the consensus service)
         * @implements ITopicID
         * @constructor
         * @param {proto.ITopicID=} [p] Properties to set
         */
        function TopicID(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The shard number (nonnegative)
         * @member {Long} shardNum
         * @memberof proto.TopicID
         * @instance
         */
        TopicID.prototype.shardNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * The realm number (nonnegative)
         * @member {Long} realmNum
         * @memberof proto.TopicID
         * @instance
         */
        TopicID.prototype.realmNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * Unique topic identifier within a realm (nonnegative).
         * @member {Long} topicNum
         * @memberof proto.TopicID
         * @instance
         */
        TopicID.prototype.topicNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * Creates a new TopicID instance using the specified properties.
         * @function create
         * @memberof proto.TopicID
         * @static
         * @param {proto.ITopicID=} [properties] Properties to set
         * @returns {proto.TopicID} TopicID instance
         */
        TopicID.create = function create(properties) {
            return new TopicID(properties);
        };

        /**
         * Encodes the specified TopicID message. Does not implicitly {@link proto.TopicID.verify|verify} messages.
         * @function encode
         * @memberof proto.TopicID
         * @static
         * @param {proto.ITopicID} m TopicID message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TopicID.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.shardNum != null && Object.hasOwnProperty.call(m, "shardNum")) w.uint32(8).int64(m.shardNum);
            if (m.realmNum != null && Object.hasOwnProperty.call(m, "realmNum")) w.uint32(16).int64(m.realmNum);
            if (m.topicNum != null && Object.hasOwnProperty.call(m, "topicNum")) w.uint32(24).int64(m.topicNum);
            return w;
        };

        /**
         * Decodes a TopicID message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TopicID
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TopicID} TopicID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TopicID.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.TopicID();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.shardNum = r.int64();
                        break;
                    }
                    case 2: {
                        m.realmNum = r.int64();
                        break;
                    }
                    case 3: {
                        m.topicNum = r.int64();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TopicID
         * @function getTypeUrl
         * @memberof proto.TopicID
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TopicID.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TopicID";
        };

        return TopicID;
    })();

    proto.TokenID = (function () {
        /**
         * Properties of a TokenID.
         * @memberof proto
         * @interface ITokenID
         * @property {Long|null} [shardNum] A nonnegative shard number
         * @property {Long|null} [realmNum] A nonnegative realm number
         * @property {Long|null} [tokenNum] A nonnegative token number
         */

        /**
         * Constructs a new TokenID.
         * @memberof proto
         * @classdesc Unique identifier for a token
         * @implements ITokenID
         * @constructor
         * @param {proto.ITokenID=} [p] Properties to set
         */
        function TokenID(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * A nonnegative shard number
         * @member {Long} shardNum
         * @memberof proto.TokenID
         * @instance
         */
        TokenID.prototype.shardNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * A nonnegative realm number
         * @member {Long} realmNum
         * @memberof proto.TokenID
         * @instance
         */
        TokenID.prototype.realmNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * A nonnegative token number
         * @member {Long} tokenNum
         * @memberof proto.TokenID
         * @instance
         */
        TokenID.prototype.tokenNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * Creates a new TokenID instance using the specified properties.
         * @function create
         * @memberof proto.TokenID
         * @static
         * @param {proto.ITokenID=} [properties] Properties to set
         * @returns {proto.TokenID} TokenID instance
         */
        TokenID.create = function create(properties) {
            return new TokenID(properties);
        };

        /**
         * Encodes the specified TokenID message. Does not implicitly {@link proto.TokenID.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenID
         * @static
         * @param {proto.ITokenID} m TokenID message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenID.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.shardNum != null && Object.hasOwnProperty.call(m, "shardNum")) w.uint32(8).int64(m.shardNum);
            if (m.realmNum != null && Object.hasOwnProperty.call(m, "realmNum")) w.uint32(16).int64(m.realmNum);
            if (m.tokenNum != null && Object.hasOwnProperty.call(m, "tokenNum")) w.uint32(24).int64(m.tokenNum);
            return w;
        };

        /**
         * Decodes a TokenID message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenID
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenID} TokenID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenID.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.TokenID();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.shardNum = r.int64();
                        break;
                    }
                    case 2: {
                        m.realmNum = r.int64();
                        break;
                    }
                    case 3: {
                        m.tokenNum = r.int64();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenID
         * @function getTypeUrl
         * @memberof proto.TokenID
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenID.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenID";
        };

        return TokenID;
    })();

    proto.ScheduleID = (function () {
        /**
         * Properties of a ScheduleID.
         * @memberof proto
         * @interface IScheduleID
         * @property {Long|null} [shardNum] A nonnegative shard number
         * @property {Long|null} [realmNum] A nonnegative realm number
         * @property {Long|null} [scheduleNum] A nonnegative schedule number
         */

        /**
         * Constructs a new ScheduleID.
         * @memberof proto
         * @classdesc Unique identifier for a Schedule
         * @implements IScheduleID
         * @constructor
         * @param {proto.IScheduleID=} [p] Properties to set
         */
        function ScheduleID(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * A nonnegative shard number
         * @member {Long} shardNum
         * @memberof proto.ScheduleID
         * @instance
         */
        ScheduleID.prototype.shardNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * A nonnegative realm number
         * @member {Long} realmNum
         * @memberof proto.ScheduleID
         * @instance
         */
        ScheduleID.prototype.realmNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * A nonnegative schedule number
         * @member {Long} scheduleNum
         * @memberof proto.ScheduleID
         * @instance
         */
        ScheduleID.prototype.scheduleNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * Creates a new ScheduleID instance using the specified properties.
         * @function create
         * @memberof proto.ScheduleID
         * @static
         * @param {proto.IScheduleID=} [properties] Properties to set
         * @returns {proto.ScheduleID} ScheduleID instance
         */
        ScheduleID.create = function create(properties) {
            return new ScheduleID(properties);
        };

        /**
         * Encodes the specified ScheduleID message. Does not implicitly {@link proto.ScheduleID.verify|verify} messages.
         * @function encode
         * @memberof proto.ScheduleID
         * @static
         * @param {proto.IScheduleID} m ScheduleID message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ScheduleID.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.shardNum != null && Object.hasOwnProperty.call(m, "shardNum")) w.uint32(8).int64(m.shardNum);
            if (m.realmNum != null && Object.hasOwnProperty.call(m, "realmNum")) w.uint32(16).int64(m.realmNum);
            if (m.scheduleNum != null && Object.hasOwnProperty.call(m, "scheduleNum"))
                w.uint32(24).int64(m.scheduleNum);
            return w;
        };

        /**
         * Decodes a ScheduleID message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ScheduleID
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ScheduleID} ScheduleID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ScheduleID.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.ScheduleID();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.shardNum = r.int64();
                        break;
                    }
                    case 2: {
                        m.realmNum = r.int64();
                        break;
                    }
                    case 3: {
                        m.scheduleNum = r.int64();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ScheduleID
         * @function getTypeUrl
         * @memberof proto.ScheduleID
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ScheduleID.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ScheduleID";
        };

        return ScheduleID;
    })();

    /**
     * Possible Token Types (IWA Compatibility).
     * Apart from fungible and non-fungible, Tokens can have either a common or unique representation.
     * This distinction might seem subtle, but it is important when considering how tokens can be traced
     * and if they can have isolated and unique properties.
     * @name proto.TokenType
     * @enum {number}
     * @property {number} FUNGIBLE_COMMON=0 Interchangeable value with one another, where any quantity of them has the same value as
     * another equal quantity if they are in the same class.  Share a single set of properties, not
     * distinct from one another. Simply represented as a balance or quantity to a given Hedera
     * account.
     * @property {number} NON_FUNGIBLE_UNIQUE=1 Unique, not interchangeable with other tokens of the same type as they typically have
     * different values.  Individually traced and can carry unique properties (e.g. serial number).
     */
    proto.TokenType = (function () {
        const valuesById = {},
            values = Object.create(valuesById);
        values[(valuesById[0] = "FUNGIBLE_COMMON")] = 0;
        values[(valuesById[1] = "NON_FUNGIBLE_UNIQUE")] = 1;
        return values;
    })();

    /**
     * Allows a set of resource prices to be scoped to a certain type of a HAPI operation.
     *
     * For example, the resource prices for a TokenMint operation are different between minting fungible
     * and non-fungible tokens. This enum allows us to "mark" a set of prices as applying to one or the
     * other.
     *
     * Similarly, the resource prices for a basic TokenCreate without a custom fee schedule yield a
     * total price of $1. The resource prices for a TokenCreate with a custom fee schedule are different
     * and yield a total base price of $2.
     * @name proto.SubType
     * @enum {number}
     * @property {number} DEFAULT=0 The resource prices have no special scope
     * @property {number} TOKEN_FUNGIBLE_COMMON=1 The resource prices are scoped to an operation on a fungible common token
     * @property {number} TOKEN_NON_FUNGIBLE_UNIQUE=2 The resource prices are scoped to an operation on a non-fungible unique token
     * @property {number} TOKEN_FUNGIBLE_COMMON_WITH_CUSTOM_FEES=3 The resource prices are scoped to an operation on a fungible common
     * token with a custom fee schedule
     * @property {number} TOKEN_NON_FUNGIBLE_UNIQUE_WITH_CUSTOM_FEES=4 The resource prices are scoped to an operation on a non-fungible unique
     * token with a custom fee schedule
     * @property {number} SCHEDULE_CREATE_CONTRACT_CALL=5 The resource prices are scoped to a ScheduleCreate containing a ContractCall.
     */
    proto.SubType = (function () {
        const valuesById = {},
            values = Object.create(valuesById);
        values[(valuesById[0] = "DEFAULT")] = 0;
        values[(valuesById[1] = "TOKEN_FUNGIBLE_COMMON")] = 1;
        values[(valuesById[2] = "TOKEN_NON_FUNGIBLE_UNIQUE")] = 2;
        values[(valuesById[3] = "TOKEN_FUNGIBLE_COMMON_WITH_CUSTOM_FEES")] = 3;
        values[(valuesById[4] = "TOKEN_NON_FUNGIBLE_UNIQUE_WITH_CUSTOM_FEES")] = 4;
        values[(valuesById[5] = "SCHEDULE_CREATE_CONTRACT_CALL")] = 5;
        return values;
    })();

    /**
     * Possible Token Supply Types (IWA Compatibility).
     * Indicates how many tokens can have during its lifetime.
     * @name proto.TokenSupplyType
     * @enum {number}
     * @property {number} INFINITE=0 Indicates that tokens of that type have an upper bound of Long.MAX_VALUE.
     * @property {number} FINITE=1 Indicates that tokens of that type have an upper bound of maxSupply,
     * provided on token creation.
     */
    proto.TokenSupplyType = (function () {
        const valuesById = {},
            values = Object.create(valuesById);
        values[(valuesById[0] = "INFINITE")] = 0;
        values[(valuesById[1] = "FINITE")] = 1;
        return values;
    })();

    /**
     * Possible Freeze statuses returned on TokenGetInfoQuery or CryptoGetInfoResponse in
     * TokenRelationship
     * @name proto.TokenFreezeStatus
     * @enum {number}
     * @property {number} FreezeNotApplicable=0 UNDOCUMENTED
     * @property {number} Frozen=1 UNDOCUMENTED
     * @property {number} Unfrozen=2 UNDOCUMENTED
     */
    proto.TokenFreezeStatus = (function () {
        const valuesById = {},
            values = Object.create(valuesById);
        values[(valuesById[0] = "FreezeNotApplicable")] = 0;
        values[(valuesById[1] = "Frozen")] = 1;
        values[(valuesById[2] = "Unfrozen")] = 2;
        return values;
    })();

    /**
     * Possible KYC statuses returned on TokenGetInfoQuery or CryptoGetInfoResponse in TokenRelationship
     * @name proto.TokenKycStatus
     * @enum {number}
     * @property {number} KycNotApplicable=0 UNDOCUMENTED
     * @property {number} Granted=1 UNDOCUMENTED
     * @property {number} Revoked=2 UNDOCUMENTED
     */
    proto.TokenKycStatus = (function () {
        const valuesById = {},
            values = Object.create(valuesById);
        values[(valuesById[0] = "KycNotApplicable")] = 0;
        values[(valuesById[1] = "Granted")] = 1;
        values[(valuesById[2] = "Revoked")] = 2;
        return values;
    })();

    /**
     * Possible Pause statuses returned on TokenGetInfoQuery
     * @name proto.TokenPauseStatus
     * @enum {number}
     * @property {number} PauseNotApplicable=0 Indicates that a Token has no pauseKey
     * @property {number} Paused=1 Indicates that a Token is Paused
     * @property {number} Unpaused=2 Indicates that a Token is Unpaused.
     */
    proto.TokenPauseStatus = (function () {
        const valuesById = {},
            values = Object.create(valuesById);
        values[(valuesById[0] = "PauseNotApplicable")] = 0;
        values[(valuesById[1] = "Paused")] = 1;
        values[(valuesById[2] = "Unpaused")] = 2;
        return values;
    })();

    proto.Key = (function () {
        /**
         * Properties of a Key.
         * @memberof proto
         * @interface IKey
         * @property {proto.IContractID|null} [contractID] smart contract instance that is authorized as if it had signed with a key
         * @property {Uint8Array|null} [ed25519] Ed25519 public key bytes
         * @property {Uint8Array|null} [RSA_3072] (NOT SUPPORTED) RSA-3072 public key bytes
         * @property {Uint8Array|null} [ECDSA_384] (NOT SUPPORTED) ECDSA with the p-384 curve public key bytes
         * @property {proto.IThresholdKey|null} [thresholdKey] a threshold N followed by a list of M keys, any N of which are required to form a valid
         * signature
         * @property {proto.IKeyList|null} [keyList] A list of Keys of the Key type.
         * @property {Uint8Array|null} [ECDSASecp256k1] Compressed ECDSA(secp256k1) public key bytes
         * @property {proto.IContractID|null} [delegatableContractId] A smart contract that, if the recipient of the active message frame, should be treated
         * as having signed. (Note this does not mean the <i>code being executed in the frame</i>
         * will belong to the given contract, since it could be running another contract's code via
         * <tt>delegatecall</tt>. So setting this key is a more permissive version of setting the
         * contractID key, which also requires the code in the active message frame belong to the
         * the contract with the given id.)
         */

        /**
         * Constructs a new Key.
         * @memberof proto
         * @classdesc A Key can be a public key from either the Ed25519 or ECDSA(secp256k1) signature schemes, where
         * in the ECDSA(secp256k1) case we require the 33-byte compressed form of the public key. We call
         * these public keys <b>primitive keys</b>.
         *
         * If an account has primitive key associated to it, then the corresponding private key must sign
         * any transaction to transfer cryptocurrency out of it.
         *
         * A Key can also be the ID of a smart contract instance, which is then authorized to perform any
         * precompiled contract action that requires this key to sign.
         *
         * Note that when a Key is a smart contract ID, it <i>doesn't</i> mean the contract with that ID
         * will actually create a cryptographic signature. It only means that when the contract calls a
         * precompiled contract, the resulting "child transaction" will be authorized to perform any action
         * controlled by the Key.
         *
         * A Key can be a "threshold key", which means a list of M keys, any N of which must sign in order
         * for the threshold signature to be considered valid. The keys within a threshold signature may
         * themselves be threshold signatures, to allow complex signature requirements.
         *
         * A Key can be a "key list" where all keys in the list must sign unless specified otherwise in the
         * documentation for a specific transaction type (e.g.  FileDeleteTransactionBody).  Their use is
         * dependent on context. For example, a Hedera file is created with a list of keys, where all of
         * them must sign a transaction to create or modify the file, but only one of them is needed to sign
         * a transaction to delete the file. So it's a single list that sometimes acts as a 1-of-M threshold
         * key, and sometimes acts as an M-of-M threshold key.  A key list is always an M-of-M, unless
         * specified otherwise in documentation. A key list can have nested key lists or threshold keys.
         * Nested key lists are always M-of-M. A key list can have repeated primitive public keys, but all
         * repeated keys are only required to sign once.
         *
         * A Key can contain a ThresholdKey or KeyList, which in turn contain a Key, so this mutual
         * recursion would allow nesting arbitrarily deep. A ThresholdKey which contains a list of primitive
         * keys has 3 levels: ThresholdKey -> KeyList -> Key. A KeyList which contains several primitive
         * keys has 2 levels: KeyList -> Key. A Key with 2 levels of nested ThresholdKeys has 7 levels:
         * Key -> ThresholdKey -> KeyList -> Key -> ThresholdKey -> KeyList -> Key.
         *
         * Each Key should not have more than 46 levels, which implies 15 levels of nested ThresholdKeys.
         * @implements IKey
         * @constructor
         * @param {proto.IKey=} [p] Properties to set
         */
        function Key(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * smart contract instance that is authorized as if it had signed with a key
         * @member {proto.IContractID|null|undefined} contractID
         * @memberof proto.Key
         * @instance
         */
        Key.prototype.contractID = null;

        /**
         * Ed25519 public key bytes
         * @member {Uint8Array|null|undefined} ed25519
         * @memberof proto.Key
         * @instance
         */
        Key.prototype.ed25519 = null;

        /**
         * (NOT SUPPORTED) RSA-3072 public key bytes
         * @member {Uint8Array|null|undefined} RSA_3072
         * @memberof proto.Key
         * @instance
         */
        Key.prototype.RSA_3072 = null;

        /**
         * (NOT SUPPORTED) ECDSA with the p-384 curve public key bytes
         * @member {Uint8Array|null|undefined} ECDSA_384
         * @memberof proto.Key
         * @instance
         */
        Key.prototype.ECDSA_384 = null;

        /**
         * a threshold N followed by a list of M keys, any N of which are required to form a valid
         * signature
         * @member {proto.IThresholdKey|null|undefined} thresholdKey
         * @memberof proto.Key
         * @instance
         */
        Key.prototype.thresholdKey = null;

        /**
         * A list of Keys of the Key type.
         * @member {proto.IKeyList|null|undefined} keyList
         * @memberof proto.Key
         * @instance
         */
        Key.prototype.keyList = null;

        /**
         * Compressed ECDSA(secp256k1) public key bytes
         * @member {Uint8Array|null|undefined} ECDSASecp256k1
         * @memberof proto.Key
         * @instance
         */
        Key.prototype.ECDSASecp256k1 = null;

        /**
         * A smart contract that, if the recipient of the active message frame, should be treated
         * as having signed. (Note this does not mean the <i>code being executed in the frame</i>
         * will belong to the given contract, since it could be running another contract's code via
         * <tt>delegatecall</tt>. So setting this key is a more permissive version of setting the
         * contractID key, which also requires the code in the active message frame belong to the
         * the contract with the given id.)
         * @member {proto.IContractID|null|undefined} delegatableContractId
         * @memberof proto.Key
         * @instance
         */
        Key.prototype.delegatableContractId = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * Key key.
         * @member {"contractID"|"ed25519"|"RSA_3072"|"ECDSA_384"|"thresholdKey"|"keyList"|"ECDSASecp256k1"|"delegatableContractId"|undefined} key
         * @memberof proto.Key
         * @instance
         */
        Object.defineProperty(Key.prototype, "key", {
            get: $util.oneOfGetter(
                ($oneOfFields = [
                    "contractID",
                    "ed25519",
                    "RSA_3072",
                    "ECDSA_384",
                    "thresholdKey",
                    "keyList",
                    "ECDSASecp256k1",
                    "delegatableContractId",
                ])
            ),
            set: $util.oneOfSetter($oneOfFields),
        });

        /**
         * Creates a new Key instance using the specified properties.
         * @function create
         * @memberof proto.Key
         * @static
         * @param {proto.IKey=} [properties] Properties to set
         * @returns {proto.Key} Key instance
         */
        Key.create = function create(properties) {
            return new Key(properties);
        };

        /**
         * Encodes the specified Key message. Does not implicitly {@link proto.Key.verify|verify} messages.
         * @function encode
         * @memberof proto.Key
         * @static
         * @param {proto.IKey} m Key message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Key.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.contractID != null && Object.hasOwnProperty.call(m, "contractID"))
                $root.proto.ContractID.encode(m.contractID, w.uint32(10).fork()).ldelim();
            if (m.ed25519 != null && Object.hasOwnProperty.call(m, "ed25519")) w.uint32(18).bytes(m.ed25519);
            if (m.RSA_3072 != null && Object.hasOwnProperty.call(m, "RSA_3072")) w.uint32(26).bytes(m.RSA_3072);
            if (m.ECDSA_384 != null && Object.hasOwnProperty.call(m, "ECDSA_384")) w.uint32(34).bytes(m.ECDSA_384);
            if (m.thresholdKey != null && Object.hasOwnProperty.call(m, "thresholdKey"))
                $root.proto.ThresholdKey.encode(m.thresholdKey, w.uint32(42).fork()).ldelim();
            if (m.keyList != null && Object.hasOwnProperty.call(m, "keyList"))
                $root.proto.KeyList.encode(m.keyList, w.uint32(50).fork()).ldelim();
            if (m.ECDSASecp256k1 != null && Object.hasOwnProperty.call(m, "ECDSASecp256k1"))
                w.uint32(58).bytes(m.ECDSASecp256k1);
            if (m.delegatableContractId != null && Object.hasOwnProperty.call(m, "delegatableContractId"))
                $root.proto.ContractID.encode(m.delegatableContractId, w.uint32(66).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a Key message from the specified reader or buffer.
         * @function decode
         * @memberof proto.Key
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.Key} Key
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Key.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.Key();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.contractID = $root.proto.ContractID.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.ed25519 = r.bytes();
                        break;
                    }
                    case 3: {
                        m.RSA_3072 = r.bytes();
                        break;
                    }
                    case 4: {
                        m.ECDSA_384 = r.bytes();
                        break;
                    }
                    case 5: {
                        m.thresholdKey = $root.proto.ThresholdKey.decode(r, r.uint32());
                        break;
                    }
                    case 6: {
                        m.keyList = $root.proto.KeyList.decode(r, r.uint32());
                        break;
                    }
                    case 7: {
                        m.ECDSASecp256k1 = r.bytes();
                        break;
                    }
                    case 8: {
                        m.delegatableContractId = $root.proto.ContractID.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for Key
         * @function getTypeUrl
         * @memberof proto.Key
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Key.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.Key";
        };

        return Key;
    })();

    proto.ThresholdKey = (function () {
        /**
         * Properties of a ThresholdKey.
         * @memberof proto
         * @interface IThresholdKey
         * @property {number|null} [threshold] A valid signature set must have at least this many signatures
         * @property {proto.IKeyList|null} [keys] List of all the keys that can sign
         */

        /**
         * Constructs a new ThresholdKey.
         * @memberof proto
         * @classdesc A set of public keys that are used together to form a threshold signature.  If the threshold is N
         * and there are M keys, then this is an N of M threshold signature. If an account is associated
         * with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list
         * of M signatures, where at most M-N of them are blank, and the other at least N of them are valid
         * signatures corresponding to at least N of the public keys listed here.
         * @implements IThresholdKey
         * @constructor
         * @param {proto.IThresholdKey=} [p] Properties to set
         */
        function ThresholdKey(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * A valid signature set must have at least this many signatures
         * @member {number} threshold
         * @memberof proto.ThresholdKey
         * @instance
         */
        ThresholdKey.prototype.threshold = 0;

        /**
         * List of all the keys that can sign
         * @member {proto.IKeyList|null|undefined} keys
         * @memberof proto.ThresholdKey
         * @instance
         */
        ThresholdKey.prototype.keys = null;

        /**
         * Creates a new ThresholdKey instance using the specified properties.
         * @function create
         * @memberof proto.ThresholdKey
         * @static
         * @param {proto.IThresholdKey=} [properties] Properties to set
         * @returns {proto.ThresholdKey} ThresholdKey instance
         */
        ThresholdKey.create = function create(properties) {
            return new ThresholdKey(properties);
        };

        /**
         * Encodes the specified ThresholdKey message. Does not implicitly {@link proto.ThresholdKey.verify|verify} messages.
         * @function encode
         * @memberof proto.ThresholdKey
         * @static
         * @param {proto.IThresholdKey} m ThresholdKey message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ThresholdKey.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.threshold != null && Object.hasOwnProperty.call(m, "threshold")) w.uint32(8).uint32(m.threshold);
            if (m.keys != null && Object.hasOwnProperty.call(m, "keys"))
                $root.proto.KeyList.encode(m.keys, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a ThresholdKey message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ThresholdKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ThresholdKey} ThresholdKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ThresholdKey.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.ThresholdKey();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.threshold = r.uint32();
                        break;
                    }
                    case 2: {
                        m.keys = $root.proto.KeyList.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ThresholdKey
         * @function getTypeUrl
         * @memberof proto.ThresholdKey
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ThresholdKey.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ThresholdKey";
        };

        return ThresholdKey;
    })();

    proto.KeyList = (function () {
        /**
         * Properties of a KeyList.
         * @memberof proto
         * @interface IKeyList
         * @property {Array.<proto.IKey>|null} [keys] list of keys
         */

        /**
         * Constructs a new KeyList.
         * @memberof proto
         * @classdesc A list of keys that requires all keys (M-of-M) to sign unless otherwise specified in
         * documentation. A KeyList may contain repeated keys, but all repeated keys are only required to
         * sign once.
         * @implements IKeyList
         * @constructor
         * @param {proto.IKeyList=} [p] Properties to set
         */
        function KeyList(p) {
            this.keys = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * list of keys
         * @member {Array.<proto.IKey>} keys
         * @memberof proto.KeyList
         * @instance
         */
        KeyList.prototype.keys = $util.emptyArray;

        /**
         * Creates a new KeyList instance using the specified properties.
         * @function create
         * @memberof proto.KeyList
         * @static
         * @param {proto.IKeyList=} [properties] Properties to set
         * @returns {proto.KeyList} KeyList instance
         */
        KeyList.create = function create(properties) {
            return new KeyList(properties);
        };

        /**
         * Encodes the specified KeyList message. Does not implicitly {@link proto.KeyList.verify|verify} messages.
         * @function encode
         * @memberof proto.KeyList
         * @static
         * @param {proto.IKeyList} m KeyList message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KeyList.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.keys != null && m.keys.length) {
                for (var i = 0; i < m.keys.length; ++i) $root.proto.Key.encode(m.keys[i], w.uint32(10).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a KeyList message from the specified reader or buffer.
         * @function decode
         * @memberof proto.KeyList
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.KeyList} KeyList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KeyList.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.KeyList();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        if (!(m.keys && m.keys.length)) m.keys = [];
                        m.keys.push($root.proto.Key.decode(r, r.uint32()));
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for KeyList
         * @function getTypeUrl
         * @memberof proto.KeyList
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        KeyList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.KeyList";
        };

        return KeyList;
    })();

    proto.Signature = (function () {
        /**
         * Properties of a Signature.
         * @memberof proto
         * @interface ISignature
         * @property {Uint8Array|null} [contract] smart contract virtual signature (always length zero)
         * @property {Uint8Array|null} [ed25519] ed25519 signature bytes
         * @property {Uint8Array|null} [RSA_3072] RSA-3072 signature bytes
         * @property {Uint8Array|null} [ECDSA_384] ECDSA p-384 signature bytes
         * @property {proto.IThresholdSignature|null} [thresholdSignature] A list of signatures for a single N-of-M threshold Key. This must be a list of exactly M
         * signatures, at least N of which are non-null.
         * @property {proto.ISignatureList|null} [signatureList] A list of M signatures, each corresponding to a Key in a KeyList of the same length.
         */

        /**
         * Constructs a new Signature.
         * @memberof proto
         * @classdesc This message is <b>DEPRECATED</b> and <b>UNUSABLE</b> with network nodes. It is retained
         * here only for historical reasons.
         *
         * Please use the SignaturePair and SignatureMap messages.
         * @implements ISignature
         * @constructor
         * @param {proto.ISignature=} [p] Properties to set
         */
        function Signature(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * smart contract virtual signature (always length zero)
         * @member {Uint8Array|null|undefined} contract
         * @memberof proto.Signature
         * @instance
         */
        Signature.prototype.contract = null;

        /**
         * ed25519 signature bytes
         * @member {Uint8Array|null|undefined} ed25519
         * @memberof proto.Signature
         * @instance
         */
        Signature.prototype.ed25519 = null;

        /**
         * RSA-3072 signature bytes
         * @member {Uint8Array|null|undefined} RSA_3072
         * @memberof proto.Signature
         * @instance
         */
        Signature.prototype.RSA_3072 = null;

        /**
         * ECDSA p-384 signature bytes
         * @member {Uint8Array|null|undefined} ECDSA_384
         * @memberof proto.Signature
         * @instance
         */
        Signature.prototype.ECDSA_384 = null;

        /**
         * A list of signatures for a single N-of-M threshold Key. This must be a list of exactly M
         * signatures, at least N of which are non-null.
         * @member {proto.IThresholdSignature|null|undefined} thresholdSignature
         * @memberof proto.Signature
         * @instance
         */
        Signature.prototype.thresholdSignature = null;

        /**
         * A list of M signatures, each corresponding to a Key in a KeyList of the same length.
         * @member {proto.ISignatureList|null|undefined} signatureList
         * @memberof proto.Signature
         * @instance
         */
        Signature.prototype.signatureList = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * Signature signature.
         * @member {"contract"|"ed25519"|"RSA_3072"|"ECDSA_384"|"thresholdSignature"|"signatureList"|undefined} signature
         * @memberof proto.Signature
         * @instance
         */
        Object.defineProperty(Signature.prototype, "signature", {
            get: $util.oneOfGetter(
                ($oneOfFields = ["contract", "ed25519", "RSA_3072", "ECDSA_384", "thresholdSignature", "signatureList"])
            ),
            set: $util.oneOfSetter($oneOfFields),
        });

        /**
         * Creates a new Signature instance using the specified properties.
         * @function create
         * @memberof proto.Signature
         * @static
         * @param {proto.ISignature=} [properties] Properties to set
         * @returns {proto.Signature} Signature instance
         */
        Signature.create = function create(properties) {
            return new Signature(properties);
        };

        /**
         * Encodes the specified Signature message. Does not implicitly {@link proto.Signature.verify|verify} messages.
         * @function encode
         * @memberof proto.Signature
         * @static
         * @param {proto.ISignature} m Signature message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Signature.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.contract != null && Object.hasOwnProperty.call(m, "contract")) w.uint32(10).bytes(m.contract);
            if (m.ed25519 != null && Object.hasOwnProperty.call(m, "ed25519")) w.uint32(18).bytes(m.ed25519);
            if (m.RSA_3072 != null && Object.hasOwnProperty.call(m, "RSA_3072")) w.uint32(26).bytes(m.RSA_3072);
            if (m.ECDSA_384 != null && Object.hasOwnProperty.call(m, "ECDSA_384")) w.uint32(34).bytes(m.ECDSA_384);
            if (m.thresholdSignature != null && Object.hasOwnProperty.call(m, "thresholdSignature"))
                $root.proto.ThresholdSignature.encode(m.thresholdSignature, w.uint32(42).fork()).ldelim();
            if (m.signatureList != null && Object.hasOwnProperty.call(m, "signatureList"))
                $root.proto.SignatureList.encode(m.signatureList, w.uint32(50).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a Signature message from the specified reader or buffer.
         * @function decode
         * @memberof proto.Signature
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.Signature} Signature
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Signature.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.Signature();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.contract = r.bytes();
                        break;
                    }
                    case 2: {
                        m.ed25519 = r.bytes();
                        break;
                    }
                    case 3: {
                        m.RSA_3072 = r.bytes();
                        break;
                    }
                    case 4: {
                        m.ECDSA_384 = r.bytes();
                        break;
                    }
                    case 5: {
                        m.thresholdSignature = $root.proto.ThresholdSignature.decode(r, r.uint32());
                        break;
                    }
                    case 6: {
                        m.signatureList = $root.proto.SignatureList.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for Signature
         * @function getTypeUrl
         * @memberof proto.Signature
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Signature.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.Signature";
        };

        return Signature;
    })();

    proto.ThresholdSignature = (function () {
        /**
         * Properties of a ThresholdSignature.
         * @memberof proto
         * @interface IThresholdSignature
         * @property {proto.ISignatureList|null} [sigs] for an N-of-M threshold key, this is a list of M signatures, at least N of which must be
         * non-null
         */

        /**
         * Constructs a new ThresholdSignature.
         * @memberof proto
         * @classdesc This message is <b>DEPRECATED</b> and <b>UNUSABLE</b> with network nodes. It is retained
         * here only for historical reasons.
         *
         * Please use the SignaturePair and SignatureMap messages.
         * @implements IThresholdSignature
         * @constructor
         * @param {proto.IThresholdSignature=} [p] Properties to set
         */
        function ThresholdSignature(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * for an N-of-M threshold key, this is a list of M signatures, at least N of which must be
         * non-null
         * @member {proto.ISignatureList|null|undefined} sigs
         * @memberof proto.ThresholdSignature
         * @instance
         */
        ThresholdSignature.prototype.sigs = null;

        /**
         * Creates a new ThresholdSignature instance using the specified properties.
         * @function create
         * @memberof proto.ThresholdSignature
         * @static
         * @param {proto.IThresholdSignature=} [properties] Properties to set
         * @returns {proto.ThresholdSignature} ThresholdSignature instance
         */
        ThresholdSignature.create = function create(properties) {
            return new ThresholdSignature(properties);
        };

        /**
         * Encodes the specified ThresholdSignature message. Does not implicitly {@link proto.ThresholdSignature.verify|verify} messages.
         * @function encode
         * @memberof proto.ThresholdSignature
         * @static
         * @param {proto.IThresholdSignature} m ThresholdSignature message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ThresholdSignature.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.sigs != null && Object.hasOwnProperty.call(m, "sigs"))
                $root.proto.SignatureList.encode(m.sigs, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a ThresholdSignature message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ThresholdSignature
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ThresholdSignature} ThresholdSignature
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ThresholdSignature.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.ThresholdSignature();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 2: {
                        m.sigs = $root.proto.SignatureList.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ThresholdSignature
         * @function getTypeUrl
         * @memberof proto.ThresholdSignature
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ThresholdSignature.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ThresholdSignature";
        };

        return ThresholdSignature;
    })();

    proto.SignatureList = (function () {
        /**
         * Properties of a SignatureList.
         * @memberof proto
         * @interface ISignatureList
         * @property {Array.<proto.ISignature>|null} [sigs] each signature corresponds to a Key in the KeyList
         */

        /**
         * Constructs a new SignatureList.
         * @memberof proto
         * @classdesc This message is <b>DEPRECATED</b> and <b>UNUSABLE</b> with network nodes. It is retained
         * here only for historical reasons.
         *
         * Please use the SignaturePair and SignatureMap messages.
         * @implements ISignatureList
         * @constructor
         * @param {proto.ISignatureList=} [p] Properties to set
         */
        function SignatureList(p) {
            this.sigs = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * each signature corresponds to a Key in the KeyList
         * @member {Array.<proto.ISignature>} sigs
         * @memberof proto.SignatureList
         * @instance
         */
        SignatureList.prototype.sigs = $util.emptyArray;

        /**
         * Creates a new SignatureList instance using the specified properties.
         * @function create
         * @memberof proto.SignatureList
         * @static
         * @param {proto.ISignatureList=} [properties] Properties to set
         * @returns {proto.SignatureList} SignatureList instance
         */
        SignatureList.create = function create(properties) {
            return new SignatureList(properties);
        };

        /**
         * Encodes the specified SignatureList message. Does not implicitly {@link proto.SignatureList.verify|verify} messages.
         * @function encode
         * @memberof proto.SignatureList
         * @static
         * @param {proto.ISignatureList} m SignatureList message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignatureList.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.sigs != null && m.sigs.length) {
                for (var i = 0; i < m.sigs.length; ++i)
                    $root.proto.Signature.encode(m.sigs[i], w.uint32(18).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a SignatureList message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SignatureList
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.SignatureList} SignatureList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignatureList.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.SignatureList();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 2: {
                        if (!(m.sigs && m.sigs.length)) m.sigs = [];
                        m.sigs.push($root.proto.Signature.decode(r, r.uint32()));
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for SignatureList
         * @function getTypeUrl
         * @memberof proto.SignatureList
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SignatureList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.SignatureList";
        };

        return SignatureList;
    })();

    proto.SignaturePair = (function () {
        /**
         * Properties of a SignaturePair.
         * @memberof proto
         * @interface ISignaturePair
         * @property {Uint8Array|null} [pubKeyPrefix] First few bytes of the public key
         * @property {Uint8Array|null} [contract] smart contract virtual signature (always length zero)
         * @property {Uint8Array|null} [ed25519] ed25519 signature
         * @property {Uint8Array|null} [RSA_3072] RSA-3072 signature
         * @property {Uint8Array|null} [ECDSA_384] ECDSA p-384 signature
         * @property {Uint8Array|null} [ECDSASecp256k1] ECDSA(secp256k1) signature
         */

        /**
         * Constructs a new SignaturePair.
         * @memberof proto
         * @classdesc The client may use any number of bytes from zero to the whole length of the public key for
         * pubKeyPrefix. If zero bytes are used, then it must be that only one primitive key is required
         * to sign the linked transaction; it will surely resolve to <tt>INVALID_SIGNATURE</tt> otherwise.
         *
         * <b>IMPORTANT:</b> In the special case that a signature is being provided for a key used to
         * authorize a precompiled contract, the <tt>pubKeyPrefix</tt> must contain the <b>entire public
         * key</b>! That is, if the key is a Ed25519 key, the <tt>pubKeyPrefix</tt> should be 32 bytes
         * long. If the key is a ECDSA(secp256k1) key, the <tt>pubKeyPrefix</tt> should be 33 bytes long,
         * since we require the compressed form of the public key.
         *
         * Only Ed25519 and ECDSA(secp256k1) keys and hence signatures are currently supported.
         * @implements ISignaturePair
         * @constructor
         * @param {proto.ISignaturePair=} [p] Properties to set
         */
        function SignaturePair(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * First few bytes of the public key
         * @member {Uint8Array} pubKeyPrefix
         * @memberof proto.SignaturePair
         * @instance
         */
        SignaturePair.prototype.pubKeyPrefix = $util.newBuffer([]);

        /**
         * smart contract virtual signature (always length zero)
         * @member {Uint8Array|null|undefined} contract
         * @memberof proto.SignaturePair
         * @instance
         */
        SignaturePair.prototype.contract = null;

        /**
         * ed25519 signature
         * @member {Uint8Array|null|undefined} ed25519
         * @memberof proto.SignaturePair
         * @instance
         */
        SignaturePair.prototype.ed25519 = null;

        /**
         * RSA-3072 signature
         * @member {Uint8Array|null|undefined} RSA_3072
         * @memberof proto.SignaturePair
         * @instance
         */
        SignaturePair.prototype.RSA_3072 = null;

        /**
         * ECDSA p-384 signature
         * @member {Uint8Array|null|undefined} ECDSA_384
         * @memberof proto.SignaturePair
         * @instance
         */
        SignaturePair.prototype.ECDSA_384 = null;

        /**
         * ECDSA(secp256k1) signature
         * @member {Uint8Array|null|undefined} ECDSASecp256k1
         * @memberof proto.SignaturePair
         * @instance
         */
        SignaturePair.prototype.ECDSASecp256k1 = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * SignaturePair signature.
         * @member {"contract"|"ed25519"|"RSA_3072"|"ECDSA_384"|"ECDSASecp256k1"|undefined} signature
         * @memberof proto.SignaturePair
         * @instance
         */
        Object.defineProperty(SignaturePair.prototype, "signature", {
            get: $util.oneOfGetter(($oneOfFields = ["contract", "ed25519", "RSA_3072", "ECDSA_384", "ECDSASecp256k1"])),
            set: $util.oneOfSetter($oneOfFields),
        });

        /**
         * Creates a new SignaturePair instance using the specified properties.
         * @function create
         * @memberof proto.SignaturePair
         * @static
         * @param {proto.ISignaturePair=} [properties] Properties to set
         * @returns {proto.SignaturePair} SignaturePair instance
         */
        SignaturePair.create = function create(properties) {
            return new SignaturePair(properties);
        };

        /**
         * Encodes the specified SignaturePair message. Does not implicitly {@link proto.SignaturePair.verify|verify} messages.
         * @function encode
         * @memberof proto.SignaturePair
         * @static
         * @param {proto.ISignaturePair} m SignaturePair message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignaturePair.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.pubKeyPrefix != null && Object.hasOwnProperty.call(m, "pubKeyPrefix"))
                w.uint32(10).bytes(m.pubKeyPrefix);
            if (m.contract != null && Object.hasOwnProperty.call(m, "contract")) w.uint32(18).bytes(m.contract);
            if (m.ed25519 != null && Object.hasOwnProperty.call(m, "ed25519")) w.uint32(26).bytes(m.ed25519);
            if (m.RSA_3072 != null && Object.hasOwnProperty.call(m, "RSA_3072")) w.uint32(34).bytes(m.RSA_3072);
            if (m.ECDSA_384 != null && Object.hasOwnProperty.call(m, "ECDSA_384")) w.uint32(42).bytes(m.ECDSA_384);
            if (m.ECDSASecp256k1 != null && Object.hasOwnProperty.call(m, "ECDSASecp256k1"))
                w.uint32(50).bytes(m.ECDSASecp256k1);
            return w;
        };

        /**
         * Decodes a SignaturePair message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SignaturePair
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.SignaturePair} SignaturePair
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignaturePair.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.SignaturePair();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.pubKeyPrefix = r.bytes();
                        break;
                    }
                    case 2: {
                        m.contract = r.bytes();
                        break;
                    }
                    case 3: {
                        m.ed25519 = r.bytes();
                        break;
                    }
                    case 4: {
                        m.RSA_3072 = r.bytes();
                        break;
                    }
                    case 5: {
                        m.ECDSA_384 = r.bytes();
                        break;
                    }
                    case 6: {
                        m.ECDSASecp256k1 = r.bytes();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for SignaturePair
         * @function getTypeUrl
         * @memberof proto.SignaturePair
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SignaturePair.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.SignaturePair";
        };

        return SignaturePair;
    })();

    proto.SignatureMap = (function () {
        /**
         * Properties of a SignatureMap.
         * @memberof proto
         * @interface ISignatureMap
         * @property {Array.<proto.ISignaturePair>|null} [sigPair] Each signature pair corresponds to a unique Key required to sign the transaction.
         */

        /**
         * Constructs a new SignatureMap.
         * @memberof proto
         * @classdesc A set of signatures corresponding to every unique public key used to sign a given transaction. If
         * one public key matches more than one prefixes on the signature map, the transaction containing
         * the map will fail immediately with the response code KEY_PREFIX_MISMATCH.
         * @implements ISignatureMap
         * @constructor
         * @param {proto.ISignatureMap=} [p] Properties to set
         */
        function SignatureMap(p) {
            this.sigPair = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * Each signature pair corresponds to a unique Key required to sign the transaction.
         * @member {Array.<proto.ISignaturePair>} sigPair
         * @memberof proto.SignatureMap
         * @instance
         */
        SignatureMap.prototype.sigPair = $util.emptyArray;

        /**
         * Creates a new SignatureMap instance using the specified properties.
         * @function create
         * @memberof proto.SignatureMap
         * @static
         * @param {proto.ISignatureMap=} [properties] Properties to set
         * @returns {proto.SignatureMap} SignatureMap instance
         */
        SignatureMap.create = function create(properties) {
            return new SignatureMap(properties);
        };

        /**
         * Encodes the specified SignatureMap message. Does not implicitly {@link proto.SignatureMap.verify|verify} messages.
         * @function encode
         * @memberof proto.SignatureMap
         * @static
         * @param {proto.ISignatureMap} m SignatureMap message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignatureMap.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.sigPair != null && m.sigPair.length) {
                for (var i = 0; i < m.sigPair.length; ++i)
                    $root.proto.SignaturePair.encode(m.sigPair[i], w.uint32(10).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a SignatureMap message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SignatureMap
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.SignatureMap} SignatureMap
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignatureMap.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.SignatureMap();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        if (!(m.sigPair && m.sigPair.length)) m.sigPair = [];
                        m.sigPair.push($root.proto.SignaturePair.decode(r, r.uint32()));
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for SignatureMap
         * @function getTypeUrl
         * @memberof proto.SignatureMap
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SignatureMap.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.SignatureMap";
        };

        return SignatureMap;
    })();

    /**
     * The transactions and queries supported by Hedera Hashgraph.
     * @name proto.HederaFunctionality
     * @enum {number}
     * @property {number} NONE=0 UNSPECIFIED - Need to keep first value as unspecified because first element is ignored and
     * not parsed (0 is ignored by parser)
     * @property {number} CryptoTransfer=1 crypto transfer
     * @property {number} CryptoUpdate=2 crypto update account
     * @property {number} CryptoDelete=3 crypto delete account
     * @property {number} CryptoAddLiveHash=4 Add a livehash to a crypto account
     * @property {number} CryptoDeleteLiveHash=5 Delete a livehash from a crypto account
     * @property {number} ContractCall=6 Smart Contract Call
     * @property {number} ContractCreate=7 Smart Contract Create Contract
     * @property {number} ContractUpdate=8 Smart Contract update contract
     * @property {number} FileCreate=9 File Operation create file
     * @property {number} FileAppend=10 File Operation append file
     * @property {number} FileUpdate=11 File Operation update file
     * @property {number} FileDelete=12 File Operation delete file
     * @property {number} CryptoGetAccountBalance=13 crypto get account balance
     * @property {number} CryptoGetAccountRecords=14 crypto get account record
     * @property {number} CryptoGetInfo=15 Crypto get info
     * @property {number} ContractCallLocal=16 Smart Contract Call
     * @property {number} ContractGetInfo=17 Smart Contract get info
     * @property {number} ContractGetBytecode=18 Smart Contract, get the runtime code
     * @property {number} GetBySolidityID=19 Smart Contract, get by solidity ID
     * @property {number} GetByKey=20 Smart Contract, get by key
     * @property {number} CryptoGetLiveHash=21 Get a live hash from a crypto account
     * @property {number} CryptoGetStakers=22 Crypto, get the stakers for the node
     * @property {number} FileGetContents=23 File Operations get file contents
     * @property {number} FileGetInfo=24 File Operations get the info of the file
     * @property {number} TransactionGetRecord=25 Crypto get the transaction records
     * @property {number} ContractGetRecords=26 Contract get the transaction records
     * @property {number} CryptoCreate=27 crypto create account
     * @property {number} SystemDelete=28 system delete file
     * @property {number} SystemUndelete=29 system undelete file
     * @property {number} ContractDelete=30 delete contract
     * @property {number} Freeze=31 freeze
     * @property {number} CreateTransactionRecord=32 Create Tx Record
     * @property {number} CryptoAccountAutoRenew=33 Crypto Auto Renew
     * @property {number} ContractAutoRenew=34 Contract Auto Renew
     * @property {number} GetVersionInfo=35 Get Version
     * @property {number} TransactionGetReceipt=36 Transaction Get Receipt
     * @property {number} ConsensusCreateTopic=50 Create Topic
     * @property {number} ConsensusUpdateTopic=51 Update Topic
     * @property {number} ConsensusDeleteTopic=52 Delete Topic
     * @property {number} ConsensusGetTopicInfo=53 Get Topic information
     * @property {number} ConsensusSubmitMessage=54 Submit message to topic
     * @property {number} UncheckedSubmit=55 UncheckedSubmit value
     * @property {number} TokenCreate=56 Create Token
     * @property {number} TokenGetInfo=58 Get Token information
     * @property {number} TokenFreezeAccount=59 Freeze Account
     * @property {number} TokenUnfreezeAccount=60 Unfreeze Account
     * @property {number} TokenGrantKycToAccount=61 Grant KYC to Account
     * @property {number} TokenRevokeKycFromAccount=62 Revoke KYC from Account
     * @property {number} TokenDelete=63 Delete Token
     * @property {number} TokenUpdate=64 Update Token
     * @property {number} TokenMint=65 Mint tokens to treasury
     * @property {number} TokenBurn=66 Burn tokens from treasury
     * @property {number} TokenAccountWipe=67 Wipe token amount from Account holder
     * @property {number} TokenAssociateToAccount=68 Associate tokens to an account
     * @property {number} TokenDissociateFromAccount=69 Dissociate tokens from an account
     * @property {number} ScheduleCreate=70 Create Scheduled Transaction
     * @property {number} ScheduleDelete=71 Delete Scheduled Transaction
     * @property {number} ScheduleSign=72 Sign Scheduled Transaction
     * @property {number} ScheduleGetInfo=73 Get Scheduled Transaction Information
     * @property {number} TokenGetAccountNftInfos=74 Get Token Account Nft Information
     * @property {number} TokenGetNftInfo=75 Get Token Nft Information
     * @property {number} TokenGetNftInfos=76 Get Token Nft List Information
     * @property {number} TokenFeeScheduleUpdate=77 Update a token's custom fee schedule, if permissible
     * @property {number} NetworkGetExecutionTime=78 Get execution time(s) by TransactionID, if available
     * @property {number} TokenPause=79 Pause the Token
     * @property {number} TokenUnpause=80 Unpause the Token
     * @property {number} CryptoApproveAllowance=81 Approve allowance for a spender relative to the owner account
     * @property {number} CryptoDeleteAllowance=82 Deletes granted allowances on owner account
     * @property {number} GetAccountDetails=83 Gets all the information about an account, including balance and allowances. This does not get the list of
     * account records.
     * @property {number} EthereumTransaction=84 Ethereum Transaction
     * @property {number} NodeStakeUpdate=85 Updates the staking info at the end of staking period to indicate new staking period has started.
     * @property {number} UtilPrng=86 Generates a pseudorandom number.
     */
    proto.HederaFunctionality = (function () {
        const valuesById = {},
            values = Object.create(valuesById);
        values[(valuesById[0] = "NONE")] = 0;
        values[(valuesById[1] = "CryptoTransfer")] = 1;
        values[(valuesById[2] = "CryptoUpdate")] = 2;
        values[(valuesById[3] = "CryptoDelete")] = 3;
        values[(valuesById[4] = "CryptoAddLiveHash")] = 4;
        values[(valuesById[5] = "CryptoDeleteLiveHash")] = 5;
        values[(valuesById[6] = "ContractCall")] = 6;
        values[(valuesById[7] = "ContractCreate")] = 7;
        values[(valuesById[8] = "ContractUpdate")] = 8;
        values[(valuesById[9] = "FileCreate")] = 9;
        values[(valuesById[10] = "FileAppend")] = 10;
        values[(valuesById[11] = "FileUpdate")] = 11;
        values[(valuesById[12] = "FileDelete")] = 12;
        values[(valuesById[13] = "CryptoGetAccountBalance")] = 13;
        values[(valuesById[14] = "CryptoGetAccountRecords")] = 14;
        values[(valuesById[15] = "CryptoGetInfo")] = 15;
        values[(valuesById[16] = "ContractCallLocal")] = 16;
        values[(valuesById[17] = "ContractGetInfo")] = 17;
        values[(valuesById[18] = "ContractGetBytecode")] = 18;
        values[(valuesById[19] = "GetBySolidityID")] = 19;
        values[(valuesById[20] = "GetByKey")] = 20;
        values[(valuesById[21] = "CryptoGetLiveHash")] = 21;
        values[(valuesById[22] = "CryptoGetStakers")] = 22;
        values[(valuesById[23] = "FileGetContents")] = 23;
        values[(valuesById[24] = "FileGetInfo")] = 24;
        values[(valuesById[25] = "TransactionGetRecord")] = 25;
        values[(valuesById[26] = "ContractGetRecords")] = 26;
        values[(valuesById[27] = "CryptoCreate")] = 27;
        values[(valuesById[28] = "SystemDelete")] = 28;
        values[(valuesById[29] = "SystemUndelete")] = 29;
        values[(valuesById[30] = "ContractDelete")] = 30;
        values[(valuesById[31] = "Freeze")] = 31;
        values[(valuesById[32] = "CreateTransactionRecord")] = 32;
        values[(valuesById[33] = "CryptoAccountAutoRenew")] = 33;
        values[(valuesById[34] = "ContractAutoRenew")] = 34;
        values[(valuesById[35] = "GetVersionInfo")] = 35;
        values[(valuesById[36] = "TransactionGetReceipt")] = 36;
        values[(valuesById[50] = "ConsensusCreateTopic")] = 50;
        values[(valuesById[51] = "ConsensusUpdateTopic")] = 51;
        values[(valuesById[52] = "ConsensusDeleteTopic")] = 52;
        values[(valuesById[53] = "ConsensusGetTopicInfo")] = 53;
        values[(valuesById[54] = "ConsensusSubmitMessage")] = 54;
        values[(valuesById[55] = "UncheckedSubmit")] = 55;
        values[(valuesById[56] = "TokenCreate")] = 56;
        values[(valuesById[58] = "TokenGetInfo")] = 58;
        values[(valuesById[59] = "TokenFreezeAccount")] = 59;
        values[(valuesById[60] = "TokenUnfreezeAccount")] = 60;
        values[(valuesById[61] = "TokenGrantKycToAccount")] = 61;
        values[(valuesById[62] = "TokenRevokeKycFromAccount")] = 62;
        values[(valuesById[63] = "TokenDelete")] = 63;
        values[(valuesById[64] = "TokenUpdate")] = 64;
        values[(valuesById[65] = "TokenMint")] = 65;
        values[(valuesById[66] = "TokenBurn")] = 66;
        values[(valuesById[67] = "TokenAccountWipe")] = 67;
        values[(valuesById[68] = "TokenAssociateToAccount")] = 68;
        values[(valuesById[69] = "TokenDissociateFromAccount")] = 69;
        values[(valuesById[70] = "ScheduleCreate")] = 70;
        values[(valuesById[71] = "ScheduleDelete")] = 71;
        values[(valuesById[72] = "ScheduleSign")] = 72;
        values[(valuesById[73] = "ScheduleGetInfo")] = 73;
        values[(valuesById[74] = "TokenGetAccountNftInfos")] = 74;
        values[(valuesById[75] = "TokenGetNftInfo")] = 75;
        values[(valuesById[76] = "TokenGetNftInfos")] = 76;
        values[(valuesById[77] = "TokenFeeScheduleUpdate")] = 77;
        values[(valuesById[78] = "NetworkGetExecutionTime")] = 78;
        values[(valuesById[79] = "TokenPause")] = 79;
        values[(valuesById[80] = "TokenUnpause")] = 80;
        values[(valuesById[81] = "CryptoApproveAllowance")] = 81;
        values[(valuesById[82] = "CryptoDeleteAllowance")] = 82;
        values[(valuesById[83] = "GetAccountDetails")] = 83;
        values[(valuesById[84] = "EthereumTransaction")] = 84;
        values[(valuesById[85] = "NodeStakeUpdate")] = 85;
        values[(valuesById[86] = "UtilPrng")] = 86;
        return values;
    })();

    proto.FeeComponents = (function () {
        /**
         * Properties of a FeeComponents.
         * @memberof proto
         * @interface IFeeComponents
         * @property {Long|null} [min] A minimum, the calculated fee must be greater than this value
         * @property {Long|null} [max] A maximum, the calculated fee must be less than this value
         * @property {Long|null} [constant] A constant contribution to the fee
         * @property {Long|null} [bpt] The price of bandwidth consumed by a transaction, measured in bytes
         * @property {Long|null} [vpt] The price per signature verification for a transaction
         * @property {Long|null} [rbh] The price of RAM consumed by a transaction, measured in byte-hours
         * @property {Long|null} [sbh] The price of storage consumed by a transaction, measured in byte-hours
         * @property {Long|null} [gas] The price of computation for a smart contract transaction, measured in gas
         * @property {Long|null} [tv] The price per hbar transferred for a transfer
         * @property {Long|null} [bpr] The price of bandwidth for data retrieved from memory for a response, measured in bytes
         * @property {Long|null} [sbpr] The price of bandwidth for data retrieved from disk for a response, measured in bytes
         */

        /**
         * Constructs a new FeeComponents.
         * @memberof proto
         * @classdesc A set of prices the nodes use in determining transaction and query fees, and constants involved
         * in fee calculations.  Nodes multiply the amount of resources consumed by a transaction or query
         * by the corresponding price to calculate the appropriate fee. Units are one-thousandth of a
         * tinyCent.
         * @implements IFeeComponents
         * @constructor
         * @param {proto.IFeeComponents=} [p] Properties to set
         */
        function FeeComponents(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * A minimum, the calculated fee must be greater than this value
         * @member {Long} min
         * @memberof proto.FeeComponents
         * @instance
         */
        FeeComponents.prototype.min = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * A maximum, the calculated fee must be less than this value
         * @member {Long} max
         * @memberof proto.FeeComponents
         * @instance
         */
        FeeComponents.prototype.max = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * A constant contribution to the fee
         * @member {Long} constant
         * @memberof proto.FeeComponents
         * @instance
         */
        FeeComponents.prototype.constant = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * The price of bandwidth consumed by a transaction, measured in bytes
         * @member {Long} bpt
         * @memberof proto.FeeComponents
         * @instance
         */
        FeeComponents.prototype.bpt = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * The price per signature verification for a transaction
         * @member {Long} vpt
         * @memberof proto.FeeComponents
         * @instance
         */
        FeeComponents.prototype.vpt = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * The price of RAM consumed by a transaction, measured in byte-hours
         * @member {Long} rbh
         * @memberof proto.FeeComponents
         * @instance
         */
        FeeComponents.prototype.rbh = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * The price of storage consumed by a transaction, measured in byte-hours
         * @member {Long} sbh
         * @memberof proto.FeeComponents
         * @instance
         */
        FeeComponents.prototype.sbh = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * The price of computation for a smart contract transaction, measured in gas
         * @member {Long} gas
         * @memberof proto.FeeComponents
         * @instance
         */
        FeeComponents.prototype.gas = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * The price per hbar transferred for a transfer
         * @member {Long} tv
         * @memberof proto.FeeComponents
         * @instance
         */
        FeeComponents.prototype.tv = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * The price of bandwidth for data retrieved from memory for a response, measured in bytes
         * @member {Long} bpr
         * @memberof proto.FeeComponents
         * @instance
         */
        FeeComponents.prototype.bpr = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * The price of bandwidth for data retrieved from disk for a response, measured in bytes
         * @member {Long} sbpr
         * @memberof proto.FeeComponents
         * @instance
         */
        FeeComponents.prototype.sbpr = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * Creates a new FeeComponents instance using the specified properties.
         * @function create
         * @memberof proto.FeeComponents
         * @static
         * @param {proto.IFeeComponents=} [properties] Properties to set
         * @returns {proto.FeeComponents} FeeComponents instance
         */
        FeeComponents.create = function create(properties) {
            return new FeeComponents(properties);
        };

        /**
         * Encodes the specified FeeComponents message. Does not implicitly {@link proto.FeeComponents.verify|verify} messages.
         * @function encode
         * @memberof proto.FeeComponents
         * @static
         * @param {proto.IFeeComponents} m FeeComponents message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeeComponents.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.min != null && Object.hasOwnProperty.call(m, "min")) w.uint32(8).int64(m.min);
            if (m.max != null && Object.hasOwnProperty.call(m, "max")) w.uint32(16).int64(m.max);
            if (m.constant != null && Object.hasOwnProperty.call(m, "constant")) w.uint32(24).int64(m.constant);
            if (m.bpt != null && Object.hasOwnProperty.call(m, "bpt")) w.uint32(32).int64(m.bpt);
            if (m.vpt != null && Object.hasOwnProperty.call(m, "vpt")) w.uint32(40).int64(m.vpt);
            if (m.rbh != null && Object.hasOwnProperty.call(m, "rbh")) w.uint32(48).int64(m.rbh);
            if (m.sbh != null && Object.hasOwnProperty.call(m, "sbh")) w.uint32(56).int64(m.sbh);
            if (m.gas != null && Object.hasOwnProperty.call(m, "gas")) w.uint32(64).int64(m.gas);
            if (m.tv != null && Object.hasOwnProperty.call(m, "tv")) w.uint32(72).int64(m.tv);
            if (m.bpr != null && Object.hasOwnProperty.call(m, "bpr")) w.uint32(80).int64(m.bpr);
            if (m.sbpr != null && Object.hasOwnProperty.call(m, "sbpr")) w.uint32(88).int64(m.sbpr);
            return w;
        };

        /**
         * Decodes a FeeComponents message from the specified reader or buffer.
         * @function decode
         * @memberof proto.FeeComponents
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.FeeComponents} FeeComponents
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeeComponents.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.FeeComponents();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.min = r.int64();
                        break;
                    }
                    case 2: {
                        m.max = r.int64();
                        break;
                    }
                    case 3: {
                        m.constant = r.int64();
                        break;
                    }
                    case 4: {
                        m.bpt = r.int64();
                        break;
                    }
                    case 5: {
                        m.vpt = r.int64();
                        break;
                    }
                    case 6: {
                        m.rbh = r.int64();
                        break;
                    }
                    case 7: {
                        m.sbh = r.int64();
                        break;
                    }
                    case 8: {
                        m.gas = r.int64();
                        break;
                    }
                    case 9: {
                        m.tv = r.int64();
                        break;
                    }
                    case 10: {
                        m.bpr = r.int64();
                        break;
                    }
                    case 11: {
                        m.sbpr = r.int64();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for FeeComponents
         * @function getTypeUrl
         * @memberof proto.FeeComponents
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        FeeComponents.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.FeeComponents";
        };

        return FeeComponents;
    })();

    proto.TransactionFeeSchedule = (function () {
        /**
         * Properties of a TransactionFeeSchedule.
         * @memberof proto
         * @interface ITransactionFeeSchedule
         * @property {proto.HederaFunctionality|null} [hederaFunctionality] A particular transaction or query
         * @property {proto.IFeeData|null} [feeData] Resource price coefficients
         * @property {Array.<proto.IFeeData>|null} [fees] Resource price coefficients. Supports subtype price definition.
         */

        /**
         * Constructs a new TransactionFeeSchedule.
         * @memberof proto
         * @classdesc The fees for a specific transaction or query based on the fee data.
         * @implements ITransactionFeeSchedule
         * @constructor
         * @param {proto.ITransactionFeeSchedule=} [p] Properties to set
         */
        function TransactionFeeSchedule(p) {
            this.fees = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * A particular transaction or query
         * @member {proto.HederaFunctionality} hederaFunctionality
         * @memberof proto.TransactionFeeSchedule
         * @instance
         */
        TransactionFeeSchedule.prototype.hederaFunctionality = 0;

        /**
         * Resource price coefficients
         * @member {proto.IFeeData|null|undefined} feeData
         * @memberof proto.TransactionFeeSchedule
         * @instance
         */
        TransactionFeeSchedule.prototype.feeData = null;

        /**
         * Resource price coefficients. Supports subtype price definition.
         * @member {Array.<proto.IFeeData>} fees
         * @memberof proto.TransactionFeeSchedule
         * @instance
         */
        TransactionFeeSchedule.prototype.fees = $util.emptyArray;

        /**
         * Creates a new TransactionFeeSchedule instance using the specified properties.
         * @function create
         * @memberof proto.TransactionFeeSchedule
         * @static
         * @param {proto.ITransactionFeeSchedule=} [properties] Properties to set
         * @returns {proto.TransactionFeeSchedule} TransactionFeeSchedule instance
         */
        TransactionFeeSchedule.create = function create(properties) {
            return new TransactionFeeSchedule(properties);
        };

        /**
         * Encodes the specified TransactionFeeSchedule message. Does not implicitly {@link proto.TransactionFeeSchedule.verify|verify} messages.
         * @function encode
         * @memberof proto.TransactionFeeSchedule
         * @static
         * @param {proto.ITransactionFeeSchedule} m TransactionFeeSchedule message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionFeeSchedule.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.hederaFunctionality != null && Object.hasOwnProperty.call(m, "hederaFunctionality"))
                w.uint32(8).int32(m.hederaFunctionality);
            if (m.feeData != null && Object.hasOwnProperty.call(m, "feeData"))
                $root.proto.FeeData.encode(m.feeData, w.uint32(18).fork()).ldelim();
            if (m.fees != null && m.fees.length) {
                for (var i = 0; i < m.fees.length; ++i)
                    $root.proto.FeeData.encode(m.fees[i], w.uint32(26).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a TransactionFeeSchedule message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TransactionFeeSchedule
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TransactionFeeSchedule} TransactionFeeSchedule
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionFeeSchedule.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.TransactionFeeSchedule();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.hederaFunctionality = r.int32();
                        break;
                    }
                    case 2: {
                        m.feeData = $root.proto.FeeData.decode(r, r.uint32());
                        break;
                    }
                    case 3: {
                        if (!(m.fees && m.fees.length)) m.fees = [];
                        m.fees.push($root.proto.FeeData.decode(r, r.uint32()));
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TransactionFeeSchedule
         * @function getTypeUrl
         * @memberof proto.TransactionFeeSchedule
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TransactionFeeSchedule.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TransactionFeeSchedule";
        };

        return TransactionFeeSchedule;
    })();

    proto.FeeData = (function () {
        /**
         * Properties of a FeeData.
         * @memberof proto
         * @interface IFeeData
         * @property {proto.IFeeComponents|null} [nodedata] Fee paid to the submitting node
         * @property {proto.IFeeComponents|null} [networkdata] Fee paid to the network for processing a transaction into consensus
         * @property {proto.IFeeComponents|null} [servicedata] Fee paid to the network for providing the service associated with the
         * transaction; for instance, storing a file
         * @property {proto.SubType|null} [subType] SubType distinguishing between different types of FeeData, correlating
         * to the same HederaFunctionality
         */

        /**
         * Constructs a new FeeData.
         * @memberof proto
         * @classdesc The total fee charged for a transaction. It is composed of three components – a node fee that
         * compensates the specific node that submitted the transaction, a network fee that compensates the
         * network for assigning the transaction a consensus timestamp, and a service fee that compensates
         * the network for the ongoing maintenance of the consequences of the transaction.
         * @implements IFeeData
         * @constructor
         * @param {proto.IFeeData=} [p] Properties to set
         */
        function FeeData(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * Fee paid to the submitting node
         * @member {proto.IFeeComponents|null|undefined} nodedata
         * @memberof proto.FeeData
         * @instance
         */
        FeeData.prototype.nodedata = null;

        /**
         * Fee paid to the network for processing a transaction into consensus
         * @member {proto.IFeeComponents|null|undefined} networkdata
         * @memberof proto.FeeData
         * @instance
         */
        FeeData.prototype.networkdata = null;

        /**
         * Fee paid to the network for providing the service associated with the
         * transaction; for instance, storing a file
         * @member {proto.IFeeComponents|null|undefined} servicedata
         * @memberof proto.FeeData
         * @instance
         */
        FeeData.prototype.servicedata = null;

        /**
         * SubType distinguishing between different types of FeeData, correlating
         * to the same HederaFunctionality
         * @member {proto.SubType} subType
         * @memberof proto.FeeData
         * @instance
         */
        FeeData.prototype.subType = 0;

        /**
         * Creates a new FeeData instance using the specified properties.
         * @function create
         * @memberof proto.FeeData
         * @static
         * @param {proto.IFeeData=} [properties] Properties to set
         * @returns {proto.FeeData} FeeData instance
         */
        FeeData.create = function create(properties) {
            return new FeeData(properties);
        };

        /**
         * Encodes the specified FeeData message. Does not implicitly {@link proto.FeeData.verify|verify} messages.
         * @function encode
         * @memberof proto.FeeData
         * @static
         * @param {proto.IFeeData} m FeeData message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeeData.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.nodedata != null && Object.hasOwnProperty.call(m, "nodedata"))
                $root.proto.FeeComponents.encode(m.nodedata, w.uint32(10).fork()).ldelim();
            if (m.networkdata != null && Object.hasOwnProperty.call(m, "networkdata"))
                $root.proto.FeeComponents.encode(m.networkdata, w.uint32(18).fork()).ldelim();
            if (m.servicedata != null && Object.hasOwnProperty.call(m, "servicedata"))
                $root.proto.FeeComponents.encode(m.servicedata, w.uint32(26).fork()).ldelim();
            if (m.subType != null && Object.hasOwnProperty.call(m, "subType")) w.uint32(32).int32(m.subType);
            return w;
        };

        /**
         * Decodes a FeeData message from the specified reader or buffer.
         * @function decode
         * @memberof proto.FeeData
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.FeeData} FeeData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeeData.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.FeeData();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.nodedata = $root.proto.FeeComponents.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.networkdata = $root.proto.FeeComponents.decode(r, r.uint32());
                        break;
                    }
                    case 3: {
                        m.servicedata = $root.proto.FeeComponents.decode(r, r.uint32());
                        break;
                    }
                    case 4: {
                        m.subType = r.int32();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for FeeData
         * @function getTypeUrl
         * @memberof proto.FeeData
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        FeeData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.FeeData";
        };

        return FeeData;
    })();

    proto.FeeSchedule = (function () {
        /**
         * Properties of a FeeSchedule.
         * @memberof proto
         * @interface IFeeSchedule
         * @property {Array.<proto.ITransactionFeeSchedule>|null} [transactionFeeSchedule] List of price coefficients for network resources
         * @property {proto.ITimestampSeconds|null} [expiryTime] FeeSchedule expiry time
         */

        /**
         * Constructs a new FeeSchedule.
         * @memberof proto
         * @classdesc A list of resource prices fee for different transactions and queries and the time period at which
         * this fee schedule will expire. Nodes use the prices to determine the fees for all transactions
         * based on how much of those resources each transaction uses.
         * @implements IFeeSchedule
         * @constructor
         * @param {proto.IFeeSchedule=} [p] Properties to set
         */
        function FeeSchedule(p) {
            this.transactionFeeSchedule = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * List of price coefficients for network resources
         * @member {Array.<proto.ITransactionFeeSchedule>} transactionFeeSchedule
         * @memberof proto.FeeSchedule
         * @instance
         */
        FeeSchedule.prototype.transactionFeeSchedule = $util.emptyArray;

        /**
         * FeeSchedule expiry time
         * @member {proto.ITimestampSeconds|null|undefined} expiryTime
         * @memberof proto.FeeSchedule
         * @instance
         */
        FeeSchedule.prototype.expiryTime = null;

        /**
         * Creates a new FeeSchedule instance using the specified properties.
         * @function create
         * @memberof proto.FeeSchedule
         * @static
         * @param {proto.IFeeSchedule=} [properties] Properties to set
         * @returns {proto.FeeSchedule} FeeSchedule instance
         */
        FeeSchedule.create = function create(properties) {
            return new FeeSchedule(properties);
        };

        /**
         * Encodes the specified FeeSchedule message. Does not implicitly {@link proto.FeeSchedule.verify|verify} messages.
         * @function encode
         * @memberof proto.FeeSchedule
         * @static
         * @param {proto.IFeeSchedule} m FeeSchedule message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeeSchedule.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.transactionFeeSchedule != null && m.transactionFeeSchedule.length) {
                for (var i = 0; i < m.transactionFeeSchedule.length; ++i)
                    $root.proto.TransactionFeeSchedule.encode(
                        m.transactionFeeSchedule[i],
                        w.uint32(10).fork()
                    ).ldelim();
            }
            if (m.expiryTime != null && Object.hasOwnProperty.call(m, "expiryTime"))
                $root.proto.TimestampSeconds.encode(m.expiryTime, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a FeeSchedule message from the specified reader or buffer.
         * @function decode
         * @memberof proto.FeeSchedule
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.FeeSchedule} FeeSchedule
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeeSchedule.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.FeeSchedule();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        if (!(m.transactionFeeSchedule && m.transactionFeeSchedule.length))
                            m.transactionFeeSchedule = [];
                        m.transactionFeeSchedule.push($root.proto.TransactionFeeSchedule.decode(r, r.uint32()));
                        break;
                    }
                    case 2: {
                        m.expiryTime = $root.proto.TimestampSeconds.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for FeeSchedule
         * @function getTypeUrl
         * @memberof proto.FeeSchedule
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        FeeSchedule.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.FeeSchedule";
        };

        return FeeSchedule;
    })();

    proto.CurrentAndNextFeeSchedule = (function () {
        /**
         * Properties of a CurrentAndNextFeeSchedule.
         * @memberof proto
         * @interface ICurrentAndNextFeeSchedule
         * @property {proto.IFeeSchedule|null} [currentFeeSchedule] Contains current Fee Schedule
         * @property {proto.IFeeSchedule|null} [nextFeeSchedule] Contains next Fee Schedule
         */

        /**
         * Constructs a new CurrentAndNextFeeSchedule.
         * @memberof proto
         * @classdesc This contains two Fee Schedules with expiry timestamp.
         * @implements ICurrentAndNextFeeSchedule
         * @constructor
         * @param {proto.ICurrentAndNextFeeSchedule=} [p] Properties to set
         */
        function CurrentAndNextFeeSchedule(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * Contains current Fee Schedule
         * @member {proto.IFeeSchedule|null|undefined} currentFeeSchedule
         * @memberof proto.CurrentAndNextFeeSchedule
         * @instance
         */
        CurrentAndNextFeeSchedule.prototype.currentFeeSchedule = null;

        /**
         * Contains next Fee Schedule
         * @member {proto.IFeeSchedule|null|undefined} nextFeeSchedule
         * @memberof proto.CurrentAndNextFeeSchedule
         * @instance
         */
        CurrentAndNextFeeSchedule.prototype.nextFeeSchedule = null;

        /**
         * Creates a new CurrentAndNextFeeSchedule instance using the specified properties.
         * @function create
         * @memberof proto.CurrentAndNextFeeSchedule
         * @static
         * @param {proto.ICurrentAndNextFeeSchedule=} [properties] Properties to set
         * @returns {proto.CurrentAndNextFeeSchedule} CurrentAndNextFeeSchedule instance
         */
        CurrentAndNextFeeSchedule.create = function create(properties) {
            return new CurrentAndNextFeeSchedule(properties);
        };

        /**
         * Encodes the specified CurrentAndNextFeeSchedule message. Does not implicitly {@link proto.CurrentAndNextFeeSchedule.verify|verify} messages.
         * @function encode
         * @memberof proto.CurrentAndNextFeeSchedule
         * @static
         * @param {proto.ICurrentAndNextFeeSchedule} m CurrentAndNextFeeSchedule message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CurrentAndNextFeeSchedule.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.currentFeeSchedule != null && Object.hasOwnProperty.call(m, "currentFeeSchedule"))
                $root.proto.FeeSchedule.encode(m.currentFeeSchedule, w.uint32(10).fork()).ldelim();
            if (m.nextFeeSchedule != null && Object.hasOwnProperty.call(m, "nextFeeSchedule"))
                $root.proto.FeeSchedule.encode(m.nextFeeSchedule, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a CurrentAndNextFeeSchedule message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CurrentAndNextFeeSchedule
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.CurrentAndNextFeeSchedule} CurrentAndNextFeeSchedule
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CurrentAndNextFeeSchedule.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.CurrentAndNextFeeSchedule();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.currentFeeSchedule = $root.proto.FeeSchedule.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.nextFeeSchedule = $root.proto.FeeSchedule.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for CurrentAndNextFeeSchedule
         * @function getTypeUrl
         * @memberof proto.CurrentAndNextFeeSchedule
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CurrentAndNextFeeSchedule.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.CurrentAndNextFeeSchedule";
        };

        return CurrentAndNextFeeSchedule;
    })();

    proto.ServiceEndpoint = (function () {
        /**
         * Properties of a ServiceEndpoint.
         * @memberof proto
         * @interface IServiceEndpoint
         * @property {Uint8Array|null} [ipAddressV4] The 32-bit IPv4 address of the node encoded in left to right order (e.g.  127.0.0.1 has 127
         * as its first byte)
         * @property {number|null} [port] The port of the node
         */

        /**
         * Constructs a new ServiceEndpoint.
         * @memberof proto
         * @classdesc Contains the IP address and the port representing a service endpoint of a Node in a network. Used
         * to reach the Hedera API and submit transactions to the network.
         * @implements IServiceEndpoint
         * @constructor
         * @param {proto.IServiceEndpoint=} [p] Properties to set
         */
        function ServiceEndpoint(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The 32-bit IPv4 address of the node encoded in left to right order (e.g.  127.0.0.1 has 127
         * as its first byte)
         * @member {Uint8Array} ipAddressV4
         * @memberof proto.ServiceEndpoint
         * @instance
         */
        ServiceEndpoint.prototype.ipAddressV4 = $util.newBuffer([]);

        /**
         * The port of the node
         * @member {number} port
         * @memberof proto.ServiceEndpoint
         * @instance
         */
        ServiceEndpoint.prototype.port = 0;

        /**
         * Creates a new ServiceEndpoint instance using the specified properties.
         * @function create
         * @memberof proto.ServiceEndpoint
         * @static
         * @param {proto.IServiceEndpoint=} [properties] Properties to set
         * @returns {proto.ServiceEndpoint} ServiceEndpoint instance
         */
        ServiceEndpoint.create = function create(properties) {
            return new ServiceEndpoint(properties);
        };

        /**
         * Encodes the specified ServiceEndpoint message. Does not implicitly {@link proto.ServiceEndpoint.verify|verify} messages.
         * @function encode
         * @memberof proto.ServiceEndpoint
         * @static
         * @param {proto.IServiceEndpoint} m ServiceEndpoint message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServiceEndpoint.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.ipAddressV4 != null && Object.hasOwnProperty.call(m, "ipAddressV4"))
                w.uint32(10).bytes(m.ipAddressV4);
            if (m.port != null && Object.hasOwnProperty.call(m, "port")) w.uint32(16).int32(m.port);
            return w;
        };

        /**
         * Decodes a ServiceEndpoint message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ServiceEndpoint
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ServiceEndpoint} ServiceEndpoint
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServiceEndpoint.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.ServiceEndpoint();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.ipAddressV4 = r.bytes();
                        break;
                    }
                    case 2: {
                        m.port = r.int32();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ServiceEndpoint
         * @function getTypeUrl
         * @memberof proto.ServiceEndpoint
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ServiceEndpoint.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ServiceEndpoint";
        };

        return ServiceEndpoint;
    })();

    proto.NodeAddress = (function () {
        /**
         * Properties of a NodeAddress.
         * @memberof proto
         * @interface INodeAddress
         * @property {Uint8Array|null} [ipAddress] The IP address of the Node with separator & octets encoded in UTF-8.  Usage is deprecated,
         * ServiceEndpoint is preferred to retrieve a node's list of IP addresses and ports
         * @property {number|null} [portno] The port number of the grpc server for the node.  Usage is deprecated, ServiceEndpoint is
         * preferred to retrieve a node's list of IP addresses and ports
         * @property {Uint8Array|null} [memo] Usage is deprecated, nodeAccountId is preferred to retrieve a node's account ID
         * @property {string|null} [RSA_PubKey] The node's X509 RSA public key used to sign stream files (e.g., record stream
         * files). Precisely, this field is a string of hexadecimal characters which,
         * translated to binary, are the public key's DER encoding.
         * @property {Long|null} [nodeId] # A non-sequential identifier for the node
         * @property {proto.IAccountID|null} [nodeAccountId] # The account to be paid for queries and transactions sent to this node
         * @property {Uint8Array|null} [nodeCertHash] # Hash of the node's TLS certificate. Precisely, this field is a string of
         * hexadecimal characters which, translated to binary, are the SHA-384 hash of
         * the UTF-8 NFKD encoding of the node's TLS cert in PEM format. Its value can be
         * used to verify the node's certificate it presents during TLS negotiations.
         * @property {Array.<proto.IServiceEndpoint>|null} [serviceEndpoint] # A node's service IP addresses and ports
         * @property {string|null} [description] A description of the node, with UTF-8 encoding up to 100 bytes
         * @property {Long|null} [stake] [Deprecated] The amount of tinybars staked to the node
         */

        /**
         * Constructs a new NodeAddress.
         * @memberof proto
         * @classdesc The data about a node, including its service endpoints and the Hedera account to be paid for
         * services provided by the node (that is, queries answered and transactions submitted.)
         *
         * If the <tt>serviceEndpoint</tt> list is not set, or empty, then the endpoint given by the
         * (deprecated) <tt>ipAddress</tt> and <tt>portno</tt> fields should be used.
         *
         * All fields are populated in the 0.0.102 address book file while only fields that start with # are
         * populated in the 0.0.101 address book file.
         * @implements INodeAddress
         * @constructor
         * @param {proto.INodeAddress=} [p] Properties to set
         */
        function NodeAddress(p) {
            this.serviceEndpoint = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The IP address of the Node with separator & octets encoded in UTF-8.  Usage is deprecated,
         * ServiceEndpoint is preferred to retrieve a node's list of IP addresses and ports
         * @member {Uint8Array} ipAddress
         * @memberof proto.NodeAddress
         * @instance
         */
        NodeAddress.prototype.ipAddress = $util.newBuffer([]);

        /**
         * The port number of the grpc server for the node.  Usage is deprecated, ServiceEndpoint is
         * preferred to retrieve a node's list of IP addresses and ports
         * @member {number} portno
         * @memberof proto.NodeAddress
         * @instance
         */
        NodeAddress.prototype.portno = 0;

        /**
         * Usage is deprecated, nodeAccountId is preferred to retrieve a node's account ID
         * @member {Uint8Array} memo
         * @memberof proto.NodeAddress
         * @instance
         */
        NodeAddress.prototype.memo = $util.newBuffer([]);

        /**
         * The node's X509 RSA public key used to sign stream files (e.g., record stream
         * files). Precisely, this field is a string of hexadecimal characters which,
         * translated to binary, are the public key's DER encoding.
         * @member {string} RSA_PubKey
         * @memberof proto.NodeAddress
         * @instance
         */
        NodeAddress.prototype.RSA_PubKey = "";

        /**
         * # A non-sequential identifier for the node
         * @member {Long} nodeId
         * @memberof proto.NodeAddress
         * @instance
         */
        NodeAddress.prototype.nodeId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * # The account to be paid for queries and transactions sent to this node
         * @member {proto.IAccountID|null|undefined} nodeAccountId
         * @memberof proto.NodeAddress
         * @instance
         */
        NodeAddress.prototype.nodeAccountId = null;

        /**
         * # Hash of the node's TLS certificate. Precisely, this field is a string of
         * hexadecimal characters which, translated to binary, are the SHA-384 hash of
         * the UTF-8 NFKD encoding of the node's TLS cert in PEM format. Its value can be
         * used to verify the node's certificate it presents during TLS negotiations.
         * @member {Uint8Array} nodeCertHash
         * @memberof proto.NodeAddress
         * @instance
         */
        NodeAddress.prototype.nodeCertHash = $util.newBuffer([]);

        /**
         * # A node's service IP addresses and ports
         * @member {Array.<proto.IServiceEndpoint>} serviceEndpoint
         * @memberof proto.NodeAddress
         * @instance
         */
        NodeAddress.prototype.serviceEndpoint = $util.emptyArray;

        /**
         * A description of the node, with UTF-8 encoding up to 100 bytes
         * @member {string} description
         * @memberof proto.NodeAddress
         * @instance
         */
        NodeAddress.prototype.description = "";

        /**
         * [Deprecated] The amount of tinybars staked to the node
         * @member {Long} stake
         * @memberof proto.NodeAddress
         * @instance
         */
        NodeAddress.prototype.stake = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * Creates a new NodeAddress instance using the specified properties.
         * @function create
         * @memberof proto.NodeAddress
         * @static
         * @param {proto.INodeAddress=} [properties] Properties to set
         * @returns {proto.NodeAddress} NodeAddress instance
         */
        NodeAddress.create = function create(properties) {
            return new NodeAddress(properties);
        };

        /**
         * Encodes the specified NodeAddress message. Does not implicitly {@link proto.NodeAddress.verify|verify} messages.
         * @function encode
         * @memberof proto.NodeAddress
         * @static
         * @param {proto.INodeAddress} m NodeAddress message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeAddress.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.ipAddress != null && Object.hasOwnProperty.call(m, "ipAddress")) w.uint32(10).bytes(m.ipAddress);
            if (m.portno != null && Object.hasOwnProperty.call(m, "portno")) w.uint32(16).int32(m.portno);
            if (m.memo != null && Object.hasOwnProperty.call(m, "memo")) w.uint32(26).bytes(m.memo);
            if (m.RSA_PubKey != null && Object.hasOwnProperty.call(m, "RSA_PubKey")) w.uint32(34).string(m.RSA_PubKey);
            if (m.nodeId != null && Object.hasOwnProperty.call(m, "nodeId")) w.uint32(40).int64(m.nodeId);
            if (m.nodeAccountId != null && Object.hasOwnProperty.call(m, "nodeAccountId"))
                $root.proto.AccountID.encode(m.nodeAccountId, w.uint32(50).fork()).ldelim();
            if (m.nodeCertHash != null && Object.hasOwnProperty.call(m, "nodeCertHash"))
                w.uint32(58).bytes(m.nodeCertHash);
            if (m.serviceEndpoint != null && m.serviceEndpoint.length) {
                for (var i = 0; i < m.serviceEndpoint.length; ++i)
                    $root.proto.ServiceEndpoint.encode(m.serviceEndpoint[i], w.uint32(66).fork()).ldelim();
            }
            if (m.description != null && Object.hasOwnProperty.call(m, "description"))
                w.uint32(74).string(m.description);
            if (m.stake != null && Object.hasOwnProperty.call(m, "stake")) w.uint32(80).int64(m.stake);
            return w;
        };

        /**
         * Decodes a NodeAddress message from the specified reader or buffer.
         * @function decode
         * @memberof proto.NodeAddress
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.NodeAddress} NodeAddress
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeAddress.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.NodeAddress();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.ipAddress = r.bytes();
                        break;
                    }
                    case 2: {
                        m.portno = r.int32();
                        break;
                    }
                    case 3: {
                        m.memo = r.bytes();
                        break;
                    }
                    case 4: {
                        m.RSA_PubKey = r.string();
                        break;
                    }
                    case 5: {
                        m.nodeId = r.int64();
                        break;
                    }
                    case 6: {
                        m.nodeAccountId = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    case 7: {
                        m.nodeCertHash = r.bytes();
                        break;
                    }
                    case 8: {
                        if (!(m.serviceEndpoint && m.serviceEndpoint.length)) m.serviceEndpoint = [];
                        m.serviceEndpoint.push($root.proto.ServiceEndpoint.decode(r, r.uint32()));
                        break;
                    }
                    case 9: {
                        m.description = r.string();
                        break;
                    }
                    case 10: {
                        m.stake = r.int64();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for NodeAddress
         * @function getTypeUrl
         * @memberof proto.NodeAddress
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        NodeAddress.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.NodeAddress";
        };

        return NodeAddress;
    })();

    proto.NodeAddressBook = (function () {
        /**
         * Properties of a NodeAddressBook.
         * @memberof proto
         * @interface INodeAddressBook
         * @property {Array.<proto.INodeAddress>|null} [nodeAddress] Metadata of all nodes in the network
         */

        /**
         * Constructs a new NodeAddressBook.
         * @memberof proto
         * @classdesc A list of nodes and their metadata that contains all details of the nodes for the network.  Used
         * to parse the contents of system files <tt>0.0.101</tt> and <tt>0.0.102</tt>.
         * @implements INodeAddressBook
         * @constructor
         * @param {proto.INodeAddressBook=} [p] Properties to set
         */
        function NodeAddressBook(p) {
            this.nodeAddress = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * Metadata of all nodes in the network
         * @member {Array.<proto.INodeAddress>} nodeAddress
         * @memberof proto.NodeAddressBook
         * @instance
         */
        NodeAddressBook.prototype.nodeAddress = $util.emptyArray;

        /**
         * Creates a new NodeAddressBook instance using the specified properties.
         * @function create
         * @memberof proto.NodeAddressBook
         * @static
         * @param {proto.INodeAddressBook=} [properties] Properties to set
         * @returns {proto.NodeAddressBook} NodeAddressBook instance
         */
        NodeAddressBook.create = function create(properties) {
            return new NodeAddressBook(properties);
        };

        /**
         * Encodes the specified NodeAddressBook message. Does not implicitly {@link proto.NodeAddressBook.verify|verify} messages.
         * @function encode
         * @memberof proto.NodeAddressBook
         * @static
         * @param {proto.INodeAddressBook} m NodeAddressBook message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeAddressBook.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.nodeAddress != null && m.nodeAddress.length) {
                for (var i = 0; i < m.nodeAddress.length; ++i)
                    $root.proto.NodeAddress.encode(m.nodeAddress[i], w.uint32(10).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a NodeAddressBook message from the specified reader or buffer.
         * @function decode
         * @memberof proto.NodeAddressBook
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.NodeAddressBook} NodeAddressBook
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeAddressBook.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.NodeAddressBook();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        if (!(m.nodeAddress && m.nodeAddress.length)) m.nodeAddress = [];
                        m.nodeAddress.push($root.proto.NodeAddress.decode(r, r.uint32()));
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for NodeAddressBook
         * @function getTypeUrl
         * @memberof proto.NodeAddressBook
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        NodeAddressBook.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.NodeAddressBook";
        };

        return NodeAddressBook;
    })();

    proto.SemanticVersion = (function () {
        /**
         * Properties of a SemanticVersion.
         * @memberof proto
         * @interface ISemanticVersion
         * @property {number|null} [major] Increases with incompatible API changes
         * @property {number|null} [minor] Increases with backwards-compatible new functionality
         * @property {number|null} [patch] Increases with backwards-compatible bug fixes
         * @property {string|null} [pre] A pre-release version MAY be denoted by appending a hyphen and a series of dot separated
         * identifiers (https://semver.org/#spec-item-9); so given a semver 0.14.0-alpha.1+21AF26D3,
         * this field would contain 'alpha.1'
         * @property {string|null} [build] Build metadata MAY be denoted by appending a plus sign and a series of dot separated
         * identifiers immediately following the patch or pre-release version
         * (https://semver.org/#spec-item-10); so given a semver 0.14.0-alpha.1+21AF26D3, this field
         * would contain '21AF26D3'
         */

        /**
         * Constructs a new SemanticVersion.
         * @memberof proto
         * @classdesc Hedera follows semantic versioning (https://semver.org/) for both the HAPI protobufs and the
         * Services software.  This type allows the <tt>getVersionInfo</tt> query in the
         * <tt>NetworkService</tt> to return the deployed versions of both protobufs and software on the
         * node answering the query.
         * @implements ISemanticVersion
         * @constructor
         * @param {proto.ISemanticVersion=} [p] Properties to set
         */
        function SemanticVersion(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * Increases with incompatible API changes
         * @member {number} major
         * @memberof proto.SemanticVersion
         * @instance
         */
        SemanticVersion.prototype.major = 0;

        /**
         * Increases with backwards-compatible new functionality
         * @member {number} minor
         * @memberof proto.SemanticVersion
         * @instance
         */
        SemanticVersion.prototype.minor = 0;

        /**
         * Increases with backwards-compatible bug fixes
         * @member {number} patch
         * @memberof proto.SemanticVersion
         * @instance
         */
        SemanticVersion.prototype.patch = 0;

        /**
         * A pre-release version MAY be denoted by appending a hyphen and a series of dot separated
         * identifiers (https://semver.org/#spec-item-9); so given a semver 0.14.0-alpha.1+21AF26D3,
         * this field would contain 'alpha.1'
         * @member {string} pre
         * @memberof proto.SemanticVersion
         * @instance
         */
        SemanticVersion.prototype.pre = "";

        /**
         * Build metadata MAY be denoted by appending a plus sign and a series of dot separated
         * identifiers immediately following the patch or pre-release version
         * (https://semver.org/#spec-item-10); so given a semver 0.14.0-alpha.1+21AF26D3, this field
         * would contain '21AF26D3'
         * @member {string} build
         * @memberof proto.SemanticVersion
         * @instance
         */
        SemanticVersion.prototype.build = "";

        /**
         * Creates a new SemanticVersion instance using the specified properties.
         * @function create
         * @memberof proto.SemanticVersion
         * @static
         * @param {proto.ISemanticVersion=} [properties] Properties to set
         * @returns {proto.SemanticVersion} SemanticVersion instance
         */
        SemanticVersion.create = function create(properties) {
            return new SemanticVersion(properties);
        };

        /**
         * Encodes the specified SemanticVersion message. Does not implicitly {@link proto.SemanticVersion.verify|verify} messages.
         * @function encode
         * @memberof proto.SemanticVersion
         * @static
         * @param {proto.ISemanticVersion} m SemanticVersion message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SemanticVersion.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.major != null && Object.hasOwnProperty.call(m, "major")) w.uint32(8).int32(m.major);
            if (m.minor != null && Object.hasOwnProperty.call(m, "minor")) w.uint32(16).int32(m.minor);
            if (m.patch != null && Object.hasOwnProperty.call(m, "patch")) w.uint32(24).int32(m.patch);
            if (m.pre != null && Object.hasOwnProperty.call(m, "pre")) w.uint32(34).string(m.pre);
            if (m.build != null && Object.hasOwnProperty.call(m, "build")) w.uint32(42).string(m.build);
            return w;
        };

        /**
         * Decodes a SemanticVersion message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SemanticVersion
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.SemanticVersion} SemanticVersion
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SemanticVersion.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.SemanticVersion();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.major = r.int32();
                        break;
                    }
                    case 2: {
                        m.minor = r.int32();
                        break;
                    }
                    case 3: {
                        m.patch = r.int32();
                        break;
                    }
                    case 4: {
                        m.pre = r.string();
                        break;
                    }
                    case 5: {
                        m.build = r.string();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for SemanticVersion
         * @function getTypeUrl
         * @memberof proto.SemanticVersion
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SemanticVersion.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.SemanticVersion";
        };

        return SemanticVersion;
    })();

    proto.Setting = (function () {
        /**
         * Properties of a Setting.
         * @memberof proto
         * @interface ISetting
         * @property {string|null} [name] name of the property
         * @property {string|null} [value] value of the property
         * @property {Uint8Array|null} [data] any data associated with property
         */

        /**
         * Constructs a new Setting.
         * @memberof proto
         * @classdesc UNDOCUMENTED
         * @implements ISetting
         * @constructor
         * @param {proto.ISetting=} [p] Properties to set
         */
        function Setting(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * name of the property
         * @member {string} name
         * @memberof proto.Setting
         * @instance
         */
        Setting.prototype.name = "";

        /**
         * value of the property
         * @member {string} value
         * @memberof proto.Setting
         * @instance
         */
        Setting.prototype.value = "";

        /**
         * any data associated with property
         * @member {Uint8Array} data
         * @memberof proto.Setting
         * @instance
         */
        Setting.prototype.data = $util.newBuffer([]);

        /**
         * Creates a new Setting instance using the specified properties.
         * @function create
         * @memberof proto.Setting
         * @static
         * @param {proto.ISetting=} [properties] Properties to set
         * @returns {proto.Setting} Setting instance
         */
        Setting.create = function create(properties) {
            return new Setting(properties);
        };

        /**
         * Encodes the specified Setting message. Does not implicitly {@link proto.Setting.verify|verify} messages.
         * @function encode
         * @memberof proto.Setting
         * @static
         * @param {proto.ISetting} m Setting message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Setting.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.name != null && Object.hasOwnProperty.call(m, "name")) w.uint32(10).string(m.name);
            if (m.value != null && Object.hasOwnProperty.call(m, "value")) w.uint32(18).string(m.value);
            if (m.data != null && Object.hasOwnProperty.call(m, "data")) w.uint32(26).bytes(m.data);
            return w;
        };

        /**
         * Decodes a Setting message from the specified reader or buffer.
         * @function decode
         * @memberof proto.Setting
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.Setting} Setting
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Setting.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.Setting();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.name = r.string();
                        break;
                    }
                    case 2: {
                        m.value = r.string();
                        break;
                    }
                    case 3: {
                        m.data = r.bytes();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for Setting
         * @function getTypeUrl
         * @memberof proto.Setting
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Setting.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.Setting";
        };

        return Setting;
    })();

    proto.ServicesConfigurationList = (function () {
        /**
         * Properties of a ServicesConfigurationList.
         * @memberof proto
         * @interface IServicesConfigurationList
         * @property {Array.<proto.ISetting>|null} [nameValue] list of name value pairs of the application properties
         */

        /**
         * Constructs a new ServicesConfigurationList.
         * @memberof proto
         * @classdesc UNDOCUMENTED
         * @implements IServicesConfigurationList
         * @constructor
         * @param {proto.IServicesConfigurationList=} [p] Properties to set
         */
        function ServicesConfigurationList(p) {
            this.nameValue = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * list of name value pairs of the application properties
         * @member {Array.<proto.ISetting>} nameValue
         * @memberof proto.ServicesConfigurationList
         * @instance
         */
        ServicesConfigurationList.prototype.nameValue = $util.emptyArray;

        /**
         * Creates a new ServicesConfigurationList instance using the specified properties.
         * @function create
         * @memberof proto.ServicesConfigurationList
         * @static
         * @param {proto.IServicesConfigurationList=} [properties] Properties to set
         * @returns {proto.ServicesConfigurationList} ServicesConfigurationList instance
         */
        ServicesConfigurationList.create = function create(properties) {
            return new ServicesConfigurationList(properties);
        };

        /**
         * Encodes the specified ServicesConfigurationList message. Does not implicitly {@link proto.ServicesConfigurationList.verify|verify} messages.
         * @function encode
         * @memberof proto.ServicesConfigurationList
         * @static
         * @param {proto.IServicesConfigurationList} m ServicesConfigurationList message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServicesConfigurationList.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.nameValue != null && m.nameValue.length) {
                for (var i = 0; i < m.nameValue.length; ++i)
                    $root.proto.Setting.encode(m.nameValue[i], w.uint32(10).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a ServicesConfigurationList message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ServicesConfigurationList
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ServicesConfigurationList} ServicesConfigurationList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServicesConfigurationList.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.ServicesConfigurationList();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        if (!(m.nameValue && m.nameValue.length)) m.nameValue = [];
                        m.nameValue.push($root.proto.Setting.decode(r, r.uint32()));
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ServicesConfigurationList
         * @function getTypeUrl
         * @memberof proto.ServicesConfigurationList
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ServicesConfigurationList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ServicesConfigurationList";
        };

        return ServicesConfigurationList;
    })();

    proto.TokenRelationship = (function () {
        /**
         * Properties of a TokenRelationship.
         * @memberof proto
         * @interface ITokenRelationship
         * @property {proto.ITokenID|null} [tokenId] The ID of the token
         * @property {string|null} [symbol] The Symbol of the token
         * @property {Long|null} [balance] For token of type FUNGIBLE_COMMON - the balance that the Account holds in the smallest
         * denomination. For token of type NON_FUNGIBLE_UNIQUE - the number of NFTs held by the account
         * @property {proto.TokenKycStatus|null} [kycStatus] The KYC status of the account (KycNotApplicable, Granted or Revoked). If the token does not
         * have KYC key, KycNotApplicable is returned
         * @property {proto.TokenFreezeStatus|null} [freezeStatus] The Freeze status of the account (FreezeNotApplicable, Frozen or Unfrozen). If the token does
         * not have Freeze key, FreezeNotApplicable is returned
         * @property {number|null} [decimals] Tokens divide into <tt>10<sup>decimals</sup></tt> pieces
         * @property {boolean|null} [automaticAssociation] Specifies if the relationship is created implicitly. False : explicitly associated, True :
         * implicitly associated.
         */

        /**
         * Constructs a new TokenRelationship.
         * @memberof proto
         * @classdesc Token's information related to the given Account
         * @implements ITokenRelationship
         * @constructor
         * @param {proto.ITokenRelationship=} [p] Properties to set
         */
        function TokenRelationship(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The ID of the token
         * @member {proto.ITokenID|null|undefined} tokenId
         * @memberof proto.TokenRelationship
         * @instance
         */
        TokenRelationship.prototype.tokenId = null;

        /**
         * The Symbol of the token
         * @member {string} symbol
         * @memberof proto.TokenRelationship
         * @instance
         */
        TokenRelationship.prototype.symbol = "";

        /**
         * For token of type FUNGIBLE_COMMON - the balance that the Account holds in the smallest
         * denomination. For token of type NON_FUNGIBLE_UNIQUE - the number of NFTs held by the account
         * @member {Long} balance
         * @memberof proto.TokenRelationship
         * @instance
         */
        TokenRelationship.prototype.balance = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * The KYC status of the account (KycNotApplicable, Granted or Revoked). If the token does not
         * have KYC key, KycNotApplicable is returned
         * @member {proto.TokenKycStatus} kycStatus
         * @memberof proto.TokenRelationship
         * @instance
         */
        TokenRelationship.prototype.kycStatus = 0;

        /**
         * The Freeze status of the account (FreezeNotApplicable, Frozen or Unfrozen). If the token does
         * not have Freeze key, FreezeNotApplicable is returned
         * @member {proto.TokenFreezeStatus} freezeStatus
         * @memberof proto.TokenRelationship
         * @instance
         */
        TokenRelationship.prototype.freezeStatus = 0;

        /**
         * Tokens divide into <tt>10<sup>decimals</sup></tt> pieces
         * @member {number} decimals
         * @memberof proto.TokenRelationship
         * @instance
         */
        TokenRelationship.prototype.decimals = 0;

        /**
         * Specifies if the relationship is created implicitly. False : explicitly associated, True :
         * implicitly associated.
         * @member {boolean} automaticAssociation
         * @memberof proto.TokenRelationship
         * @instance
         */
        TokenRelationship.prototype.automaticAssociation = false;

        /**
         * Creates a new TokenRelationship instance using the specified properties.
         * @function create
         * @memberof proto.TokenRelationship
         * @static
         * @param {proto.ITokenRelationship=} [properties] Properties to set
         * @returns {proto.TokenRelationship} TokenRelationship instance
         */
        TokenRelationship.create = function create(properties) {
            return new TokenRelationship(properties);
        };

        /**
         * Encodes the specified TokenRelationship message. Does not implicitly {@link proto.TokenRelationship.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenRelationship
         * @static
         * @param {proto.ITokenRelationship} m TokenRelationship message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenRelationship.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.tokenId != null && Object.hasOwnProperty.call(m, "tokenId"))
                $root.proto.TokenID.encode(m.tokenId, w.uint32(10).fork()).ldelim();
            if (m.symbol != null && Object.hasOwnProperty.call(m, "symbol")) w.uint32(18).string(m.symbol);
            if (m.balance != null && Object.hasOwnProperty.call(m, "balance")) w.uint32(24).uint64(m.balance);
            if (m.kycStatus != null && Object.hasOwnProperty.call(m, "kycStatus")) w.uint32(32).int32(m.kycStatus);
            if (m.freezeStatus != null && Object.hasOwnProperty.call(m, "freezeStatus"))
                w.uint32(40).int32(m.freezeStatus);
            if (m.decimals != null && Object.hasOwnProperty.call(m, "decimals")) w.uint32(48).uint32(m.decimals);
            if (m.automaticAssociation != null && Object.hasOwnProperty.call(m, "automaticAssociation"))
                w.uint32(56).bool(m.automaticAssociation);
            return w;
        };

        /**
         * Decodes a TokenRelationship message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenRelationship
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenRelationship} TokenRelationship
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenRelationship.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.TokenRelationship();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.tokenId = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.symbol = r.string();
                        break;
                    }
                    case 3: {
                        m.balance = r.uint64();
                        break;
                    }
                    case 4: {
                        m.kycStatus = r.int32();
                        break;
                    }
                    case 5: {
                        m.freezeStatus = r.int32();
                        break;
                    }
                    case 6: {
                        m.decimals = r.uint32();
                        break;
                    }
                    case 7: {
                        m.automaticAssociation = r.bool();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenRelationship
         * @function getTypeUrl
         * @memberof proto.TokenRelationship
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenRelationship.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenRelationship";
        };

        return TokenRelationship;
    })();

    proto.TokenBalance = (function () {
        /**
         * Properties of a TokenBalance.
         * @memberof proto
         * @interface ITokenBalance
         * @property {proto.ITokenID|null} [tokenId] A unique token id
         * @property {Long|null} [balance] Number of transferable units of the identified token. For token of type FUNGIBLE_COMMON -
         * balance in the smallest denomination. For token of type NON_FUNGIBLE_UNIQUE - the number of
         * NFTs held by the account
         * @property {number|null} [decimals] Tokens divide into <tt>10<sup>decimals</sup></tt> pieces
         */

        /**
         * Constructs a new TokenBalance.
         * @memberof proto
         * @classdesc A number of <i>transferable units</i> of a certain token.
         *
         * The transferable unit of a token is its smallest denomination, as given by the token's
         * <tt>decimals</tt> property---each minted token contains <tt>10<sup>decimals</sup></tt>
         * transferable units. For example, we could think of the cent as the transferable unit of the US
         * dollar (<tt>decimals=2</tt>); and the tinybar as the transferable unit of hbar
         * (<tt>decimals=8</tt>).
         *
         * Transferable units are not directly comparable across different tokens.
         * @implements ITokenBalance
         * @constructor
         * @param {proto.ITokenBalance=} [p] Properties to set
         */
        function TokenBalance(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * A unique token id
         * @member {proto.ITokenID|null|undefined} tokenId
         * @memberof proto.TokenBalance
         * @instance
         */
        TokenBalance.prototype.tokenId = null;

        /**
         * Number of transferable units of the identified token. For token of type FUNGIBLE_COMMON -
         * balance in the smallest denomination. For token of type NON_FUNGIBLE_UNIQUE - the number of
         * NFTs held by the account
         * @member {Long} balance
         * @memberof proto.TokenBalance
         * @instance
         */
        TokenBalance.prototype.balance = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * Tokens divide into <tt>10<sup>decimals</sup></tt> pieces
         * @member {number} decimals
         * @memberof proto.TokenBalance
         * @instance
         */
        TokenBalance.prototype.decimals = 0;

        /**
         * Creates a new TokenBalance instance using the specified properties.
         * @function create
         * @memberof proto.TokenBalance
         * @static
         * @param {proto.ITokenBalance=} [properties] Properties to set
         * @returns {proto.TokenBalance} TokenBalance instance
         */
        TokenBalance.create = function create(properties) {
            return new TokenBalance(properties);
        };

        /**
         * Encodes the specified TokenBalance message. Does not implicitly {@link proto.TokenBalance.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenBalance
         * @static
         * @param {proto.ITokenBalance} m TokenBalance message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenBalance.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.tokenId != null && Object.hasOwnProperty.call(m, "tokenId"))
                $root.proto.TokenID.encode(m.tokenId, w.uint32(10).fork()).ldelim();
            if (m.balance != null && Object.hasOwnProperty.call(m, "balance")) w.uint32(16).uint64(m.balance);
            if (m.decimals != null && Object.hasOwnProperty.call(m, "decimals")) w.uint32(24).uint32(m.decimals);
            return w;
        };

        /**
         * Decodes a TokenBalance message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenBalance
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenBalance} TokenBalance
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenBalance.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.TokenBalance();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.tokenId = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.balance = r.uint64();
                        break;
                    }
                    case 3: {
                        m.decimals = r.uint32();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenBalance
         * @function getTypeUrl
         * @memberof proto.TokenBalance
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenBalance.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenBalance";
        };

        return TokenBalance;
    })();

    proto.TokenBalances = (function () {
        /**
         * Properties of a TokenBalances.
         * @memberof proto
         * @interface ITokenBalances
         * @property {Array.<proto.ITokenBalance>|null} [tokenBalances] TokenBalances tokenBalances
         */

        /**
         * Constructs a new TokenBalances.
         * @memberof proto
         * @classdesc A sequence of token balances
         * @implements ITokenBalances
         * @constructor
         * @param {proto.ITokenBalances=} [p] Properties to set
         */
        function TokenBalances(p) {
            this.tokenBalances = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * TokenBalances tokenBalances.
         * @member {Array.<proto.ITokenBalance>} tokenBalances
         * @memberof proto.TokenBalances
         * @instance
         */
        TokenBalances.prototype.tokenBalances = $util.emptyArray;

        /**
         * Creates a new TokenBalances instance using the specified properties.
         * @function create
         * @memberof proto.TokenBalances
         * @static
         * @param {proto.ITokenBalances=} [properties] Properties to set
         * @returns {proto.TokenBalances} TokenBalances instance
         */
        TokenBalances.create = function create(properties) {
            return new TokenBalances(properties);
        };

        /**
         * Encodes the specified TokenBalances message. Does not implicitly {@link proto.TokenBalances.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenBalances
         * @static
         * @param {proto.ITokenBalances} m TokenBalances message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenBalances.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.tokenBalances != null && m.tokenBalances.length) {
                for (var i = 0; i < m.tokenBalances.length; ++i)
                    $root.proto.TokenBalance.encode(m.tokenBalances[i], w.uint32(10).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a TokenBalances message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenBalances
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenBalances} TokenBalances
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenBalances.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.TokenBalances();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        if (!(m.tokenBalances && m.tokenBalances.length)) m.tokenBalances = [];
                        m.tokenBalances.push($root.proto.TokenBalance.decode(r, r.uint32()));
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenBalances
         * @function getTypeUrl
         * @memberof proto.TokenBalances
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenBalances.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenBalances";
        };

        return TokenBalances;
    })();

    proto.TokenAssociation = (function () {
        /**
         * Properties of a TokenAssociation.
         * @memberof proto
         * @interface ITokenAssociation
         * @property {proto.ITokenID|null} [tokenId] TokenAssociation tokenId
         * @property {proto.IAccountID|null} [accountId] TokenAssociation accountId
         */

        /**
         * Constructs a new TokenAssociation.
         * @memberof proto
         * @classdesc Represents a TokenAssociation.
         * @implements ITokenAssociation
         * @constructor
         * @param {proto.ITokenAssociation=} [p] Properties to set
         */
        function TokenAssociation(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * TokenAssociation tokenId.
         * @member {proto.ITokenID|null|undefined} tokenId
         * @memberof proto.TokenAssociation
         * @instance
         */
        TokenAssociation.prototype.tokenId = null;

        /**
         * TokenAssociation accountId.
         * @member {proto.IAccountID|null|undefined} accountId
         * @memberof proto.TokenAssociation
         * @instance
         */
        TokenAssociation.prototype.accountId = null;

        /**
         * Creates a new TokenAssociation instance using the specified properties.
         * @function create
         * @memberof proto.TokenAssociation
         * @static
         * @param {proto.ITokenAssociation=} [properties] Properties to set
         * @returns {proto.TokenAssociation} TokenAssociation instance
         */
        TokenAssociation.create = function create(properties) {
            return new TokenAssociation(properties);
        };

        /**
         * Encodes the specified TokenAssociation message. Does not implicitly {@link proto.TokenAssociation.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenAssociation
         * @static
         * @param {proto.ITokenAssociation} m TokenAssociation message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenAssociation.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.tokenId != null && Object.hasOwnProperty.call(m, "tokenId"))
                $root.proto.TokenID.encode(m.tokenId, w.uint32(10).fork()).ldelim();
            if (m.accountId != null && Object.hasOwnProperty.call(m, "accountId"))
                $root.proto.AccountID.encode(m.accountId, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a TokenAssociation message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenAssociation
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenAssociation} TokenAssociation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenAssociation.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.TokenAssociation();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.tokenId = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.accountId = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenAssociation
         * @function getTypeUrl
         * @memberof proto.TokenAssociation
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenAssociation.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenAssociation";
        };

        return TokenAssociation;
    })();

    proto.StakingInfo = (function () {
        /**
         * Properties of a StakingInfo.
         * @memberof proto
         * @interface IStakingInfo
         * @property {boolean|null} [declineReward] If true, this account or contract declined to receive a staking reward.
         * @property {proto.ITimestamp|null} [stakePeriodStart] The staking period during which either the staking settings for this account or contract changed (such as starting
         * staking or changing staked_node_id) or the most recent reward was earned, whichever is later. If this account or contract
         * is not currently staked to a node, then this field is not set.
         * @property {Long|null} [pendingReward] The amount in tinybars that will be received in the next reward situation.
         * @property {Long|null} [stakedToMe] The total of balance of all accounts staked to this account or contract.
         * @property {proto.IAccountID|null} [stakedAccountId] The account to which this account or contract is staking.
         * @property {Long|null} [stakedNodeId] The ID of the node this account or contract is staked to.
         */

        /**
         * Constructs a new StakingInfo.
         * @memberof proto
         * @classdesc Staking metadata for an account or a contract returned in CryptoGetInfo or ContractGetInfo queries
         * @implements IStakingInfo
         * @constructor
         * @param {proto.IStakingInfo=} [p] Properties to set
         */
        function StakingInfo(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * If true, this account or contract declined to receive a staking reward.
         * @member {boolean} declineReward
         * @memberof proto.StakingInfo
         * @instance
         */
        StakingInfo.prototype.declineReward = false;

        /**
         * The staking period during which either the staking settings for this account or contract changed (such as starting
         * staking or changing staked_node_id) or the most recent reward was earned, whichever is later. If this account or contract
         * is not currently staked to a node, then this field is not set.
         * @member {proto.ITimestamp|null|undefined} stakePeriodStart
         * @memberof proto.StakingInfo
         * @instance
         */
        StakingInfo.prototype.stakePeriodStart = null;

        /**
         * The amount in tinybars that will be received in the next reward situation.
         * @member {Long} pendingReward
         * @memberof proto.StakingInfo
         * @instance
         */
        StakingInfo.prototype.pendingReward = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * The total of balance of all accounts staked to this account or contract.
         * @member {Long} stakedToMe
         * @memberof proto.StakingInfo
         * @instance
         */
        StakingInfo.prototype.stakedToMe = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * The account to which this account or contract is staking.
         * @member {proto.IAccountID|null|undefined} stakedAccountId
         * @memberof proto.StakingInfo
         * @instance
         */
        StakingInfo.prototype.stakedAccountId = null;

        /**
         * The ID of the node this account or contract is staked to.
         * @member {Long|null|undefined} stakedNodeId
         * @memberof proto.StakingInfo
         * @instance
         */
        StakingInfo.prototype.stakedNodeId = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * ID of the account or node to which this account or contract is staking.
         * @member {"stakedAccountId"|"stakedNodeId"|undefined} stakedId
         * @memberof proto.StakingInfo
         * @instance
         */
        Object.defineProperty(StakingInfo.prototype, "stakedId", {
            get: $util.oneOfGetter(($oneOfFields = ["stakedAccountId", "stakedNodeId"])),
            set: $util.oneOfSetter($oneOfFields),
        });

        /**
         * Creates a new StakingInfo instance using the specified properties.
         * @function create
         * @memberof proto.StakingInfo
         * @static
         * @param {proto.IStakingInfo=} [properties] Properties to set
         * @returns {proto.StakingInfo} StakingInfo instance
         */
        StakingInfo.create = function create(properties) {
            return new StakingInfo(properties);
        };

        /**
         * Encodes the specified StakingInfo message. Does not implicitly {@link proto.StakingInfo.verify|verify} messages.
         * @function encode
         * @memberof proto.StakingInfo
         * @static
         * @param {proto.IStakingInfo} m StakingInfo message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StakingInfo.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.declineReward != null && Object.hasOwnProperty.call(m, "declineReward"))
                w.uint32(8).bool(m.declineReward);
            if (m.stakePeriodStart != null && Object.hasOwnProperty.call(m, "stakePeriodStart"))
                $root.proto.Timestamp.encode(m.stakePeriodStart, w.uint32(18).fork()).ldelim();
            if (m.pendingReward != null && Object.hasOwnProperty.call(m, "pendingReward"))
                w.uint32(24).int64(m.pendingReward);
            if (m.stakedToMe != null && Object.hasOwnProperty.call(m, "stakedToMe")) w.uint32(32).int64(m.stakedToMe);
            if (m.stakedAccountId != null && Object.hasOwnProperty.call(m, "stakedAccountId"))
                $root.proto.AccountID.encode(m.stakedAccountId, w.uint32(42).fork()).ldelim();
            if (m.stakedNodeId != null && Object.hasOwnProperty.call(m, "stakedNodeId"))
                w.uint32(48).int64(m.stakedNodeId);
            return w;
        };

        /**
         * Decodes a StakingInfo message from the specified reader or buffer.
         * @function decode
         * @memberof proto.StakingInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.StakingInfo} StakingInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StakingInfo.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.StakingInfo();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.declineReward = r.bool();
                        break;
                    }
                    case 2: {
                        m.stakePeriodStart = $root.proto.Timestamp.decode(r, r.uint32());
                        break;
                    }
                    case 3: {
                        m.pendingReward = r.int64();
                        break;
                    }
                    case 4: {
                        m.stakedToMe = r.int64();
                        break;
                    }
                    case 5: {
                        m.stakedAccountId = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    case 6: {
                        m.stakedNodeId = r.int64();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for StakingInfo
         * @function getTypeUrl
         * @memberof proto.StakingInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        StakingInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.StakingInfo";
        };

        return StakingInfo;
    })();

    proto.Timestamp = (function () {
        /**
         * Properties of a Timestamp.
         * @memberof proto
         * @interface ITimestamp
         * @property {Long|null} [seconds] Number of complete seconds since the start of the epoch
         * @property {number|null} [nanos] Number of nanoseconds since the start of the last second
         */

        /**
         * Constructs a new Timestamp.
         * @memberof proto
         * @classdesc An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the
         * comments in https://github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto)
         * @implements ITimestamp
         * @constructor
         * @param {proto.ITimestamp=} [p] Properties to set
         */
        function Timestamp(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * Number of complete seconds since the start of the epoch
         * @member {Long} seconds
         * @memberof proto.Timestamp
         * @instance
         */
        Timestamp.prototype.seconds = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * Number of nanoseconds since the start of the last second
         * @member {number} nanos
         * @memberof proto.Timestamp
         * @instance
         */
        Timestamp.prototype.nanos = 0;

        /**
         * Creates a new Timestamp instance using the specified properties.
         * @function create
         * @memberof proto.Timestamp
         * @static
         * @param {proto.ITimestamp=} [properties] Properties to set
         * @returns {proto.Timestamp} Timestamp instance
         */
        Timestamp.create = function create(properties) {
            return new Timestamp(properties);
        };

        /**
         * Encodes the specified Timestamp message. Does not implicitly {@link proto.Timestamp.verify|verify} messages.
         * @function encode
         * @memberof proto.Timestamp
         * @static
         * @param {proto.ITimestamp} m Timestamp message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Timestamp.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.seconds != null && Object.hasOwnProperty.call(m, "seconds")) w.uint32(8).int64(m.seconds);
            if (m.nanos != null && Object.hasOwnProperty.call(m, "nanos")) w.uint32(16).int32(m.nanos);
            return w;
        };

        /**
         * Decodes a Timestamp message from the specified reader or buffer.
         * @function decode
         * @memberof proto.Timestamp
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.Timestamp} Timestamp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Timestamp.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.Timestamp();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.seconds = r.int64();
                        break;
                    }
                    case 2: {
                        m.nanos = r.int32();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for Timestamp
         * @function getTypeUrl
         * @memberof proto.Timestamp
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Timestamp.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.Timestamp";
        };

        return Timestamp;
    })();

    proto.TimestampSeconds = (function () {
        /**
         * Properties of a TimestampSeconds.
         * @memberof proto
         * @interface ITimestampSeconds
         * @property {Long|null} [seconds] Number of complete seconds since the start of the epoch
         */

        /**
         * Constructs a new TimestampSeconds.
         * @memberof proto
         * @classdesc An exact date and time,  with a resolution of one second (no nanoseconds).
         * @implements ITimestampSeconds
         * @constructor
         * @param {proto.ITimestampSeconds=} [p] Properties to set
         */
        function TimestampSeconds(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * Number of complete seconds since the start of the epoch
         * @member {Long} seconds
         * @memberof proto.TimestampSeconds
         * @instance
         */
        TimestampSeconds.prototype.seconds = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * Creates a new TimestampSeconds instance using the specified properties.
         * @function create
         * @memberof proto.TimestampSeconds
         * @static
         * @param {proto.ITimestampSeconds=} [properties] Properties to set
         * @returns {proto.TimestampSeconds} TimestampSeconds instance
         */
        TimestampSeconds.create = function create(properties) {
            return new TimestampSeconds(properties);
        };

        /**
         * Encodes the specified TimestampSeconds message. Does not implicitly {@link proto.TimestampSeconds.verify|verify} messages.
         * @function encode
         * @memberof proto.TimestampSeconds
         * @static
         * @param {proto.ITimestampSeconds} m TimestampSeconds message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TimestampSeconds.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.seconds != null && Object.hasOwnProperty.call(m, "seconds")) w.uint32(8).int64(m.seconds);
            return w;
        };

        /**
         * Decodes a TimestampSeconds message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TimestampSeconds
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TimestampSeconds} TimestampSeconds
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TimestampSeconds.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.TimestampSeconds();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.seconds = r.int64();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TimestampSeconds
         * @function getTypeUrl
         * @memberof proto.TimestampSeconds
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TimestampSeconds.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TimestampSeconds";
        };

        return TimestampSeconds;
    })();

    proto.ConsensusCreateTopicTransactionBody = (function () {
        /**
         * Properties of a ConsensusCreateTopicTransactionBody.
         * @memberof proto
         * @interface IConsensusCreateTopicTransactionBody
         * @property {string|null} [memo] Short publicly visible memo about the topic. No guarantee of uniqueness.
         * @property {proto.IKey|null} [adminKey] Access control for updateTopic/deleteTopic.
         * Anyone can increase the topic's expirationTime via ConsensusService.updateTopic(), regardless of the adminKey.
         * If no adminKey is specified, updateTopic may only be used to extend the topic's expirationTime, and deleteTopic
         * is disallowed.
         * @property {proto.IKey|null} [submitKey] Access control for submitMessage.
         * If unspecified, no access control is performed on ConsensusService.submitMessage (all submissions are allowed).
         * @property {proto.IDuration|null} [autoRenewPeriod] The initial lifetime of the topic and the amount of time to attempt to extend the topic's lifetime by
         * automatically at the topic's expirationTime, if the autoRenewAccount is configured (once autoRenew functionality
         * is supported by HAPI).
         * Limited to MIN_AUTORENEW_PERIOD and MAX_AUTORENEW_PERIOD value by server-side configuration.
         * Required.
         * @property {proto.IAccountID|null} [autoRenewAccount] Optional account to be used at the topic's expirationTime to extend the life of the topic (once autoRenew
         * functionality is supported by HAPI).
         * The topic lifetime will be extended up to a maximum of the autoRenewPeriod or however long the topic
         * can be extended using all funds on the account (whichever is the smaller duration/amount and if any extension
         * is possible with the account's funds).
         * If specified, there must be an adminKey and the autoRenewAccount must sign this transaction.
         */

        /**
         * Constructs a new ConsensusCreateTopicTransactionBody.
         * @memberof proto
         * @classdesc See [ConsensusService.createTopic()](#proto.ConsensusService)
         * @implements IConsensusCreateTopicTransactionBody
         * @constructor
         * @param {proto.IConsensusCreateTopicTransactionBody=} [p] Properties to set
         */
        function ConsensusCreateTopicTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * Short publicly visible memo about the topic. No guarantee of uniqueness.
         * @member {string} memo
         * @memberof proto.ConsensusCreateTopicTransactionBody
         * @instance
         */
        ConsensusCreateTopicTransactionBody.prototype.memo = "";

        /**
         * Access control for updateTopic/deleteTopic.
         * Anyone can increase the topic's expirationTime via ConsensusService.updateTopic(), regardless of the adminKey.
         * If no adminKey is specified, updateTopic may only be used to extend the topic's expirationTime, and deleteTopic
         * is disallowed.
         * @member {proto.IKey|null|undefined} adminKey
         * @memberof proto.ConsensusCreateTopicTransactionBody
         * @instance
         */
        ConsensusCreateTopicTransactionBody.prototype.adminKey = null;

        /**
         * Access control for submitMessage.
         * If unspecified, no access control is performed on ConsensusService.submitMessage (all submissions are allowed).
         * @member {proto.IKey|null|undefined} submitKey
         * @memberof proto.ConsensusCreateTopicTransactionBody
         * @instance
         */
        ConsensusCreateTopicTransactionBody.prototype.submitKey = null;

        /**
         * The initial lifetime of the topic and the amount of time to attempt to extend the topic's lifetime by
         * automatically at the topic's expirationTime, if the autoRenewAccount is configured (once autoRenew functionality
         * is supported by HAPI).
         * Limited to MIN_AUTORENEW_PERIOD and MAX_AUTORENEW_PERIOD value by server-side configuration.
         * Required.
         * @member {proto.IDuration|null|undefined} autoRenewPeriod
         * @memberof proto.ConsensusCreateTopicTransactionBody
         * @instance
         */
        ConsensusCreateTopicTransactionBody.prototype.autoRenewPeriod = null;

        /**
         * Optional account to be used at the topic's expirationTime to extend the life of the topic (once autoRenew
         * functionality is supported by HAPI).
         * The topic lifetime will be extended up to a maximum of the autoRenewPeriod or however long the topic
         * can be extended using all funds on the account (whichever is the smaller duration/amount and if any extension
         * is possible with the account's funds).
         * If specified, there must be an adminKey and the autoRenewAccount must sign this transaction.
         * @member {proto.IAccountID|null|undefined} autoRenewAccount
         * @memberof proto.ConsensusCreateTopicTransactionBody
         * @instance
         */
        ConsensusCreateTopicTransactionBody.prototype.autoRenewAccount = null;

        /**
         * Creates a new ConsensusCreateTopicTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.ConsensusCreateTopicTransactionBody
         * @static
         * @param {proto.IConsensusCreateTopicTransactionBody=} [properties] Properties to set
         * @returns {proto.ConsensusCreateTopicTransactionBody} ConsensusCreateTopicTransactionBody instance
         */
        ConsensusCreateTopicTransactionBody.create = function create(properties) {
            return new ConsensusCreateTopicTransactionBody(properties);
        };

        /**
         * Encodes the specified ConsensusCreateTopicTransactionBody message. Does not implicitly {@link proto.ConsensusCreateTopicTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.ConsensusCreateTopicTransactionBody
         * @static
         * @param {proto.IConsensusCreateTopicTransactionBody} m ConsensusCreateTopicTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConsensusCreateTopicTransactionBody.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.memo != null && Object.hasOwnProperty.call(m, "memo")) w.uint32(10).string(m.memo);
            if (m.adminKey != null && Object.hasOwnProperty.call(m, "adminKey"))
                $root.proto.Key.encode(m.adminKey, w.uint32(18).fork()).ldelim();
            if (m.submitKey != null && Object.hasOwnProperty.call(m, "submitKey"))
                $root.proto.Key.encode(m.submitKey, w.uint32(26).fork()).ldelim();
            if (m.autoRenewPeriod != null && Object.hasOwnProperty.call(m, "autoRenewPeriod"))
                $root.proto.Duration.encode(m.autoRenewPeriod, w.uint32(50).fork()).ldelim();
            if (m.autoRenewAccount != null && Object.hasOwnProperty.call(m, "autoRenewAccount"))
                $root.proto.AccountID.encode(m.autoRenewAccount, w.uint32(58).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a ConsensusCreateTopicTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ConsensusCreateTopicTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ConsensusCreateTopicTransactionBody} ConsensusCreateTopicTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConsensusCreateTopicTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.ConsensusCreateTopicTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.memo = r.string();
                        break;
                    }
                    case 2: {
                        m.adminKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                    case 3: {
                        m.submitKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                    case 6: {
                        m.autoRenewPeriod = $root.proto.Duration.decode(r, r.uint32());
                        break;
                    }
                    case 7: {
                        m.autoRenewAccount = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ConsensusCreateTopicTransactionBody
         * @function getTypeUrl
         * @memberof proto.ConsensusCreateTopicTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ConsensusCreateTopicTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ConsensusCreateTopicTransactionBody";
        };

        return ConsensusCreateTopicTransactionBody;
    })();

    proto.Duration = (function () {
        /**
         * Properties of a Duration.
         * @memberof proto
         * @interface IDuration
         * @property {Long|null} [seconds] The number of seconds
         */

        /**
         * Constructs a new Duration.
         * @memberof proto
         * @classdesc A length of time in seconds.
         * @implements IDuration
         * @constructor
         * @param {proto.IDuration=} [p] Properties to set
         */
        function Duration(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The number of seconds
         * @member {Long} seconds
         * @memberof proto.Duration
         * @instance
         */
        Duration.prototype.seconds = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * Creates a new Duration instance using the specified properties.
         * @function create
         * @memberof proto.Duration
         * @static
         * @param {proto.IDuration=} [properties] Properties to set
         * @returns {proto.Duration} Duration instance
         */
        Duration.create = function create(properties) {
            return new Duration(properties);
        };

        /**
         * Encodes the specified Duration message. Does not implicitly {@link proto.Duration.verify|verify} messages.
         * @function encode
         * @memberof proto.Duration
         * @static
         * @param {proto.IDuration} m Duration message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Duration.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.seconds != null && Object.hasOwnProperty.call(m, "seconds")) w.uint32(8).int64(m.seconds);
            return w;
        };

        /**
         * Decodes a Duration message from the specified reader or buffer.
         * @function decode
         * @memberof proto.Duration
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.Duration} Duration
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Duration.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.Duration();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.seconds = r.int64();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for Duration
         * @function getTypeUrl
         * @memberof proto.Duration
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Duration.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.Duration";
        };

        return Duration;
    })();

    proto.ConsensusDeleteTopicTransactionBody = (function () {
        /**
         * Properties of a ConsensusDeleteTopicTransactionBody.
         * @memberof proto
         * @interface IConsensusDeleteTopicTransactionBody
         * @property {proto.ITopicID|null} [topicID] Topic identifier
         */

        /**
         * Constructs a new ConsensusDeleteTopicTransactionBody.
         * @memberof proto
         * @classdesc See [ConsensusService.deleteTopic()](#proto.ConsensusService)
         * @implements IConsensusDeleteTopicTransactionBody
         * @constructor
         * @param {proto.IConsensusDeleteTopicTransactionBody=} [p] Properties to set
         */
        function ConsensusDeleteTopicTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * Topic identifier
         * @member {proto.ITopicID|null|undefined} topicID
         * @memberof proto.ConsensusDeleteTopicTransactionBody
         * @instance
         */
        ConsensusDeleteTopicTransactionBody.prototype.topicID = null;

        /**
         * Creates a new ConsensusDeleteTopicTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.ConsensusDeleteTopicTransactionBody
         * @static
         * @param {proto.IConsensusDeleteTopicTransactionBody=} [properties] Properties to set
         * @returns {proto.ConsensusDeleteTopicTransactionBody} ConsensusDeleteTopicTransactionBody instance
         */
        ConsensusDeleteTopicTransactionBody.create = function create(properties) {
            return new ConsensusDeleteTopicTransactionBody(properties);
        };

        /**
         * Encodes the specified ConsensusDeleteTopicTransactionBody message. Does not implicitly {@link proto.ConsensusDeleteTopicTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.ConsensusDeleteTopicTransactionBody
         * @static
         * @param {proto.IConsensusDeleteTopicTransactionBody} m ConsensusDeleteTopicTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConsensusDeleteTopicTransactionBody.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.topicID != null && Object.hasOwnProperty.call(m, "topicID"))
                $root.proto.TopicID.encode(m.topicID, w.uint32(10).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a ConsensusDeleteTopicTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ConsensusDeleteTopicTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ConsensusDeleteTopicTransactionBody} ConsensusDeleteTopicTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConsensusDeleteTopicTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.ConsensusDeleteTopicTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.topicID = $root.proto.TopicID.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ConsensusDeleteTopicTransactionBody
         * @function getTypeUrl
         * @memberof proto.ConsensusDeleteTopicTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ConsensusDeleteTopicTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ConsensusDeleteTopicTransactionBody";
        };

        return ConsensusDeleteTopicTransactionBody;
    })();

    proto.ConsensusGetTopicInfoQuery = (function () {
        /**
         * Properties of a ConsensusGetTopicInfoQuery.
         * @memberof proto
         * @interface IConsensusGetTopicInfoQuery
         * @property {proto.IQueryHeader|null} [header] Standard info sent from client to node, including the signed payment, and what kind of response is requested
         * (cost, state proof, both, or neither).
         * @property {proto.ITopicID|null} [topicID] The Topic for which information is being requested
         */

        /**
         * Constructs a new ConsensusGetTopicInfoQuery.
         * @memberof proto
         * @classdesc See [ConsensusService.getTopicInfo()](#proto.ConsensusService)
         * @implements IConsensusGetTopicInfoQuery
         * @constructor
         * @param {proto.IConsensusGetTopicInfoQuery=} [p] Properties to set
         */
        function ConsensusGetTopicInfoQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * Standard info sent from client to node, including the signed payment, and what kind of response is requested
         * (cost, state proof, both, or neither).
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.ConsensusGetTopicInfoQuery
         * @instance
         */
        ConsensusGetTopicInfoQuery.prototype.header = null;

        /**
         * The Topic for which information is being requested
         * @member {proto.ITopicID|null|undefined} topicID
         * @memberof proto.ConsensusGetTopicInfoQuery
         * @instance
         */
        ConsensusGetTopicInfoQuery.prototype.topicID = null;

        /**
         * Creates a new ConsensusGetTopicInfoQuery instance using the specified properties.
         * @function create
         * @memberof proto.ConsensusGetTopicInfoQuery
         * @static
         * @param {proto.IConsensusGetTopicInfoQuery=} [properties] Properties to set
         * @returns {proto.ConsensusGetTopicInfoQuery} ConsensusGetTopicInfoQuery instance
         */
        ConsensusGetTopicInfoQuery.create = function create(properties) {
            return new ConsensusGetTopicInfoQuery(properties);
        };

        /**
         * Encodes the specified ConsensusGetTopicInfoQuery message. Does not implicitly {@link proto.ConsensusGetTopicInfoQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.ConsensusGetTopicInfoQuery
         * @static
         * @param {proto.IConsensusGetTopicInfoQuery} m ConsensusGetTopicInfoQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConsensusGetTopicInfoQuery.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.topicID != null && Object.hasOwnProperty.call(m, "topicID"))
                $root.proto.TopicID.encode(m.topicID, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a ConsensusGetTopicInfoQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ConsensusGetTopicInfoQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ConsensusGetTopicInfoQuery} ConsensusGetTopicInfoQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConsensusGetTopicInfoQuery.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.ConsensusGetTopicInfoQuery();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.topicID = $root.proto.TopicID.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ConsensusGetTopicInfoQuery
         * @function getTypeUrl
         * @memberof proto.ConsensusGetTopicInfoQuery
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ConsensusGetTopicInfoQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ConsensusGetTopicInfoQuery";
        };

        return ConsensusGetTopicInfoQuery;
    })();

    proto.ConsensusGetTopicInfoResponse = (function () {
        /**
         * Properties of a ConsensusGetTopicInfoResponse.
         * @memberof proto
         * @interface IConsensusGetTopicInfoResponse
         * @property {proto.IResponseHeader|null} [header] Standard response from node to client, including the requested fields: cost, or state proof, or both, or neither.
         * @property {proto.ITopicID|null} [topicID] Topic identifier.
         * @property {proto.IConsensusTopicInfo|null} [topicInfo] Current state of the topic
         */

        /**
         * Constructs a new ConsensusGetTopicInfoResponse.
         * @memberof proto
         * @classdesc Retrieve the parameters of and state of a consensus topic.
         * @implements IConsensusGetTopicInfoResponse
         * @constructor
         * @param {proto.IConsensusGetTopicInfoResponse=} [p] Properties to set
         */
        function ConsensusGetTopicInfoResponse(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * Standard response from node to client, including the requested fields: cost, or state proof, or both, or neither.
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.ConsensusGetTopicInfoResponse
         * @instance
         */
        ConsensusGetTopicInfoResponse.prototype.header = null;

        /**
         * Topic identifier.
         * @member {proto.ITopicID|null|undefined} topicID
         * @memberof proto.ConsensusGetTopicInfoResponse
         * @instance
         */
        ConsensusGetTopicInfoResponse.prototype.topicID = null;

        /**
         * Current state of the topic
         * @member {proto.IConsensusTopicInfo|null|undefined} topicInfo
         * @memberof proto.ConsensusGetTopicInfoResponse
         * @instance
         */
        ConsensusGetTopicInfoResponse.prototype.topicInfo = null;

        /**
         * Creates a new ConsensusGetTopicInfoResponse instance using the specified properties.
         * @function create
         * @memberof proto.ConsensusGetTopicInfoResponse
         * @static
         * @param {proto.IConsensusGetTopicInfoResponse=} [properties] Properties to set
         * @returns {proto.ConsensusGetTopicInfoResponse} ConsensusGetTopicInfoResponse instance
         */
        ConsensusGetTopicInfoResponse.create = function create(properties) {
            return new ConsensusGetTopicInfoResponse(properties);
        };

        /**
         * Encodes the specified ConsensusGetTopicInfoResponse message. Does not implicitly {@link proto.ConsensusGetTopicInfoResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ConsensusGetTopicInfoResponse
         * @static
         * @param {proto.IConsensusGetTopicInfoResponse} m ConsensusGetTopicInfoResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConsensusGetTopicInfoResponse.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.topicID != null && Object.hasOwnProperty.call(m, "topicID"))
                $root.proto.TopicID.encode(m.topicID, w.uint32(18).fork()).ldelim();
            if (m.topicInfo != null && Object.hasOwnProperty.call(m, "topicInfo"))
                $root.proto.ConsensusTopicInfo.encode(m.topicInfo, w.uint32(42).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a ConsensusGetTopicInfoResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ConsensusGetTopicInfoResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ConsensusGetTopicInfoResponse} ConsensusGetTopicInfoResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConsensusGetTopicInfoResponse.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.ConsensusGetTopicInfoResponse();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.topicID = $root.proto.TopicID.decode(r, r.uint32());
                        break;
                    }
                    case 5: {
                        m.topicInfo = $root.proto.ConsensusTopicInfo.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ConsensusGetTopicInfoResponse
         * @function getTypeUrl
         * @memberof proto.ConsensusGetTopicInfoResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ConsensusGetTopicInfoResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ConsensusGetTopicInfoResponse";
        };

        return ConsensusGetTopicInfoResponse;
    })();

    /**
     * The client uses the ResponseType to indicate that it desires the node send just the answer, or
     * both the answer and a state proof. It can also ask for just the cost and not the answer itself
     * (allowing it to tailor the payment transaction accordingly). If the payment in the query fails
     * the precheck, then the response may have some fields blank. The state proof is only available for
     * some types of information. It is available for a Record, but not a receipt. It is available for
     * the information in each kind of *GetInfo request.
     * @name proto.ResponseType
     * @enum {number}
     * @property {number} ANSWER_ONLY=0 Response returns answer
     * @property {number} ANSWER_STATE_PROOF=1 (NOT YET SUPPORTED) Response returns both answer and state proof
     * @property {number} COST_ANSWER=2 Response returns the cost of answer
     * @property {number} COST_ANSWER_STATE_PROOF=3 (NOT YET SUPPORTED) Response returns the total cost of answer and state proof
     */
    proto.ResponseType = (function () {
        const valuesById = {},
            values = Object.create(valuesById);
        values[(valuesById[0] = "ANSWER_ONLY")] = 0;
        values[(valuesById[1] = "ANSWER_STATE_PROOF")] = 1;
        values[(valuesById[2] = "COST_ANSWER")] = 2;
        values[(valuesById[3] = "COST_ANSWER_STATE_PROOF")] = 3;
        return values;
    })();

    proto.QueryHeader = (function () {
        /**
         * Properties of a QueryHeader.
         * @memberof proto
         * @interface IQueryHeader
         * @property {proto.ITransaction|null} [payment] A signed CryptoTransferTransaction to pay the node a fee for handling this query
         * @property {proto.ResponseType|null} [responseType] The requested response, asking for cost, state proof, both, or neither
         */

        /**
         * Constructs a new QueryHeader.
         * @memberof proto
         * @classdesc Each query from the client to the node will contain the QueryHeader, which gives the requested
         * response type, and includes a payment transaction that will compensate the node for responding to
         * the query. The payment can be blank if the query is free.
         * @implements IQueryHeader
         * @constructor
         * @param {proto.IQueryHeader=} [p] Properties to set
         */
        function QueryHeader(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * A signed CryptoTransferTransaction to pay the node a fee for handling this query
         * @member {proto.ITransaction|null|undefined} payment
         * @memberof proto.QueryHeader
         * @instance
         */
        QueryHeader.prototype.payment = null;

        /**
         * The requested response, asking for cost, state proof, both, or neither
         * @member {proto.ResponseType} responseType
         * @memberof proto.QueryHeader
         * @instance
         */
        QueryHeader.prototype.responseType = 0;

        /**
         * Creates a new QueryHeader instance using the specified properties.
         * @function create
         * @memberof proto.QueryHeader
         * @static
         * @param {proto.IQueryHeader=} [properties] Properties to set
         * @returns {proto.QueryHeader} QueryHeader instance
         */
        QueryHeader.create = function create(properties) {
            return new QueryHeader(properties);
        };

        /**
         * Encodes the specified QueryHeader message. Does not implicitly {@link proto.QueryHeader.verify|verify} messages.
         * @function encode
         * @memberof proto.QueryHeader
         * @static
         * @param {proto.IQueryHeader} m QueryHeader message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryHeader.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.payment != null && Object.hasOwnProperty.call(m, "payment"))
                $root.proto.Transaction.encode(m.payment, w.uint32(10).fork()).ldelim();
            if (m.responseType != null && Object.hasOwnProperty.call(m, "responseType"))
                w.uint32(16).int32(m.responseType);
            return w;
        };

        /**
         * Decodes a QueryHeader message from the specified reader or buffer.
         * @function decode
         * @memberof proto.QueryHeader
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.QueryHeader} QueryHeader
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryHeader.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.QueryHeader();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.payment = $root.proto.Transaction.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.responseType = r.int32();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for QueryHeader
         * @function getTypeUrl
         * @memberof proto.QueryHeader
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        QueryHeader.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.QueryHeader";
        };

        return QueryHeader;
    })();

    proto.Transaction = (function () {
        /**
         * Properties of a Transaction.
         * @memberof proto
         * @interface ITransaction
         * @property {proto.ITransactionBody|null} [body] the body of the transaction, which needs to be signed
         * @property {proto.ISignatureList|null} [sigs] The signatures on the body, to authorize the transaction; deprecated and to be succeeded by
         * SignatureMap field
         * @property {proto.ISignatureMap|null} [sigMap] The signatures on the body with the new format, to authorize the transaction
         * @property {Uint8Array|null} [bodyBytes] TransactionBody serialized into bytes, which needs to be signed
         * @property {Uint8Array|null} [signedTransactionBytes] SignedTransaction serialized into bytes
         */

        /**
         * Constructs a new Transaction.
         * @memberof proto
         * @classdesc A single signed transaction, including all its signatures. The SignatureList will have a
         * Signature for each Key in the transaction, either explicit or implicit, in the order that they
         * appear in the transaction. For example, a CryptoTransfer will first have a Signature
         * corresponding to the Key for the paying account, followed by a Signature corresponding to the Key
         * for each account that is sending or receiving cryptocurrency in the transfer. Each Transaction
         * should not have more than 50 levels.
         * The SignatureList field is deprecated and succeeded by SignatureMap.
         * @implements ITransaction
         * @constructor
         * @param {proto.ITransaction=} [p] Properties to set
         */
        function Transaction(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * the body of the transaction, which needs to be signed
         * @member {proto.ITransactionBody|null|undefined} body
         * @memberof proto.Transaction
         * @instance
         */
        Transaction.prototype.body = null;

        /**
         * The signatures on the body, to authorize the transaction; deprecated and to be succeeded by
         * SignatureMap field
         * @member {proto.ISignatureList|null|undefined} sigs
         * @memberof proto.Transaction
         * @instance
         */
        Transaction.prototype.sigs = null;

        /**
         * The signatures on the body with the new format, to authorize the transaction
         * @member {proto.ISignatureMap|null|undefined} sigMap
         * @memberof proto.Transaction
         * @instance
         */
        Transaction.prototype.sigMap = null;

        /**
         * TransactionBody serialized into bytes, which needs to be signed
         * @member {Uint8Array} bodyBytes
         * @memberof proto.Transaction
         * @instance
         */
        Transaction.prototype.bodyBytes = $util.newBuffer([]);

        /**
         * SignedTransaction serialized into bytes
         * @member {Uint8Array} signedTransactionBytes
         * @memberof proto.Transaction
         * @instance
         */
        Transaction.prototype.signedTransactionBytes = $util.newBuffer([]);

        /**
         * Creates a new Transaction instance using the specified properties.
         * @function create
         * @memberof proto.Transaction
         * @static
         * @param {proto.ITransaction=} [properties] Properties to set
         * @returns {proto.Transaction} Transaction instance
         */
        Transaction.create = function create(properties) {
            return new Transaction(properties);
        };

        /**
         * Encodes the specified Transaction message. Does not implicitly {@link proto.Transaction.verify|verify} messages.
         * @function encode
         * @memberof proto.Transaction
         * @static
         * @param {proto.ITransaction} m Transaction message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Transaction.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.body != null && Object.hasOwnProperty.call(m, "body"))
                $root.proto.TransactionBody.encode(m.body, w.uint32(10).fork()).ldelim();
            if (m.sigs != null && Object.hasOwnProperty.call(m, "sigs"))
                $root.proto.SignatureList.encode(m.sigs, w.uint32(18).fork()).ldelim();
            if (m.sigMap != null && Object.hasOwnProperty.call(m, "sigMap"))
                $root.proto.SignatureMap.encode(m.sigMap, w.uint32(26).fork()).ldelim();
            if (m.bodyBytes != null && Object.hasOwnProperty.call(m, "bodyBytes")) w.uint32(34).bytes(m.bodyBytes);
            if (m.signedTransactionBytes != null && Object.hasOwnProperty.call(m, "signedTransactionBytes"))
                w.uint32(42).bytes(m.signedTransactionBytes);
            return w;
        };

        /**
         * Decodes a Transaction message from the specified reader or buffer.
         * @function decode
         * @memberof proto.Transaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.Transaction} Transaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Transaction.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.Transaction();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.body = $root.proto.TransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.sigs = $root.proto.SignatureList.decode(r, r.uint32());
                        break;
                    }
                    case 3: {
                        m.sigMap = $root.proto.SignatureMap.decode(r, r.uint32());
                        break;
                    }
                    case 4: {
                        m.bodyBytes = r.bytes();
                        break;
                    }
                    case 5: {
                        m.signedTransactionBytes = r.bytes();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for Transaction
         * @function getTypeUrl
         * @memberof proto.Transaction
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Transaction.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.Transaction";
        };

        return Transaction;
    })();

    proto.TransactionBody = (function () {
        /**
         * Properties of a TransactionBody.
         * @memberof proto
         * @interface ITransactionBody
         * @property {proto.ITransactionID|null} [transactionID] The ID for this transaction, which includes the payer's account (the account paying the
         * transaction fee). If two transactions have the same transactionID, they won't both have an
         * effect
         * @property {proto.IAccountID|null} [nodeAccountID] The account of the node that submits the client's transaction to the network
         * @property {Long|null} [transactionFee] The maximum transaction fee the client is willing to pay
         * @property {proto.IDuration|null} [transactionValidDuration] The transaction is invalid if consensusTimestamp > transactionID.transactionValidStart +
         * transactionValidDuration
         * @property {boolean|null} [generateRecord] Should a record of this transaction be generated? (A receipt is always generated, but the
         * record is optional)
         * @property {string|null} [memo] Any notes or descriptions that should be put into the record (max length 100)
         * @property {proto.IContractCallTransactionBody|null} [contractCall] Calls a function of a contract instance
         * @property {proto.IContractCreateTransactionBody|null} [contractCreateInstance] Creates a contract instance
         * @property {proto.IContractUpdateTransactionBody|null} [contractUpdateInstance] Updates a contract
         * @property {proto.IContractDeleteTransactionBody|null} [contractDeleteInstance] Delete contract and transfer remaining balance into specified account
         * @property {proto.IEthereumTransactionBody|null} [ethereumTransaction] An Ethereum encoded transaction.
         * @property {proto.ICryptoAddLiveHashTransactionBody|null} [cryptoAddLiveHash] Attach a new livehash to an account
         * @property {proto.ICryptoApproveAllowanceTransactionBody|null} [cryptoApproveAllowance] Adds one or more approved allowances for spenders to transfer the paying account's hbar or tokens.
         * @property {proto.ICryptoDeleteAllowanceTransactionBody|null} [cryptoDeleteAllowance] Deletes one or more of the specific approved NFT serial numbers on an owner account.
         * @property {proto.ICryptoCreateTransactionBody|null} [cryptoCreateAccount] Create a new cryptocurrency account
         * @property {proto.ICryptoDeleteTransactionBody|null} [cryptoDelete] Delete a cryptocurrency account (mark as deleted, and transfer hbars out)
         * @property {proto.ICryptoDeleteLiveHashTransactionBody|null} [cryptoDeleteLiveHash] Remove a livehash from an account
         * @property {proto.ICryptoTransferTransactionBody|null} [cryptoTransfer] Transfer amount between accounts
         * @property {proto.ICryptoUpdateTransactionBody|null} [cryptoUpdateAccount] Modify information such as the expiration date for an account
         * @property {proto.IFileAppendTransactionBody|null} [fileAppend] Add bytes to the end of the contents of a file
         * @property {proto.IFileCreateTransactionBody|null} [fileCreate] Create a new file
         * @property {proto.IFileDeleteTransactionBody|null} [fileDelete] Delete a file (remove contents and mark as deleted until it expires)
         * @property {proto.IFileUpdateTransactionBody|null} [fileUpdate] Modify information such as the expiration date for a file
         * @property {proto.ISystemDeleteTransactionBody|null} [systemDelete] Hedera administrative deletion of a file or smart contract
         * @property {proto.ISystemUndeleteTransactionBody|null} [systemUndelete] To undelete an entity deleted by SystemDelete
         * @property {proto.IFreezeTransactionBody|null} [freeze] Freeze the nodes
         * @property {proto.IConsensusCreateTopicTransactionBody|null} [consensusCreateTopic] Creates a topic
         * @property {proto.IConsensusUpdateTopicTransactionBody|null} [consensusUpdateTopic] Updates a topic
         * @property {proto.IConsensusDeleteTopicTransactionBody|null} [consensusDeleteTopic] Deletes a topic
         * @property {proto.IConsensusSubmitMessageTransactionBody|null} [consensusSubmitMessage] Submits message to a topic
         * @property {proto.IUncheckedSubmitBody|null} [uncheckedSubmit] UNDOCUMENTED
         * @property {proto.ITokenCreateTransactionBody|null} [tokenCreation] Creates a token instance
         * @property {proto.ITokenFreezeAccountTransactionBody|null} [tokenFreeze] Freezes account not to be able to transact with a token
         * @property {proto.ITokenUnfreezeAccountTransactionBody|null} [tokenUnfreeze] Unfreezes account for a token
         * @property {proto.ITokenGrantKycTransactionBody|null} [tokenGrantKyc] Grants KYC to an account for a token
         * @property {proto.ITokenRevokeKycTransactionBody|null} [tokenRevokeKyc] Revokes KYC of an account for a token
         * @property {proto.ITokenDeleteTransactionBody|null} [tokenDeletion] Deletes a token instance
         * @property {proto.ITokenUpdateTransactionBody|null} [tokenUpdate] Updates a token instance
         * @property {proto.ITokenMintTransactionBody|null} [tokenMint] Mints new tokens to a token's treasury account
         * @property {proto.ITokenBurnTransactionBody|null} [tokenBurn] Burns tokens from a token's treasury account
         * @property {proto.ITokenWipeAccountTransactionBody|null} [tokenWipe] Wipes amount of tokens from an account
         * @property {proto.ITokenAssociateTransactionBody|null} [tokenAssociate] Associate tokens to an account
         * @property {proto.ITokenDissociateTransactionBody|null} [tokenDissociate] Dissociate tokens from an account
         * @property {proto.ITokenFeeScheduleUpdateTransactionBody|null} [tokenFeeScheduleUpdate] Updates a token's custom fee schedule
         * @property {proto.ITokenPauseTransactionBody|null} [tokenPause] Pauses the Token
         * @property {proto.ITokenUnpauseTransactionBody|null} [tokenUnpause] Unpauses the Token
         * @property {proto.IScheduleCreateTransactionBody|null} [scheduleCreate] Creates a schedule in the network's action queue
         * @property {proto.IScheduleDeleteTransactionBody|null} [scheduleDelete] Deletes a schedule from the network's action queue
         * @property {proto.IScheduleSignTransactionBody|null} [scheduleSign] Adds one or more Ed25519 keys to the affirmed signers of a scheduled transaction
         * @property {proto.INodeStakeUpdateTransactionBody|null} [nodeStakeUpdate] Updates the staking info at the end of staking period to indicate new staking period has started.
         * @property {proto.IUtilPrngTransactionBody|null} [utilPrng] Generates a pseudorandom number.
         */

        /**
         * Constructs a new TransactionBody.
         * @memberof proto
         * @classdesc A single transaction. All transaction types are possible here.
         * @implements ITransactionBody
         * @constructor
         * @param {proto.ITransactionBody=} [p] Properties to set
         */
        function TransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The ID for this transaction, which includes the payer's account (the account paying the
         * transaction fee). If two transactions have the same transactionID, they won't both have an
         * effect
         * @member {proto.ITransactionID|null|undefined} transactionID
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.transactionID = null;

        /**
         * The account of the node that submits the client's transaction to the network
         * @member {proto.IAccountID|null|undefined} nodeAccountID
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.nodeAccountID = null;

        /**
         * The maximum transaction fee the client is willing to pay
         * @member {Long} transactionFee
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.transactionFee = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * The transaction is invalid if consensusTimestamp > transactionID.transactionValidStart +
         * transactionValidDuration
         * @member {proto.IDuration|null|undefined} transactionValidDuration
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.transactionValidDuration = null;

        /**
         * Should a record of this transaction be generated? (A receipt is always generated, but the
         * record is optional)
         * @member {boolean} generateRecord
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.generateRecord = false;

        /**
         * Any notes or descriptions that should be put into the record (max length 100)
         * @member {string} memo
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.memo = "";

        /**
         * Calls a function of a contract instance
         * @member {proto.IContractCallTransactionBody|null|undefined} contractCall
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.contractCall = null;

        /**
         * Creates a contract instance
         * @member {proto.IContractCreateTransactionBody|null|undefined} contractCreateInstance
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.contractCreateInstance = null;

        /**
         * Updates a contract
         * @member {proto.IContractUpdateTransactionBody|null|undefined} contractUpdateInstance
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.contractUpdateInstance = null;

        /**
         * Delete contract and transfer remaining balance into specified account
         * @member {proto.IContractDeleteTransactionBody|null|undefined} contractDeleteInstance
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.contractDeleteInstance = null;

        /**
         * An Ethereum encoded transaction.
         * @member {proto.IEthereumTransactionBody|null|undefined} ethereumTransaction
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.ethereumTransaction = null;

        /**
         * Attach a new livehash to an account
         * @member {proto.ICryptoAddLiveHashTransactionBody|null|undefined} cryptoAddLiveHash
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.cryptoAddLiveHash = null;

        /**
         * Adds one or more approved allowances for spenders to transfer the paying account's hbar or tokens.
         * @member {proto.ICryptoApproveAllowanceTransactionBody|null|undefined} cryptoApproveAllowance
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.cryptoApproveAllowance = null;

        /**
         * Deletes one or more of the specific approved NFT serial numbers on an owner account.
         * @member {proto.ICryptoDeleteAllowanceTransactionBody|null|undefined} cryptoDeleteAllowance
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.cryptoDeleteAllowance = null;

        /**
         * Create a new cryptocurrency account
         * @member {proto.ICryptoCreateTransactionBody|null|undefined} cryptoCreateAccount
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.cryptoCreateAccount = null;

        /**
         * Delete a cryptocurrency account (mark as deleted, and transfer hbars out)
         * @member {proto.ICryptoDeleteTransactionBody|null|undefined} cryptoDelete
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.cryptoDelete = null;

        /**
         * Remove a livehash from an account
         * @member {proto.ICryptoDeleteLiveHashTransactionBody|null|undefined} cryptoDeleteLiveHash
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.cryptoDeleteLiveHash = null;

        /**
         * Transfer amount between accounts
         * @member {proto.ICryptoTransferTransactionBody|null|undefined} cryptoTransfer
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.cryptoTransfer = null;

        /**
         * Modify information such as the expiration date for an account
         * @member {proto.ICryptoUpdateTransactionBody|null|undefined} cryptoUpdateAccount
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.cryptoUpdateAccount = null;

        /**
         * Add bytes to the end of the contents of a file
         * @member {proto.IFileAppendTransactionBody|null|undefined} fileAppend
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.fileAppend = null;

        /**
         * Create a new file
         * @member {proto.IFileCreateTransactionBody|null|undefined} fileCreate
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.fileCreate = null;

        /**
         * Delete a file (remove contents and mark as deleted until it expires)
         * @member {proto.IFileDeleteTransactionBody|null|undefined} fileDelete
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.fileDelete = null;

        /**
         * Modify information such as the expiration date for a file
         * @member {proto.IFileUpdateTransactionBody|null|undefined} fileUpdate
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.fileUpdate = null;

        /**
         * Hedera administrative deletion of a file or smart contract
         * @member {proto.ISystemDeleteTransactionBody|null|undefined} systemDelete
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.systemDelete = null;

        /**
         * To undelete an entity deleted by SystemDelete
         * @member {proto.ISystemUndeleteTransactionBody|null|undefined} systemUndelete
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.systemUndelete = null;

        /**
         * Freeze the nodes
         * @member {proto.IFreezeTransactionBody|null|undefined} freeze
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.freeze = null;

        /**
         * Creates a topic
         * @member {proto.IConsensusCreateTopicTransactionBody|null|undefined} consensusCreateTopic
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.consensusCreateTopic = null;

        /**
         * Updates a topic
         * @member {proto.IConsensusUpdateTopicTransactionBody|null|undefined} consensusUpdateTopic
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.consensusUpdateTopic = null;

        /**
         * Deletes a topic
         * @member {proto.IConsensusDeleteTopicTransactionBody|null|undefined} consensusDeleteTopic
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.consensusDeleteTopic = null;

        /**
         * Submits message to a topic
         * @member {proto.IConsensusSubmitMessageTransactionBody|null|undefined} consensusSubmitMessage
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.consensusSubmitMessage = null;

        /**
         * UNDOCUMENTED
         * @member {proto.IUncheckedSubmitBody|null|undefined} uncheckedSubmit
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.uncheckedSubmit = null;

        /**
         * Creates a token instance
         * @member {proto.ITokenCreateTransactionBody|null|undefined} tokenCreation
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.tokenCreation = null;

        /**
         * Freezes account not to be able to transact with a token
         * @member {proto.ITokenFreezeAccountTransactionBody|null|undefined} tokenFreeze
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.tokenFreeze = null;

        /**
         * Unfreezes account for a token
         * @member {proto.ITokenUnfreezeAccountTransactionBody|null|undefined} tokenUnfreeze
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.tokenUnfreeze = null;

        /**
         * Grants KYC to an account for a token
         * @member {proto.ITokenGrantKycTransactionBody|null|undefined} tokenGrantKyc
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.tokenGrantKyc = null;

        /**
         * Revokes KYC of an account for a token
         * @member {proto.ITokenRevokeKycTransactionBody|null|undefined} tokenRevokeKyc
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.tokenRevokeKyc = null;

        /**
         * Deletes a token instance
         * @member {proto.ITokenDeleteTransactionBody|null|undefined} tokenDeletion
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.tokenDeletion = null;

        /**
         * Updates a token instance
         * @member {proto.ITokenUpdateTransactionBody|null|undefined} tokenUpdate
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.tokenUpdate = null;

        /**
         * Mints new tokens to a token's treasury account
         * @member {proto.ITokenMintTransactionBody|null|undefined} tokenMint
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.tokenMint = null;

        /**
         * Burns tokens from a token's treasury account
         * @member {proto.ITokenBurnTransactionBody|null|undefined} tokenBurn
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.tokenBurn = null;

        /**
         * Wipes amount of tokens from an account
         * @member {proto.ITokenWipeAccountTransactionBody|null|undefined} tokenWipe
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.tokenWipe = null;

        /**
         * Associate tokens to an account
         * @member {proto.ITokenAssociateTransactionBody|null|undefined} tokenAssociate
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.tokenAssociate = null;

        /**
         * Dissociate tokens from an account
         * @member {proto.ITokenDissociateTransactionBody|null|undefined} tokenDissociate
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.tokenDissociate = null;

        /**
         * Updates a token's custom fee schedule
         * @member {proto.ITokenFeeScheduleUpdateTransactionBody|null|undefined} tokenFeeScheduleUpdate
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.tokenFeeScheduleUpdate = null;

        /**
         * Pauses the Token
         * @member {proto.ITokenPauseTransactionBody|null|undefined} tokenPause
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.tokenPause = null;

        /**
         * Unpauses the Token
         * @member {proto.ITokenUnpauseTransactionBody|null|undefined} tokenUnpause
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.tokenUnpause = null;

        /**
         * Creates a schedule in the network's action queue
         * @member {proto.IScheduleCreateTransactionBody|null|undefined} scheduleCreate
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.scheduleCreate = null;

        /**
         * Deletes a schedule from the network's action queue
         * @member {proto.IScheduleDeleteTransactionBody|null|undefined} scheduleDelete
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.scheduleDelete = null;

        /**
         * Adds one or more Ed25519 keys to the affirmed signers of a scheduled transaction
         * @member {proto.IScheduleSignTransactionBody|null|undefined} scheduleSign
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.scheduleSign = null;

        /**
         * Updates the staking info at the end of staking period to indicate new staking period has started.
         * @member {proto.INodeStakeUpdateTransactionBody|null|undefined} nodeStakeUpdate
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.nodeStakeUpdate = null;

        /**
         * Generates a pseudorandom number.
         * @member {proto.IUtilPrngTransactionBody|null|undefined} utilPrng
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.utilPrng = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * The choices here are arranged by service in roughly lexicographical order. The field ordinals are non-sequential, and a result of the historical order of implementation.
         * @member {"contractCall"|"contractCreateInstance"|"contractUpdateInstance"|"contractDeleteInstance"|"ethereumTransaction"|"cryptoAddLiveHash"|"cryptoApproveAllowance"|"cryptoDeleteAllowance"|"cryptoCreateAccount"|"cryptoDelete"|"cryptoDeleteLiveHash"|"cryptoTransfer"|"cryptoUpdateAccount"|"fileAppend"|"fileCreate"|"fileDelete"|"fileUpdate"|"systemDelete"|"systemUndelete"|"freeze"|"consensusCreateTopic"|"consensusUpdateTopic"|"consensusDeleteTopic"|"consensusSubmitMessage"|"uncheckedSubmit"|"tokenCreation"|"tokenFreeze"|"tokenUnfreeze"|"tokenGrantKyc"|"tokenRevokeKyc"|"tokenDeletion"|"tokenUpdate"|"tokenMint"|"tokenBurn"|"tokenWipe"|"tokenAssociate"|"tokenDissociate"|"tokenFeeScheduleUpdate"|"tokenPause"|"tokenUnpause"|"scheduleCreate"|"scheduleDelete"|"scheduleSign"|"nodeStakeUpdate"|"utilPrng"|undefined} data
         * @memberof proto.TransactionBody
         * @instance
         */
        Object.defineProperty(TransactionBody.prototype, "data", {
            get: $util.oneOfGetter(
                ($oneOfFields = [
                    "contractCall",
                    "contractCreateInstance",
                    "contractUpdateInstance",
                    "contractDeleteInstance",
                    "ethereumTransaction",
                    "cryptoAddLiveHash",
                    "cryptoApproveAllowance",
                    "cryptoDeleteAllowance",
                    "cryptoCreateAccount",
                    "cryptoDelete",
                    "cryptoDeleteLiveHash",
                    "cryptoTransfer",
                    "cryptoUpdateAccount",
                    "fileAppend",
                    "fileCreate",
                    "fileDelete",
                    "fileUpdate",
                    "systemDelete",
                    "systemUndelete",
                    "freeze",
                    "consensusCreateTopic",
                    "consensusUpdateTopic",
                    "consensusDeleteTopic",
                    "consensusSubmitMessage",
                    "uncheckedSubmit",
                    "tokenCreation",
                    "tokenFreeze",
                    "tokenUnfreeze",
                    "tokenGrantKyc",
                    "tokenRevokeKyc",
                    "tokenDeletion",
                    "tokenUpdate",
                    "tokenMint",
                    "tokenBurn",
                    "tokenWipe",
                    "tokenAssociate",
                    "tokenDissociate",
                    "tokenFeeScheduleUpdate",
                    "tokenPause",
                    "tokenUnpause",
                    "scheduleCreate",
                    "scheduleDelete",
                    "scheduleSign",
                    "nodeStakeUpdate",
                    "utilPrng",
                ])
            ),
            set: $util.oneOfSetter($oneOfFields),
        });

        /**
         * Creates a new TransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.TransactionBody
         * @static
         * @param {proto.ITransactionBody=} [properties] Properties to set
         * @returns {proto.TransactionBody} TransactionBody instance
         */
        TransactionBody.create = function create(properties) {
            return new TransactionBody(properties);
        };

        /**
         * Encodes the specified TransactionBody message. Does not implicitly {@link proto.TransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.TransactionBody
         * @static
         * @param {proto.ITransactionBody} m TransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionBody.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.transactionID != null && Object.hasOwnProperty.call(m, "transactionID"))
                $root.proto.TransactionID.encode(m.transactionID, w.uint32(10).fork()).ldelim();
            if (m.nodeAccountID != null && Object.hasOwnProperty.call(m, "nodeAccountID"))
                $root.proto.AccountID.encode(m.nodeAccountID, w.uint32(18).fork()).ldelim();
            if (m.transactionFee != null && Object.hasOwnProperty.call(m, "transactionFee"))
                w.uint32(24).uint64(m.transactionFee);
            if (m.transactionValidDuration != null && Object.hasOwnProperty.call(m, "transactionValidDuration"))
                $root.proto.Duration.encode(m.transactionValidDuration, w.uint32(34).fork()).ldelim();
            if (m.generateRecord != null && Object.hasOwnProperty.call(m, "generateRecord"))
                w.uint32(40).bool(m.generateRecord);
            if (m.memo != null && Object.hasOwnProperty.call(m, "memo")) w.uint32(50).string(m.memo);
            if (m.contractCall != null && Object.hasOwnProperty.call(m, "contractCall"))
                $root.proto.ContractCallTransactionBody.encode(m.contractCall, w.uint32(58).fork()).ldelim();
            if (m.contractCreateInstance != null && Object.hasOwnProperty.call(m, "contractCreateInstance"))
                $root.proto.ContractCreateTransactionBody.encode(
                    m.contractCreateInstance,
                    w.uint32(66).fork()
                ).ldelim();
            if (m.contractUpdateInstance != null && Object.hasOwnProperty.call(m, "contractUpdateInstance"))
                $root.proto.ContractUpdateTransactionBody.encode(
                    m.contractUpdateInstance,
                    w.uint32(74).fork()
                ).ldelim();
            if (m.cryptoAddLiveHash != null && Object.hasOwnProperty.call(m, "cryptoAddLiveHash"))
                $root.proto.CryptoAddLiveHashTransactionBody.encode(m.cryptoAddLiveHash, w.uint32(82).fork()).ldelim();
            if (m.cryptoCreateAccount != null && Object.hasOwnProperty.call(m, "cryptoCreateAccount"))
                $root.proto.CryptoCreateTransactionBody.encode(m.cryptoCreateAccount, w.uint32(90).fork()).ldelim();
            if (m.cryptoDelete != null && Object.hasOwnProperty.call(m, "cryptoDelete"))
                $root.proto.CryptoDeleteTransactionBody.encode(m.cryptoDelete, w.uint32(98).fork()).ldelim();
            if (m.cryptoDeleteLiveHash != null && Object.hasOwnProperty.call(m, "cryptoDeleteLiveHash"))
                $root.proto.CryptoDeleteLiveHashTransactionBody.encode(
                    m.cryptoDeleteLiveHash,
                    w.uint32(106).fork()
                ).ldelim();
            if (m.cryptoTransfer != null && Object.hasOwnProperty.call(m, "cryptoTransfer"))
                $root.proto.CryptoTransferTransactionBody.encode(m.cryptoTransfer, w.uint32(114).fork()).ldelim();
            if (m.cryptoUpdateAccount != null && Object.hasOwnProperty.call(m, "cryptoUpdateAccount"))
                $root.proto.CryptoUpdateTransactionBody.encode(m.cryptoUpdateAccount, w.uint32(122).fork()).ldelim();
            if (m.fileAppend != null && Object.hasOwnProperty.call(m, "fileAppend"))
                $root.proto.FileAppendTransactionBody.encode(m.fileAppend, w.uint32(130).fork()).ldelim();
            if (m.fileCreate != null && Object.hasOwnProperty.call(m, "fileCreate"))
                $root.proto.FileCreateTransactionBody.encode(m.fileCreate, w.uint32(138).fork()).ldelim();
            if (m.fileDelete != null && Object.hasOwnProperty.call(m, "fileDelete"))
                $root.proto.FileDeleteTransactionBody.encode(m.fileDelete, w.uint32(146).fork()).ldelim();
            if (m.fileUpdate != null && Object.hasOwnProperty.call(m, "fileUpdate"))
                $root.proto.FileUpdateTransactionBody.encode(m.fileUpdate, w.uint32(154).fork()).ldelim();
            if (m.systemDelete != null && Object.hasOwnProperty.call(m, "systemDelete"))
                $root.proto.SystemDeleteTransactionBody.encode(m.systemDelete, w.uint32(162).fork()).ldelim();
            if (m.systemUndelete != null && Object.hasOwnProperty.call(m, "systemUndelete"))
                $root.proto.SystemUndeleteTransactionBody.encode(m.systemUndelete, w.uint32(170).fork()).ldelim();
            if (m.contractDeleteInstance != null && Object.hasOwnProperty.call(m, "contractDeleteInstance"))
                $root.proto.ContractDeleteTransactionBody.encode(
                    m.contractDeleteInstance,
                    w.uint32(178).fork()
                ).ldelim();
            if (m.freeze != null && Object.hasOwnProperty.call(m, "freeze"))
                $root.proto.FreezeTransactionBody.encode(m.freeze, w.uint32(186).fork()).ldelim();
            if (m.consensusCreateTopic != null && Object.hasOwnProperty.call(m, "consensusCreateTopic"))
                $root.proto.ConsensusCreateTopicTransactionBody.encode(
                    m.consensusCreateTopic,
                    w.uint32(194).fork()
                ).ldelim();
            if (m.consensusUpdateTopic != null && Object.hasOwnProperty.call(m, "consensusUpdateTopic"))
                $root.proto.ConsensusUpdateTopicTransactionBody.encode(
                    m.consensusUpdateTopic,
                    w.uint32(202).fork()
                ).ldelim();
            if (m.consensusDeleteTopic != null && Object.hasOwnProperty.call(m, "consensusDeleteTopic"))
                $root.proto.ConsensusDeleteTopicTransactionBody.encode(
                    m.consensusDeleteTopic,
                    w.uint32(210).fork()
                ).ldelim();
            if (m.consensusSubmitMessage != null && Object.hasOwnProperty.call(m, "consensusSubmitMessage"))
                $root.proto.ConsensusSubmitMessageTransactionBody.encode(
                    m.consensusSubmitMessage,
                    w.uint32(218).fork()
                ).ldelim();
            if (m.uncheckedSubmit != null && Object.hasOwnProperty.call(m, "uncheckedSubmit"))
                $root.proto.UncheckedSubmitBody.encode(m.uncheckedSubmit, w.uint32(226).fork()).ldelim();
            if (m.tokenCreation != null && Object.hasOwnProperty.call(m, "tokenCreation"))
                $root.proto.TokenCreateTransactionBody.encode(m.tokenCreation, w.uint32(234).fork()).ldelim();
            if (m.tokenFreeze != null && Object.hasOwnProperty.call(m, "tokenFreeze"))
                $root.proto.TokenFreezeAccountTransactionBody.encode(m.tokenFreeze, w.uint32(250).fork()).ldelim();
            if (m.tokenUnfreeze != null && Object.hasOwnProperty.call(m, "tokenUnfreeze"))
                $root.proto.TokenUnfreezeAccountTransactionBody.encode(m.tokenUnfreeze, w.uint32(258).fork()).ldelim();
            if (m.tokenGrantKyc != null && Object.hasOwnProperty.call(m, "tokenGrantKyc"))
                $root.proto.TokenGrantKycTransactionBody.encode(m.tokenGrantKyc, w.uint32(266).fork()).ldelim();
            if (m.tokenRevokeKyc != null && Object.hasOwnProperty.call(m, "tokenRevokeKyc"))
                $root.proto.TokenRevokeKycTransactionBody.encode(m.tokenRevokeKyc, w.uint32(274).fork()).ldelim();
            if (m.tokenDeletion != null && Object.hasOwnProperty.call(m, "tokenDeletion"))
                $root.proto.TokenDeleteTransactionBody.encode(m.tokenDeletion, w.uint32(282).fork()).ldelim();
            if (m.tokenUpdate != null && Object.hasOwnProperty.call(m, "tokenUpdate"))
                $root.proto.TokenUpdateTransactionBody.encode(m.tokenUpdate, w.uint32(290).fork()).ldelim();
            if (m.tokenMint != null && Object.hasOwnProperty.call(m, "tokenMint"))
                $root.proto.TokenMintTransactionBody.encode(m.tokenMint, w.uint32(298).fork()).ldelim();
            if (m.tokenBurn != null && Object.hasOwnProperty.call(m, "tokenBurn"))
                $root.proto.TokenBurnTransactionBody.encode(m.tokenBurn, w.uint32(306).fork()).ldelim();
            if (m.tokenWipe != null && Object.hasOwnProperty.call(m, "tokenWipe"))
                $root.proto.TokenWipeAccountTransactionBody.encode(m.tokenWipe, w.uint32(314).fork()).ldelim();
            if (m.tokenAssociate != null && Object.hasOwnProperty.call(m, "tokenAssociate"))
                $root.proto.TokenAssociateTransactionBody.encode(m.tokenAssociate, w.uint32(322).fork()).ldelim();
            if (m.tokenDissociate != null && Object.hasOwnProperty.call(m, "tokenDissociate"))
                $root.proto.TokenDissociateTransactionBody.encode(m.tokenDissociate, w.uint32(330).fork()).ldelim();
            if (m.scheduleCreate != null && Object.hasOwnProperty.call(m, "scheduleCreate"))
                $root.proto.ScheduleCreateTransactionBody.encode(m.scheduleCreate, w.uint32(338).fork()).ldelim();
            if (m.scheduleDelete != null && Object.hasOwnProperty.call(m, "scheduleDelete"))
                $root.proto.ScheduleDeleteTransactionBody.encode(m.scheduleDelete, w.uint32(346).fork()).ldelim();
            if (m.scheduleSign != null && Object.hasOwnProperty.call(m, "scheduleSign"))
                $root.proto.ScheduleSignTransactionBody.encode(m.scheduleSign, w.uint32(354).fork()).ldelim();
            if (m.tokenFeeScheduleUpdate != null && Object.hasOwnProperty.call(m, "tokenFeeScheduleUpdate"))
                $root.proto.TokenFeeScheduleUpdateTransactionBody.encode(
                    m.tokenFeeScheduleUpdate,
                    w.uint32(362).fork()
                ).ldelim();
            if (m.tokenPause != null && Object.hasOwnProperty.call(m, "tokenPause"))
                $root.proto.TokenPauseTransactionBody.encode(m.tokenPause, w.uint32(370).fork()).ldelim();
            if (m.tokenUnpause != null && Object.hasOwnProperty.call(m, "tokenUnpause"))
                $root.proto.TokenUnpauseTransactionBody.encode(m.tokenUnpause, w.uint32(378).fork()).ldelim();
            if (m.cryptoApproveAllowance != null && Object.hasOwnProperty.call(m, "cryptoApproveAllowance"))
                $root.proto.CryptoApproveAllowanceTransactionBody.encode(
                    m.cryptoApproveAllowance,
                    w.uint32(386).fork()
                ).ldelim();
            if (m.cryptoDeleteAllowance != null && Object.hasOwnProperty.call(m, "cryptoDeleteAllowance"))
                $root.proto.CryptoDeleteAllowanceTransactionBody.encode(
                    m.cryptoDeleteAllowance,
                    w.uint32(394).fork()
                ).ldelim();
            if (m.ethereumTransaction != null && Object.hasOwnProperty.call(m, "ethereumTransaction"))
                $root.proto.EthereumTransactionBody.encode(m.ethereumTransaction, w.uint32(402).fork()).ldelim();
            if (m.nodeStakeUpdate != null && Object.hasOwnProperty.call(m, "nodeStakeUpdate"))
                $root.proto.NodeStakeUpdateTransactionBody.encode(m.nodeStakeUpdate, w.uint32(410).fork()).ldelim();
            if (m.utilPrng != null && Object.hasOwnProperty.call(m, "utilPrng"))
                $root.proto.UtilPrngTransactionBody.encode(m.utilPrng, w.uint32(418).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a TransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TransactionBody} TransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.TransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.transactionID = $root.proto.TransactionID.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.nodeAccountID = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    case 3: {
                        m.transactionFee = r.uint64();
                        break;
                    }
                    case 4: {
                        m.transactionValidDuration = $root.proto.Duration.decode(r, r.uint32());
                        break;
                    }
                    case 5: {
                        m.generateRecord = r.bool();
                        break;
                    }
                    case 6: {
                        m.memo = r.string();
                        break;
                    }
                    case 7: {
                        m.contractCall = $root.proto.ContractCallTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 8: {
                        m.contractCreateInstance = $root.proto.ContractCreateTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 9: {
                        m.contractUpdateInstance = $root.proto.ContractUpdateTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 22: {
                        m.contractDeleteInstance = $root.proto.ContractDeleteTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 50: {
                        m.ethereumTransaction = $root.proto.EthereumTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 10: {
                        m.cryptoAddLiveHash = $root.proto.CryptoAddLiveHashTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 48: {
                        m.cryptoApproveAllowance = $root.proto.CryptoApproveAllowanceTransactionBody.decode(
                            r,
                            r.uint32()
                        );
                        break;
                    }
                    case 49: {
                        m.cryptoDeleteAllowance = $root.proto.CryptoDeleteAllowanceTransactionBody.decode(
                            r,
                            r.uint32()
                        );
                        break;
                    }
                    case 11: {
                        m.cryptoCreateAccount = $root.proto.CryptoCreateTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 12: {
                        m.cryptoDelete = $root.proto.CryptoDeleteTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 13: {
                        m.cryptoDeleteLiveHash = $root.proto.CryptoDeleteLiveHashTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 14: {
                        m.cryptoTransfer = $root.proto.CryptoTransferTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 15: {
                        m.cryptoUpdateAccount = $root.proto.CryptoUpdateTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 16: {
                        m.fileAppend = $root.proto.FileAppendTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 17: {
                        m.fileCreate = $root.proto.FileCreateTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 18: {
                        m.fileDelete = $root.proto.FileDeleteTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 19: {
                        m.fileUpdate = $root.proto.FileUpdateTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 20: {
                        m.systemDelete = $root.proto.SystemDeleteTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 21: {
                        m.systemUndelete = $root.proto.SystemUndeleteTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 23: {
                        m.freeze = $root.proto.FreezeTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 24: {
                        m.consensusCreateTopic = $root.proto.ConsensusCreateTopicTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 25: {
                        m.consensusUpdateTopic = $root.proto.ConsensusUpdateTopicTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 26: {
                        m.consensusDeleteTopic = $root.proto.ConsensusDeleteTopicTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 27: {
                        m.consensusSubmitMessage = $root.proto.ConsensusSubmitMessageTransactionBody.decode(
                            r,
                            r.uint32()
                        );
                        break;
                    }
                    case 28: {
                        m.uncheckedSubmit = $root.proto.UncheckedSubmitBody.decode(r, r.uint32());
                        break;
                    }
                    case 29: {
                        m.tokenCreation = $root.proto.TokenCreateTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 31: {
                        m.tokenFreeze = $root.proto.TokenFreezeAccountTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 32: {
                        m.tokenUnfreeze = $root.proto.TokenUnfreezeAccountTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 33: {
                        m.tokenGrantKyc = $root.proto.TokenGrantKycTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 34: {
                        m.tokenRevokeKyc = $root.proto.TokenRevokeKycTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 35: {
                        m.tokenDeletion = $root.proto.TokenDeleteTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 36: {
                        m.tokenUpdate = $root.proto.TokenUpdateTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 37: {
                        m.tokenMint = $root.proto.TokenMintTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 38: {
                        m.tokenBurn = $root.proto.TokenBurnTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 39: {
                        m.tokenWipe = $root.proto.TokenWipeAccountTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 40: {
                        m.tokenAssociate = $root.proto.TokenAssociateTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 41: {
                        m.tokenDissociate = $root.proto.TokenDissociateTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 45: {
                        m.tokenFeeScheduleUpdate = $root.proto.TokenFeeScheduleUpdateTransactionBody.decode(
                            r,
                            r.uint32()
                        );
                        break;
                    }
                    case 46: {
                        m.tokenPause = $root.proto.TokenPauseTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 47: {
                        m.tokenUnpause = $root.proto.TokenUnpauseTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 42: {
                        m.scheduleCreate = $root.proto.ScheduleCreateTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 43: {
                        m.scheduleDelete = $root.proto.ScheduleDeleteTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 44: {
                        m.scheduleSign = $root.proto.ScheduleSignTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 51: {
                        m.nodeStakeUpdate = $root.proto.NodeStakeUpdateTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 52: {
                        m.utilPrng = $root.proto.UtilPrngTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TransactionBody
         * @function getTypeUrl
         * @memberof proto.TransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TransactionBody";
        };

        return TransactionBody;
    })();

    proto.SystemDeleteTransactionBody = (function () {
        /**
         * Properties of a SystemDeleteTransactionBody.
         * @memberof proto
         * @interface ISystemDeleteTransactionBody
         * @property {proto.IFileID|null} [fileID] The file ID of the file to delete, in the format used in transactions
         * @property {proto.IContractID|null} [contractID] The contract ID instance to delete, in the format used in transactions
         * @property {proto.ITimestampSeconds|null} [expirationTime] The timestamp in seconds at which the "deleted" file should truly be permanently deleted
         */

        /**
         * Constructs a new SystemDeleteTransactionBody.
         * @memberof proto
         * @classdesc Delete a file or smart contract - can only be done with a Hedera administrative multisignature.
         * When it is deleted, it immediately disappears from the system as seen by the user, but is still
         * stored internally until the expiration time, at which time it is truly and permanently deleted.
         * Until that time, it can be undeleted by the Hedera administrative multisignature. When a smart
         * contract is deleted, the cryptocurrency account within it continues to exist, and is not affected
         * by the expiration time here.
         * @implements ISystemDeleteTransactionBody
         * @constructor
         * @param {proto.ISystemDeleteTransactionBody=} [p] Properties to set
         */
        function SystemDeleteTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The file ID of the file to delete, in the format used in transactions
         * @member {proto.IFileID|null|undefined} fileID
         * @memberof proto.SystemDeleteTransactionBody
         * @instance
         */
        SystemDeleteTransactionBody.prototype.fileID = null;

        /**
         * The contract ID instance to delete, in the format used in transactions
         * @member {proto.IContractID|null|undefined} contractID
         * @memberof proto.SystemDeleteTransactionBody
         * @instance
         */
        SystemDeleteTransactionBody.prototype.contractID = null;

        /**
         * The timestamp in seconds at which the "deleted" file should truly be permanently deleted
         * @member {proto.ITimestampSeconds|null|undefined} expirationTime
         * @memberof proto.SystemDeleteTransactionBody
         * @instance
         */
        SystemDeleteTransactionBody.prototype.expirationTime = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * SystemDeleteTransactionBody id.
         * @member {"fileID"|"contractID"|undefined} id
         * @memberof proto.SystemDeleteTransactionBody
         * @instance
         */
        Object.defineProperty(SystemDeleteTransactionBody.prototype, "id", {
            get: $util.oneOfGetter(($oneOfFields = ["fileID", "contractID"])),
            set: $util.oneOfSetter($oneOfFields),
        });

        /**
         * Creates a new SystemDeleteTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.SystemDeleteTransactionBody
         * @static
         * @param {proto.ISystemDeleteTransactionBody=} [properties] Properties to set
         * @returns {proto.SystemDeleteTransactionBody} SystemDeleteTransactionBody instance
         */
        SystemDeleteTransactionBody.create = function create(properties) {
            return new SystemDeleteTransactionBody(properties);
        };

        /**
         * Encodes the specified SystemDeleteTransactionBody message. Does not implicitly {@link proto.SystemDeleteTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.SystemDeleteTransactionBody
         * @static
         * @param {proto.ISystemDeleteTransactionBody} m SystemDeleteTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SystemDeleteTransactionBody.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.fileID != null && Object.hasOwnProperty.call(m, "fileID"))
                $root.proto.FileID.encode(m.fileID, w.uint32(10).fork()).ldelim();
            if (m.contractID != null && Object.hasOwnProperty.call(m, "contractID"))
                $root.proto.ContractID.encode(m.contractID, w.uint32(18).fork()).ldelim();
            if (m.expirationTime != null && Object.hasOwnProperty.call(m, "expirationTime"))
                $root.proto.TimestampSeconds.encode(m.expirationTime, w.uint32(26).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a SystemDeleteTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SystemDeleteTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.SystemDeleteTransactionBody} SystemDeleteTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SystemDeleteTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.SystemDeleteTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.fileID = $root.proto.FileID.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.contractID = $root.proto.ContractID.decode(r, r.uint32());
                        break;
                    }
                    case 3: {
                        m.expirationTime = $root.proto.TimestampSeconds.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for SystemDeleteTransactionBody
         * @function getTypeUrl
         * @memberof proto.SystemDeleteTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SystemDeleteTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.SystemDeleteTransactionBody";
        };

        return SystemDeleteTransactionBody;
    })();

    proto.SystemUndeleteTransactionBody = (function () {
        /**
         * Properties of a SystemUndeleteTransactionBody.
         * @memberof proto
         * @interface ISystemUndeleteTransactionBody
         * @property {proto.IFileID|null} [fileID] The file ID to undelete, in the format used in transactions
         * @property {proto.IContractID|null} [contractID] The contract ID instance to undelete, in the format used in transactions
         */

        /**
         * Constructs a new SystemUndeleteTransactionBody.
         * @memberof proto
         * @classdesc Undelete a file or smart contract that was deleted by SystemDelete; requires a Hedera
         * administrative multisignature.
         * @implements ISystemUndeleteTransactionBody
         * @constructor
         * @param {proto.ISystemUndeleteTransactionBody=} [p] Properties to set
         */
        function SystemUndeleteTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The file ID to undelete, in the format used in transactions
         * @member {proto.IFileID|null|undefined} fileID
         * @memberof proto.SystemUndeleteTransactionBody
         * @instance
         */
        SystemUndeleteTransactionBody.prototype.fileID = null;

        /**
         * The contract ID instance to undelete, in the format used in transactions
         * @member {proto.IContractID|null|undefined} contractID
         * @memberof proto.SystemUndeleteTransactionBody
         * @instance
         */
        SystemUndeleteTransactionBody.prototype.contractID = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * SystemUndeleteTransactionBody id.
         * @member {"fileID"|"contractID"|undefined} id
         * @memberof proto.SystemUndeleteTransactionBody
         * @instance
         */
        Object.defineProperty(SystemUndeleteTransactionBody.prototype, "id", {
            get: $util.oneOfGetter(($oneOfFields = ["fileID", "contractID"])),
            set: $util.oneOfSetter($oneOfFields),
        });

        /**
         * Creates a new SystemUndeleteTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.SystemUndeleteTransactionBody
         * @static
         * @param {proto.ISystemUndeleteTransactionBody=} [properties] Properties to set
         * @returns {proto.SystemUndeleteTransactionBody} SystemUndeleteTransactionBody instance
         */
        SystemUndeleteTransactionBody.create = function create(properties) {
            return new SystemUndeleteTransactionBody(properties);
        };

        /**
         * Encodes the specified SystemUndeleteTransactionBody message. Does not implicitly {@link proto.SystemUndeleteTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.SystemUndeleteTransactionBody
         * @static
         * @param {proto.ISystemUndeleteTransactionBody} m SystemUndeleteTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SystemUndeleteTransactionBody.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.fileID != null && Object.hasOwnProperty.call(m, "fileID"))
                $root.proto.FileID.encode(m.fileID, w.uint32(10).fork()).ldelim();
            if (m.contractID != null && Object.hasOwnProperty.call(m, "contractID"))
                $root.proto.ContractID.encode(m.contractID, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a SystemUndeleteTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SystemUndeleteTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.SystemUndeleteTransactionBody} SystemUndeleteTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SystemUndeleteTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.SystemUndeleteTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.fileID = $root.proto.FileID.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.contractID = $root.proto.ContractID.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for SystemUndeleteTransactionBody
         * @function getTypeUrl
         * @memberof proto.SystemUndeleteTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SystemUndeleteTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.SystemUndeleteTransactionBody";
        };

        return SystemUndeleteTransactionBody;
    })();

    proto.FreezeTransactionBody = (function () {
        /**
         * Properties of a FreezeTransactionBody.
         * @memberof proto
         * @interface IFreezeTransactionBody
         * @property {number|null} [startHour] !! DEPRECATED and REJECTED by nodes
         * The start hour (in UTC time), a value between 0 and 23
         * @property {number|null} [startMin] !! DEPRECATED and REJECTED by nodes
         * The start minute (in UTC time), a value between 0 and 59
         * @property {number|null} [endHour] !! DEPRECATED and REJECTED by nodes
         * The end hour (in UTC time), a value between 0 and 23
         * @property {number|null} [endMin] !! DEPRECATED and REJECTED by nodes
         * The end minute (in UTC time), a value between 0 and 59
         * @property {proto.IFileID|null} [updateFile] If set, the file whose contents should be used for a network software update during the
         * maintenance window.
         * @property {Uint8Array|null} [fileHash] If set, the expected hash of the contents of the update file (used to verify the update).
         * @property {proto.ITimestamp|null} [startTime] The consensus time at which the maintenance window should begin.
         * @property {proto.FreezeType|null} [freezeType] The type of network freeze or upgrade operation to perform.
         */

        /**
         * Constructs a new FreezeTransactionBody.
         * @memberof proto
         * @classdesc At consensus, sets the consensus time at which the platform should stop creating events and
         * accepting transactions, and enter a maintenance window.
         * @implements IFreezeTransactionBody
         * @constructor
         * @param {proto.IFreezeTransactionBody=} [p] Properties to set
         */
        function FreezeTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * !! DEPRECATED and REJECTED by nodes
         * The start hour (in UTC time), a value between 0 and 23
         * @member {number} startHour
         * @memberof proto.FreezeTransactionBody
         * @instance
         */
        FreezeTransactionBody.prototype.startHour = 0;

        /**
         * !! DEPRECATED and REJECTED by nodes
         * The start minute (in UTC time), a value between 0 and 59
         * @member {number} startMin
         * @memberof proto.FreezeTransactionBody
         * @instance
         */
        FreezeTransactionBody.prototype.startMin = 0;

        /**
         * !! DEPRECATED and REJECTED by nodes
         * The end hour (in UTC time), a value between 0 and 23
         * @member {number} endHour
         * @memberof proto.FreezeTransactionBody
         * @instance
         */
        FreezeTransactionBody.prototype.endHour = 0;

        /**
         * !! DEPRECATED and REJECTED by nodes
         * The end minute (in UTC time), a value between 0 and 59
         * @member {number} endMin
         * @memberof proto.FreezeTransactionBody
         * @instance
         */
        FreezeTransactionBody.prototype.endMin = 0;

        /**
         * If set, the file whose contents should be used for a network software update during the
         * maintenance window.
         * @member {proto.IFileID|null|undefined} updateFile
         * @memberof proto.FreezeTransactionBody
         * @instance
         */
        FreezeTransactionBody.prototype.updateFile = null;

        /**
         * If set, the expected hash of the contents of the update file (used to verify the update).
         * @member {Uint8Array} fileHash
         * @memberof proto.FreezeTransactionBody
         * @instance
         */
        FreezeTransactionBody.prototype.fileHash = $util.newBuffer([]);

        /**
         * The consensus time at which the maintenance window should begin.
         * @member {proto.ITimestamp|null|undefined} startTime
         * @memberof proto.FreezeTransactionBody
         * @instance
         */
        FreezeTransactionBody.prototype.startTime = null;

        /**
         * The type of network freeze or upgrade operation to perform.
         * @member {proto.FreezeType} freezeType
         * @memberof proto.FreezeTransactionBody
         * @instance
         */
        FreezeTransactionBody.prototype.freezeType = 0;

        /**
         * Creates a new FreezeTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.FreezeTransactionBody
         * @static
         * @param {proto.IFreezeTransactionBody=} [properties] Properties to set
         * @returns {proto.FreezeTransactionBody} FreezeTransactionBody instance
         */
        FreezeTransactionBody.create = function create(properties) {
            return new FreezeTransactionBody(properties);
        };

        /**
         * Encodes the specified FreezeTransactionBody message. Does not implicitly {@link proto.FreezeTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.FreezeTransactionBody
         * @static
         * @param {proto.IFreezeTransactionBody} m FreezeTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FreezeTransactionBody.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.startHour != null && Object.hasOwnProperty.call(m, "startHour")) w.uint32(8).int32(m.startHour);
            if (m.startMin != null && Object.hasOwnProperty.call(m, "startMin")) w.uint32(16).int32(m.startMin);
            if (m.endHour != null && Object.hasOwnProperty.call(m, "endHour")) w.uint32(24).int32(m.endHour);
            if (m.endMin != null && Object.hasOwnProperty.call(m, "endMin")) w.uint32(32).int32(m.endMin);
            if (m.updateFile != null && Object.hasOwnProperty.call(m, "updateFile"))
                $root.proto.FileID.encode(m.updateFile, w.uint32(42).fork()).ldelim();
            if (m.fileHash != null && Object.hasOwnProperty.call(m, "fileHash")) w.uint32(50).bytes(m.fileHash);
            if (m.startTime != null && Object.hasOwnProperty.call(m, "startTime"))
                $root.proto.Timestamp.encode(m.startTime, w.uint32(58).fork()).ldelim();
            if (m.freezeType != null && Object.hasOwnProperty.call(m, "freezeType")) w.uint32(64).int32(m.freezeType);
            return w;
        };

        /**
         * Decodes a FreezeTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.FreezeTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.FreezeTransactionBody} FreezeTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FreezeTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.FreezeTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.startHour = r.int32();
                        break;
                    }
                    case 2: {
                        m.startMin = r.int32();
                        break;
                    }
                    case 3: {
                        m.endHour = r.int32();
                        break;
                    }
                    case 4: {
                        m.endMin = r.int32();
                        break;
                    }
                    case 5: {
                        m.updateFile = $root.proto.FileID.decode(r, r.uint32());
                        break;
                    }
                    case 6: {
                        m.fileHash = r.bytes();
                        break;
                    }
                    case 7: {
                        m.startTime = $root.proto.Timestamp.decode(r, r.uint32());
                        break;
                    }
                    case 8: {
                        m.freezeType = r.int32();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for FreezeTransactionBody
         * @function getTypeUrl
         * @memberof proto.FreezeTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        FreezeTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.FreezeTransactionBody";
        };

        return FreezeTransactionBody;
    })();

    /**
     * The type of network freeze or upgrade operation to be performed. This type dictates which
     * fields are required.
     * @name proto.FreezeType
     * @enum {number}
     * @property {number} UNKNOWN_FREEZE_TYPE=0 An (invalid) default value for this enum, to ensure the client explicitly sets
     * the intended type of freeze transaction.
     * @property {number} FREEZE_ONLY=1 Freezes the network at the specified time. The start_time field must be provided and
     * must reference a future time. Any values specified for the update_file and file_hash
     * fields will be ignored. This transaction does not perform any network changes or
     * upgrades and requires manual intervention to restart the network.
     * @property {number} PREPARE_UPGRADE=2 A non-freezing operation that initiates network wide preparation in advance of a
     * scheduled freeze upgrade. The update_file and file_hash fields must be provided and
     * valid. The start_time field may be omitted and any value present will be ignored.
     * @property {number} FREEZE_UPGRADE=3 Freezes the network at the specified time and performs the previously prepared
     * automatic upgrade across the entire network.
     * @property {number} FREEZE_ABORT=4 Aborts a pending network freeze operation.
     * @property {number} TELEMETRY_UPGRADE=5 Performs an immediate upgrade on auxilary services and containers providing
     * telemetry/metrics. Does not impact network operations.
     */
    proto.FreezeType = (function () {
        const valuesById = {},
            values = Object.create(valuesById);
        values[(valuesById[0] = "UNKNOWN_FREEZE_TYPE")] = 0;
        values[(valuesById[1] = "FREEZE_ONLY")] = 1;
        values[(valuesById[2] = "PREPARE_UPGRADE")] = 2;
        values[(valuesById[3] = "FREEZE_UPGRADE")] = 3;
        values[(valuesById[4] = "FREEZE_ABORT")] = 4;
        values[(valuesById[5] = "TELEMETRY_UPGRADE")] = 5;
        return values;
    })();

    proto.ContractCallTransactionBody = (function () {
        /**
         * Properties of a ContractCallTransactionBody.
         * @memberof proto
         * @interface IContractCallTransactionBody
         * @property {proto.IContractID|null} [contractID] The contract to call
         * @property {Long|null} [gas] the maximum amount of gas to use for the call
         * @property {Long|null} [amount] number of tinybars sent (the function must be payable if this is nonzero)
         * @property {Uint8Array|null} [functionParameters] which function to call, and the parameters to pass to the function
         */

        /**
         * Constructs a new ContractCallTransactionBody.
         * @memberof proto
         * @classdesc Call a function of the given smart contract instance, giving it functionParameters as its inputs.
         * The call can use at maximum the given amount of gas – the paying account will not be charged for
         * any unspent gas.
         *
         * If this function results in data being stored, an amount of gas is calculated that reflects this
         * storage burden.
         *
         * The amount of gas used, as well as other attributes of the transaction, e.g. size, number of
         * signatures to be verified, determine the fee for the transaction – which is charged to the paying
         * account.
         * @implements IContractCallTransactionBody
         * @constructor
         * @param {proto.IContractCallTransactionBody=} [p] Properties to set
         */
        function ContractCallTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The contract to call
         * @member {proto.IContractID|null|undefined} contractID
         * @memberof proto.ContractCallTransactionBody
         * @instance
         */
        ContractCallTransactionBody.prototype.contractID = null;

        /**
         * the maximum amount of gas to use for the call
         * @member {Long} gas
         * @memberof proto.ContractCallTransactionBody
         * @instance
         */
        ContractCallTransactionBody.prototype.gas = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * number of tinybars sent (the function must be payable if this is nonzero)
         * @member {Long} amount
         * @memberof proto.ContractCallTransactionBody
         * @instance
         */
        ContractCallTransactionBody.prototype.amount = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * which function to call, and the parameters to pass to the function
         * @member {Uint8Array} functionParameters
         * @memberof proto.ContractCallTransactionBody
         * @instance
         */
        ContractCallTransactionBody.prototype.functionParameters = $util.newBuffer([]);

        /**
         * Creates a new ContractCallTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.ContractCallTransactionBody
         * @static
         * @param {proto.IContractCallTransactionBody=} [properties] Properties to set
         * @returns {proto.ContractCallTransactionBody} ContractCallTransactionBody instance
         */
        ContractCallTransactionBody.create = function create(properties) {
            return new ContractCallTransactionBody(properties);
        };

        /**
         * Encodes the specified ContractCallTransactionBody message. Does not implicitly {@link proto.ContractCallTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.ContractCallTransactionBody
         * @static
         * @param {proto.IContractCallTransactionBody} m ContractCallTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractCallTransactionBody.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.contractID != null && Object.hasOwnProperty.call(m, "contractID"))
                $root.proto.ContractID.encode(m.contractID, w.uint32(10).fork()).ldelim();
            if (m.gas != null && Object.hasOwnProperty.call(m, "gas")) w.uint32(16).int64(m.gas);
            if (m.amount != null && Object.hasOwnProperty.call(m, "amount")) w.uint32(24).int64(m.amount);
            if (m.functionParameters != null && Object.hasOwnProperty.call(m, "functionParameters"))
                w.uint32(34).bytes(m.functionParameters);
            return w;
        };

        /**
         * Decodes a ContractCallTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ContractCallTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ContractCallTransactionBody} ContractCallTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractCallTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.ContractCallTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.contractID = $root.proto.ContractID.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.gas = r.int64();
                        break;
                    }
                    case 3: {
                        m.amount = r.int64();
                        break;
                    }
                    case 4: {
                        m.functionParameters = r.bytes();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ContractCallTransactionBody
         * @function getTypeUrl
         * @memberof proto.ContractCallTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ContractCallTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ContractCallTransactionBody";
        };

        return ContractCallTransactionBody;
    })();

    proto.ContractCreateTransactionBody = (function () {
        /**
         * Properties of a ContractCreateTransactionBody.
         * @memberof proto
         * @interface IContractCreateTransactionBody
         * @property {proto.IFileID|null} [fileID] The file containing the smart contract initcode. A copy will be made and held by the
         * contract instance, and have the same expiration time as the instance.
         * @property {Uint8Array|null} [initcode] The bytes of the smart contract initcode. This is only useful if the smart contract init
         * is less than the hedera transaction limit. In those cases fileID must be used.
         * @property {proto.IKey|null} [adminKey] the state of the instance and its fields can be modified arbitrarily if this key signs a
         * transaction to modify it. If this is null, then such modifications are not possible, and
         * there is no administrator that can override the normal operation of this smart contract
         * instance. Note that if it is created with no admin keys, then there is no administrator to
         * authorize changing the admin keys, so there can never be any admin keys for that instance.
         * @property {Long|null} [gas] gas to run the constructor
         * @property {Long|null} [initialBalance] initial number of tinybars to put into the cryptocurrency account associated with and owned
         * by the smart contract
         * @property {proto.IAccountID|null} [proxyAccountID] [Deprecated] ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an
         * invalid account, or is an account that isn't a node, then this account is automatically proxy
         * staked to a node chosen by the network, but without earning payments. If the proxyAccountID
         * account refuses to accept proxy staking , or if it is not currently running a node, then it
         * will behave as if  proxyAccountID was null.
         * @property {proto.IDuration|null} [autoRenewPeriod] the instance will charge its account every this many seconds to renew for this long
         * @property {Uint8Array|null} [constructorParameters] parameters to pass to the constructor
         * @property {proto.IShardID|null} [shardID] shard in which to create this
         * @property {proto.IRealmID|null} [realmID] realm in which to create this (leave this null to create a new realm)
         * @property {proto.IKey|null} [newRealmAdminKey] if realmID is null, then this the admin key for the new realm that will be created
         * @property {string|null} [memo] the memo that was submitted as part of the contract (max 100 bytes)
         * @property {number|null} [maxAutomaticTokenAssociations] The maximum number of tokens that this contract can be automatically associated
         * with (i.e., receive air-drops from).
         * @property {proto.IAccountID|null} [autoRenewAccountId] An account to charge for auto-renewal of this contract. If not set, or set to an
         * account with zero hbar balance, the contract's own hbar balance will be used to
         * cover auto-renewal fees.
         * @property {proto.IAccountID|null} [stakedAccountId] ID of the account to which this contract is staking.
         * @property {Long|null} [stakedNodeId] ID of the node this contract is staked to.
         * @property {boolean|null} [declineReward] If true, the contract declines receiving a staking reward. The default value is false.
         */

        /**
         * Constructs a new ContractCreateTransactionBody.
         * @memberof proto
         * @classdesc Start a new smart contract instance. After the instance is created, the ContractID for it is in
         * the receipt, and can be retrieved by the Record or with a GetByKey query. The instance will run
         * the bytecode, either stored in a previously created file or in the transaction body itself for
         * small contracts.
         *
         *
         * The constructor will be executed using the given amount of gas, and any unspent gas will be
         * refunded to the paying account. Constructor inputs come from the given constructorParameters.
         * - The instance will exist for autoRenewPeriod seconds. When that is reached, it will renew
         * itself for another autoRenewPeriod seconds by charging its associated cryptocurrency account
         * (which it creates here). If it has insufficient cryptocurrency to extend that long, it will
         * extend as long as it can. If its balance is zero, the instance will be deleted.
         *
         * - A smart contract instance normally enforces rules, so "the code is law". For example, an
         * ERC-20 contract prevents a transfer from being undone without a signature by the recipient of
         * the transfer. This is always enforced if the contract instance was created with the adminKeys
         * being null. But for some uses, it might be desirable to create something like an ERC-20
         * contract that has a specific group of trusted individuals who can act as a "supreme court"
         * with the ability to override the normal operation, when a sufficient number of them agree to
         * do so. If adminKeys is not null, then they can sign a transaction that can change the state of
         * the smart contract in arbitrary ways, such as to reverse a transaction that violates some
         * standard of behavior that is not covered by the code itself. The admin keys can also be used
         * to change the autoRenewPeriod, and change the adminKeys field itself. The API currently does
         * not implement this ability. But it does allow the adminKeys field to be set and queried, and
         * will in the future implement such admin abilities for any instance that has a non-null
         * adminKeys.
         *
         * - If this constructor stores information, it is charged gas to store it. There is a fee in hbars
         * to maintain that storage until the expiration time, and that fee is added as part of the
         * transaction fee.
         *
         * - An entity (account, file, or smart contract instance) must be created in a particular realm.
         * If the realmID is left null, then a new realm will be created with the given admin key. If a
         * new realm has a null adminKey, then anyone can create/modify/delete entities in that realm.
         * But if an admin key is given, then any transaction to create/modify/delete an entity in that
         * realm must be signed by that key, though anyone can still call functions on smart contract
         * instances that exist in that realm. A realm ceases to exist when everything within it has
         * expired and no longer exists.
         *
         * - The current API ignores shardID, realmID, and newRealmAdminKey, and creates everything in
         * shard 0 and realm 0, with a null key. Future versions of the API will support multiple realms
         * and multiple shards.
         *
         * - The optional memo field can contain a string whose length is up to 100 bytes. That is the size
         * after Unicode NFD then UTF-8 conversion. This field can be used to describe the smart contract.
         * It could also be used for other purposes. One recommended purpose is to hold a hexadecimal
         * string that is the SHA-384 hash of a PDF file containing a human-readable legal contract. Then,
         * if the admin keys are the public keys of human arbitrators, they can use that legal document to
         * guide their decisions during a binding arbitration tribunal, convened to consider any changes
         * to the smart contract in the future. The memo field can only be changed using the admin keys.
         * If there are no admin keys, then it cannot be changed after the smart contract is created.
         *
         * <b>Signing requirements:</b> If an admin key is set, it must sign the transaction. If an
         * auto-renew account is set, its key must sign the transaction.
         * @implements IContractCreateTransactionBody
         * @constructor
         * @param {proto.IContractCreateTransactionBody=} [p] Properties to set
         */
        function ContractCreateTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The file containing the smart contract initcode. A copy will be made and held by the
         * contract instance, and have the same expiration time as the instance.
         * @member {proto.IFileID|null|undefined} fileID
         * @memberof proto.ContractCreateTransactionBody
         * @instance
         */
        ContractCreateTransactionBody.prototype.fileID = null;

        /**
         * The bytes of the smart contract initcode. This is only useful if the smart contract init
         * is less than the hedera transaction limit. In those cases fileID must be used.
         * @member {Uint8Array|null|undefined} initcode
         * @memberof proto.ContractCreateTransactionBody
         * @instance
         */
        ContractCreateTransactionBody.prototype.initcode = null;

        /**
         * the state of the instance and its fields can be modified arbitrarily if this key signs a
         * transaction to modify it. If this is null, then such modifications are not possible, and
         * there is no administrator that can override the normal operation of this smart contract
         * instance. Note that if it is created with no admin keys, then there is no administrator to
         * authorize changing the admin keys, so there can never be any admin keys for that instance.
         * @member {proto.IKey|null|undefined} adminKey
         * @memberof proto.ContractCreateTransactionBody
         * @instance
         */
        ContractCreateTransactionBody.prototype.adminKey = null;

        /**
         * gas to run the constructor
         * @member {Long} gas
         * @memberof proto.ContractCreateTransactionBody
         * @instance
         */
        ContractCreateTransactionBody.prototype.gas = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * initial number of tinybars to put into the cryptocurrency account associated with and owned
         * by the smart contract
         * @member {Long} initialBalance
         * @memberof proto.ContractCreateTransactionBody
         * @instance
         */
        ContractCreateTransactionBody.prototype.initialBalance = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * [Deprecated] ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an
         * invalid account, or is an account that isn't a node, then this account is automatically proxy
         * staked to a node chosen by the network, but without earning payments. If the proxyAccountID
         * account refuses to accept proxy staking , or if it is not currently running a node, then it
         * will behave as if  proxyAccountID was null.
         * @member {proto.IAccountID|null|undefined} proxyAccountID
         * @memberof proto.ContractCreateTransactionBody
         * @instance
         */
        ContractCreateTransactionBody.prototype.proxyAccountID = null;

        /**
         * the instance will charge its account every this many seconds to renew for this long
         * @member {proto.IDuration|null|undefined} autoRenewPeriod
         * @memberof proto.ContractCreateTransactionBody
         * @instance
         */
        ContractCreateTransactionBody.prototype.autoRenewPeriod = null;

        /**
         * parameters to pass to the constructor
         * @member {Uint8Array} constructorParameters
         * @memberof proto.ContractCreateTransactionBody
         * @instance
         */
        ContractCreateTransactionBody.prototype.constructorParameters = $util.newBuffer([]);

        /**
         * shard in which to create this
         * @member {proto.IShardID|null|undefined} shardID
         * @memberof proto.ContractCreateTransactionBody
         * @instance
         */
        ContractCreateTransactionBody.prototype.shardID = null;

        /**
         * realm in which to create this (leave this null to create a new realm)
         * @member {proto.IRealmID|null|undefined} realmID
         * @memberof proto.ContractCreateTransactionBody
         * @instance
         */
        ContractCreateTransactionBody.prototype.realmID = null;

        /**
         * if realmID is null, then this the admin key for the new realm that will be created
         * @member {proto.IKey|null|undefined} newRealmAdminKey
         * @memberof proto.ContractCreateTransactionBody
         * @instance
         */
        ContractCreateTransactionBody.prototype.newRealmAdminKey = null;

        /**
         * the memo that was submitted as part of the contract (max 100 bytes)
         * @member {string} memo
         * @memberof proto.ContractCreateTransactionBody
         * @instance
         */
        ContractCreateTransactionBody.prototype.memo = "";

        /**
         * The maximum number of tokens that this contract can be automatically associated
         * with (i.e., receive air-drops from).
         * @member {number} maxAutomaticTokenAssociations
         * @memberof proto.ContractCreateTransactionBody
         * @instance
         */
        ContractCreateTransactionBody.prototype.maxAutomaticTokenAssociations = 0;

        /**
         * An account to charge for auto-renewal of this contract. If not set, or set to an
         * account with zero hbar balance, the contract's own hbar balance will be used to
         * cover auto-renewal fees.
         * @member {proto.IAccountID|null|undefined} autoRenewAccountId
         * @memberof proto.ContractCreateTransactionBody
         * @instance
         */
        ContractCreateTransactionBody.prototype.autoRenewAccountId = null;

        /**
         * ID of the account to which this contract is staking.
         * @member {proto.IAccountID|null|undefined} stakedAccountId
         * @memberof proto.ContractCreateTransactionBody
         * @instance
         */
        ContractCreateTransactionBody.prototype.stakedAccountId = null;

        /**
         * ID of the node this contract is staked to.
         * @member {Long|null|undefined} stakedNodeId
         * @memberof proto.ContractCreateTransactionBody
         * @instance
         */
        ContractCreateTransactionBody.prototype.stakedNodeId = null;

        /**
         * If true, the contract declines receiving a staking reward. The default value is false.
         * @member {boolean} declineReward
         * @memberof proto.ContractCreateTransactionBody
         * @instance
         */
        ContractCreateTransactionBody.prototype.declineReward = false;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * There are two ways to specify the initcode of a ContractCreateTransction. If the initcode is
         * large (> 5K) then it must be stored in a file as hex encoded ascii. If it is small then it may
         * either be stored as a hex encoded file or as a binary encoded field as part of the transaciton.
         * @member {"fileID"|"initcode"|undefined} initcodeSource
         * @memberof proto.ContractCreateTransactionBody
         * @instance
         */
        Object.defineProperty(ContractCreateTransactionBody.prototype, "initcodeSource", {
            get: $util.oneOfGetter(($oneOfFields = ["fileID", "initcode"])),
            set: $util.oneOfSetter($oneOfFields),
        });

        /**
         * ID of the new account or node to which this contract is staking.
         * @member {"stakedAccountId"|"stakedNodeId"|undefined} stakedId
         * @memberof proto.ContractCreateTransactionBody
         * @instance
         */
        Object.defineProperty(ContractCreateTransactionBody.prototype, "stakedId", {
            get: $util.oneOfGetter(($oneOfFields = ["stakedAccountId", "stakedNodeId"])),
            set: $util.oneOfSetter($oneOfFields),
        });

        /**
         * Creates a new ContractCreateTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.ContractCreateTransactionBody
         * @static
         * @param {proto.IContractCreateTransactionBody=} [properties] Properties to set
         * @returns {proto.ContractCreateTransactionBody} ContractCreateTransactionBody instance
         */
        ContractCreateTransactionBody.create = function create(properties) {
            return new ContractCreateTransactionBody(properties);
        };

        /**
         * Encodes the specified ContractCreateTransactionBody message. Does not implicitly {@link proto.ContractCreateTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.ContractCreateTransactionBody
         * @static
         * @param {proto.IContractCreateTransactionBody} m ContractCreateTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractCreateTransactionBody.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.fileID != null && Object.hasOwnProperty.call(m, "fileID"))
                $root.proto.FileID.encode(m.fileID, w.uint32(10).fork()).ldelim();
            if (m.adminKey != null && Object.hasOwnProperty.call(m, "adminKey"))
                $root.proto.Key.encode(m.adminKey, w.uint32(26).fork()).ldelim();
            if (m.gas != null && Object.hasOwnProperty.call(m, "gas")) w.uint32(32).int64(m.gas);
            if (m.initialBalance != null && Object.hasOwnProperty.call(m, "initialBalance"))
                w.uint32(40).int64(m.initialBalance);
            if (m.proxyAccountID != null && Object.hasOwnProperty.call(m, "proxyAccountID"))
                $root.proto.AccountID.encode(m.proxyAccountID, w.uint32(50).fork()).ldelim();
            if (m.autoRenewPeriod != null && Object.hasOwnProperty.call(m, "autoRenewPeriod"))
                $root.proto.Duration.encode(m.autoRenewPeriod, w.uint32(66).fork()).ldelim();
            if (m.constructorParameters != null && Object.hasOwnProperty.call(m, "constructorParameters"))
                w.uint32(74).bytes(m.constructorParameters);
            if (m.shardID != null && Object.hasOwnProperty.call(m, "shardID"))
                $root.proto.ShardID.encode(m.shardID, w.uint32(82).fork()).ldelim();
            if (m.realmID != null && Object.hasOwnProperty.call(m, "realmID"))
                $root.proto.RealmID.encode(m.realmID, w.uint32(90).fork()).ldelim();
            if (m.newRealmAdminKey != null && Object.hasOwnProperty.call(m, "newRealmAdminKey"))
                $root.proto.Key.encode(m.newRealmAdminKey, w.uint32(98).fork()).ldelim();
            if (m.memo != null && Object.hasOwnProperty.call(m, "memo")) w.uint32(106).string(m.memo);
            if (
                m.maxAutomaticTokenAssociations != null &&
                Object.hasOwnProperty.call(m, "maxAutomaticTokenAssociations")
            )
                w.uint32(112).int32(m.maxAutomaticTokenAssociations);
            if (m.autoRenewAccountId != null && Object.hasOwnProperty.call(m, "autoRenewAccountId"))
                $root.proto.AccountID.encode(m.autoRenewAccountId, w.uint32(122).fork()).ldelim();
            if (m.initcode != null && Object.hasOwnProperty.call(m, "initcode")) w.uint32(130).bytes(m.initcode);
            if (m.stakedAccountId != null && Object.hasOwnProperty.call(m, "stakedAccountId"))
                $root.proto.AccountID.encode(m.stakedAccountId, w.uint32(138).fork()).ldelim();
            if (m.stakedNodeId != null && Object.hasOwnProperty.call(m, "stakedNodeId"))
                w.uint32(144).int64(m.stakedNodeId);
            if (m.declineReward != null && Object.hasOwnProperty.call(m, "declineReward"))
                w.uint32(152).bool(m.declineReward);
            return w;
        };

        /**
         * Decodes a ContractCreateTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ContractCreateTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ContractCreateTransactionBody} ContractCreateTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractCreateTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.ContractCreateTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.fileID = $root.proto.FileID.decode(r, r.uint32());
                        break;
                    }
                    case 16: {
                        m.initcode = r.bytes();
                        break;
                    }
                    case 3: {
                        m.adminKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                    case 4: {
                        m.gas = r.int64();
                        break;
                    }
                    case 5: {
                        m.initialBalance = r.int64();
                        break;
                    }
                    case 6: {
                        m.proxyAccountID = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    case 8: {
                        m.autoRenewPeriod = $root.proto.Duration.decode(r, r.uint32());
                        break;
                    }
                    case 9: {
                        m.constructorParameters = r.bytes();
                        break;
                    }
                    case 10: {
                        m.shardID = $root.proto.ShardID.decode(r, r.uint32());
                        break;
                    }
                    case 11: {
                        m.realmID = $root.proto.RealmID.decode(r, r.uint32());
                        break;
                    }
                    case 12: {
                        m.newRealmAdminKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                    case 13: {
                        m.memo = r.string();
                        break;
                    }
                    case 14: {
                        m.maxAutomaticTokenAssociations = r.int32();
                        break;
                    }
                    case 15: {
                        m.autoRenewAccountId = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    case 17: {
                        m.stakedAccountId = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    case 18: {
                        m.stakedNodeId = r.int64();
                        break;
                    }
                    case 19: {
                        m.declineReward = r.bool();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ContractCreateTransactionBody
         * @function getTypeUrl
         * @memberof proto.ContractCreateTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ContractCreateTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ContractCreateTransactionBody";
        };

        return ContractCreateTransactionBody;
    })();

    proto.ContractUpdateTransactionBody = (function () {
        /**
         * Properties of a ContractUpdateTransactionBody.
         * @memberof proto
         * @interface IContractUpdateTransactionBody
         * @property {proto.IContractID|null} [contractID] The id of the contract to be updated
         * @property {proto.ITimestamp|null} [expirationTime] The new expiry of the contract, no earlier than the current expiry (resolves to
         * EXPIRATION_REDUCTION_NOT_ALLOWED otherwise)
         * @property {proto.IKey|null} [adminKey] The new key to control updates to the contract
         * @property {proto.IAccountID|null} [proxyAccountID] [Deprecated] The new id of the account to which the contract is proxy staked
         * @property {proto.IDuration|null} [autoRenewPeriod] If an auto-renew account is in use, the lifetime to be added by each auto-renewal.
         * @property {proto.IFileID|null} [fileID] This field is unused and will have no impact on the specified smart contract.
         * @property {string|null} [memo] [Deprecated] If set with a non-zero length, the new memo to be associated with the account
         * (UTF-8 encoding max 100 bytes)
         * @property {google.protobuf.IStringValue|null} [memoWrapper] If set, the new memo to be associated with the account (UTF-8 encoding max 100 bytes)
         * @property {google.protobuf.IInt32Value|null} [maxAutomaticTokenAssociations] If set, the new maximum number of tokens that this contract can be
         * automatically associated with (i.e., receive air-drops from).
         * @property {proto.IAccountID|null} [autoRenewAccountId] If set to the sentinel <tt>0.0.0</tt> AccountID, this field removes the contract's auto-renew
         * account. Otherwise it updates the contract's auto-renew account to the referenced account.
         * @property {proto.IAccountID|null} [stakedAccountId] ID of the new account to which this contract is staking. If set to the sentinel <tt>0.0.0</tt> AccountID,
         * this field removes the contract's staked account ID.
         * @property {Long|null} [stakedNodeId] ID of the new node this contract is staked to. If set to the sentinel <tt>-1</tt>, this field
         * removes the contract's staked node ID.
         * @property {google.protobuf.IBoolValue|null} [declineReward] If true, the contract declines receiving a staking reward.
         */

        /**
         * Constructs a new ContractUpdateTransactionBody.
         * @memberof proto
         * @classdesc At consensus, updates the fields of a smart contract to the given values.
         *
         * If no value is given for a field, that field is left unchanged on the contract. For an immutable
         * smart contract (that is, a contract created without an adminKey), only the expirationTime may be
         * updated; setting any other field in this case will cause the transaction status to resolve to
         * MODIFYING_IMMUTABLE_CONTRACT.
         *
         * --- Signing Requirements ---
         * 1. Whether or not a contract has an admin key, its expiry can be extended with only the
         * transaction payer's signature.
         * 2. Updating any other field of a mutable contract requires the admin key's signature.
         * 3. If the update transaction includes a new admin key, this new key must also sign <b>unless</b>
         * it is exactly an empty <tt>KeyList</tt>. This special sentinel key removes the existing admin
         * key and causes the contract to become immutable. (Other <tt>Key</tt> structures without a
         * constituent <tt>Ed25519</tt> key will be rejected with <tt>INVALID_ADMIN_KEY</tt>.)
         * 4. If the update transaction sets the AccountID auto_renew_account_id wrapper field to anything
         * other than the sentinel <tt>0.0.0</tt> value, then the key of the referenced account must sign.
         * @implements IContractUpdateTransactionBody
         * @constructor
         * @param {proto.IContractUpdateTransactionBody=} [p] Properties to set
         */
        function ContractUpdateTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The id of the contract to be updated
         * @member {proto.IContractID|null|undefined} contractID
         * @memberof proto.ContractUpdateTransactionBody
         * @instance
         */
        ContractUpdateTransactionBody.prototype.contractID = null;

        /**
         * The new expiry of the contract, no earlier than the current expiry (resolves to
         * EXPIRATION_REDUCTION_NOT_ALLOWED otherwise)
         * @member {proto.ITimestamp|null|undefined} expirationTime
         * @memberof proto.ContractUpdateTransactionBody
         * @instance
         */
        ContractUpdateTransactionBody.prototype.expirationTime = null;

        /**
         * The new key to control updates to the contract
         * @member {proto.IKey|null|undefined} adminKey
         * @memberof proto.ContractUpdateTransactionBody
         * @instance
         */
        ContractUpdateTransactionBody.prototype.adminKey = null;

        /**
         * [Deprecated] The new id of the account to which the contract is proxy staked
         * @member {proto.IAccountID|null|undefined} proxyAccountID
         * @memberof proto.ContractUpdateTransactionBody
         * @instance
         */
        ContractUpdateTransactionBody.prototype.proxyAccountID = null;

        /**
         * If an auto-renew account is in use, the lifetime to be added by each auto-renewal.
         * @member {proto.IDuration|null|undefined} autoRenewPeriod
         * @memberof proto.ContractUpdateTransactionBody
         * @instance
         */
        ContractUpdateTransactionBody.prototype.autoRenewPeriod = null;

        /**
         * This field is unused and will have no impact on the specified smart contract.
         * @member {proto.IFileID|null|undefined} fileID
         * @memberof proto.ContractUpdateTransactionBody
         * @instance
         */
        ContractUpdateTransactionBody.prototype.fileID = null;

        /**
         * [Deprecated] If set with a non-zero length, the new memo to be associated with the account
         * (UTF-8 encoding max 100 bytes)
         * @member {string|null|undefined} memo
         * @memberof proto.ContractUpdateTransactionBody
         * @instance
         */
        ContractUpdateTransactionBody.prototype.memo = null;

        /**
         * If set, the new memo to be associated with the account (UTF-8 encoding max 100 bytes)
         * @member {google.protobuf.IStringValue|null|undefined} memoWrapper
         * @memberof proto.ContractUpdateTransactionBody
         * @instance
         */
        ContractUpdateTransactionBody.prototype.memoWrapper = null;

        /**
         * If set, the new maximum number of tokens that this contract can be
         * automatically associated with (i.e., receive air-drops from).
         * @member {google.protobuf.IInt32Value|null|undefined} maxAutomaticTokenAssociations
         * @memberof proto.ContractUpdateTransactionBody
         * @instance
         */
        ContractUpdateTransactionBody.prototype.maxAutomaticTokenAssociations = null;

        /**
         * If set to the sentinel <tt>0.0.0</tt> AccountID, this field removes the contract's auto-renew
         * account. Otherwise it updates the contract's auto-renew account to the referenced account.
         * @member {proto.IAccountID|null|undefined} autoRenewAccountId
         * @memberof proto.ContractUpdateTransactionBody
         * @instance
         */
        ContractUpdateTransactionBody.prototype.autoRenewAccountId = null;

        /**
         * ID of the new account to which this contract is staking. If set to the sentinel <tt>0.0.0</tt> AccountID,
         * this field removes the contract's staked account ID.
         * @member {proto.IAccountID|null|undefined} stakedAccountId
         * @memberof proto.ContractUpdateTransactionBody
         * @instance
         */
        ContractUpdateTransactionBody.prototype.stakedAccountId = null;

        /**
         * ID of the new node this contract is staked to. If set to the sentinel <tt>-1</tt>, this field
         * removes the contract's staked node ID.
         * @member {Long|null|undefined} stakedNodeId
         * @memberof proto.ContractUpdateTransactionBody
         * @instance
         */
        ContractUpdateTransactionBody.prototype.stakedNodeId = null;

        /**
         * If true, the contract declines receiving a staking reward.
         * @member {google.protobuf.IBoolValue|null|undefined} declineReward
         * @memberof proto.ContractUpdateTransactionBody
         * @instance
         */
        ContractUpdateTransactionBody.prototype.declineReward = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * The new contract memo, assumed to be Unicode encoded with UTF-8 (at most 100 bytes)
         * @member {"memo"|"memoWrapper"|undefined} memoField
         * @memberof proto.ContractUpdateTransactionBody
         * @instance
         */
        Object.defineProperty(ContractUpdateTransactionBody.prototype, "memoField", {
            get: $util.oneOfGetter(($oneOfFields = ["memo", "memoWrapper"])),
            set: $util.oneOfSetter($oneOfFields),
        });

        /**
         * ID of the new account or node to which this contract is staking.
         * @member {"stakedAccountId"|"stakedNodeId"|undefined} stakedId
         * @memberof proto.ContractUpdateTransactionBody
         * @instance
         */
        Object.defineProperty(ContractUpdateTransactionBody.prototype, "stakedId", {
            get: $util.oneOfGetter(($oneOfFields = ["stakedAccountId", "stakedNodeId"])),
            set: $util.oneOfSetter($oneOfFields),
        });

        /**
         * Creates a new ContractUpdateTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.ContractUpdateTransactionBody
         * @static
         * @param {proto.IContractUpdateTransactionBody=} [properties] Properties to set
         * @returns {proto.ContractUpdateTransactionBody} ContractUpdateTransactionBody instance
         */
        ContractUpdateTransactionBody.create = function create(properties) {
            return new ContractUpdateTransactionBody(properties);
        };

        /**
         * Encodes the specified ContractUpdateTransactionBody message. Does not implicitly {@link proto.ContractUpdateTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.ContractUpdateTransactionBody
         * @static
         * @param {proto.IContractUpdateTransactionBody} m ContractUpdateTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractUpdateTransactionBody.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.contractID != null && Object.hasOwnProperty.call(m, "contractID"))
                $root.proto.ContractID.encode(m.contractID, w.uint32(10).fork()).ldelim();
            if (m.expirationTime != null && Object.hasOwnProperty.call(m, "expirationTime"))
                $root.proto.Timestamp.encode(m.expirationTime, w.uint32(18).fork()).ldelim();
            if (m.adminKey != null && Object.hasOwnProperty.call(m, "adminKey"))
                $root.proto.Key.encode(m.adminKey, w.uint32(26).fork()).ldelim();
            if (m.proxyAccountID != null && Object.hasOwnProperty.call(m, "proxyAccountID"))
                $root.proto.AccountID.encode(m.proxyAccountID, w.uint32(50).fork()).ldelim();
            if (m.autoRenewPeriod != null && Object.hasOwnProperty.call(m, "autoRenewPeriod"))
                $root.proto.Duration.encode(m.autoRenewPeriod, w.uint32(58).fork()).ldelim();
            if (m.fileID != null && Object.hasOwnProperty.call(m, "fileID"))
                $root.proto.FileID.encode(m.fileID, w.uint32(66).fork()).ldelim();
            if (m.memo != null && Object.hasOwnProperty.call(m, "memo")) w.uint32(74).string(m.memo);
            if (m.memoWrapper != null && Object.hasOwnProperty.call(m, "memoWrapper"))
                $root.google.protobuf.StringValue.encode(m.memoWrapper, w.uint32(82).fork()).ldelim();
            if (
                m.maxAutomaticTokenAssociations != null &&
                Object.hasOwnProperty.call(m, "maxAutomaticTokenAssociations")
            )
                $root.google.protobuf.Int32Value.encode(m.maxAutomaticTokenAssociations, w.uint32(90).fork()).ldelim();
            if (m.autoRenewAccountId != null && Object.hasOwnProperty.call(m, "autoRenewAccountId"))
                $root.proto.AccountID.encode(m.autoRenewAccountId, w.uint32(98).fork()).ldelim();
            if (m.stakedAccountId != null && Object.hasOwnProperty.call(m, "stakedAccountId"))
                $root.proto.AccountID.encode(m.stakedAccountId, w.uint32(106).fork()).ldelim();
            if (m.stakedNodeId != null && Object.hasOwnProperty.call(m, "stakedNodeId"))
                w.uint32(112).int64(m.stakedNodeId);
            if (m.declineReward != null && Object.hasOwnProperty.call(m, "declineReward"))
                $root.google.protobuf.BoolValue.encode(m.declineReward, w.uint32(122).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a ContractUpdateTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ContractUpdateTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ContractUpdateTransactionBody} ContractUpdateTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractUpdateTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.ContractUpdateTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.contractID = $root.proto.ContractID.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.expirationTime = $root.proto.Timestamp.decode(r, r.uint32());
                        break;
                    }
                    case 3: {
                        m.adminKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                    case 6: {
                        m.proxyAccountID = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    case 7: {
                        m.autoRenewPeriod = $root.proto.Duration.decode(r, r.uint32());
                        break;
                    }
                    case 8: {
                        m.fileID = $root.proto.FileID.decode(r, r.uint32());
                        break;
                    }
                    case 9: {
                        m.memo = r.string();
                        break;
                    }
                    case 10: {
                        m.memoWrapper = $root.google.protobuf.StringValue.decode(r, r.uint32());
                        break;
                    }
                    case 11: {
                        m.maxAutomaticTokenAssociations = $root.google.protobuf.Int32Value.decode(r, r.uint32());
                        break;
                    }
                    case 12: {
                        m.autoRenewAccountId = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    case 13: {
                        m.stakedAccountId = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    case 14: {
                        m.stakedNodeId = r.int64();
                        break;
                    }
                    case 15: {
                        m.declineReward = $root.google.protobuf.BoolValue.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ContractUpdateTransactionBody
         * @function getTypeUrl
         * @memberof proto.ContractUpdateTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ContractUpdateTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ContractUpdateTransactionBody";
        };

        return ContractUpdateTransactionBody;
    })();

    proto.LiveHash = (function () {
        /**
         * Properties of a LiveHash.
         * @memberof proto
         * @interface ILiveHash
         * @property {proto.IAccountID|null} [accountId] The account to which the livehash is attached
         * @property {Uint8Array|null} [hash] The SHA-384 hash of a credential or certificate
         * @property {proto.IKeyList|null} [keys] A list of keys (primitive or threshold), all of which must sign to attach the livehash to an account, and any one of which can later delete it.
         * @property {proto.IDuration|null} [duration] The duration for which the livehash will remain valid
         */

        /**
         * Constructs a new LiveHash.
         * @memberof proto
         * @classdesc A hash---presumably of some kind of credential or certificate---along with a list of keys, each
         * of which may be either a primitive or a threshold key.
         * @implements ILiveHash
         * @constructor
         * @param {proto.ILiveHash=} [p] Properties to set
         */
        function LiveHash(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The account to which the livehash is attached
         * @member {proto.IAccountID|null|undefined} accountId
         * @memberof proto.LiveHash
         * @instance
         */
        LiveHash.prototype.accountId = null;

        /**
         * The SHA-384 hash of a credential or certificate
         * @member {Uint8Array} hash
         * @memberof proto.LiveHash
         * @instance
         */
        LiveHash.prototype.hash = $util.newBuffer([]);

        /**
         * A list of keys (primitive or threshold), all of which must sign to attach the livehash to an account, and any one of which can later delete it.
         * @member {proto.IKeyList|null|undefined} keys
         * @memberof proto.LiveHash
         * @instance
         */
        LiveHash.prototype.keys = null;

        /**
         * The duration for which the livehash will remain valid
         * @member {proto.IDuration|null|undefined} duration
         * @memberof proto.LiveHash
         * @instance
         */
        LiveHash.prototype.duration = null;

        /**
         * Creates a new LiveHash instance using the specified properties.
         * @function create
         * @memberof proto.LiveHash
         * @static
         * @param {proto.ILiveHash=} [properties] Properties to set
         * @returns {proto.LiveHash} LiveHash instance
         */
        LiveHash.create = function create(properties) {
            return new LiveHash(properties);
        };

        /**
         * Encodes the specified LiveHash message. Does not implicitly {@link proto.LiveHash.verify|verify} messages.
         * @function encode
         * @memberof proto.LiveHash
         * @static
         * @param {proto.ILiveHash} m LiveHash message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LiveHash.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.accountId != null && Object.hasOwnProperty.call(m, "accountId"))
                $root.proto.AccountID.encode(m.accountId, w.uint32(10).fork()).ldelim();
            if (m.hash != null && Object.hasOwnProperty.call(m, "hash")) w.uint32(18).bytes(m.hash);
            if (m.keys != null && Object.hasOwnProperty.call(m, "keys"))
                $root.proto.KeyList.encode(m.keys, w.uint32(26).fork()).ldelim();
            if (m.duration != null && Object.hasOwnProperty.call(m, "duration"))
                $root.proto.Duration.encode(m.duration, w.uint32(42).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a LiveHash message from the specified reader or buffer.
         * @function decode
         * @memberof proto.LiveHash
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.LiveHash} LiveHash
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LiveHash.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.LiveHash();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.accountId = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.hash = r.bytes();
                        break;
                    }
                    case 3: {
                        m.keys = $root.proto.KeyList.decode(r, r.uint32());
                        break;
                    }
                    case 5: {
                        m.duration = $root.proto.Duration.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for LiveHash
         * @function getTypeUrl
         * @memberof proto.LiveHash
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        LiveHash.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.LiveHash";
        };

        return LiveHash;
    })();

    proto.CryptoAddLiveHashTransactionBody = (function () {
        /**
         * Properties of a CryptoAddLiveHashTransactionBody.
         * @memberof proto
         * @interface ICryptoAddLiveHashTransactionBody
         * @property {proto.ILiveHash|null} [liveHash] A hash of some credential or certificate, along with the keys of the entities that asserted it validity
         */

        /**
         * Constructs a new CryptoAddLiveHashTransactionBody.
         * @memberof proto
         * @classdesc At consensus, attaches the given livehash to the given account.  The hash can be deleted by the
         * key controlling the account, or by any of the keys associated to the livehash.  Hence livehashes
         * provide a revocation service for their implied credentials; for example, when an authority grants
         * a credential to the account, the account owner will cosign with the authority (or authorities) to
         * attach a hash of the credential to the account---hence proving the grant. If the credential is
         * revoked, then any of the authorities may delete it (or the account owner). In this way, the
         * livehash mechanism acts as a revocation service.  An account cannot have two identical livehashes
         * associated. To modify the list of keys in a livehash, the livehash should first be deleted, then
         * recreated with a new list of keys.
         * @implements ICryptoAddLiveHashTransactionBody
         * @constructor
         * @param {proto.ICryptoAddLiveHashTransactionBody=} [p] Properties to set
         */
        function CryptoAddLiveHashTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * A hash of some credential or certificate, along with the keys of the entities that asserted it validity
         * @member {proto.ILiveHash|null|undefined} liveHash
         * @memberof proto.CryptoAddLiveHashTransactionBody
         * @instance
         */
        CryptoAddLiveHashTransactionBody.prototype.liveHash = null;

        /**
         * Creates a new CryptoAddLiveHashTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.CryptoAddLiveHashTransactionBody
         * @static
         * @param {proto.ICryptoAddLiveHashTransactionBody=} [properties] Properties to set
         * @returns {proto.CryptoAddLiveHashTransactionBody} CryptoAddLiveHashTransactionBody instance
         */
        CryptoAddLiveHashTransactionBody.create = function create(properties) {
            return new CryptoAddLiveHashTransactionBody(properties);
        };

        /**
         * Encodes the specified CryptoAddLiveHashTransactionBody message. Does not implicitly {@link proto.CryptoAddLiveHashTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.CryptoAddLiveHashTransactionBody
         * @static
         * @param {proto.ICryptoAddLiveHashTransactionBody} m CryptoAddLiveHashTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CryptoAddLiveHashTransactionBody.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.liveHash != null && Object.hasOwnProperty.call(m, "liveHash"))
                $root.proto.LiveHash.encode(m.liveHash, w.uint32(26).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a CryptoAddLiveHashTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CryptoAddLiveHashTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.CryptoAddLiveHashTransactionBody} CryptoAddLiveHashTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CryptoAddLiveHashTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.CryptoAddLiveHashTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 3: {
                        m.liveHash = $root.proto.LiveHash.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for CryptoAddLiveHashTransactionBody
         * @function getTypeUrl
         * @memberof proto.CryptoAddLiveHashTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CryptoAddLiveHashTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.CryptoAddLiveHashTransactionBody";
        };

        return CryptoAddLiveHashTransactionBody;
    })();

    proto.CryptoCreateTransactionBody = (function () {
        /**
         * Properties of a CryptoCreateTransactionBody.
         * @memberof proto
         * @interface ICryptoCreateTransactionBody
         * @property {proto.IKey|null} [key] The key that must sign each transfer out of the account. If receiverSigRequired is true, then
         * it must also sign any transfer into the account.
         * @property {Long|null} [initialBalance] The initial number of tinybars to put into the account
         * @property {proto.IAccountID|null} [proxyAccountID] [Deprecated] ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an
         * invalid account, or is an account that isn't a node, then this account is automatically proxy
         * staked to a node chosen by the network, but without earning payments. If the proxyAccountID
         * account refuses to accept proxy staking , or if it is not currently running a node, then it
         * will behave as if proxyAccountID was null.
         * @property {Long|null} [sendRecordThreshold] [Deprecated]. The threshold amount (in tinybars) for which an account record is created for
         * any send/withdraw transaction
         * @property {Long|null} [receiveRecordThreshold] [Deprecated]. The threshold amount (in tinybars) for which an account record is created for
         * any receive/deposit transaction
         * @property {boolean|null} [receiverSigRequired] If true, this account's key must sign any transaction depositing into this account (in
         * addition to all withdrawals)
         * @property {proto.IDuration|null} [autoRenewPeriod] The account is charged to extend its expiration date every this many seconds. If it doesn't
         * have enough balance, it extends as long as possible. If it is empty when it expires, then it
         * is deleted.
         * @property {proto.IShardID|null} [shardID] The shard in which this account is created
         * @property {proto.IRealmID|null} [realmID] The realm in which this account is created (leave this null to create a new realm)
         * @property {proto.IKey|null} [newRealmAdminKey] If realmID is null, then this the admin key for the new realm that will be created
         * @property {string|null} [memo] The memo associated with the account (UTF-8 encoding max 100 bytes)
         * @property {number|null} [maxAutomaticTokenAssociations] The maximum number of tokens that an Account can be implicitly associated with. Defaults to 0
         * and up to a maximum value of 1000.
         * @property {proto.IAccountID|null} [stakedAccountId] ID of the account to which this account is staking.
         * @property {Long|null} [stakedNodeId] ID of the node this account is staked to.
         * @property {boolean|null} [declineReward] If true, the account declines receiving a staking reward. The default value is false.
         * @property {Uint8Array|null} [alias] The bytes to be used as the account's alias. It will be the
         * serialization of a protobuf Key message for an ED25519/ECDSA_SECP256K1 primitive key type. Currently only primitive key bytes are
         * supported as the key for an account with an alias. ThresholdKey, KeyList, ContractID, and
         * delegatable_contract_id are not supported.
         *
         * May also be the EOA 20-byte address to create that is derived from the keccak-256 hash of a ECDSA_SECP256K1 primitive key.
         *
         * A given alias can map to at most one account on the network at a time. This uniqueness will be enforced
         * relative to aliases currently on the network at alias assignment.
         *
         * If a transaction creates an account using an alias, any further crypto transfers to that alias will
         * simply be deposited in that account, without creating anything, and with no creation fee being charged.
         */

        /**
         * Constructs a new CryptoCreateTransactionBody.
         * @memberof proto
         * @classdesc Represents a CryptoCreateTransactionBody.
         * @implements ICryptoCreateTransactionBody
         * @constructor
         * @param {proto.ICryptoCreateTransactionBody=} [p] Properties to set
         */
        function CryptoCreateTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The key that must sign each transfer out of the account. If receiverSigRequired is true, then
         * it must also sign any transfer into the account.
         * @member {proto.IKey|null|undefined} key
         * @memberof proto.CryptoCreateTransactionBody
         * @instance
         */
        CryptoCreateTransactionBody.prototype.key = null;

        /**
         * The initial number of tinybars to put into the account
         * @member {Long} initialBalance
         * @memberof proto.CryptoCreateTransactionBody
         * @instance
         */
        CryptoCreateTransactionBody.prototype.initialBalance = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * [Deprecated] ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an
         * invalid account, or is an account that isn't a node, then this account is automatically proxy
         * staked to a node chosen by the network, but without earning payments. If the proxyAccountID
         * account refuses to accept proxy staking , or if it is not currently running a node, then it
         * will behave as if proxyAccountID was null.
         * @member {proto.IAccountID|null|undefined} proxyAccountID
         * @memberof proto.CryptoCreateTransactionBody
         * @instance
         */
        CryptoCreateTransactionBody.prototype.proxyAccountID = null;

        /**
         * [Deprecated]. The threshold amount (in tinybars) for which an account record is created for
         * any send/withdraw transaction
         * @member {Long} sendRecordThreshold
         * @memberof proto.CryptoCreateTransactionBody
         * @instance
         */
        CryptoCreateTransactionBody.prototype.sendRecordThreshold = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * [Deprecated]. The threshold amount (in tinybars) for which an account record is created for
         * any receive/deposit transaction
         * @member {Long} receiveRecordThreshold
         * @memberof proto.CryptoCreateTransactionBody
         * @instance
         */
        CryptoCreateTransactionBody.prototype.receiveRecordThreshold = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * If true, this account's key must sign any transaction depositing into this account (in
         * addition to all withdrawals)
         * @member {boolean} receiverSigRequired
         * @memberof proto.CryptoCreateTransactionBody
         * @instance
         */
        CryptoCreateTransactionBody.prototype.receiverSigRequired = false;

        /**
         * The account is charged to extend its expiration date every this many seconds. If it doesn't
         * have enough balance, it extends as long as possible. If it is empty when it expires, then it
         * is deleted.
         * @member {proto.IDuration|null|undefined} autoRenewPeriod
         * @memberof proto.CryptoCreateTransactionBody
         * @instance
         */
        CryptoCreateTransactionBody.prototype.autoRenewPeriod = null;

        /**
         * The shard in which this account is created
         * @member {proto.IShardID|null|undefined} shardID
         * @memberof proto.CryptoCreateTransactionBody
         * @instance
         */
        CryptoCreateTransactionBody.prototype.shardID = null;

        /**
         * The realm in which this account is created (leave this null to create a new realm)
         * @member {proto.IRealmID|null|undefined} realmID
         * @memberof proto.CryptoCreateTransactionBody
         * @instance
         */
        CryptoCreateTransactionBody.prototype.realmID = null;

        /**
         * If realmID is null, then this the admin key for the new realm that will be created
         * @member {proto.IKey|null|undefined} newRealmAdminKey
         * @memberof proto.CryptoCreateTransactionBody
         * @instance
         */
        CryptoCreateTransactionBody.prototype.newRealmAdminKey = null;

        /**
         * The memo associated with the account (UTF-8 encoding max 100 bytes)
         * @member {string} memo
         * @memberof proto.CryptoCreateTransactionBody
         * @instance
         */
        CryptoCreateTransactionBody.prototype.memo = "";

        /**
         * The maximum number of tokens that an Account can be implicitly associated with. Defaults to 0
         * and up to a maximum value of 1000.
         * @member {number} maxAutomaticTokenAssociations
         * @memberof proto.CryptoCreateTransactionBody
         * @instance
         */
        CryptoCreateTransactionBody.prototype.maxAutomaticTokenAssociations = 0;

        /**
         * ID of the account to which this account is staking.
         * @member {proto.IAccountID|null|undefined} stakedAccountId
         * @memberof proto.CryptoCreateTransactionBody
         * @instance
         */
        CryptoCreateTransactionBody.prototype.stakedAccountId = null;

        /**
         * ID of the node this account is staked to.
         * @member {Long|null|undefined} stakedNodeId
         * @memberof proto.CryptoCreateTransactionBody
         * @instance
         */
        CryptoCreateTransactionBody.prototype.stakedNodeId = null;

        /**
         * If true, the account declines receiving a staking reward. The default value is false.
         * @member {boolean} declineReward
         * @memberof proto.CryptoCreateTransactionBody
         * @instance
         */
        CryptoCreateTransactionBody.prototype.declineReward = false;

        /**
         * The bytes to be used as the account's alias. It will be the
         * serialization of a protobuf Key message for an ED25519/ECDSA_SECP256K1 primitive key type. Currently only primitive key bytes are
         * supported as the key for an account with an alias. ThresholdKey, KeyList, ContractID, and
         * delegatable_contract_id are not supported.
         *
         * May also be the EOA 20-byte address to create that is derived from the keccak-256 hash of a ECDSA_SECP256K1 primitive key.
         *
         * A given alias can map to at most one account on the network at a time. This uniqueness will be enforced
         * relative to aliases currently on the network at alias assignment.
         *
         * If a transaction creates an account using an alias, any further crypto transfers to that alias will
         * simply be deposited in that account, without creating anything, and with no creation fee being charged.
         * @member {Uint8Array} alias
         * @memberof proto.CryptoCreateTransactionBody
         * @instance
         */
        CryptoCreateTransactionBody.prototype.alias = $util.newBuffer([]);

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * ID of the account or node to which this account is staking.
         * @member {"stakedAccountId"|"stakedNodeId"|undefined} stakedId
         * @memberof proto.CryptoCreateTransactionBody
         * @instance
         */
        Object.defineProperty(CryptoCreateTransactionBody.prototype, "stakedId", {
            get: $util.oneOfGetter(($oneOfFields = ["stakedAccountId", "stakedNodeId"])),
            set: $util.oneOfSetter($oneOfFields),
        });

        /**
         * Creates a new CryptoCreateTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.CryptoCreateTransactionBody
         * @static
         * @param {proto.ICryptoCreateTransactionBody=} [properties] Properties to set
         * @returns {proto.CryptoCreateTransactionBody} CryptoCreateTransactionBody instance
         */
        CryptoCreateTransactionBody.create = function create(properties) {
            return new CryptoCreateTransactionBody(properties);
        };

        /**
         * Encodes the specified CryptoCreateTransactionBody message. Does not implicitly {@link proto.CryptoCreateTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.CryptoCreateTransactionBody
         * @static
         * @param {proto.ICryptoCreateTransactionBody} m CryptoCreateTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CryptoCreateTransactionBody.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.key != null && Object.hasOwnProperty.call(m, "key"))
                $root.proto.Key.encode(m.key, w.uint32(10).fork()).ldelim();
            if (m.initialBalance != null && Object.hasOwnProperty.call(m, "initialBalance"))
                w.uint32(16).uint64(m.initialBalance);
            if (m.proxyAccountID != null && Object.hasOwnProperty.call(m, "proxyAccountID"))
                $root.proto.AccountID.encode(m.proxyAccountID, w.uint32(26).fork()).ldelim();
            if (m.sendRecordThreshold != null && Object.hasOwnProperty.call(m, "sendRecordThreshold"))
                w.uint32(48).uint64(m.sendRecordThreshold);
            if (m.receiveRecordThreshold != null && Object.hasOwnProperty.call(m, "receiveRecordThreshold"))
                w.uint32(56).uint64(m.receiveRecordThreshold);
            if (m.receiverSigRequired != null && Object.hasOwnProperty.call(m, "receiverSigRequired"))
                w.uint32(64).bool(m.receiverSigRequired);
            if (m.autoRenewPeriod != null && Object.hasOwnProperty.call(m, "autoRenewPeriod"))
                $root.proto.Duration.encode(m.autoRenewPeriod, w.uint32(74).fork()).ldelim();
            if (m.shardID != null && Object.hasOwnProperty.call(m, "shardID"))
                $root.proto.ShardID.encode(m.shardID, w.uint32(82).fork()).ldelim();
            if (m.realmID != null && Object.hasOwnProperty.call(m, "realmID"))
                $root.proto.RealmID.encode(m.realmID, w.uint32(90).fork()).ldelim();
            if (m.newRealmAdminKey != null && Object.hasOwnProperty.call(m, "newRealmAdminKey"))
                $root.proto.Key.encode(m.newRealmAdminKey, w.uint32(98).fork()).ldelim();
            if (m.memo != null && Object.hasOwnProperty.call(m, "memo")) w.uint32(106).string(m.memo);
            if (
                m.maxAutomaticTokenAssociations != null &&
                Object.hasOwnProperty.call(m, "maxAutomaticTokenAssociations")
            )
                w.uint32(112).int32(m.maxAutomaticTokenAssociations);
            if (m.stakedAccountId != null && Object.hasOwnProperty.call(m, "stakedAccountId"))
                $root.proto.AccountID.encode(m.stakedAccountId, w.uint32(122).fork()).ldelim();
            if (m.stakedNodeId != null && Object.hasOwnProperty.call(m, "stakedNodeId"))
                w.uint32(128).int64(m.stakedNodeId);
            if (m.declineReward != null && Object.hasOwnProperty.call(m, "declineReward"))
                w.uint32(136).bool(m.declineReward);
            if (m.alias != null && Object.hasOwnProperty.call(m, "alias")) w.uint32(146).bytes(m.alias);
            return w;
        };

        /**
         * Decodes a CryptoCreateTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CryptoCreateTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.CryptoCreateTransactionBody} CryptoCreateTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CryptoCreateTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.CryptoCreateTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.key = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.initialBalance = r.uint64();
                        break;
                    }
                    case 3: {
                        m.proxyAccountID = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    case 6: {
                        m.sendRecordThreshold = r.uint64();
                        break;
                    }
                    case 7: {
                        m.receiveRecordThreshold = r.uint64();
                        break;
                    }
                    case 8: {
                        m.receiverSigRequired = r.bool();
                        break;
                    }
                    case 9: {
                        m.autoRenewPeriod = $root.proto.Duration.decode(r, r.uint32());
                        break;
                    }
                    case 10: {
                        m.shardID = $root.proto.ShardID.decode(r, r.uint32());
                        break;
                    }
                    case 11: {
                        m.realmID = $root.proto.RealmID.decode(r, r.uint32());
                        break;
                    }
                    case 12: {
                        m.newRealmAdminKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                    case 13: {
                        m.memo = r.string();
                        break;
                    }
                    case 14: {
                        m.maxAutomaticTokenAssociations = r.int32();
                        break;
                    }
                    case 15: {
                        m.stakedAccountId = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    case 16: {
                        m.stakedNodeId = r.int64();
                        break;
                    }
                    case 17: {
                        m.declineReward = r.bool();
                        break;
                    }
                    case 18: {
                        m.alias = r.bytes();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for CryptoCreateTransactionBody
         * @function getTypeUrl
         * @memberof proto.CryptoCreateTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CryptoCreateTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.CryptoCreateTransactionBody";
        };

        return CryptoCreateTransactionBody;
    })();

    proto.CryptoDeleteTransactionBody = (function () {
        /**
         * Properties of a CryptoDeleteTransactionBody.
         * @memberof proto
         * @interface ICryptoDeleteTransactionBody
         * @property {proto.IAccountID|null} [transferAccountID] The account ID which will receive all remaining hbars
         * @property {proto.IAccountID|null} [deleteAccountID] The account ID which should be deleted
         */

        /**
         * Constructs a new CryptoDeleteTransactionBody.
         * @memberof proto
         * @classdesc Mark an account as deleted, moving all its current hbars to another account. It will remain in
         * the ledger, marked as deleted, until it expires. Transfers into it a deleted account fail. But a
         * deleted account can still have its expiration extended in the normal way.
         * @implements ICryptoDeleteTransactionBody
         * @constructor
         * @param {proto.ICryptoDeleteTransactionBody=} [p] Properties to set
         */
        function CryptoDeleteTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The account ID which will receive all remaining hbars
         * @member {proto.IAccountID|null|undefined} transferAccountID
         * @memberof proto.CryptoDeleteTransactionBody
         * @instance
         */
        CryptoDeleteTransactionBody.prototype.transferAccountID = null;

        /**
         * The account ID which should be deleted
         * @member {proto.IAccountID|null|undefined} deleteAccountID
         * @memberof proto.CryptoDeleteTransactionBody
         * @instance
         */
        CryptoDeleteTransactionBody.prototype.deleteAccountID = null;

        /**
         * Creates a new CryptoDeleteTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.CryptoDeleteTransactionBody
         * @static
         * @param {proto.ICryptoDeleteTransactionBody=} [properties] Properties to set
         * @returns {proto.CryptoDeleteTransactionBody} CryptoDeleteTransactionBody instance
         */
        CryptoDeleteTransactionBody.create = function create(properties) {
            return new CryptoDeleteTransactionBody(properties);
        };

        /**
         * Encodes the specified CryptoDeleteTransactionBody message. Does not implicitly {@link proto.CryptoDeleteTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.CryptoDeleteTransactionBody
         * @static
         * @param {proto.ICryptoDeleteTransactionBody} m CryptoDeleteTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CryptoDeleteTransactionBody.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.transferAccountID != null && Object.hasOwnProperty.call(m, "transferAccountID"))
                $root.proto.AccountID.encode(m.transferAccountID, w.uint32(10).fork()).ldelim();
            if (m.deleteAccountID != null && Object.hasOwnProperty.call(m, "deleteAccountID"))
                $root.proto.AccountID.encode(m.deleteAccountID, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a CryptoDeleteTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CryptoDeleteTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.CryptoDeleteTransactionBody} CryptoDeleteTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CryptoDeleteTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.CryptoDeleteTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.transferAccountID = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.deleteAccountID = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for CryptoDeleteTransactionBody
         * @function getTypeUrl
         * @memberof proto.CryptoDeleteTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CryptoDeleteTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.CryptoDeleteTransactionBody";
        };

        return CryptoDeleteTransactionBody;
    })();

    proto.CryptoDeleteLiveHashTransactionBody = (function () {
        /**
         * Properties of a CryptoDeleteLiveHashTransactionBody.
         * @memberof proto
         * @interface ICryptoDeleteLiveHashTransactionBody
         * @property {proto.IAccountID|null} [accountOfLiveHash] The account owning the livehash
         * @property {Uint8Array|null} [liveHashToDelete] The SHA-384 livehash to delete from the account
         */

        /**
         * Constructs a new CryptoDeleteLiveHashTransactionBody.
         * @memberof proto
         * @classdesc At consensus, deletes a livehash associated to the given account. The transaction must be signed
         * by either the key of the owning account, or at least one of the keys associated to the livehash.
         * @implements ICryptoDeleteLiveHashTransactionBody
         * @constructor
         * @param {proto.ICryptoDeleteLiveHashTransactionBody=} [p] Properties to set
         */
        function CryptoDeleteLiveHashTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The account owning the livehash
         * @member {proto.IAccountID|null|undefined} accountOfLiveHash
         * @memberof proto.CryptoDeleteLiveHashTransactionBody
         * @instance
         */
        CryptoDeleteLiveHashTransactionBody.prototype.accountOfLiveHash = null;

        /**
         * The SHA-384 livehash to delete from the account
         * @member {Uint8Array} liveHashToDelete
         * @memberof proto.CryptoDeleteLiveHashTransactionBody
         * @instance
         */
        CryptoDeleteLiveHashTransactionBody.prototype.liveHashToDelete = $util.newBuffer([]);

        /**
         * Creates a new CryptoDeleteLiveHashTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.CryptoDeleteLiveHashTransactionBody
         * @static
         * @param {proto.ICryptoDeleteLiveHashTransactionBody=} [properties] Properties to set
         * @returns {proto.CryptoDeleteLiveHashTransactionBody} CryptoDeleteLiveHashTransactionBody instance
         */
        CryptoDeleteLiveHashTransactionBody.create = function create(properties) {
            return new CryptoDeleteLiveHashTransactionBody(properties);
        };

        /**
         * Encodes the specified CryptoDeleteLiveHashTransactionBody message. Does not implicitly {@link proto.CryptoDeleteLiveHashTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.CryptoDeleteLiveHashTransactionBody
         * @static
         * @param {proto.ICryptoDeleteLiveHashTransactionBody} m CryptoDeleteLiveHashTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CryptoDeleteLiveHashTransactionBody.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.accountOfLiveHash != null && Object.hasOwnProperty.call(m, "accountOfLiveHash"))
                $root.proto.AccountID.encode(m.accountOfLiveHash, w.uint32(10).fork()).ldelim();
            if (m.liveHashToDelete != null && Object.hasOwnProperty.call(m, "liveHashToDelete"))
                w.uint32(18).bytes(m.liveHashToDelete);
            return w;
        };

        /**
         * Decodes a CryptoDeleteLiveHashTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CryptoDeleteLiveHashTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.CryptoDeleteLiveHashTransactionBody} CryptoDeleteLiveHashTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CryptoDeleteLiveHashTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.CryptoDeleteLiveHashTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.accountOfLiveHash = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.liveHashToDelete = r.bytes();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for CryptoDeleteLiveHashTransactionBody
         * @function getTypeUrl
         * @memberof proto.CryptoDeleteLiveHashTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CryptoDeleteLiveHashTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.CryptoDeleteLiveHashTransactionBody";
        };

        return CryptoDeleteLiveHashTransactionBody;
    })();

    proto.CryptoTransferTransactionBody = (function () {
        /**
         * Properties of a CryptoTransferTransactionBody.
         * @memberof proto
         * @interface ICryptoTransferTransactionBody
         * @property {proto.ITransferList|null} [transfers] The desired hbar balance adjustments
         * @property {Array.<proto.ITokenTransferList>|null} [tokenTransfers] The desired token unit balance adjustments; if any custom fees are assessed, the ledger will
         * try to deduct them from the payer of this CryptoTransfer, resolving the transaction to
         * INSUFFICIENT_PAYER_BALANCE_FOR_CUSTOM_FEE if this is not possible
         */

        /**
         * Constructs a new CryptoTransferTransactionBody.
         * @memberof proto
         * @classdesc Transfers cryptocurrency among two or more accounts by making the desired adjustments to their
         * balances. Each transfer list can specify up to 10 adjustments. Each negative amount is withdrawn
         * from the corresponding account (a sender), and each positive one is added to the corresponding
         * account (a receiver). The amounts list must sum to zero. Each amount is a number of tinybars
         * (there are 100,000,000 tinybars in one hbar).  If any sender account fails to have sufficient
         * hbars, then the entire transaction fails, and none of those transfers occur, though the
         * transaction fee is still charged. This transaction must be signed by the keys for all the sending
         * accounts, and for any receiving accounts that have receiverSigRequired == true. The signatures
         * are in the same order as the accounts, skipping those accounts that don't need a signature.
         * @implements ICryptoTransferTransactionBody
         * @constructor
         * @param {proto.ICryptoTransferTransactionBody=} [p] Properties to set
         */
        function CryptoTransferTransactionBody(p) {
            this.tokenTransfers = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The desired hbar balance adjustments
         * @member {proto.ITransferList|null|undefined} transfers
         * @memberof proto.CryptoTransferTransactionBody
         * @instance
         */
        CryptoTransferTransactionBody.prototype.transfers = null;

        /**
         * The desired token unit balance adjustments; if any custom fees are assessed, the ledger will
         * try to deduct them from the payer of this CryptoTransfer, resolving the transaction to
         * INSUFFICIENT_PAYER_BALANCE_FOR_CUSTOM_FEE if this is not possible
         * @member {Array.<proto.ITokenTransferList>} tokenTransfers
         * @memberof proto.CryptoTransferTransactionBody
         * @instance
         */
        CryptoTransferTransactionBody.prototype.tokenTransfers = $util.emptyArray;

        /**
         * Creates a new CryptoTransferTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.CryptoTransferTransactionBody
         * @static
         * @param {proto.ICryptoTransferTransactionBody=} [properties] Properties to set
         * @returns {proto.CryptoTransferTransactionBody} CryptoTransferTransactionBody instance
         */
        CryptoTransferTransactionBody.create = function create(properties) {
            return new CryptoTransferTransactionBody(properties);
        };

        /**
         * Encodes the specified CryptoTransferTransactionBody message. Does not implicitly {@link proto.CryptoTransferTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.CryptoTransferTransactionBody
         * @static
         * @param {proto.ICryptoTransferTransactionBody} m CryptoTransferTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CryptoTransferTransactionBody.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.transfers != null && Object.hasOwnProperty.call(m, "transfers"))
                $root.proto.TransferList.encode(m.transfers, w.uint32(10).fork()).ldelim();
            if (m.tokenTransfers != null && m.tokenTransfers.length) {
                for (var i = 0; i < m.tokenTransfers.length; ++i)
                    $root.proto.TokenTransferList.encode(m.tokenTransfers[i], w.uint32(18).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a CryptoTransferTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CryptoTransferTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.CryptoTransferTransactionBody} CryptoTransferTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CryptoTransferTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.CryptoTransferTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.transfers = $root.proto.TransferList.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        if (!(m.tokenTransfers && m.tokenTransfers.length)) m.tokenTransfers = [];
                        m.tokenTransfers.push($root.proto.TokenTransferList.decode(r, r.uint32()));
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for CryptoTransferTransactionBody
         * @function getTypeUrl
         * @memberof proto.CryptoTransferTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CryptoTransferTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.CryptoTransferTransactionBody";
        };

        return CryptoTransferTransactionBody;
    })();

    proto.CryptoUpdateTransactionBody = (function () {
        /**
         * Properties of a CryptoUpdateTransactionBody.
         * @memberof proto
         * @interface ICryptoUpdateTransactionBody
         * @property {proto.IAccountID|null} [accountIDToUpdate] The account ID which is being updated in this transaction
         * @property {proto.IKey|null} [key] The new key
         * @property {proto.IAccountID|null} [proxyAccountID] [Deprecated] ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an
         * invalid account, or is an account that isn't a node, then this account is automatically proxy
         * staked to a node chosen by the network, but without earning payments. If the proxyAccountID
         * account refuses to accept proxy staking , or if it is not currently running a node, then it
         * will behave as if proxyAccountID was null.
         * @property {number|null} [proxyFraction] [Deprecated]. Payments earned from proxy staking are shared between the node and this
         * account, with proxyFraction / 10000 going to this account
         * @property {Long|null} [sendRecordThreshold] [Deprecated]. The new threshold amount (in tinybars) for which an account record is
         * created for any send/withdraw transaction
         * @property {google.protobuf.IUInt64Value|null} [sendRecordThresholdWrapper] [Deprecated]. The new threshold amount (in tinybars) for which an account record is
         * created for any send/withdraw transaction
         * @property {Long|null} [receiveRecordThreshold] [Deprecated]. The new threshold amount (in tinybars) for which an account record is
         * created for any receive/deposit transaction.
         * @property {google.protobuf.IUInt64Value|null} [receiveRecordThresholdWrapper] [Deprecated]. The new threshold amount (in tinybars) for which an account record is
         * created for any receive/deposit transaction.
         * @property {proto.IDuration|null} [autoRenewPeriod] The duration in which it will automatically extend the expiration period. If it doesn't have
         * enough balance, it extends as long as possible. If it is empty when it expires, then it is
         * deleted.
         * @property {proto.ITimestamp|null} [expirationTime] The new expiration time to extend to (ignored if equal to or before the current one)
         * @property {boolean|null} [receiverSigRequired] [Deprecated] Do NOT use this field to set a false value because the server cannot
         * distinguish from the default value. Use receiverSigRequiredWrapper field for this
         * purpose.
         * @property {google.protobuf.IBoolValue|null} [receiverSigRequiredWrapper] If true, this account's key must sign any transaction depositing into this account (in
         * addition to all withdrawals)
         * @property {google.protobuf.IStringValue|null} [memo] If set, the new memo to be associated with the account (UTF-8 encoding max 100 bytes)
         * @property {google.protobuf.IInt32Value|null} [maxAutomaticTokenAssociations] The maximum number of tokens that an Account can be implicitly associated with. Up to a 1000
         * including implicit and explicit associations.
         * @property {proto.IAccountID|null} [stakedAccountId] ID of the new account to which this account is staking. If set to the sentinel <tt>0.0.0</tt> AccountID,
         * this field removes this account's staked account ID.
         * @property {Long|null} [stakedNodeId] ID of the new node this account is staked to. If set to the sentinel <tt>-1</tt>, this field
         * removes this account's staked node ID.
         * @property {google.protobuf.IBoolValue|null} [declineReward] If true, the account declines receiving a staking reward. The default value is false.
         */

        /**
         * Constructs a new CryptoUpdateTransactionBody.
         * @memberof proto
         * @classdesc Change properties for the given account. Any null field is ignored (left unchanged). This
         * transaction must be signed by the existing key for this account. If the transaction is changing
         * the key field, then the transaction must be signed by both the old key (from before the change)
         * and the new key. The old key must sign for security. The new key must sign as a safeguard to
         * avoid accidentally changing to an invalid key, and then having no way to recover.
         * If the update transaction sets the <tt>auto_renew_account</tt> field to anything other
         * than the sentinel <tt>0.0.0</tt>, the key of the referenced account must sign.
         * @implements ICryptoUpdateTransactionBody
         * @constructor
         * @param {proto.ICryptoUpdateTransactionBody=} [p] Properties to set
         */
        function CryptoUpdateTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The account ID which is being updated in this transaction
         * @member {proto.IAccountID|null|undefined} accountIDToUpdate
         * @memberof proto.CryptoUpdateTransactionBody
         * @instance
         */
        CryptoUpdateTransactionBody.prototype.accountIDToUpdate = null;

        /**
         * The new key
         * @member {proto.IKey|null|undefined} key
         * @memberof proto.CryptoUpdateTransactionBody
         * @instance
         */
        CryptoUpdateTransactionBody.prototype.key = null;

        /**
         * [Deprecated] ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an
         * invalid account, or is an account that isn't a node, then this account is automatically proxy
         * staked to a node chosen by the network, but without earning payments. If the proxyAccountID
         * account refuses to accept proxy staking , or if it is not currently running a node, then it
         * will behave as if proxyAccountID was null.
         * @member {proto.IAccountID|null|undefined} proxyAccountID
         * @memberof proto.CryptoUpdateTransactionBody
         * @instance
         */
        CryptoUpdateTransactionBody.prototype.proxyAccountID = null;

        /**
         * [Deprecated]. Payments earned from proxy staking are shared between the node and this
         * account, with proxyFraction / 10000 going to this account
         * @member {number} proxyFraction
         * @memberof proto.CryptoUpdateTransactionBody
         * @instance
         */
        CryptoUpdateTransactionBody.prototype.proxyFraction = 0;

        /**
         * [Deprecated]. The new threshold amount (in tinybars) for which an account record is
         * created for any send/withdraw transaction
         * @member {Long|null|undefined} sendRecordThreshold
         * @memberof proto.CryptoUpdateTransactionBody
         * @instance
         */
        CryptoUpdateTransactionBody.prototype.sendRecordThreshold = null;

        /**
         * [Deprecated]. The new threshold amount (in tinybars) for which an account record is
         * created for any send/withdraw transaction
         * @member {google.protobuf.IUInt64Value|null|undefined} sendRecordThresholdWrapper
         * @memberof proto.CryptoUpdateTransactionBody
         * @instance
         */
        CryptoUpdateTransactionBody.prototype.sendRecordThresholdWrapper = null;

        /**
         * [Deprecated]. The new threshold amount (in tinybars) for which an account record is
         * created for any receive/deposit transaction.
         * @member {Long|null|undefined} receiveRecordThreshold
         * @memberof proto.CryptoUpdateTransactionBody
         * @instance
         */
        CryptoUpdateTransactionBody.prototype.receiveRecordThreshold = null;

        /**
         * [Deprecated]. The new threshold amount (in tinybars) for which an account record is
         * created for any receive/deposit transaction.
         * @member {google.protobuf.IUInt64Value|null|undefined} receiveRecordThresholdWrapper
         * @memberof proto.CryptoUpdateTransactionBody
         * @instance
         */
        CryptoUpdateTransactionBody.prototype.receiveRecordThresholdWrapper = null;

        /**
         * The duration in which it will automatically extend the expiration period. If it doesn't have
         * enough balance, it extends as long as possible. If it is empty when it expires, then it is
         * deleted.
         * @member {proto.IDuration|null|undefined} autoRenewPeriod
         * @memberof proto.CryptoUpdateTransactionBody
         * @instance
         */
        CryptoUpdateTransactionBody.prototype.autoRenewPeriod = null;

        /**
         * The new expiration time to extend to (ignored if equal to or before the current one)
         * @member {proto.ITimestamp|null|undefined} expirationTime
         * @memberof proto.CryptoUpdateTransactionBody
         * @instance
         */
        CryptoUpdateTransactionBody.prototype.expirationTime = null;

        /**
         * [Deprecated] Do NOT use this field to set a false value because the server cannot
         * distinguish from the default value. Use receiverSigRequiredWrapper field for this
         * purpose.
         * @member {boolean|null|undefined} receiverSigRequired
         * @memberof proto.CryptoUpdateTransactionBody
         * @instance
         */
        CryptoUpdateTransactionBody.prototype.receiverSigRequired = null;

        /**
         * If true, this account's key must sign any transaction depositing into this account (in
         * addition to all withdrawals)
         * @member {google.protobuf.IBoolValue|null|undefined} receiverSigRequiredWrapper
         * @memberof proto.CryptoUpdateTransactionBody
         * @instance
         */
        CryptoUpdateTransactionBody.prototype.receiverSigRequiredWrapper = null;

        /**
         * If set, the new memo to be associated with the account (UTF-8 encoding max 100 bytes)
         * @member {google.protobuf.IStringValue|null|undefined} memo
         * @memberof proto.CryptoUpdateTransactionBody
         * @instance
         */
        CryptoUpdateTransactionBody.prototype.memo = null;

        /**
         * The maximum number of tokens that an Account can be implicitly associated with. Up to a 1000
         * including implicit and explicit associations.
         * @member {google.protobuf.IInt32Value|null|undefined} maxAutomaticTokenAssociations
         * @memberof proto.CryptoUpdateTransactionBody
         * @instance
         */
        CryptoUpdateTransactionBody.prototype.maxAutomaticTokenAssociations = null;

        /**
         * ID of the new account to which this account is staking. If set to the sentinel <tt>0.0.0</tt> AccountID,
         * this field removes this account's staked account ID.
         * @member {proto.IAccountID|null|undefined} stakedAccountId
         * @memberof proto.CryptoUpdateTransactionBody
         * @instance
         */
        CryptoUpdateTransactionBody.prototype.stakedAccountId = null;

        /**
         * ID of the new node this account is staked to. If set to the sentinel <tt>-1</tt>, this field
         * removes this account's staked node ID.
         * @member {Long|null|undefined} stakedNodeId
         * @memberof proto.CryptoUpdateTransactionBody
         * @instance
         */
        CryptoUpdateTransactionBody.prototype.stakedNodeId = null;

        /**
         * If true, the account declines receiving a staking reward. The default value is false.
         * @member {google.protobuf.IBoolValue|null|undefined} declineReward
         * @memberof proto.CryptoUpdateTransactionBody
         * @instance
         */
        CryptoUpdateTransactionBody.prototype.declineReward = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * CryptoUpdateTransactionBody sendRecordThresholdField.
         * @member {"sendRecordThreshold"|"sendRecordThresholdWrapper"|undefined} sendRecordThresholdField
         * @memberof proto.CryptoUpdateTransactionBody
         * @instance
         */
        Object.defineProperty(CryptoUpdateTransactionBody.prototype, "sendRecordThresholdField", {
            get: $util.oneOfGetter(($oneOfFields = ["sendRecordThreshold", "sendRecordThresholdWrapper"])),
            set: $util.oneOfSetter($oneOfFields),
        });

        /**
         * CryptoUpdateTransactionBody receiveRecordThresholdField.
         * @member {"receiveRecordThreshold"|"receiveRecordThresholdWrapper"|undefined} receiveRecordThresholdField
         * @memberof proto.CryptoUpdateTransactionBody
         * @instance
         */
        Object.defineProperty(CryptoUpdateTransactionBody.prototype, "receiveRecordThresholdField", {
            get: $util.oneOfGetter(($oneOfFields = ["receiveRecordThreshold", "receiveRecordThresholdWrapper"])),
            set: $util.oneOfSetter($oneOfFields),
        });

        /**
         * CryptoUpdateTransactionBody receiverSigRequiredField.
         * @member {"receiverSigRequired"|"receiverSigRequiredWrapper"|undefined} receiverSigRequiredField
         * @memberof proto.CryptoUpdateTransactionBody
         * @instance
         */
        Object.defineProperty(CryptoUpdateTransactionBody.prototype, "receiverSigRequiredField", {
            get: $util.oneOfGetter(($oneOfFields = ["receiverSigRequired", "receiverSigRequiredWrapper"])),
            set: $util.oneOfSetter($oneOfFields),
        });

        /**
         * ID of the account or node to which this account is staking.
         * @member {"stakedAccountId"|"stakedNodeId"|undefined} stakedId
         * @memberof proto.CryptoUpdateTransactionBody
         * @instance
         */
        Object.defineProperty(CryptoUpdateTransactionBody.prototype, "stakedId", {
            get: $util.oneOfGetter(($oneOfFields = ["stakedAccountId", "stakedNodeId"])),
            set: $util.oneOfSetter($oneOfFields),
        });

        /**
         * Creates a new CryptoUpdateTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.CryptoUpdateTransactionBody
         * @static
         * @param {proto.ICryptoUpdateTransactionBody=} [properties] Properties to set
         * @returns {proto.CryptoUpdateTransactionBody} CryptoUpdateTransactionBody instance
         */
        CryptoUpdateTransactionBody.create = function create(properties) {
            return new CryptoUpdateTransactionBody(properties);
        };

        /**
         * Encodes the specified CryptoUpdateTransactionBody message. Does not implicitly {@link proto.CryptoUpdateTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.CryptoUpdateTransactionBody
         * @static
         * @param {proto.ICryptoUpdateTransactionBody} m CryptoUpdateTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CryptoUpdateTransactionBody.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.accountIDToUpdate != null && Object.hasOwnProperty.call(m, "accountIDToUpdate"))
                $root.proto.AccountID.encode(m.accountIDToUpdate, w.uint32(18).fork()).ldelim();
            if (m.key != null && Object.hasOwnProperty.call(m, "key"))
                $root.proto.Key.encode(m.key, w.uint32(26).fork()).ldelim();
            if (m.proxyAccountID != null && Object.hasOwnProperty.call(m, "proxyAccountID"))
                $root.proto.AccountID.encode(m.proxyAccountID, w.uint32(34).fork()).ldelim();
            if (m.proxyFraction != null && Object.hasOwnProperty.call(m, "proxyFraction"))
                w.uint32(40).int32(m.proxyFraction);
            if (m.sendRecordThreshold != null && Object.hasOwnProperty.call(m, "sendRecordThreshold"))
                w.uint32(48).uint64(m.sendRecordThreshold);
            if (m.receiveRecordThreshold != null && Object.hasOwnProperty.call(m, "receiveRecordThreshold"))
                w.uint32(56).uint64(m.receiveRecordThreshold);
            if (m.autoRenewPeriod != null && Object.hasOwnProperty.call(m, "autoRenewPeriod"))
                $root.proto.Duration.encode(m.autoRenewPeriod, w.uint32(66).fork()).ldelim();
            if (m.expirationTime != null && Object.hasOwnProperty.call(m, "expirationTime"))
                $root.proto.Timestamp.encode(m.expirationTime, w.uint32(74).fork()).ldelim();
            if (m.receiverSigRequired != null && Object.hasOwnProperty.call(m, "receiverSigRequired"))
                w.uint32(80).bool(m.receiverSigRequired);
            if (m.sendRecordThresholdWrapper != null && Object.hasOwnProperty.call(m, "sendRecordThresholdWrapper"))
                $root.google.protobuf.UInt64Value.encode(m.sendRecordThresholdWrapper, w.uint32(90).fork()).ldelim();
            if (
                m.receiveRecordThresholdWrapper != null &&
                Object.hasOwnProperty.call(m, "receiveRecordThresholdWrapper")
            )
                $root.google.protobuf.UInt64Value.encode(m.receiveRecordThresholdWrapper, w.uint32(98).fork()).ldelim();
            if (m.receiverSigRequiredWrapper != null && Object.hasOwnProperty.call(m, "receiverSigRequiredWrapper"))
                $root.google.protobuf.BoolValue.encode(m.receiverSigRequiredWrapper, w.uint32(106).fork()).ldelim();
            if (m.memo != null && Object.hasOwnProperty.call(m, "memo"))
                $root.google.protobuf.StringValue.encode(m.memo, w.uint32(114).fork()).ldelim();
            if (
                m.maxAutomaticTokenAssociations != null &&
                Object.hasOwnProperty.call(m, "maxAutomaticTokenAssociations")
            )
                $root.google.protobuf.Int32Value.encode(m.maxAutomaticTokenAssociations, w.uint32(122).fork()).ldelim();
            if (m.stakedAccountId != null && Object.hasOwnProperty.call(m, "stakedAccountId"))
                $root.proto.AccountID.encode(m.stakedAccountId, w.uint32(130).fork()).ldelim();
            if (m.stakedNodeId != null && Object.hasOwnProperty.call(m, "stakedNodeId"))
                w.uint32(136).int64(m.stakedNodeId);
            if (m.declineReward != null && Object.hasOwnProperty.call(m, "declineReward"))
                $root.google.protobuf.BoolValue.encode(m.declineReward, w.uint32(146).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a CryptoUpdateTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CryptoUpdateTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.CryptoUpdateTransactionBody} CryptoUpdateTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CryptoUpdateTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.CryptoUpdateTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 2: {
                        m.accountIDToUpdate = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    case 3: {
                        m.key = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                    case 4: {
                        m.proxyAccountID = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    case 5: {
                        m.proxyFraction = r.int32();
                        break;
                    }
                    case 6: {
                        m.sendRecordThreshold = r.uint64();
                        break;
                    }
                    case 11: {
                        m.sendRecordThresholdWrapper = $root.google.protobuf.UInt64Value.decode(r, r.uint32());
                        break;
                    }
                    case 7: {
                        m.receiveRecordThreshold = r.uint64();
                        break;
                    }
                    case 12: {
                        m.receiveRecordThresholdWrapper = $root.google.protobuf.UInt64Value.decode(r, r.uint32());
                        break;
                    }
                    case 8: {
                        m.autoRenewPeriod = $root.proto.Duration.decode(r, r.uint32());
                        break;
                    }
                    case 9: {
                        m.expirationTime = $root.proto.Timestamp.decode(r, r.uint32());
                        break;
                    }
                    case 10: {
                        m.receiverSigRequired = r.bool();
                        break;
                    }
                    case 13: {
                        m.receiverSigRequiredWrapper = $root.google.protobuf.BoolValue.decode(r, r.uint32());
                        break;
                    }
                    case 14: {
                        m.memo = $root.google.protobuf.StringValue.decode(r, r.uint32());
                        break;
                    }
                    case 15: {
                        m.maxAutomaticTokenAssociations = $root.google.protobuf.Int32Value.decode(r, r.uint32());
                        break;
                    }
                    case 16: {
                        m.stakedAccountId = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    case 17: {
                        m.stakedNodeId = r.int64();
                        break;
                    }
                    case 18: {
                        m.declineReward = $root.google.protobuf.BoolValue.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for CryptoUpdateTransactionBody
         * @function getTypeUrl
         * @memberof proto.CryptoUpdateTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CryptoUpdateTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.CryptoUpdateTransactionBody";
        };

        return CryptoUpdateTransactionBody;
    })();

    proto.CryptoApproveAllowanceTransactionBody = (function () {
        /**
         * Properties of a CryptoApproveAllowanceTransactionBody.
         * @memberof proto
         * @interface ICryptoApproveAllowanceTransactionBody
         * @property {Array.<proto.ICryptoAllowance>|null} [cryptoAllowances] List of hbar allowances approved by the account owner.
         * @property {Array.<proto.INftAllowance>|null} [nftAllowances] List of non-fungible token allowances approved by the account owner.
         * @property {Array.<proto.ITokenAllowance>|null} [tokenAllowances] List of fungible token allowances approved by the account owner.
         */

        /**
         * Constructs a new CryptoApproveAllowanceTransactionBody.
         * @memberof proto
         * @classdesc Creates one or more hbar/token approved allowances <b>relative to the owner account specified in the allowances of
         * this transaction</b>. Each allowance grants a spender the right to transfer a pre-determined amount of the owner's
         * hbar/token to any other account of the spender's choice. If the owner is not specified in any allowance, the payer
         * of transaction is considered to be the owner for that particular allowance.
         * Setting the amount to zero in CryptoAllowance or TokenAllowance will remove the respective allowance for the spender.
         *
         * (So if account <tt>0.0.X</tt> pays for this transaction and owner is not specified in the allowance,
         * then at consensus each spender account will have new allowances to spend hbar or tokens from <tt>0.0.X</tt>).
         * @implements ICryptoApproveAllowanceTransactionBody
         * @constructor
         * @param {proto.ICryptoApproveAllowanceTransactionBody=} [p] Properties to set
         */
        function CryptoApproveAllowanceTransactionBody(p) {
            this.cryptoAllowances = [];
            this.nftAllowances = [];
            this.tokenAllowances = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * List of hbar allowances approved by the account owner.
         * @member {Array.<proto.ICryptoAllowance>} cryptoAllowances
         * @memberof proto.CryptoApproveAllowanceTransactionBody
         * @instance
         */
        CryptoApproveAllowanceTransactionBody.prototype.cryptoAllowances = $util.emptyArray;

        /**
         * List of non-fungible token allowances approved by the account owner.
         * @member {Array.<proto.INftAllowance>} nftAllowances
         * @memberof proto.CryptoApproveAllowanceTransactionBody
         * @instance
         */
        CryptoApproveAllowanceTransactionBody.prototype.nftAllowances = $util.emptyArray;

        /**
         * List of fungible token allowances approved by the account owner.
         * @member {Array.<proto.ITokenAllowance>} tokenAllowances
         * @memberof proto.CryptoApproveAllowanceTransactionBody
         * @instance
         */
        CryptoApproveAllowanceTransactionBody.prototype.tokenAllowances = $util.emptyArray;

        /**
         * Creates a new CryptoApproveAllowanceTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.CryptoApproveAllowanceTransactionBody
         * @static
         * @param {proto.ICryptoApproveAllowanceTransactionBody=} [properties] Properties to set
         * @returns {proto.CryptoApproveAllowanceTransactionBody} CryptoApproveAllowanceTransactionBody instance
         */
        CryptoApproveAllowanceTransactionBody.create = function create(properties) {
            return new CryptoApproveAllowanceTransactionBody(properties);
        };

        /**
         * Encodes the specified CryptoApproveAllowanceTransactionBody message. Does not implicitly {@link proto.CryptoApproveAllowanceTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.CryptoApproveAllowanceTransactionBody
         * @static
         * @param {proto.ICryptoApproveAllowanceTransactionBody} m CryptoApproveAllowanceTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CryptoApproveAllowanceTransactionBody.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.cryptoAllowances != null && m.cryptoAllowances.length) {
                for (var i = 0; i < m.cryptoAllowances.length; ++i)
                    $root.proto.CryptoAllowance.encode(m.cryptoAllowances[i], w.uint32(10).fork()).ldelim();
            }
            if (m.nftAllowances != null && m.nftAllowances.length) {
                for (var i = 0; i < m.nftAllowances.length; ++i)
                    $root.proto.NftAllowance.encode(m.nftAllowances[i], w.uint32(18).fork()).ldelim();
            }
            if (m.tokenAllowances != null && m.tokenAllowances.length) {
                for (var i = 0; i < m.tokenAllowances.length; ++i)
                    $root.proto.TokenAllowance.encode(m.tokenAllowances[i], w.uint32(26).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a CryptoApproveAllowanceTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CryptoApproveAllowanceTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.CryptoApproveAllowanceTransactionBody} CryptoApproveAllowanceTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CryptoApproveAllowanceTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.CryptoApproveAllowanceTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        if (!(m.cryptoAllowances && m.cryptoAllowances.length)) m.cryptoAllowances = [];
                        m.cryptoAllowances.push($root.proto.CryptoAllowance.decode(r, r.uint32()));
                        break;
                    }
                    case 2: {
                        if (!(m.nftAllowances && m.nftAllowances.length)) m.nftAllowances = [];
                        m.nftAllowances.push($root.proto.NftAllowance.decode(r, r.uint32()));
                        break;
                    }
                    case 3: {
                        if (!(m.tokenAllowances && m.tokenAllowances.length)) m.tokenAllowances = [];
                        m.tokenAllowances.push($root.proto.TokenAllowance.decode(r, r.uint32()));
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for CryptoApproveAllowanceTransactionBody
         * @function getTypeUrl
         * @memberof proto.CryptoApproveAllowanceTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CryptoApproveAllowanceTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.CryptoApproveAllowanceTransactionBody";
        };

        return CryptoApproveAllowanceTransactionBody;
    })();

    proto.CryptoAllowance = (function () {
        /**
         * Properties of a CryptoAllowance.
         * @memberof proto
         * @interface ICryptoAllowance
         * @property {proto.IAccountID|null} [owner] The account ID of the hbar owner (ie. the grantor of the allowance).
         * @property {proto.IAccountID|null} [spender] The account ID of the spender of the hbar allowance.
         * @property {Long|null} [amount] The amount of the spender's allowance in tinybars.
         */

        /**
         * Constructs a new CryptoAllowance.
         * @memberof proto
         * @classdesc An approved allowance of hbar transfers for a spender.
         * @implements ICryptoAllowance
         * @constructor
         * @param {proto.ICryptoAllowance=} [p] Properties to set
         */
        function CryptoAllowance(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The account ID of the hbar owner (ie. the grantor of the allowance).
         * @member {proto.IAccountID|null|undefined} owner
         * @memberof proto.CryptoAllowance
         * @instance
         */
        CryptoAllowance.prototype.owner = null;

        /**
         * The account ID of the spender of the hbar allowance.
         * @member {proto.IAccountID|null|undefined} spender
         * @memberof proto.CryptoAllowance
         * @instance
         */
        CryptoAllowance.prototype.spender = null;

        /**
         * The amount of the spender's allowance in tinybars.
         * @member {Long} amount
         * @memberof proto.CryptoAllowance
         * @instance
         */
        CryptoAllowance.prototype.amount = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * Creates a new CryptoAllowance instance using the specified properties.
         * @function create
         * @memberof proto.CryptoAllowance
         * @static
         * @param {proto.ICryptoAllowance=} [properties] Properties to set
         * @returns {proto.CryptoAllowance} CryptoAllowance instance
         */
        CryptoAllowance.create = function create(properties) {
            return new CryptoAllowance(properties);
        };

        /**
         * Encodes the specified CryptoAllowance message. Does not implicitly {@link proto.CryptoAllowance.verify|verify} messages.
         * @function encode
         * @memberof proto.CryptoAllowance
         * @static
         * @param {proto.ICryptoAllowance} m CryptoAllowance message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CryptoAllowance.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.owner != null && Object.hasOwnProperty.call(m, "owner"))
                $root.proto.AccountID.encode(m.owner, w.uint32(10).fork()).ldelim();
            if (m.spender != null && Object.hasOwnProperty.call(m, "spender"))
                $root.proto.AccountID.encode(m.spender, w.uint32(18).fork()).ldelim();
            if (m.amount != null && Object.hasOwnProperty.call(m, "amount")) w.uint32(24).int64(m.amount);
            return w;
        };

        /**
         * Decodes a CryptoAllowance message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CryptoAllowance
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.CryptoAllowance} CryptoAllowance
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CryptoAllowance.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.CryptoAllowance();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.owner = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.spender = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    case 3: {
                        m.amount = r.int64();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for CryptoAllowance
         * @function getTypeUrl
         * @memberof proto.CryptoAllowance
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CryptoAllowance.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.CryptoAllowance";
        };

        return CryptoAllowance;
    })();

    proto.NftAllowance = (function () {
        /**
         * Properties of a NftAllowance.
         * @memberof proto
         * @interface INftAllowance
         * @property {proto.ITokenID|null} [tokenId] The NFT token type that the allowance pertains to.
         * @property {proto.IAccountID|null} [owner] The account ID of the token owner (ie. the grantor of the allowance).
         * @property {proto.IAccountID|null} [spender] The account ID of the token allowance spender.
         * @property {Array.<Long>|null} [serialNumbers] The list of serial numbers that the spender is permitted to transfer.
         * @property {google.protobuf.IBoolValue|null} [approvedForAll] If true, the spender has access to all of the owner's NFT units of type tokenId (currently
         * owned and any in the future).
         * @property {proto.IAccountID|null} [delegatingSpender] The account ID of the spender who is granted approvedForAll allowance and granting
         * approval on an NFT serial to another spender.
         */

        /**
         * Constructs a new NftAllowance.
         * @memberof proto
         * @classdesc An approved allowance of non-fungible token transfers for a spender.
         * @implements INftAllowance
         * @constructor
         * @param {proto.INftAllowance=} [p] Properties to set
         */
        function NftAllowance(p) {
            this.serialNumbers = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The NFT token type that the allowance pertains to.
         * @member {proto.ITokenID|null|undefined} tokenId
         * @memberof proto.NftAllowance
         * @instance
         */
        NftAllowance.prototype.tokenId = null;

        /**
         * The account ID of the token owner (ie. the grantor of the allowance).
         * @member {proto.IAccountID|null|undefined} owner
         * @memberof proto.NftAllowance
         * @instance
         */
        NftAllowance.prototype.owner = null;

        /**
         * The account ID of the token allowance spender.
         * @member {proto.IAccountID|null|undefined} spender
         * @memberof proto.NftAllowance
         * @instance
         */
        NftAllowance.prototype.spender = null;

        /**
         * The list of serial numbers that the spender is permitted to transfer.
         * @member {Array.<Long>} serialNumbers
         * @memberof proto.NftAllowance
         * @instance
         */
        NftAllowance.prototype.serialNumbers = $util.emptyArray;

        /**
         * If true, the spender has access to all of the owner's NFT units of type tokenId (currently
         * owned and any in the future).
         * @member {google.protobuf.IBoolValue|null|undefined} approvedForAll
         * @memberof proto.NftAllowance
         * @instance
         */
        NftAllowance.prototype.approvedForAll = null;

        /**
         * The account ID of the spender who is granted approvedForAll allowance and granting
         * approval on an NFT serial to another spender.
         * @member {proto.IAccountID|null|undefined} delegatingSpender
         * @memberof proto.NftAllowance
         * @instance
         */
        NftAllowance.prototype.delegatingSpender = null;

        /**
         * Creates a new NftAllowance instance using the specified properties.
         * @function create
         * @memberof proto.NftAllowance
         * @static
         * @param {proto.INftAllowance=} [properties] Properties to set
         * @returns {proto.NftAllowance} NftAllowance instance
         */
        NftAllowance.create = function create(properties) {
            return new NftAllowance(properties);
        };

        /**
         * Encodes the specified NftAllowance message. Does not implicitly {@link proto.NftAllowance.verify|verify} messages.
         * @function encode
         * @memberof proto.NftAllowance
         * @static
         * @param {proto.INftAllowance} m NftAllowance message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NftAllowance.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.tokenId != null && Object.hasOwnProperty.call(m, "tokenId"))
                $root.proto.TokenID.encode(m.tokenId, w.uint32(10).fork()).ldelim();
            if (m.owner != null && Object.hasOwnProperty.call(m, "owner"))
                $root.proto.AccountID.encode(m.owner, w.uint32(18).fork()).ldelim();
            if (m.spender != null && Object.hasOwnProperty.call(m, "spender"))
                $root.proto.AccountID.encode(m.spender, w.uint32(26).fork()).ldelim();
            if (m.serialNumbers != null && m.serialNumbers.length) {
                w.uint32(34).fork();
                for (var i = 0; i < m.serialNumbers.length; ++i) w.int64(m.serialNumbers[i]);
                w.ldelim();
            }
            if (m.approvedForAll != null && Object.hasOwnProperty.call(m, "approvedForAll"))
                $root.google.protobuf.BoolValue.encode(m.approvedForAll, w.uint32(42).fork()).ldelim();
            if (m.delegatingSpender != null && Object.hasOwnProperty.call(m, "delegatingSpender"))
                $root.proto.AccountID.encode(m.delegatingSpender, w.uint32(50).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a NftAllowance message from the specified reader or buffer.
         * @function decode
         * @memberof proto.NftAllowance
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.NftAllowance} NftAllowance
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NftAllowance.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.NftAllowance();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.tokenId = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.owner = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    case 3: {
                        m.spender = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    case 4: {
                        if (!(m.serialNumbers && m.serialNumbers.length)) m.serialNumbers = [];
                        if ((t & 7) === 2) {
                            var c2 = r.uint32() + r.pos;
                            while (r.pos < c2) m.serialNumbers.push(r.int64());
                        } else m.serialNumbers.push(r.int64());
                        break;
                    }
                    case 5: {
                        m.approvedForAll = $root.google.protobuf.BoolValue.decode(r, r.uint32());
                        break;
                    }
                    case 6: {
                        m.delegatingSpender = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for NftAllowance
         * @function getTypeUrl
         * @memberof proto.NftAllowance
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        NftAllowance.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.NftAllowance";
        };

        return NftAllowance;
    })();

    proto.TokenAllowance = (function () {
        /**
         * Properties of a TokenAllowance.
         * @memberof proto
         * @interface ITokenAllowance
         * @property {proto.ITokenID|null} [tokenId] The token that the allowance pertains to.
         * @property {proto.IAccountID|null} [owner] The account ID of the token owner (ie. the grantor of the allowance).
         * @property {proto.IAccountID|null} [spender] The account ID of the token allowance spender.
         * @property {Long|null} [amount] The amount of the spender's token allowance.
         */

        /**
         * Constructs a new TokenAllowance.
         * @memberof proto
         * @classdesc An approved allowance of fungible token transfers for a spender.
         * @implements ITokenAllowance
         * @constructor
         * @param {proto.ITokenAllowance=} [p] Properties to set
         */
        function TokenAllowance(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The token that the allowance pertains to.
         * @member {proto.ITokenID|null|undefined} tokenId
         * @memberof proto.TokenAllowance
         * @instance
         */
        TokenAllowance.prototype.tokenId = null;

        /**
         * The account ID of the token owner (ie. the grantor of the allowance).
         * @member {proto.IAccountID|null|undefined} owner
         * @memberof proto.TokenAllowance
         * @instance
         */
        TokenAllowance.prototype.owner = null;

        /**
         * The account ID of the token allowance spender.
         * @member {proto.IAccountID|null|undefined} spender
         * @memberof proto.TokenAllowance
         * @instance
         */
        TokenAllowance.prototype.spender = null;

        /**
         * The amount of the spender's token allowance.
         * @member {Long} amount
         * @memberof proto.TokenAllowance
         * @instance
         */
        TokenAllowance.prototype.amount = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * Creates a new TokenAllowance instance using the specified properties.
         * @function create
         * @memberof proto.TokenAllowance
         * @static
         * @param {proto.ITokenAllowance=} [properties] Properties to set
         * @returns {proto.TokenAllowance} TokenAllowance instance
         */
        TokenAllowance.create = function create(properties) {
            return new TokenAllowance(properties);
        };

        /**
         * Encodes the specified TokenAllowance message. Does not implicitly {@link proto.TokenAllowance.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenAllowance
         * @static
         * @param {proto.ITokenAllowance} m TokenAllowance message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenAllowance.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.tokenId != null && Object.hasOwnProperty.call(m, "tokenId"))
                $root.proto.TokenID.encode(m.tokenId, w.uint32(10).fork()).ldelim();
            if (m.owner != null && Object.hasOwnProperty.call(m, "owner"))
                $root.proto.AccountID.encode(m.owner, w.uint32(18).fork()).ldelim();
            if (m.spender != null && Object.hasOwnProperty.call(m, "spender"))
                $root.proto.AccountID.encode(m.spender, w.uint32(26).fork()).ldelim();
            if (m.amount != null && Object.hasOwnProperty.call(m, "amount")) w.uint32(32).int64(m.amount);
            return w;
        };

        /**
         * Decodes a TokenAllowance message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenAllowance
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenAllowance} TokenAllowance
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenAllowance.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.TokenAllowance();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.tokenId = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.owner = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    case 3: {
                        m.spender = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    case 4: {
                        m.amount = r.int64();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenAllowance
         * @function getTypeUrl
         * @memberof proto.TokenAllowance
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenAllowance.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenAllowance";
        };

        return TokenAllowance;
    })();

    proto.CryptoDeleteAllowanceTransactionBody = (function () {
        /**
         * Properties of a CryptoDeleteAllowanceTransactionBody.
         * @memberof proto
         * @interface ICryptoDeleteAllowanceTransactionBody
         * @property {Array.<proto.INftRemoveAllowance>|null} [nftAllowances] List of non-fungible token allowances to remove.
         */

        /**
         * Constructs a new CryptoDeleteAllowanceTransactionBody.
         * @memberof proto
         * @classdesc Deletes one or more non-fungible approved allowances from an owner's account. This operation
         * will remove the allowances granted to one or more specific non-fungible token serial numbers. Each owner account
         * listed as wiping an allowance must sign the transaction. Hbar and fungible token allowances
         * can be removed by setting the amount to zero in CryptoApproveAllowance.
         * @implements ICryptoDeleteAllowanceTransactionBody
         * @constructor
         * @param {proto.ICryptoDeleteAllowanceTransactionBody=} [p] Properties to set
         */
        function CryptoDeleteAllowanceTransactionBody(p) {
            this.nftAllowances = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * List of non-fungible token allowances to remove.
         * @member {Array.<proto.INftRemoveAllowance>} nftAllowances
         * @memberof proto.CryptoDeleteAllowanceTransactionBody
         * @instance
         */
        CryptoDeleteAllowanceTransactionBody.prototype.nftAllowances = $util.emptyArray;

        /**
         * Creates a new CryptoDeleteAllowanceTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.CryptoDeleteAllowanceTransactionBody
         * @static
         * @param {proto.ICryptoDeleteAllowanceTransactionBody=} [properties] Properties to set
         * @returns {proto.CryptoDeleteAllowanceTransactionBody} CryptoDeleteAllowanceTransactionBody instance
         */
        CryptoDeleteAllowanceTransactionBody.create = function create(properties) {
            return new CryptoDeleteAllowanceTransactionBody(properties);
        };

        /**
         * Encodes the specified CryptoDeleteAllowanceTransactionBody message. Does not implicitly {@link proto.CryptoDeleteAllowanceTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.CryptoDeleteAllowanceTransactionBody
         * @static
         * @param {proto.ICryptoDeleteAllowanceTransactionBody} m CryptoDeleteAllowanceTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CryptoDeleteAllowanceTransactionBody.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.nftAllowances != null && m.nftAllowances.length) {
                for (var i = 0; i < m.nftAllowances.length; ++i)
                    $root.proto.NftRemoveAllowance.encode(m.nftAllowances[i], w.uint32(18).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a CryptoDeleteAllowanceTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CryptoDeleteAllowanceTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.CryptoDeleteAllowanceTransactionBody} CryptoDeleteAllowanceTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CryptoDeleteAllowanceTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.CryptoDeleteAllowanceTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 2: {
                        if (!(m.nftAllowances && m.nftAllowances.length)) m.nftAllowances = [];
                        m.nftAllowances.push($root.proto.NftRemoveAllowance.decode(r, r.uint32()));
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for CryptoDeleteAllowanceTransactionBody
         * @function getTypeUrl
         * @memberof proto.CryptoDeleteAllowanceTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CryptoDeleteAllowanceTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.CryptoDeleteAllowanceTransactionBody";
        };

        return CryptoDeleteAllowanceTransactionBody;
    })();

    proto.NftRemoveAllowance = (function () {
        /**
         * Properties of a NftRemoveAllowance.
         * @memberof proto
         * @interface INftRemoveAllowance
         * @property {proto.ITokenID|null} [tokenId] The token that the allowance pertains to.
         * @property {proto.IAccountID|null} [owner] The account ID of the token owner (ie. the grantor of the allowance).
         * @property {Array.<Long>|null} [serialNumbers] The list of serial numbers to remove allowances from.
         */

        /**
         * Constructs a new NftRemoveAllowance.
         * @memberof proto
         * @classdesc Nft allowances to be removed on an owner account
         * @implements INftRemoveAllowance
         * @constructor
         * @param {proto.INftRemoveAllowance=} [p] Properties to set
         */
        function NftRemoveAllowance(p) {
            this.serialNumbers = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The token that the allowance pertains to.
         * @member {proto.ITokenID|null|undefined} tokenId
         * @memberof proto.NftRemoveAllowance
         * @instance
         */
        NftRemoveAllowance.prototype.tokenId = null;

        /**
         * The account ID of the token owner (ie. the grantor of the allowance).
         * @member {proto.IAccountID|null|undefined} owner
         * @memberof proto.NftRemoveAllowance
         * @instance
         */
        NftRemoveAllowance.prototype.owner = null;

        /**
         * The list of serial numbers to remove allowances from.
         * @member {Array.<Long>} serialNumbers
         * @memberof proto.NftRemoveAllowance
         * @instance
         */
        NftRemoveAllowance.prototype.serialNumbers = $util.emptyArray;

        /**
         * Creates a new NftRemoveAllowance instance using the specified properties.
         * @function create
         * @memberof proto.NftRemoveAllowance
         * @static
         * @param {proto.INftRemoveAllowance=} [properties] Properties to set
         * @returns {proto.NftRemoveAllowance} NftRemoveAllowance instance
         */
        NftRemoveAllowance.create = function create(properties) {
            return new NftRemoveAllowance(properties);
        };

        /**
         * Encodes the specified NftRemoveAllowance message. Does not implicitly {@link proto.NftRemoveAllowance.verify|verify} messages.
         * @function encode
         * @memberof proto.NftRemoveAllowance
         * @static
         * @param {proto.INftRemoveAllowance} m NftRemoveAllowance message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NftRemoveAllowance.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.tokenId != null && Object.hasOwnProperty.call(m, "tokenId"))
                $root.proto.TokenID.encode(m.tokenId, w.uint32(10).fork()).ldelim();
            if (m.owner != null && Object.hasOwnProperty.call(m, "owner"))
                $root.proto.AccountID.encode(m.owner, w.uint32(18).fork()).ldelim();
            if (m.serialNumbers != null && m.serialNumbers.length) {
                w.uint32(26).fork();
                for (var i = 0; i < m.serialNumbers.length; ++i) w.int64(m.serialNumbers[i]);
                w.ldelim();
            }
            return w;
        };

        /**
         * Decodes a NftRemoveAllowance message from the specified reader or buffer.
         * @function decode
         * @memberof proto.NftRemoveAllowance
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.NftRemoveAllowance} NftRemoveAllowance
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NftRemoveAllowance.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.NftRemoveAllowance();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.tokenId = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.owner = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    case 3: {
                        if (!(m.serialNumbers && m.serialNumbers.length)) m.serialNumbers = [];
                        if ((t & 7) === 2) {
                            var c2 = r.uint32() + r.pos;
                            while (r.pos < c2) m.serialNumbers.push(r.int64());
                        } else m.serialNumbers.push(r.int64());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for NftRemoveAllowance
         * @function getTypeUrl
         * @memberof proto.NftRemoveAllowance
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        NftRemoveAllowance.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.NftRemoveAllowance";
        };

        return NftRemoveAllowance;
    })();

    proto.EthereumTransactionBody = (function () {
        /**
         * Properties of an EthereumTransactionBody.
         * @memberof proto
         * @interface IEthereumTransactionBody
         * @property {Uint8Array|null} [ethereumData] The raw Ethereum transaction (RLP encoded type 0, 1, and 2). Complete
         * unless the callData field is set.
         * @property {proto.IFileID|null} [callData] For large transactions (for example contract create) this is the callData
         * of the ethereumData. The data in the ethereumData will be re-written with
         * the callData element as a zero length string with the original contents in
         * the referenced file at time of execution. The ethereumData will need to be
         * "rehydrated" with the callData for signature validation to pass.
         * @property {Long|null} [maxGasAllowance] The maximum amount, in tinybars, that the payer of the hedera transaction
         * is willing to pay to complete the transaction.
         *
         * Ordinarily the account with the ECDSA alias corresponding to the public
         * key that is extracted from the ethereum_data signature is responsible for
         * fees that result from the execution of the transaction. If that amount of
         * authorized fees is not sufficient then the payer of the transaction can be
         * charged, up to but not exceeding this amount. If the ethereum_data
         * transaction authorized an amount that was insufficient then the payer will
         * only be charged the amount needed to make up the difference. If the gas
         * price in the transaction was set to zero then the payer will be assessed
         * the entire fee.
         */

        /**
         * Constructs a new EthereumTransactionBody.
         * @memberof proto
         * @classdesc Represents an EthereumTransactionBody.
         * @implements IEthereumTransactionBody
         * @constructor
         * @param {proto.IEthereumTransactionBody=} [p] Properties to set
         */
        function EthereumTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The raw Ethereum transaction (RLP encoded type 0, 1, and 2). Complete
         * unless the callData field is set.
         * @member {Uint8Array} ethereumData
         * @memberof proto.EthereumTransactionBody
         * @instance
         */
        EthereumTransactionBody.prototype.ethereumData = $util.newBuffer([]);

        /**
         * For large transactions (for example contract create) this is the callData
         * of the ethereumData. The data in the ethereumData will be re-written with
         * the callData element as a zero length string with the original contents in
         * the referenced file at time of execution. The ethereumData will need to be
         * "rehydrated" with the callData for signature validation to pass.
         * @member {proto.IFileID|null|undefined} callData
         * @memberof proto.EthereumTransactionBody
         * @instance
         */
        EthereumTransactionBody.prototype.callData = null;

        /**
         * The maximum amount, in tinybars, that the payer of the hedera transaction
         * is willing to pay to complete the transaction.
         *
         * Ordinarily the account with the ECDSA alias corresponding to the public
         * key that is extracted from the ethereum_data signature is responsible for
         * fees that result from the execution of the transaction. If that amount of
         * authorized fees is not sufficient then the payer of the transaction can be
         * charged, up to but not exceeding this amount. If the ethereum_data
         * transaction authorized an amount that was insufficient then the payer will
         * only be charged the amount needed to make up the difference. If the gas
         * price in the transaction was set to zero then the payer will be assessed
         * the entire fee.
         * @member {Long} maxGasAllowance
         * @memberof proto.EthereumTransactionBody
         * @instance
         */
        EthereumTransactionBody.prototype.maxGasAllowance = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * Creates a new EthereumTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.EthereumTransactionBody
         * @static
         * @param {proto.IEthereumTransactionBody=} [properties] Properties to set
         * @returns {proto.EthereumTransactionBody} EthereumTransactionBody instance
         */
        EthereumTransactionBody.create = function create(properties) {
            return new EthereumTransactionBody(properties);
        };

        /**
         * Encodes the specified EthereumTransactionBody message. Does not implicitly {@link proto.EthereumTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.EthereumTransactionBody
         * @static
         * @param {proto.IEthereumTransactionBody} m EthereumTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EthereumTransactionBody.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.ethereumData != null && Object.hasOwnProperty.call(m, "ethereumData"))
                w.uint32(10).bytes(m.ethereumData);
            if (m.callData != null && Object.hasOwnProperty.call(m, "callData"))
                $root.proto.FileID.encode(m.callData, w.uint32(18).fork()).ldelim();
            if (m.maxGasAllowance != null && Object.hasOwnProperty.call(m, "maxGasAllowance"))
                w.uint32(24).int64(m.maxGasAllowance);
            return w;
        };

        /**
         * Decodes an EthereumTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.EthereumTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.EthereumTransactionBody} EthereumTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EthereumTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.EthereumTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.ethereumData = r.bytes();
                        break;
                    }
                    case 2: {
                        m.callData = $root.proto.FileID.decode(r, r.uint32());
                        break;
                    }
                    case 3: {
                        m.maxGasAllowance = r.int64();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for EthereumTransactionBody
         * @function getTypeUrl
         * @memberof proto.EthereumTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        EthereumTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.EthereumTransactionBody";
        };

        return EthereumTransactionBody;
    })();

    proto.FileAppendTransactionBody = (function () {
        /**
         * Properties of a FileAppendTransactionBody.
         * @memberof proto
         * @interface IFileAppendTransactionBody
         * @property {proto.IFileID|null} [fileID] The file to which the bytes will be appended
         * @property {Uint8Array|null} [contents] The bytes that will be appended to the end of the specified file
         */

        /**
         * Constructs a new FileAppendTransactionBody.
         * @memberof proto
         * @classdesc Append the given contents to the end of the specified file. If a file is too big to create with a
         * single FileCreateTransaction, then it can be created with the first part of its contents, and
         * then appended as many times as necessary to create the entire file. This transaction must be
         * signed by all initial M-of-M KeyList keys. If keys contains additional KeyList or ThresholdKey
         * then M-of-M secondary KeyList or ThresholdKey signing requirements must be meet.
         * @implements IFileAppendTransactionBody
         * @constructor
         * @param {proto.IFileAppendTransactionBody=} [p] Properties to set
         */
        function FileAppendTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The file to which the bytes will be appended
         * @member {proto.IFileID|null|undefined} fileID
         * @memberof proto.FileAppendTransactionBody
         * @instance
         */
        FileAppendTransactionBody.prototype.fileID = null;

        /**
         * The bytes that will be appended to the end of the specified file
         * @member {Uint8Array} contents
         * @memberof proto.FileAppendTransactionBody
         * @instance
         */
        FileAppendTransactionBody.prototype.contents = $util.newBuffer([]);

        /**
         * Creates a new FileAppendTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.FileAppendTransactionBody
         * @static
         * @param {proto.IFileAppendTransactionBody=} [properties] Properties to set
         * @returns {proto.FileAppendTransactionBody} FileAppendTransactionBody instance
         */
        FileAppendTransactionBody.create = function create(properties) {
            return new FileAppendTransactionBody(properties);
        };

        /**
         * Encodes the specified FileAppendTransactionBody message. Does not implicitly {@link proto.FileAppendTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.FileAppendTransactionBody
         * @static
         * @param {proto.IFileAppendTransactionBody} m FileAppendTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FileAppendTransactionBody.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.fileID != null && Object.hasOwnProperty.call(m, "fileID"))
                $root.proto.FileID.encode(m.fileID, w.uint32(18).fork()).ldelim();
            if (m.contents != null && Object.hasOwnProperty.call(m, "contents")) w.uint32(34).bytes(m.contents);
            return w;
        };

        /**
         * Decodes a FileAppendTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.FileAppendTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.FileAppendTransactionBody} FileAppendTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FileAppendTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.FileAppendTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 2: {
                        m.fileID = $root.proto.FileID.decode(r, r.uint32());
                        break;
                    }
                    case 4: {
                        m.contents = r.bytes();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for FileAppendTransactionBody
         * @function getTypeUrl
         * @memberof proto.FileAppendTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        FileAppendTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.FileAppendTransactionBody";
        };

        return FileAppendTransactionBody;
    })();

    proto.FileCreateTransactionBody = (function () {
        /**
         * Properties of a FileCreateTransactionBody.
         * @memberof proto
         * @interface IFileCreateTransactionBody
         * @property {proto.ITimestamp|null} [expirationTime] The time at which this file should expire (unless FileUpdateTransaction is used before then
         * to extend its life)
         * @property {proto.IKeyList|null} [keys] All keys at the top level of a key list must sign to create or modify the file. Any one of
         * the keys at the top level key list can sign to delete the file.
         * @property {Uint8Array|null} [contents] The bytes that are the contents of the file
         * @property {proto.IShardID|null} [shardID] Shard in which this file is created
         * @property {proto.IRealmID|null} [realmID] The Realm in which to the file is created (leave this null to create a new realm)
         * @property {proto.IKey|null} [newRealmAdminKey] If realmID is null, then this the admin key for the new realm that will be created
         * @property {string|null} [memo] The memo associated with the file (UTF-8 encoding max 100 bytes)
         */

        /**
         * Constructs a new FileCreateTransactionBody.
         * @memberof proto
         * @classdesc Create a new file, containing the given contents.
         * After the file is created, the FileID for it can be found in the receipt, or record, or retrieved
         * with a GetByKey query.
         *
         * The file contains the specified contents (possibly empty). The file will automatically disappear
         * at the expirationTime, unless its expiration is extended by another transaction before that time.
         * If the file is deleted, then its contents will become empty and it will be marked as deleted
         * until it expires, and then it will cease to exist.
         *
         * The keys field is a list of keys. All keys within the top-level key list must sign (M-M) to
         * create or modify a file. However, to delete the file, only one key (1-M) is required to sign from
         * the top-level key list.  Each of those "keys" may itself be threshold key containing other keys
         * (including other threshold keys). In other words, the behavior is an AND for create/modify, OR
         * for delete. This is useful for acting as a revocation server. If it is desired to have the
         * behavior be AND for all 3 operations (or OR for all 3), then the list should have only a single
         * Key, which is a threshold key, with N=1 for OR, N=M for AND. If the auto_renew_account field
         * is set, the key of the referenced account must sign.
         *
         * If a file is created without ANY keys in the keys field, the file is immutable and ONLY the
         * expirationTime of the file can be changed with a FileUpdate transaction. The file contents or its
         * keys cannot be changed.
         *
         * An entity (account, file, or smart contract instance) must be created in a particular realm. If
         * the realmID is left null, then a new realm will be created with the given admin key. If a new
         * realm has a null adminKey, then anyone can create/modify/delete entities in that realm. But if an
         * admin key is given, then any transaction to create/modify/delete an entity in that realm must be
         * signed by that key, though anyone can still call functions on smart contract instances that exist
         * in that realm. A realm ceases to exist when everything within it has expired and no longer
         * exists.
         *
         * The current API ignores shardID, realmID, and newRealmAdminKey, and creates everything in shard 0
         * and realm 0, with a null key. Future versions of the API will support multiple realms and
         * multiple shards.
         * @implements IFileCreateTransactionBody
         * @constructor
         * @param {proto.IFileCreateTransactionBody=} [p] Properties to set
         */
        function FileCreateTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The time at which this file should expire (unless FileUpdateTransaction is used before then
         * to extend its life)
         * @member {proto.ITimestamp|null|undefined} expirationTime
         * @memberof proto.FileCreateTransactionBody
         * @instance
         */
        FileCreateTransactionBody.prototype.expirationTime = null;

        /**
         * All keys at the top level of a key list must sign to create or modify the file. Any one of
         * the keys at the top level key list can sign to delete the file.
         * @member {proto.IKeyList|null|undefined} keys
         * @memberof proto.FileCreateTransactionBody
         * @instance
         */
        FileCreateTransactionBody.prototype.keys = null;

        /**
         * The bytes that are the contents of the file
         * @member {Uint8Array} contents
         * @memberof proto.FileCreateTransactionBody
         * @instance
         */
        FileCreateTransactionBody.prototype.contents = $util.newBuffer([]);

        /**
         * Shard in which this file is created
         * @member {proto.IShardID|null|undefined} shardID
         * @memberof proto.FileCreateTransactionBody
         * @instance
         */
        FileCreateTransactionBody.prototype.shardID = null;

        /**
         * The Realm in which to the file is created (leave this null to create a new realm)
         * @member {proto.IRealmID|null|undefined} realmID
         * @memberof proto.FileCreateTransactionBody
         * @instance
         */
        FileCreateTransactionBody.prototype.realmID = null;

        /**
         * If realmID is null, then this the admin key for the new realm that will be created
         * @member {proto.IKey|null|undefined} newRealmAdminKey
         * @memberof proto.FileCreateTransactionBody
         * @instance
         */
        FileCreateTransactionBody.prototype.newRealmAdminKey = null;

        /**
         * The memo associated with the file (UTF-8 encoding max 100 bytes)
         * @member {string} memo
         * @memberof proto.FileCreateTransactionBody
         * @instance
         */
        FileCreateTransactionBody.prototype.memo = "";

        /**
         * Creates a new FileCreateTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.FileCreateTransactionBody
         * @static
         * @param {proto.IFileCreateTransactionBody=} [properties] Properties to set
         * @returns {proto.FileCreateTransactionBody} FileCreateTransactionBody instance
         */
        FileCreateTransactionBody.create = function create(properties) {
            return new FileCreateTransactionBody(properties);
        };

        /**
         * Encodes the specified FileCreateTransactionBody message. Does not implicitly {@link proto.FileCreateTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.FileCreateTransactionBody
         * @static
         * @param {proto.IFileCreateTransactionBody} m FileCreateTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FileCreateTransactionBody.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.expirationTime != null && Object.hasOwnProperty.call(m, "expirationTime"))
                $root.proto.Timestamp.encode(m.expirationTime, w.uint32(18).fork()).ldelim();
            if (m.keys != null && Object.hasOwnProperty.call(m, "keys"))
                $root.proto.KeyList.encode(m.keys, w.uint32(26).fork()).ldelim();
            if (m.contents != null && Object.hasOwnProperty.call(m, "contents")) w.uint32(34).bytes(m.contents);
            if (m.shardID != null && Object.hasOwnProperty.call(m, "shardID"))
                $root.proto.ShardID.encode(m.shardID, w.uint32(42).fork()).ldelim();
            if (m.realmID != null && Object.hasOwnProperty.call(m, "realmID"))
                $root.proto.RealmID.encode(m.realmID, w.uint32(50).fork()).ldelim();
            if (m.newRealmAdminKey != null && Object.hasOwnProperty.call(m, "newRealmAdminKey"))
                $root.proto.Key.encode(m.newRealmAdminKey, w.uint32(58).fork()).ldelim();
            if (m.memo != null && Object.hasOwnProperty.call(m, "memo")) w.uint32(66).string(m.memo);
            return w;
        };

        /**
         * Decodes a FileCreateTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.FileCreateTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.FileCreateTransactionBody} FileCreateTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FileCreateTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.FileCreateTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 2: {
                        m.expirationTime = $root.proto.Timestamp.decode(r, r.uint32());
                        break;
                    }
                    case 3: {
                        m.keys = $root.proto.KeyList.decode(r, r.uint32());
                        break;
                    }
                    case 4: {
                        m.contents = r.bytes();
                        break;
                    }
                    case 5: {
                        m.shardID = $root.proto.ShardID.decode(r, r.uint32());
                        break;
                    }
                    case 6: {
                        m.realmID = $root.proto.RealmID.decode(r, r.uint32());
                        break;
                    }
                    case 7: {
                        m.newRealmAdminKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                    case 8: {
                        m.memo = r.string();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for FileCreateTransactionBody
         * @function getTypeUrl
         * @memberof proto.FileCreateTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        FileCreateTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.FileCreateTransactionBody";
        };

        return FileCreateTransactionBody;
    })();

    proto.FileDeleteTransactionBody = (function () {
        /**
         * Properties of a FileDeleteTransactionBody.
         * @memberof proto
         * @interface IFileDeleteTransactionBody
         * @property {proto.IFileID|null} [fileID] The file to delete. It will be marked as deleted until it expires. Then it will disappear.
         */

        /**
         * Constructs a new FileDeleteTransactionBody.
         * @memberof proto
         * @classdesc Delete the given file. After deletion, it will be marked as deleted and will have no contents.
         * But information about it will continue to exist until it expires. A list of keys was given when
         * the file was created. All the top level keys on that list must sign transactions to create or
         * modify the file, but any single one of the top level keys can be used to delete the file. This
         * transaction must be signed by 1-of-M KeyList keys. If keys contains additional KeyList or
         * ThresholdKey then 1-of-M secondary KeyList or ThresholdKey signing requirements must be meet.
         * @implements IFileDeleteTransactionBody
         * @constructor
         * @param {proto.IFileDeleteTransactionBody=} [p] Properties to set
         */
        function FileDeleteTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The file to delete. It will be marked as deleted until it expires. Then it will disappear.
         * @member {proto.IFileID|null|undefined} fileID
         * @memberof proto.FileDeleteTransactionBody
         * @instance
         */
        FileDeleteTransactionBody.prototype.fileID = null;

        /**
         * Creates a new FileDeleteTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.FileDeleteTransactionBody
         * @static
         * @param {proto.IFileDeleteTransactionBody=} [properties] Properties to set
         * @returns {proto.FileDeleteTransactionBody} FileDeleteTransactionBody instance
         */
        FileDeleteTransactionBody.create = function create(properties) {
            return new FileDeleteTransactionBody(properties);
        };

        /**
         * Encodes the specified FileDeleteTransactionBody message. Does not implicitly {@link proto.FileDeleteTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.FileDeleteTransactionBody
         * @static
         * @param {proto.IFileDeleteTransactionBody} m FileDeleteTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FileDeleteTransactionBody.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.fileID != null && Object.hasOwnProperty.call(m, "fileID"))
                $root.proto.FileID.encode(m.fileID, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a FileDeleteTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.FileDeleteTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.FileDeleteTransactionBody} FileDeleteTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FileDeleteTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.FileDeleteTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 2: {
                        m.fileID = $root.proto.FileID.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for FileDeleteTransactionBody
         * @function getTypeUrl
         * @memberof proto.FileDeleteTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        FileDeleteTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.FileDeleteTransactionBody";
        };

        return FileDeleteTransactionBody;
    })();

    proto.FileUpdateTransactionBody = (function () {
        /**
         * Properties of a FileUpdateTransactionBody.
         * @memberof proto
         * @interface IFileUpdateTransactionBody
         * @property {proto.IFileID|null} [fileID] The ID of the file to update
         * @property {proto.ITimestamp|null} [expirationTime] The new expiry time (ignored if not later than the current expiry)
         * @property {proto.IKeyList|null} [keys] The new list of keys that can modify or delete the file
         * @property {Uint8Array|null} [contents] The new contents that should overwrite the file's current contents
         * @property {google.protobuf.IStringValue|null} [memo] If set, the new memo to be associated with the file (UTF-8 encoding max 100 bytes)
         */

        /**
         * Constructs a new FileUpdateTransactionBody.
         * @memberof proto
         * @classdesc Modify the metadata and/or contents of a file. If a field is not set in the transaction body, the
         * corresponding file attribute will be unchanged. This transaction must be signed by all the keys
         * in the top level of a key list (M-of-M) of the file being updated. If the keys themselves are
         * being updated, then the transaction must also be signed by all the new keys. If the keys contain
         * additional KeyList or ThresholdKey then M-of-M secondary KeyList or ThresholdKey signing
         * requirements must be meet If the update transaction sets the <tt>auto_renew_account_id</tt> field
         * to anything other than the sentinel <tt>0.0.0</tt>, the key of the referenced account must sign.
         * @implements IFileUpdateTransactionBody
         * @constructor
         * @param {proto.IFileUpdateTransactionBody=} [p] Properties to set
         */
        function FileUpdateTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The ID of the file to update
         * @member {proto.IFileID|null|undefined} fileID
         * @memberof proto.FileUpdateTransactionBody
         * @instance
         */
        FileUpdateTransactionBody.prototype.fileID = null;

        /**
         * The new expiry time (ignored if not later than the current expiry)
         * @member {proto.ITimestamp|null|undefined} expirationTime
         * @memberof proto.FileUpdateTransactionBody
         * @instance
         */
        FileUpdateTransactionBody.prototype.expirationTime = null;

        /**
         * The new list of keys that can modify or delete the file
         * @member {proto.IKeyList|null|undefined} keys
         * @memberof proto.FileUpdateTransactionBody
         * @instance
         */
        FileUpdateTransactionBody.prototype.keys = null;

        /**
         * The new contents that should overwrite the file's current contents
         * @member {Uint8Array} contents
         * @memberof proto.FileUpdateTransactionBody
         * @instance
         */
        FileUpdateTransactionBody.prototype.contents = $util.newBuffer([]);

        /**
         * If set, the new memo to be associated with the file (UTF-8 encoding max 100 bytes)
         * @member {google.protobuf.IStringValue|null|undefined} memo
         * @memberof proto.FileUpdateTransactionBody
         * @instance
         */
        FileUpdateTransactionBody.prototype.memo = null;

        /**
         * Creates a new FileUpdateTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.FileUpdateTransactionBody
         * @static
         * @param {proto.IFileUpdateTransactionBody=} [properties] Properties to set
         * @returns {proto.FileUpdateTransactionBody} FileUpdateTransactionBody instance
         */
        FileUpdateTransactionBody.create = function create(properties) {
            return new FileUpdateTransactionBody(properties);
        };

        /**
         * Encodes the specified FileUpdateTransactionBody message. Does not implicitly {@link proto.FileUpdateTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.FileUpdateTransactionBody
         * @static
         * @param {proto.IFileUpdateTransactionBody} m FileUpdateTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FileUpdateTransactionBody.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.fileID != null && Object.hasOwnProperty.call(m, "fileID"))
                $root.proto.FileID.encode(m.fileID, w.uint32(10).fork()).ldelim();
            if (m.expirationTime != null && Object.hasOwnProperty.call(m, "expirationTime"))
                $root.proto.Timestamp.encode(m.expirationTime, w.uint32(18).fork()).ldelim();
            if (m.keys != null && Object.hasOwnProperty.call(m, "keys"))
                $root.proto.KeyList.encode(m.keys, w.uint32(26).fork()).ldelim();
            if (m.contents != null && Object.hasOwnProperty.call(m, "contents")) w.uint32(34).bytes(m.contents);
            if (m.memo != null && Object.hasOwnProperty.call(m, "memo"))
                $root.google.protobuf.StringValue.encode(m.memo, w.uint32(42).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a FileUpdateTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.FileUpdateTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.FileUpdateTransactionBody} FileUpdateTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FileUpdateTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.FileUpdateTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.fileID = $root.proto.FileID.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.expirationTime = $root.proto.Timestamp.decode(r, r.uint32());
                        break;
                    }
                    case 3: {
                        m.keys = $root.proto.KeyList.decode(r, r.uint32());
                        break;
                    }
                    case 4: {
                        m.contents = r.bytes();
                        break;
                    }
                    case 5: {
                        m.memo = $root.google.protobuf.StringValue.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for FileUpdateTransactionBody
         * @function getTypeUrl
         * @memberof proto.FileUpdateTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        FileUpdateTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.FileUpdateTransactionBody";
        };

        return FileUpdateTransactionBody;
    })();

    proto.ContractDeleteTransactionBody = (function () {
        /**
         * Properties of a ContractDeleteTransactionBody.
         * @memberof proto
         * @interface IContractDeleteTransactionBody
         * @property {proto.IContractID|null} [contractID] The id of the contract to be deleted
         * @property {proto.IAccountID|null} [transferAccountID] The id of an account to receive any remaining hBars from the deleted contract
         * @property {proto.IContractID|null} [transferContractID] The id of a contract to receive any remaining hBars from the deleted contract
         * @property {boolean|null} [permanentRemoval] If set to true, means this is a "synthetic" system transaction being used to
         * alert mirror nodes that the contract is being permanently removed from the ledger.
         * <b>IMPORTANT:</b> User transactions cannot set this field to true, as permanent
         * removal is always managed by the ledger itself. Any ContractDeleteTransactionBody
         * submitted to HAPI with permanent_removal=true will be rejected with precheck status
         * PERMANENT_REMOVAL_REQUIRES_SYSTEM_INITIATION.
         */

        /**
         * Constructs a new ContractDeleteTransactionBody.
         * @memberof proto
         * @classdesc At consensus, marks a contract as deleted and transfers its remaining hBars, if any, to a
         * designated receiver. After a contract is deleted, it can no longer be called.
         *
         * If the target contract is immutable (that is, was created without an admin key), then this
         * transaction resolves to MODIFYING_IMMUTABLE_CONTRACT.
         *
         * --- Signing Requirements ---
         * 1. The admin key of the target contract must sign.
         * 2. If the transfer account or contract has receiverSigRequired, its associated key must also sign
         * @implements IContractDeleteTransactionBody
         * @constructor
         * @param {proto.IContractDeleteTransactionBody=} [p] Properties to set
         */
        function ContractDeleteTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The id of the contract to be deleted
         * @member {proto.IContractID|null|undefined} contractID
         * @memberof proto.ContractDeleteTransactionBody
         * @instance
         */
        ContractDeleteTransactionBody.prototype.contractID = null;

        /**
         * The id of an account to receive any remaining hBars from the deleted contract
         * @member {proto.IAccountID|null|undefined} transferAccountID
         * @memberof proto.ContractDeleteTransactionBody
         * @instance
         */
        ContractDeleteTransactionBody.prototype.transferAccountID = null;

        /**
         * The id of a contract to receive any remaining hBars from the deleted contract
         * @member {proto.IContractID|null|undefined} transferContractID
         * @memberof proto.ContractDeleteTransactionBody
         * @instance
         */
        ContractDeleteTransactionBody.prototype.transferContractID = null;

        /**
         * If set to true, means this is a "synthetic" system transaction being used to
         * alert mirror nodes that the contract is being permanently removed from the ledger.
         * <b>IMPORTANT:</b> User transactions cannot set this field to true, as permanent
         * removal is always managed by the ledger itself. Any ContractDeleteTransactionBody
         * submitted to HAPI with permanent_removal=true will be rejected with precheck status
         * PERMANENT_REMOVAL_REQUIRES_SYSTEM_INITIATION.
         * @member {boolean} permanentRemoval
         * @memberof proto.ContractDeleteTransactionBody
         * @instance
         */
        ContractDeleteTransactionBody.prototype.permanentRemoval = false;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * ContractDeleteTransactionBody obtainers.
         * @member {"transferAccountID"|"transferContractID"|undefined} obtainers
         * @memberof proto.ContractDeleteTransactionBody
         * @instance
         */
        Object.defineProperty(ContractDeleteTransactionBody.prototype, "obtainers", {
            get: $util.oneOfGetter(($oneOfFields = ["transferAccountID", "transferContractID"])),
            set: $util.oneOfSetter($oneOfFields),
        });

        /**
         * Creates a new ContractDeleteTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.ContractDeleteTransactionBody
         * @static
         * @param {proto.IContractDeleteTransactionBody=} [properties] Properties to set
         * @returns {proto.ContractDeleteTransactionBody} ContractDeleteTransactionBody instance
         */
        ContractDeleteTransactionBody.create = function create(properties) {
            return new ContractDeleteTransactionBody(properties);
        };

        /**
         * Encodes the specified ContractDeleteTransactionBody message. Does not implicitly {@link proto.ContractDeleteTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.ContractDeleteTransactionBody
         * @static
         * @param {proto.IContractDeleteTransactionBody} m ContractDeleteTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractDeleteTransactionBody.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.contractID != null && Object.hasOwnProperty.call(m, "contractID"))
                $root.proto.ContractID.encode(m.contractID, w.uint32(10).fork()).ldelim();
            if (m.transferAccountID != null && Object.hasOwnProperty.call(m, "transferAccountID"))
                $root.proto.AccountID.encode(m.transferAccountID, w.uint32(18).fork()).ldelim();
            if (m.transferContractID != null && Object.hasOwnProperty.call(m, "transferContractID"))
                $root.proto.ContractID.encode(m.transferContractID, w.uint32(26).fork()).ldelim();
            if (m.permanentRemoval != null && Object.hasOwnProperty.call(m, "permanentRemoval"))
                w.uint32(32).bool(m.permanentRemoval);
            return w;
        };

        /**
         * Decodes a ContractDeleteTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ContractDeleteTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ContractDeleteTransactionBody} ContractDeleteTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractDeleteTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.ContractDeleteTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.contractID = $root.proto.ContractID.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.transferAccountID = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    case 3: {
                        m.transferContractID = $root.proto.ContractID.decode(r, r.uint32());
                        break;
                    }
                    case 4: {
                        m.permanentRemoval = r.bool();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ContractDeleteTransactionBody
         * @function getTypeUrl
         * @memberof proto.ContractDeleteTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ContractDeleteTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ContractDeleteTransactionBody";
        };

        return ContractDeleteTransactionBody;
    })();

    proto.ConsensusUpdateTopicTransactionBody = (function () {
        /**
         * Properties of a ConsensusUpdateTopicTransactionBody.
         * @memberof proto
         * @interface IConsensusUpdateTopicTransactionBody
         * @property {proto.ITopicID|null} [topicID] UNDOCUMENTED
         * @property {google.protobuf.IStringValue|null} [memo] If set, the new memo to be associated with the topic (UTF-8 encoding max 100 bytes)
         * @property {proto.ITimestamp|null} [expirationTime] Effective consensus timestamp at (and after) which all consensus transactions and queries will fail.
         * The expirationTime may be no longer than MAX_AUTORENEW_PERIOD (8000001 seconds) from the consensus timestamp of
         * this transaction.
         * On topics with no adminKey, extending the expirationTime is the only updateTopic option allowed on the topic.
         * If unspecified, no change.
         * @property {proto.IKey|null} [adminKey] Access control for update/delete of the topic.
         * If unspecified, no change.
         * If empty keyList - the adminKey is cleared.
         * @property {proto.IKey|null} [submitKey] Access control for ConsensusService.submitMessage.
         * If unspecified, no change.
         * If empty keyList - the submitKey is cleared.
         * @property {proto.IDuration|null} [autoRenewPeriod] ConsensusUpdateTopicTransactionBody autoRenewPeriod
         * @property {proto.IAccountID|null} [autoRenewAccount] Optional account to be used at the topic's expirationTime to extend the life of the topic.
         * Once autoRenew functionality is supported by HAPI, the topic lifetime will be extended up to a maximum of the
         * autoRenewPeriod or however long the topic can be extended using all funds on the account (whichever is the
         * smaller duration/amount).
         * If specified as the default value (0.0.0), the autoRenewAccount will be removed.
         * If unspecified, no change.
         */

        /**
         * Constructs a new ConsensusUpdateTopicTransactionBody.
         * @memberof proto
         * @classdesc All fields left null will not be updated.
         * See [ConsensusService.updateTopic()](#proto.ConsensusService)
         * @implements IConsensusUpdateTopicTransactionBody
         * @constructor
         * @param {proto.IConsensusUpdateTopicTransactionBody=} [p] Properties to set
         */
        function ConsensusUpdateTopicTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * UNDOCUMENTED
         * @member {proto.ITopicID|null|undefined} topicID
         * @memberof proto.ConsensusUpdateTopicTransactionBody
         * @instance
         */
        ConsensusUpdateTopicTransactionBody.prototype.topicID = null;

        /**
         * If set, the new memo to be associated with the topic (UTF-8 encoding max 100 bytes)
         * @member {google.protobuf.IStringValue|null|undefined} memo
         * @memberof proto.ConsensusUpdateTopicTransactionBody
         * @instance
         */
        ConsensusUpdateTopicTransactionBody.prototype.memo = null;

        /**
         * Effective consensus timestamp at (and after) which all consensus transactions and queries will fail.
         * The expirationTime may be no longer than MAX_AUTORENEW_PERIOD (8000001 seconds) from the consensus timestamp of
         * this transaction.
         * On topics with no adminKey, extending the expirationTime is the only updateTopic option allowed on the topic.
         * If unspecified, no change.
         * @member {proto.ITimestamp|null|undefined} expirationTime
         * @memberof proto.ConsensusUpdateTopicTransactionBody
         * @instance
         */
        ConsensusUpdateTopicTransactionBody.prototype.expirationTime = null;

        /**
         * Access control for update/delete of the topic.
         * If unspecified, no change.
         * If empty keyList - the adminKey is cleared.
         * @member {proto.IKey|null|undefined} adminKey
         * @memberof proto.ConsensusUpdateTopicTransactionBody
         * @instance
         */
        ConsensusUpdateTopicTransactionBody.prototype.adminKey = null;

        /**
         * Access control for ConsensusService.submitMessage.
         * If unspecified, no change.
         * If empty keyList - the submitKey is cleared.
         * @member {proto.IKey|null|undefined} submitKey
         * @memberof proto.ConsensusUpdateTopicTransactionBody
         * @instance
         */
        ConsensusUpdateTopicTransactionBody.prototype.submitKey = null;

        /**
         * ConsensusUpdateTopicTransactionBody autoRenewPeriod.
         * @member {proto.IDuration|null|undefined} autoRenewPeriod
         * @memberof proto.ConsensusUpdateTopicTransactionBody
         * @instance
         */
        ConsensusUpdateTopicTransactionBody.prototype.autoRenewPeriod = null;

        /**
         * Optional account to be used at the topic's expirationTime to extend the life of the topic.
         * Once autoRenew functionality is supported by HAPI, the topic lifetime will be extended up to a maximum of the
         * autoRenewPeriod or however long the topic can be extended using all funds on the account (whichever is the
         * smaller duration/amount).
         * If specified as the default value (0.0.0), the autoRenewAccount will be removed.
         * If unspecified, no change.
         * @member {proto.IAccountID|null|undefined} autoRenewAccount
         * @memberof proto.ConsensusUpdateTopicTransactionBody
         * @instance
         */
        ConsensusUpdateTopicTransactionBody.prototype.autoRenewAccount = null;

        /**
         * Creates a new ConsensusUpdateTopicTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.ConsensusUpdateTopicTransactionBody
         * @static
         * @param {proto.IConsensusUpdateTopicTransactionBody=} [properties] Properties to set
         * @returns {proto.ConsensusUpdateTopicTransactionBody} ConsensusUpdateTopicTransactionBody instance
         */
        ConsensusUpdateTopicTransactionBody.create = function create(properties) {
            return new ConsensusUpdateTopicTransactionBody(properties);
        };

        /**
         * Encodes the specified ConsensusUpdateTopicTransactionBody message. Does not implicitly {@link proto.ConsensusUpdateTopicTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.ConsensusUpdateTopicTransactionBody
         * @static
         * @param {proto.IConsensusUpdateTopicTransactionBody} m ConsensusUpdateTopicTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConsensusUpdateTopicTransactionBody.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.topicID != null && Object.hasOwnProperty.call(m, "topicID"))
                $root.proto.TopicID.encode(m.topicID, w.uint32(10).fork()).ldelim();
            if (m.memo != null && Object.hasOwnProperty.call(m, "memo"))
                $root.google.protobuf.StringValue.encode(m.memo, w.uint32(18).fork()).ldelim();
            if (m.expirationTime != null && Object.hasOwnProperty.call(m, "expirationTime"))
                $root.proto.Timestamp.encode(m.expirationTime, w.uint32(34).fork()).ldelim();
            if (m.adminKey != null && Object.hasOwnProperty.call(m, "adminKey"))
                $root.proto.Key.encode(m.adminKey, w.uint32(50).fork()).ldelim();
            if (m.submitKey != null && Object.hasOwnProperty.call(m, "submitKey"))
                $root.proto.Key.encode(m.submitKey, w.uint32(58).fork()).ldelim();
            if (m.autoRenewPeriod != null && Object.hasOwnProperty.call(m, "autoRenewPeriod"))
                $root.proto.Duration.encode(m.autoRenewPeriod, w.uint32(66).fork()).ldelim();
            if (m.autoRenewAccount != null && Object.hasOwnProperty.call(m, "autoRenewAccount"))
                $root.proto.AccountID.encode(m.autoRenewAccount, w.uint32(74).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a ConsensusUpdateTopicTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ConsensusUpdateTopicTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ConsensusUpdateTopicTransactionBody} ConsensusUpdateTopicTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConsensusUpdateTopicTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.ConsensusUpdateTopicTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.topicID = $root.proto.TopicID.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.memo = $root.google.protobuf.StringValue.decode(r, r.uint32());
                        break;
                    }
                    case 4: {
                        m.expirationTime = $root.proto.Timestamp.decode(r, r.uint32());
                        break;
                    }
                    case 6: {
                        m.adminKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                    case 7: {
                        m.submitKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                    case 8: {
                        m.autoRenewPeriod = $root.proto.Duration.decode(r, r.uint32());
                        break;
                    }
                    case 9: {
                        m.autoRenewAccount = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ConsensusUpdateTopicTransactionBody
         * @function getTypeUrl
         * @memberof proto.ConsensusUpdateTopicTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ConsensusUpdateTopicTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ConsensusUpdateTopicTransactionBody";
        };

        return ConsensusUpdateTopicTransactionBody;
    })();

    proto.ConsensusMessageChunkInfo = (function () {
        /**
         * Properties of a ConsensusMessageChunkInfo.
         * @memberof proto
         * @interface IConsensusMessageChunkInfo
         * @property {proto.ITransactionID|null} [initialTransactionID] TransactionID of the first chunk, gets copied to every subsequent chunk in a fragmented message.
         * @property {number|null} [total] The total number of chunks in the message.
         * @property {number|null} [number] The sequence number (from 1 to total) of the current chunk in the message.
         */

        /**
         * Constructs a new ConsensusMessageChunkInfo.
         * @memberof proto
         * @classdesc UNDOCUMENTED
         * @implements IConsensusMessageChunkInfo
         * @constructor
         * @param {proto.IConsensusMessageChunkInfo=} [p] Properties to set
         */
        function ConsensusMessageChunkInfo(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * TransactionID of the first chunk, gets copied to every subsequent chunk in a fragmented message.
         * @member {proto.ITransactionID|null|undefined} initialTransactionID
         * @memberof proto.ConsensusMessageChunkInfo
         * @instance
         */
        ConsensusMessageChunkInfo.prototype.initialTransactionID = null;

        /**
         * The total number of chunks in the message.
         * @member {number} total
         * @memberof proto.ConsensusMessageChunkInfo
         * @instance
         */
        ConsensusMessageChunkInfo.prototype.total = 0;

        /**
         * The sequence number (from 1 to total) of the current chunk in the message.
         * @member {number} number
         * @memberof proto.ConsensusMessageChunkInfo
         * @instance
         */
        ConsensusMessageChunkInfo.prototype.number = 0;

        /**
         * Creates a new ConsensusMessageChunkInfo instance using the specified properties.
         * @function create
         * @memberof proto.ConsensusMessageChunkInfo
         * @static
         * @param {proto.IConsensusMessageChunkInfo=} [properties] Properties to set
         * @returns {proto.ConsensusMessageChunkInfo} ConsensusMessageChunkInfo instance
         */
        ConsensusMessageChunkInfo.create = function create(properties) {
            return new ConsensusMessageChunkInfo(properties);
        };

        /**
         * Encodes the specified ConsensusMessageChunkInfo message. Does not implicitly {@link proto.ConsensusMessageChunkInfo.verify|verify} messages.
         * @function encode
         * @memberof proto.ConsensusMessageChunkInfo
         * @static
         * @param {proto.IConsensusMessageChunkInfo} m ConsensusMessageChunkInfo message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConsensusMessageChunkInfo.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.initialTransactionID != null && Object.hasOwnProperty.call(m, "initialTransactionID"))
                $root.proto.TransactionID.encode(m.initialTransactionID, w.uint32(10).fork()).ldelim();
            if (m.total != null && Object.hasOwnProperty.call(m, "total")) w.uint32(16).int32(m.total);
            if (m.number != null && Object.hasOwnProperty.call(m, "number")) w.uint32(24).int32(m.number);
            return w;
        };

        /**
         * Decodes a ConsensusMessageChunkInfo message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ConsensusMessageChunkInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ConsensusMessageChunkInfo} ConsensusMessageChunkInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConsensusMessageChunkInfo.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.ConsensusMessageChunkInfo();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.initialTransactionID = $root.proto.TransactionID.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.total = r.int32();
                        break;
                    }
                    case 3: {
                        m.number = r.int32();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ConsensusMessageChunkInfo
         * @function getTypeUrl
         * @memberof proto.ConsensusMessageChunkInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ConsensusMessageChunkInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ConsensusMessageChunkInfo";
        };

        return ConsensusMessageChunkInfo;
    })();

    proto.ConsensusSubmitMessageTransactionBody = (function () {
        /**
         * Properties of a ConsensusSubmitMessageTransactionBody.
         * @memberof proto
         * @interface IConsensusSubmitMessageTransactionBody
         * @property {proto.ITopicID|null} [topicID] Topic to submit message to.
         * @property {Uint8Array|null} [message] Message to be submitted. Max size of the Transaction (including signatures) is 6KiB.
         * @property {proto.IConsensusMessageChunkInfo|null} [chunkInfo] Optional information of the current chunk in a fragmented message.
         */

        /**
         * Constructs a new ConsensusSubmitMessageTransactionBody.
         * @memberof proto
         * @classdesc UNDOCUMENTED
         * @implements IConsensusSubmitMessageTransactionBody
         * @constructor
         * @param {proto.IConsensusSubmitMessageTransactionBody=} [p] Properties to set
         */
        function ConsensusSubmitMessageTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * Topic to submit message to.
         * @member {proto.ITopicID|null|undefined} topicID
         * @memberof proto.ConsensusSubmitMessageTransactionBody
         * @instance
         */
        ConsensusSubmitMessageTransactionBody.prototype.topicID = null;

        /**
         * Message to be submitted. Max size of the Transaction (including signatures) is 6KiB.
         * @member {Uint8Array} message
         * @memberof proto.ConsensusSubmitMessageTransactionBody
         * @instance
         */
        ConsensusSubmitMessageTransactionBody.prototype.message = $util.newBuffer([]);

        /**
         * Optional information of the current chunk in a fragmented message.
         * @member {proto.IConsensusMessageChunkInfo|null|undefined} chunkInfo
         * @memberof proto.ConsensusSubmitMessageTransactionBody
         * @instance
         */
        ConsensusSubmitMessageTransactionBody.prototype.chunkInfo = null;

        /**
         * Creates a new ConsensusSubmitMessageTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.ConsensusSubmitMessageTransactionBody
         * @static
         * @param {proto.IConsensusSubmitMessageTransactionBody=} [properties] Properties to set
         * @returns {proto.ConsensusSubmitMessageTransactionBody} ConsensusSubmitMessageTransactionBody instance
         */
        ConsensusSubmitMessageTransactionBody.create = function create(properties) {
            return new ConsensusSubmitMessageTransactionBody(properties);
        };

        /**
         * Encodes the specified ConsensusSubmitMessageTransactionBody message. Does not implicitly {@link proto.ConsensusSubmitMessageTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.ConsensusSubmitMessageTransactionBody
         * @static
         * @param {proto.IConsensusSubmitMessageTransactionBody} m ConsensusSubmitMessageTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConsensusSubmitMessageTransactionBody.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.topicID != null && Object.hasOwnProperty.call(m, "topicID"))
                $root.proto.TopicID.encode(m.topicID, w.uint32(10).fork()).ldelim();
            if (m.message != null && Object.hasOwnProperty.call(m, "message")) w.uint32(18).bytes(m.message);
            if (m.chunkInfo != null && Object.hasOwnProperty.call(m, "chunkInfo"))
                $root.proto.ConsensusMessageChunkInfo.encode(m.chunkInfo, w.uint32(26).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a ConsensusSubmitMessageTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ConsensusSubmitMessageTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ConsensusSubmitMessageTransactionBody} ConsensusSubmitMessageTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConsensusSubmitMessageTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.ConsensusSubmitMessageTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.topicID = $root.proto.TopicID.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.message = r.bytes();
                        break;
                    }
                    case 3: {
                        m.chunkInfo = $root.proto.ConsensusMessageChunkInfo.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ConsensusSubmitMessageTransactionBody
         * @function getTypeUrl
         * @memberof proto.ConsensusSubmitMessageTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ConsensusSubmitMessageTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ConsensusSubmitMessageTransactionBody";
        };

        return ConsensusSubmitMessageTransactionBody;
    })();

    proto.UncheckedSubmitBody = (function () {
        /**
         * Properties of an UncheckedSubmitBody.
         * @memberof proto
         * @interface IUncheckedSubmitBody
         * @property {Uint8Array|null} [transactionBytes] The serialized bytes of the Transaction to be submitted without prechecks
         */

        /**
         * Constructs a new UncheckedSubmitBody.
         * @memberof proto
         * @classdesc Submit an arbitrary (serialized) Transaction to the network without prechecks. Requires superuser
         * privileges.
         * @implements IUncheckedSubmitBody
         * @constructor
         * @param {proto.IUncheckedSubmitBody=} [p] Properties to set
         */
        function UncheckedSubmitBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The serialized bytes of the Transaction to be submitted without prechecks
         * @member {Uint8Array} transactionBytes
         * @memberof proto.UncheckedSubmitBody
         * @instance
         */
        UncheckedSubmitBody.prototype.transactionBytes = $util.newBuffer([]);

        /**
         * Creates a new UncheckedSubmitBody instance using the specified properties.
         * @function create
         * @memberof proto.UncheckedSubmitBody
         * @static
         * @param {proto.IUncheckedSubmitBody=} [properties] Properties to set
         * @returns {proto.UncheckedSubmitBody} UncheckedSubmitBody instance
         */
        UncheckedSubmitBody.create = function create(properties) {
            return new UncheckedSubmitBody(properties);
        };

        /**
         * Encodes the specified UncheckedSubmitBody message. Does not implicitly {@link proto.UncheckedSubmitBody.verify|verify} messages.
         * @function encode
         * @memberof proto.UncheckedSubmitBody
         * @static
         * @param {proto.IUncheckedSubmitBody} m UncheckedSubmitBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UncheckedSubmitBody.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.transactionBytes != null && Object.hasOwnProperty.call(m, "transactionBytes"))
                w.uint32(10).bytes(m.transactionBytes);
            return w;
        };

        /**
         * Decodes an UncheckedSubmitBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UncheckedSubmitBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.UncheckedSubmitBody} UncheckedSubmitBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UncheckedSubmitBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.UncheckedSubmitBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.transactionBytes = r.bytes();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for UncheckedSubmitBody
         * @function getTypeUrl
         * @memberof proto.UncheckedSubmitBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        UncheckedSubmitBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.UncheckedSubmitBody";
        };

        return UncheckedSubmitBody;
    })();

    proto.TokenCreateTransactionBody = (function () {
        /**
         * Properties of a TokenCreateTransactionBody.
         * @memberof proto
         * @interface ITokenCreateTransactionBody
         * @property {string|null} [name] The publicly visible name of the token. The token name is specified as a Unicode string.
         * Its UTF-8 encoding cannot exceed 100 bytes, and cannot contain the 0 byte (NUL).
         * @property {string|null} [symbol] The publicly visible token symbol. The token symbol is specified as a Unicode string.
         * Its UTF-8 encoding cannot exceed 100 bytes, and cannot contain the 0 byte (NUL).
         * @property {number|null} [decimals] For tokens of type FUNGIBLE_COMMON - the number of decimal places a
         * token is divisible by. For tokens of type NON_FUNGIBLE_UNIQUE - value
         * must be 0
         * @property {Long|null} [initialSupply] Specifies the initial supply of tokens to be put in circulation. The
         * initial supply is sent to the Treasury Account. The supply is in the
         * lowest denomination possible. In the case for NON_FUNGIBLE_UNIQUE Type
         * the value must be 0
         * @property {proto.IAccountID|null} [treasury] The account which will act as a treasury for the token. This account
         * will receive the specified initial supply or the newly minted NFTs in
         * the case for NON_FUNGIBLE_UNIQUE Type
         * @property {proto.IKey|null} [adminKey] The key which can perform update/delete operations on the token. If empty, the token can be
         * perceived as immutable (not being able to be updated/deleted)
         * @property {proto.IKey|null} [kycKey] The key which can grant or revoke KYC of an account for the token's transactions. If empty,
         * KYC is not required, and KYC grant or revoke operations are not possible.
         * @property {proto.IKey|null} [freezeKey] The key which can sign to freeze or unfreeze an account for token transactions. If empty,
         * freezing is not possible
         * @property {proto.IKey|null} [wipeKey] The key which can wipe the token balance of an account. If empty, wipe is not possible
         * @property {proto.IKey|null} [supplyKey] The key which can change the supply of a token. The key is used to sign Token Mint/Burn
         * operations
         * @property {boolean|null} [freezeDefault] The default Freeze status (frozen or unfrozen) of Hedera accounts relative to this token. If
         * true, an account must be unfrozen before it can receive the token
         * @property {proto.ITimestamp|null} [expiry] The epoch second at which the token should expire; if an auto-renew account and period are
         * specified, this is coerced to the current epoch second plus the autoRenewPeriod
         * @property {proto.IAccountID|null} [autoRenewAccount] An account which will be automatically charged to renew the token's expiration, at
         * autoRenewPeriod interval
         * @property {proto.IDuration|null} [autoRenewPeriod] The interval at which the auto-renew account will be charged to extend the token's expiry
         * @property {string|null} [memo] The memo associated with the token (UTF-8 encoding max 100 bytes)
         * @property {proto.TokenType|null} [tokenType] IWA compatibility. Specifies the token type. Defaults to FUNGIBLE_COMMON
         * @property {proto.TokenSupplyType|null} [supplyType] IWA compatibility. Specified the token supply type. Defaults to INFINITE
         * @property {Long|null} [maxSupply] IWA Compatibility. Depends on TokenSupplyType. For tokens of type FUNGIBLE_COMMON - the
         * maximum number of tokens that can be in circulation. For tokens of type NON_FUNGIBLE_UNIQUE -
         * the maximum number of NFTs (serial numbers) that can be minted. This field can never be
         * changed!
         * @property {proto.IKey|null} [feeScheduleKey] The key which can change the token's custom fee schedule; must sign a TokenFeeScheduleUpdate
         * transaction
         * @property {Array.<proto.ICustomFee>|null} [customFees] The custom fees to be assessed during a CryptoTransfer that transfers units of this token
         * @property {proto.IKey|null} [pauseKey] The Key which can pause and unpause the Token.
         * If Empty the token pause status defaults to PauseNotApplicable, otherwise Unpaused.
         */

        /**
         * Constructs a new TokenCreateTransactionBody.
         * @memberof proto
         * @classdesc Create a new token. After the token is created, the Token ID for it is in the receipt.
         * The specified Treasury Account is receiving the initial supply of tokens as-well as the tokens
         * from the Token Mint operation once executed. The balance of the treasury account is decreased
         * when the Token Burn operation is executed.
         *
         * The <tt>initialSupply</tt> is the initial supply of the smallest parts of a token (like a
         * tinybar, not an hbar). These are the smallest units of the token which may be transferred.
         *
         * The supply can change over time. If the total supply at some moment is <i>S</i> parts of tokens,
         * and the token is using <i>D</i> decimals, then <i>S</i> must be less than or equal to
         * 2<sup>63</sup>-1, which is 9,223,372,036,854,775,807. The number of whole tokens (not parts) will
         * be <i>S / 10<sup>D</sup></i>.
         *
         * If decimals is 8 or 11, then the number of whole tokens can be at most a few billions or
         * millions, respectively. For example, it could match Bitcoin (21 million whole tokens with 8
         * decimals) or hbars (50 billion whole tokens with 8 decimals). It could even match Bitcoin with
         * milli-satoshis (21 million whole tokens with 11 decimals).
         *
         * Note that a created token is <i>immutable</i> if the <tt>adminKey</tt> is omitted. No property of
         * an immutable token can ever change, with the sole exception of its expiry. Anyone can pay to
         * extend the expiry time of an immutable token.
         *
         * A token can be either <i>FUNGIBLE_COMMON</i> or <i>NON_FUNGIBLE_UNIQUE</i>, based on its
         * <i>TokenType</i>. If it has been omitted, <i>FUNGIBLE_COMMON</i> type is used.
         *
         * A token can have either <i>INFINITE</i> or <i>FINITE</i> supply type, based on its
         * <i>TokenType</i>. If it has been omitted, <i>INFINITE</i> type is used.
         *
         * If a <i>FUNGIBLE</i> TokenType is used, <i>initialSupply</i> should explicitly be set to a
         * non-negative. If not, the transaction will resolve to INVALID_TOKEN_INITIAL_SUPPLY.
         *
         * If a <i>NON_FUNGIBLE_UNIQUE</i> TokenType is used, <i>initialSupply</i> should explicitly be set
         * to 0. If not, the transaction will resolve to INVALID_TOKEN_INITIAL_SUPPLY.
         *
         * If an <i>INFINITE</i> TokenSupplyType is used, <i>maxSupply</i> should explicitly be set to 0. If
         * it is not 0, the transaction will resolve to INVALID_TOKEN_MAX_SUPPLY.
         *
         * If a <i>FINITE</i> TokenSupplyType is used, <i>maxSupply</i> should be explicitly set to a
         * non-negative value. If it is not, the transaction will resolve to INVALID_TOKEN_MAX_SUPPLY.
         * @implements ITokenCreateTransactionBody
         * @constructor
         * @param {proto.ITokenCreateTransactionBody=} [p] Properties to set
         */
        function TokenCreateTransactionBody(p) {
            this.customFees = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The publicly visible name of the token. The token name is specified as a Unicode string.
         * Its UTF-8 encoding cannot exceed 100 bytes, and cannot contain the 0 byte (NUL).
         * @member {string} name
         * @memberof proto.TokenCreateTransactionBody
         * @instance
         */
        TokenCreateTransactionBody.prototype.name = "";

        /**
         * The publicly visible token symbol. The token symbol is specified as a Unicode string.
         * Its UTF-8 encoding cannot exceed 100 bytes, and cannot contain the 0 byte (NUL).
         * @member {string} symbol
         * @memberof proto.TokenCreateTransactionBody
         * @instance
         */
        TokenCreateTransactionBody.prototype.symbol = "";

        /**
         * For tokens of type FUNGIBLE_COMMON - the number of decimal places a
         * token is divisible by. For tokens of type NON_FUNGIBLE_UNIQUE - value
         * must be 0
         * @member {number} decimals
         * @memberof proto.TokenCreateTransactionBody
         * @instance
         */
        TokenCreateTransactionBody.prototype.decimals = 0;

        /**
         * Specifies the initial supply of tokens to be put in circulation. The
         * initial supply is sent to the Treasury Account. The supply is in the
         * lowest denomination possible. In the case for NON_FUNGIBLE_UNIQUE Type
         * the value must be 0
         * @member {Long} initialSupply
         * @memberof proto.TokenCreateTransactionBody
         * @instance
         */
        TokenCreateTransactionBody.prototype.initialSupply = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * The account which will act as a treasury for the token. This account
         * will receive the specified initial supply or the newly minted NFTs in
         * the case for NON_FUNGIBLE_UNIQUE Type
         * @member {proto.IAccountID|null|undefined} treasury
         * @memberof proto.TokenCreateTransactionBody
         * @instance
         */
        TokenCreateTransactionBody.prototype.treasury = null;

        /**
         * The key which can perform update/delete operations on the token. If empty, the token can be
         * perceived as immutable (not being able to be updated/deleted)
         * @member {proto.IKey|null|undefined} adminKey
         * @memberof proto.TokenCreateTransactionBody
         * @instance
         */
        TokenCreateTransactionBody.prototype.adminKey = null;

        /**
         * The key which can grant or revoke KYC of an account for the token's transactions. If empty,
         * KYC is not required, and KYC grant or revoke operations are not possible.
         * @member {proto.IKey|null|undefined} kycKey
         * @memberof proto.TokenCreateTransactionBody
         * @instance
         */
        TokenCreateTransactionBody.prototype.kycKey = null;

        /**
         * The key which can sign to freeze or unfreeze an account for token transactions. If empty,
         * freezing is not possible
         * @member {proto.IKey|null|undefined} freezeKey
         * @memberof proto.TokenCreateTransactionBody
         * @instance
         */
        TokenCreateTransactionBody.prototype.freezeKey = null;

        /**
         * The key which can wipe the token balance of an account. If empty, wipe is not possible
         * @member {proto.IKey|null|undefined} wipeKey
         * @memberof proto.TokenCreateTransactionBody
         * @instance
         */
        TokenCreateTransactionBody.prototype.wipeKey = null;

        /**
         * The key which can change the supply of a token. The key is used to sign Token Mint/Burn
         * operations
         * @member {proto.IKey|null|undefined} supplyKey
         * @memberof proto.TokenCreateTransactionBody
         * @instance
         */
        TokenCreateTransactionBody.prototype.supplyKey = null;

        /**
         * The default Freeze status (frozen or unfrozen) of Hedera accounts relative to this token. If
         * true, an account must be unfrozen before it can receive the token
         * @member {boolean} freezeDefault
         * @memberof proto.TokenCreateTransactionBody
         * @instance
         */
        TokenCreateTransactionBody.prototype.freezeDefault = false;

        /**
         * The epoch second at which the token should expire; if an auto-renew account and period are
         * specified, this is coerced to the current epoch second plus the autoRenewPeriod
         * @member {proto.ITimestamp|null|undefined} expiry
         * @memberof proto.TokenCreateTransactionBody
         * @instance
         */
        TokenCreateTransactionBody.prototype.expiry = null;

        /**
         * An account which will be automatically charged to renew the token's expiration, at
         * autoRenewPeriod interval
         * @member {proto.IAccountID|null|undefined} autoRenewAccount
         * @memberof proto.TokenCreateTransactionBody
         * @instance
         */
        TokenCreateTransactionBody.prototype.autoRenewAccount = null;

        /**
         * The interval at which the auto-renew account will be charged to extend the token's expiry
         * @member {proto.IDuration|null|undefined} autoRenewPeriod
         * @memberof proto.TokenCreateTransactionBody
         * @instance
         */
        TokenCreateTransactionBody.prototype.autoRenewPeriod = null;

        /**
         * The memo associated with the token (UTF-8 encoding max 100 bytes)
         * @member {string} memo
         * @memberof proto.TokenCreateTransactionBody
         * @instance
         */
        TokenCreateTransactionBody.prototype.memo = "";

        /**
         * IWA compatibility. Specifies the token type. Defaults to FUNGIBLE_COMMON
         * @member {proto.TokenType} tokenType
         * @memberof proto.TokenCreateTransactionBody
         * @instance
         */
        TokenCreateTransactionBody.prototype.tokenType = 0;

        /**
         * IWA compatibility. Specified the token supply type. Defaults to INFINITE
         * @member {proto.TokenSupplyType} supplyType
         * @memberof proto.TokenCreateTransactionBody
         * @instance
         */
        TokenCreateTransactionBody.prototype.supplyType = 0;

        /**
         * IWA Compatibility. Depends on TokenSupplyType. For tokens of type FUNGIBLE_COMMON - the
         * maximum number of tokens that can be in circulation. For tokens of type NON_FUNGIBLE_UNIQUE -
         * the maximum number of NFTs (serial numbers) that can be minted. This field can never be
         * changed!
         * @member {Long} maxSupply
         * @memberof proto.TokenCreateTransactionBody
         * @instance
         */
        TokenCreateTransactionBody.prototype.maxSupply = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * The key which can change the token's custom fee schedule; must sign a TokenFeeScheduleUpdate
         * transaction
         * @member {proto.IKey|null|undefined} feeScheduleKey
         * @memberof proto.TokenCreateTransactionBody
         * @instance
         */
        TokenCreateTransactionBody.prototype.feeScheduleKey = null;

        /**
         * The custom fees to be assessed during a CryptoTransfer that transfers units of this token
         * @member {Array.<proto.ICustomFee>} customFees
         * @memberof proto.TokenCreateTransactionBody
         * @instance
         */
        TokenCreateTransactionBody.prototype.customFees = $util.emptyArray;

        /**
         * The Key which can pause and unpause the Token.
         * If Empty the token pause status defaults to PauseNotApplicable, otherwise Unpaused.
         * @member {proto.IKey|null|undefined} pauseKey
         * @memberof proto.TokenCreateTransactionBody
         * @instance
         */
        TokenCreateTransactionBody.prototype.pauseKey = null;

        /**
         * Creates a new TokenCreateTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.TokenCreateTransactionBody
         * @static
         * @param {proto.ITokenCreateTransactionBody=} [properties] Properties to set
         * @returns {proto.TokenCreateTransactionBody} TokenCreateTransactionBody instance
         */
        TokenCreateTransactionBody.create = function create(properties) {
            return new TokenCreateTransactionBody(properties);
        };

        /**
         * Encodes the specified TokenCreateTransactionBody message. Does not implicitly {@link proto.TokenCreateTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenCreateTransactionBody
         * @static
         * @param {proto.ITokenCreateTransactionBody} m TokenCreateTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenCreateTransactionBody.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.name != null && Object.hasOwnProperty.call(m, "name")) w.uint32(10).string(m.name);
            if (m.symbol != null && Object.hasOwnProperty.call(m, "symbol")) w.uint32(18).string(m.symbol);
            if (m.decimals != null && Object.hasOwnProperty.call(m, "decimals")) w.uint32(24).uint32(m.decimals);
            if (m.initialSupply != null && Object.hasOwnProperty.call(m, "initialSupply"))
                w.uint32(32).uint64(m.initialSupply);
            if (m.treasury != null && Object.hasOwnProperty.call(m, "treasury"))
                $root.proto.AccountID.encode(m.treasury, w.uint32(42).fork()).ldelim();
            if (m.adminKey != null && Object.hasOwnProperty.call(m, "adminKey"))
                $root.proto.Key.encode(m.adminKey, w.uint32(50).fork()).ldelim();
            if (m.kycKey != null && Object.hasOwnProperty.call(m, "kycKey"))
                $root.proto.Key.encode(m.kycKey, w.uint32(58).fork()).ldelim();
            if (m.freezeKey != null && Object.hasOwnProperty.call(m, "freezeKey"))
                $root.proto.Key.encode(m.freezeKey, w.uint32(66).fork()).ldelim();
            if (m.wipeKey != null && Object.hasOwnProperty.call(m, "wipeKey"))
                $root.proto.Key.encode(m.wipeKey, w.uint32(74).fork()).ldelim();
            if (m.supplyKey != null && Object.hasOwnProperty.call(m, "supplyKey"))
                $root.proto.Key.encode(m.supplyKey, w.uint32(82).fork()).ldelim();
            if (m.freezeDefault != null && Object.hasOwnProperty.call(m, "freezeDefault"))
                w.uint32(88).bool(m.freezeDefault);
            if (m.expiry != null && Object.hasOwnProperty.call(m, "expiry"))
                $root.proto.Timestamp.encode(m.expiry, w.uint32(106).fork()).ldelim();
            if (m.autoRenewAccount != null && Object.hasOwnProperty.call(m, "autoRenewAccount"))
                $root.proto.AccountID.encode(m.autoRenewAccount, w.uint32(114).fork()).ldelim();
            if (m.autoRenewPeriod != null && Object.hasOwnProperty.call(m, "autoRenewPeriod"))
                $root.proto.Duration.encode(m.autoRenewPeriod, w.uint32(122).fork()).ldelim();
            if (m.memo != null && Object.hasOwnProperty.call(m, "memo")) w.uint32(130).string(m.memo);
            if (m.tokenType != null && Object.hasOwnProperty.call(m, "tokenType")) w.uint32(136).int32(m.tokenType);
            if (m.supplyType != null && Object.hasOwnProperty.call(m, "supplyType")) w.uint32(144).int32(m.supplyType);
            if (m.maxSupply != null && Object.hasOwnProperty.call(m, "maxSupply")) w.uint32(152).int64(m.maxSupply);
            if (m.feeScheduleKey != null && Object.hasOwnProperty.call(m, "feeScheduleKey"))
                $root.proto.Key.encode(m.feeScheduleKey, w.uint32(162).fork()).ldelim();
            if (m.customFees != null && m.customFees.length) {
                for (var i = 0; i < m.customFees.length; ++i)
                    $root.proto.CustomFee.encode(m.customFees[i], w.uint32(170).fork()).ldelim();
            }
            if (m.pauseKey != null && Object.hasOwnProperty.call(m, "pauseKey"))
                $root.proto.Key.encode(m.pauseKey, w.uint32(178).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a TokenCreateTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenCreateTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenCreateTransactionBody} TokenCreateTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenCreateTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.TokenCreateTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.name = r.string();
                        break;
                    }
                    case 2: {
                        m.symbol = r.string();
                        break;
                    }
                    case 3: {
                        m.decimals = r.uint32();
                        break;
                    }
                    case 4: {
                        m.initialSupply = r.uint64();
                        break;
                    }
                    case 5: {
                        m.treasury = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    case 6: {
                        m.adminKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                    case 7: {
                        m.kycKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                    case 8: {
                        m.freezeKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                    case 9: {
                        m.wipeKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                    case 10: {
                        m.supplyKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                    case 11: {
                        m.freezeDefault = r.bool();
                        break;
                    }
                    case 13: {
                        m.expiry = $root.proto.Timestamp.decode(r, r.uint32());
                        break;
                    }
                    case 14: {
                        m.autoRenewAccount = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    case 15: {
                        m.autoRenewPeriod = $root.proto.Duration.decode(r, r.uint32());
                        break;
                    }
                    case 16: {
                        m.memo = r.string();
                        break;
                    }
                    case 17: {
                        m.tokenType = r.int32();
                        break;
                    }
                    case 18: {
                        m.supplyType = r.int32();
                        break;
                    }
                    case 19: {
                        m.maxSupply = r.int64();
                        break;
                    }
                    case 20: {
                        m.feeScheduleKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                    case 21: {
                        if (!(m.customFees && m.customFees.length)) m.customFees = [];
                        m.customFees.push($root.proto.CustomFee.decode(r, r.uint32()));
                        break;
                    }
                    case 22: {
                        m.pauseKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenCreateTransactionBody
         * @function getTypeUrl
         * @memberof proto.TokenCreateTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenCreateTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenCreateTransactionBody";
        };

        return TokenCreateTransactionBody;
    })();

    proto.FractionalFee = (function () {
        /**
         * Properties of a FractionalFee.
         * @memberof proto
         * @interface IFractionalFee
         * @property {proto.IFraction|null} [fractionalAmount] The fraction of the transferred units to assess as a fee
         * @property {Long|null} [minimumAmount] The minimum amount to assess
         * @property {Long|null} [maximumAmount] The maximum amount to assess (zero implies no maximum)
         * @property {boolean|null} [netOfTransfers] If true, assesses the fee to the sender, so the receiver gets the full amount from the token
         * transfer list, and the sender is charged an additional fee; if false, the receiver does NOT get
         * the full amount, but only what is left over after paying the fractional fee
         */

        /**
         * Constructs a new FractionalFee.
         * @memberof proto
         * @classdesc A fraction of the transferred units of a token to assess as a fee. The amount assessed will never
         * be less than the given minimum_amount, and never greater than the given maximum_amount.  The
         * denomination is always units of the token to which this fractional fee is attached.
         * @implements IFractionalFee
         * @constructor
         * @param {proto.IFractionalFee=} [p] Properties to set
         */
        function FractionalFee(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The fraction of the transferred units to assess as a fee
         * @member {proto.IFraction|null|undefined} fractionalAmount
         * @memberof proto.FractionalFee
         * @instance
         */
        FractionalFee.prototype.fractionalAmount = null;

        /**
         * The minimum amount to assess
         * @member {Long} minimumAmount
         * @memberof proto.FractionalFee
         * @instance
         */
        FractionalFee.prototype.minimumAmount = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * The maximum amount to assess (zero implies no maximum)
         * @member {Long} maximumAmount
         * @memberof proto.FractionalFee
         * @instance
         */
        FractionalFee.prototype.maximumAmount = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * If true, assesses the fee to the sender, so the receiver gets the full amount from the token
         * transfer list, and the sender is charged an additional fee; if false, the receiver does NOT get
         * the full amount, but only what is left over after paying the fractional fee
         * @member {boolean} netOfTransfers
         * @memberof proto.FractionalFee
         * @instance
         */
        FractionalFee.prototype.netOfTransfers = false;

        /**
         * Creates a new FractionalFee instance using the specified properties.
         * @function create
         * @memberof proto.FractionalFee
         * @static
         * @param {proto.IFractionalFee=} [properties] Properties to set
         * @returns {proto.FractionalFee} FractionalFee instance
         */
        FractionalFee.create = function create(properties) {
            return new FractionalFee(properties);
        };

        /**
         * Encodes the specified FractionalFee message. Does not implicitly {@link proto.FractionalFee.verify|verify} messages.
         * @function encode
         * @memberof proto.FractionalFee
         * @static
         * @param {proto.IFractionalFee} m FractionalFee message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FractionalFee.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.fractionalAmount != null && Object.hasOwnProperty.call(m, "fractionalAmount"))
                $root.proto.Fraction.encode(m.fractionalAmount, w.uint32(10).fork()).ldelim();
            if (m.minimumAmount != null && Object.hasOwnProperty.call(m, "minimumAmount"))
                w.uint32(16).int64(m.minimumAmount);
            if (m.maximumAmount != null && Object.hasOwnProperty.call(m, "maximumAmount"))
                w.uint32(24).int64(m.maximumAmount);
            if (m.netOfTransfers != null && Object.hasOwnProperty.call(m, "netOfTransfers"))
                w.uint32(32).bool(m.netOfTransfers);
            return w;
        };

        /**
         * Decodes a FractionalFee message from the specified reader or buffer.
         * @function decode
         * @memberof proto.FractionalFee
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.FractionalFee} FractionalFee
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FractionalFee.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.FractionalFee();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.fractionalAmount = $root.proto.Fraction.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.minimumAmount = r.int64();
                        break;
                    }
                    case 3: {
                        m.maximumAmount = r.int64();
                        break;
                    }
                    case 4: {
                        m.netOfTransfers = r.bool();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for FractionalFee
         * @function getTypeUrl
         * @memberof proto.FractionalFee
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        FractionalFee.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.FractionalFee";
        };

        return FractionalFee;
    })();

    proto.FixedFee = (function () {
        /**
         * Properties of a FixedFee.
         * @memberof proto
         * @interface IFixedFee
         * @property {Long|null} [amount] The number of units to assess as a fee
         * @property {proto.ITokenID|null} [denominatingTokenId] The denomination of the fee; taken as hbar if left unset and, in a TokenCreate, taken as the id
         * of the newly created token if set to the sentinel value of 0.0.0
         */

        /**
         * Constructs a new FixedFee.
         * @memberof proto
         * @classdesc A fixed number of units (hbar or token) to assess as a fee during a CryptoTransfer that transfers
         * units of the token to which this fixed fee is attached.
         * @implements IFixedFee
         * @constructor
         * @param {proto.IFixedFee=} [p] Properties to set
         */
        function FixedFee(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The number of units to assess as a fee
         * @member {Long} amount
         * @memberof proto.FixedFee
         * @instance
         */
        FixedFee.prototype.amount = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * The denomination of the fee; taken as hbar if left unset and, in a TokenCreate, taken as the id
         * of the newly created token if set to the sentinel value of 0.0.0
         * @member {proto.ITokenID|null|undefined} denominatingTokenId
         * @memberof proto.FixedFee
         * @instance
         */
        FixedFee.prototype.denominatingTokenId = null;

        /**
         * Creates a new FixedFee instance using the specified properties.
         * @function create
         * @memberof proto.FixedFee
         * @static
         * @param {proto.IFixedFee=} [properties] Properties to set
         * @returns {proto.FixedFee} FixedFee instance
         */
        FixedFee.create = function create(properties) {
            return new FixedFee(properties);
        };

        /**
         * Encodes the specified FixedFee message. Does not implicitly {@link proto.FixedFee.verify|verify} messages.
         * @function encode
         * @memberof proto.FixedFee
         * @static
         * @param {proto.IFixedFee} m FixedFee message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FixedFee.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.amount != null && Object.hasOwnProperty.call(m, "amount")) w.uint32(8).int64(m.amount);
            if (m.denominatingTokenId != null && Object.hasOwnProperty.call(m, "denominatingTokenId"))
                $root.proto.TokenID.encode(m.denominatingTokenId, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a FixedFee message from the specified reader or buffer.
         * @function decode
         * @memberof proto.FixedFee
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.FixedFee} FixedFee
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FixedFee.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.FixedFee();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.amount = r.int64();
                        break;
                    }
                    case 2: {
                        m.denominatingTokenId = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for FixedFee
         * @function getTypeUrl
         * @memberof proto.FixedFee
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        FixedFee.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.FixedFee";
        };

        return FixedFee;
    })();

    proto.RoyaltyFee = (function () {
        /**
         * Properties of a RoyaltyFee.
         * @memberof proto
         * @interface IRoyaltyFee
         * @property {proto.IFraction|null} [exchangeValueFraction] The fraction of fungible value exchanged for an NFT to collect as royalty
         * @property {proto.IFixedFee|null} [fallbackFee] If present, the fixed fee to assess to the NFT receiver when no fungible value is exchanged
         * with the sender
         */

        /**
         * Constructs a new RoyaltyFee.
         * @memberof proto
         * @classdesc A fee to assess during a CryptoTransfer that changes ownership of an NFT. Defines the fraction of
         * the fungible value exchanged for an NFT that the ledger should collect as a royalty. ("Fungible
         * value" includes both ℏ and units of fungible HTS tokens.) When the NFT sender does not receive
         * any fungible value, the ledger will assess the fallback fee, if present, to the new NFT owner.
         * Royalty fees can only be added to tokens of type type NON_FUNGIBLE_UNIQUE.
         *
         * **IMPORTANT:** Users must understand that native royalty fees are _strictly_ a convenience feature,
         * and that the network cannot enforce inescapable royalties on the exchange of a non-fractional NFT.
         * For example, if the counterparties agree to split their value transfer and NFT exchange into separate
         * transactions, the network cannot possibly intervene. (And note the counterparties could use a smart
         * contract to make this split transaction atomic if they do not trust each other.)
         *
         * Counterparties that _do_ wish to respect creator royalties should follow the pattern the network
         * recognizes: The NFT sender and receiver should both sign a single `CryptoTransfer` that credits
         * the sender with all the fungible value the receiver is exchanging for the NFT.
         *
         * Similarly, a marketplace using an approved spender account for an escrow transaction should credit
         * the account selling the NFT in the same `CryptoTransfer` that deducts fungible value from the buying
         * account.
         *
         * There is an [open HIP discussion](https://github.com/hashgraph/hedera-improvement-proposal/discussions/578)
         * that proposes to broaden the class of transactions for which the network automatically collects
         * royalties. If this interests or concerns you, please add your voice to that discussion.
         * @implements IRoyaltyFee
         * @constructor
         * @param {proto.IRoyaltyFee=} [p] Properties to set
         */
        function RoyaltyFee(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The fraction of fungible value exchanged for an NFT to collect as royalty
         * @member {proto.IFraction|null|undefined} exchangeValueFraction
         * @memberof proto.RoyaltyFee
         * @instance
         */
        RoyaltyFee.prototype.exchangeValueFraction = null;

        /**
         * If present, the fixed fee to assess to the NFT receiver when no fungible value is exchanged
         * with the sender
         * @member {proto.IFixedFee|null|undefined} fallbackFee
         * @memberof proto.RoyaltyFee
         * @instance
         */
        RoyaltyFee.prototype.fallbackFee = null;

        /**
         * Creates a new RoyaltyFee instance using the specified properties.
         * @function create
         * @memberof proto.RoyaltyFee
         * @static
         * @param {proto.IRoyaltyFee=} [properties] Properties to set
         * @returns {proto.RoyaltyFee} RoyaltyFee instance
         */
        RoyaltyFee.create = function create(properties) {
            return new RoyaltyFee(properties);
        };

        /**
         * Encodes the specified RoyaltyFee message. Does not implicitly {@link proto.RoyaltyFee.verify|verify} messages.
         * @function encode
         * @memberof proto.RoyaltyFee
         * @static
         * @param {proto.IRoyaltyFee} m RoyaltyFee message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RoyaltyFee.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.exchangeValueFraction != null && Object.hasOwnProperty.call(m, "exchangeValueFraction"))
                $root.proto.Fraction.encode(m.exchangeValueFraction, w.uint32(10).fork()).ldelim();
            if (m.fallbackFee != null && Object.hasOwnProperty.call(m, "fallbackFee"))
                $root.proto.FixedFee.encode(m.fallbackFee, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a RoyaltyFee message from the specified reader or buffer.
         * @function decode
         * @memberof proto.RoyaltyFee
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.RoyaltyFee} RoyaltyFee
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RoyaltyFee.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.RoyaltyFee();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.exchangeValueFraction = $root.proto.Fraction.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.fallbackFee = $root.proto.FixedFee.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for RoyaltyFee
         * @function getTypeUrl
         * @memberof proto.RoyaltyFee
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        RoyaltyFee.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.RoyaltyFee";
        };

        return RoyaltyFee;
    })();

    proto.CustomFee = (function () {
        /**
         * Properties of a CustomFee.
         * @memberof proto
         * @interface ICustomFee
         * @property {proto.IFixedFee|null} [fixedFee] Fixed fee to be charged
         * @property {proto.IFractionalFee|null} [fractionalFee] Fractional fee to be charged
         * @property {proto.IRoyaltyFee|null} [royaltyFee] Royalty fee to be charged
         * @property {proto.IAccountID|null} [feeCollectorAccountId] The account to receive the custom fee
         * @property {boolean|null} [allCollectorsAreExempt] If true, exempts all the token's fee collection accounts from this fee.
         * (The token's treasury and the above fee_collector_account_id will always
         * be exempt. Please see <a href="https://hips.hedera.com/hip/hip-573">HIP-573</a>
         * for details.)
         */

        /**
         * Constructs a new CustomFee.
         * @memberof proto
         * @classdesc A transfer fee to assess during a CryptoTransfer that transfers units of the token to which the
         * fee is attached. A custom fee may be either fixed or fractional, and must specify a fee collector
         * account to receive the assessed fees. Only positive fees may be assessed.
         * @implements ICustomFee
         * @constructor
         * @param {proto.ICustomFee=} [p] Properties to set
         */
        function CustomFee(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * Fixed fee to be charged
         * @member {proto.IFixedFee|null|undefined} fixedFee
         * @memberof proto.CustomFee
         * @instance
         */
        CustomFee.prototype.fixedFee = null;

        /**
         * Fractional fee to be charged
         * @member {proto.IFractionalFee|null|undefined} fractionalFee
         * @memberof proto.CustomFee
         * @instance
         */
        CustomFee.prototype.fractionalFee = null;

        /**
         * Royalty fee to be charged
         * @member {proto.IRoyaltyFee|null|undefined} royaltyFee
         * @memberof proto.CustomFee
         * @instance
         */
        CustomFee.prototype.royaltyFee = null;

        /**
         * The account to receive the custom fee
         * @member {proto.IAccountID|null|undefined} feeCollectorAccountId
         * @memberof proto.CustomFee
         * @instance
         */
        CustomFee.prototype.feeCollectorAccountId = null;

        /**
         * If true, exempts all the token's fee collection accounts from this fee.
         * (The token's treasury and the above fee_collector_account_id will always
         * be exempt. Please see <a href="https://hips.hedera.com/hip/hip-573">HIP-573</a>
         * for details.)
         * @member {boolean} allCollectorsAreExempt
         * @memberof proto.CustomFee
         * @instance
         */
        CustomFee.prototype.allCollectorsAreExempt = false;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * CustomFee fee.
         * @member {"fixedFee"|"fractionalFee"|"royaltyFee"|undefined} fee
         * @memberof proto.CustomFee
         * @instance
         */
        Object.defineProperty(CustomFee.prototype, "fee", {
            get: $util.oneOfGetter(($oneOfFields = ["fixedFee", "fractionalFee", "royaltyFee"])),
            set: $util.oneOfSetter($oneOfFields),
        });

        /**
         * Creates a new CustomFee instance using the specified properties.
         * @function create
         * @memberof proto.CustomFee
         * @static
         * @param {proto.ICustomFee=} [properties] Properties to set
         * @returns {proto.CustomFee} CustomFee instance
         */
        CustomFee.create = function create(properties) {
            return new CustomFee(properties);
        };

        /**
         * Encodes the specified CustomFee message. Does not implicitly {@link proto.CustomFee.verify|verify} messages.
         * @function encode
         * @memberof proto.CustomFee
         * @static
         * @param {proto.ICustomFee} m CustomFee message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CustomFee.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.fixedFee != null && Object.hasOwnProperty.call(m, "fixedFee"))
                $root.proto.FixedFee.encode(m.fixedFee, w.uint32(10).fork()).ldelim();
            if (m.fractionalFee != null && Object.hasOwnProperty.call(m, "fractionalFee"))
                $root.proto.FractionalFee.encode(m.fractionalFee, w.uint32(18).fork()).ldelim();
            if (m.feeCollectorAccountId != null && Object.hasOwnProperty.call(m, "feeCollectorAccountId"))
                $root.proto.AccountID.encode(m.feeCollectorAccountId, w.uint32(26).fork()).ldelim();
            if (m.royaltyFee != null && Object.hasOwnProperty.call(m, "royaltyFee"))
                $root.proto.RoyaltyFee.encode(m.royaltyFee, w.uint32(34).fork()).ldelim();
            if (m.allCollectorsAreExempt != null && Object.hasOwnProperty.call(m, "allCollectorsAreExempt"))
                w.uint32(40).bool(m.allCollectorsAreExempt);
            return w;
        };

        /**
         * Decodes a CustomFee message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CustomFee
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.CustomFee} CustomFee
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CustomFee.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.CustomFee();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.fixedFee = $root.proto.FixedFee.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.fractionalFee = $root.proto.FractionalFee.decode(r, r.uint32());
                        break;
                    }
                    case 4: {
                        m.royaltyFee = $root.proto.RoyaltyFee.decode(r, r.uint32());
                        break;
                    }
                    case 3: {
                        m.feeCollectorAccountId = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    case 5: {
                        m.allCollectorsAreExempt = r.bool();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for CustomFee
         * @function getTypeUrl
         * @memberof proto.CustomFee
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CustomFee.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.CustomFee";
        };

        return CustomFee;
    })();

    proto.AssessedCustomFee = (function () {
        /**
         * Properties of an AssessedCustomFee.
         * @memberof proto
         * @interface IAssessedCustomFee
         * @property {Long|null} [amount] The number of units assessed for the fee
         * @property {proto.ITokenID|null} [tokenId] The denomination of the fee; taken as hbar if left unset
         * @property {proto.IAccountID|null} [feeCollectorAccountId] The account to receive the assessed fee
         * @property {Array.<proto.IAccountID>|null} [effectivePayerAccountId] The account(s) whose final balances would have been higher in the absence of this assessed fee
         */

        /**
         * Constructs a new AssessedCustomFee.
         * @memberof proto
         * @classdesc A custom transfer fee that was assessed during handling of a CryptoTransfer.
         * @implements IAssessedCustomFee
         * @constructor
         * @param {proto.IAssessedCustomFee=} [p] Properties to set
         */
        function AssessedCustomFee(p) {
            this.effectivePayerAccountId = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The number of units assessed for the fee
         * @member {Long} amount
         * @memberof proto.AssessedCustomFee
         * @instance
         */
        AssessedCustomFee.prototype.amount = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * The denomination of the fee; taken as hbar if left unset
         * @member {proto.ITokenID|null|undefined} tokenId
         * @memberof proto.AssessedCustomFee
         * @instance
         */
        AssessedCustomFee.prototype.tokenId = null;

        /**
         * The account to receive the assessed fee
         * @member {proto.IAccountID|null|undefined} feeCollectorAccountId
         * @memberof proto.AssessedCustomFee
         * @instance
         */
        AssessedCustomFee.prototype.feeCollectorAccountId = null;

        /**
         * The account(s) whose final balances would have been higher in the absence of this assessed fee
         * @member {Array.<proto.IAccountID>} effectivePayerAccountId
         * @memberof proto.AssessedCustomFee
         * @instance
         */
        AssessedCustomFee.prototype.effectivePayerAccountId = $util.emptyArray;

        /**
         * Creates a new AssessedCustomFee instance using the specified properties.
         * @function create
         * @memberof proto.AssessedCustomFee
         * @static
         * @param {proto.IAssessedCustomFee=} [properties] Properties to set
         * @returns {proto.AssessedCustomFee} AssessedCustomFee instance
         */
        AssessedCustomFee.create = function create(properties) {
            return new AssessedCustomFee(properties);
        };

        /**
         * Encodes the specified AssessedCustomFee message. Does not implicitly {@link proto.AssessedCustomFee.verify|verify} messages.
         * @function encode
         * @memberof proto.AssessedCustomFee
         * @static
         * @param {proto.IAssessedCustomFee} m AssessedCustomFee message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AssessedCustomFee.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.amount != null && Object.hasOwnProperty.call(m, "amount")) w.uint32(8).int64(m.amount);
            if (m.tokenId != null && Object.hasOwnProperty.call(m, "tokenId"))
                $root.proto.TokenID.encode(m.tokenId, w.uint32(18).fork()).ldelim();
            if (m.feeCollectorAccountId != null && Object.hasOwnProperty.call(m, "feeCollectorAccountId"))
                $root.proto.AccountID.encode(m.feeCollectorAccountId, w.uint32(26).fork()).ldelim();
            if (m.effectivePayerAccountId != null && m.effectivePayerAccountId.length) {
                for (var i = 0; i < m.effectivePayerAccountId.length; ++i)
                    $root.proto.AccountID.encode(m.effectivePayerAccountId[i], w.uint32(34).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes an AssessedCustomFee message from the specified reader or buffer.
         * @function decode
         * @memberof proto.AssessedCustomFee
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.AssessedCustomFee} AssessedCustomFee
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AssessedCustomFee.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.AssessedCustomFee();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.amount = r.int64();
                        break;
                    }
                    case 2: {
                        m.tokenId = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                    case 3: {
                        m.feeCollectorAccountId = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    case 4: {
                        if (!(m.effectivePayerAccountId && m.effectivePayerAccountId.length))
                            m.effectivePayerAccountId = [];
                        m.effectivePayerAccountId.push($root.proto.AccountID.decode(r, r.uint32()));
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for AssessedCustomFee
         * @function getTypeUrl
         * @memberof proto.AssessedCustomFee
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AssessedCustomFee.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.AssessedCustomFee";
        };

        return AssessedCustomFee;
    })();

    proto.TokenFreezeAccountTransactionBody = (function () {
        /**
         * Properties of a TokenFreezeAccountTransactionBody.
         * @memberof proto
         * @interface ITokenFreezeAccountTransactionBody
         * @property {proto.ITokenID|null} [token] The token for which this account will be frozen. If token does not exist, transaction results
         * in INVALID_TOKEN_ID
         * @property {proto.IAccountID|null} [account] The account to be frozen
         */

        /**
         * Constructs a new TokenFreezeAccountTransactionBody.
         * @memberof proto
         * @classdesc Freezes transfers of the specified token for the account. Must be signed by the Token's freezeKey.
         * If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.
         * If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.
         * If the provided token is not found, the transaction will resolve to INVALID_TOKEN_ID.
         * If the provided token has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.
         * If an Association between the provided token and account is not found, the transaction will
         * resolve to TOKEN_NOT_ASSOCIATED_TO_ACCOUNT.
         * If no Freeze Key is defined, the transaction will resolve to TOKEN_HAS_NO_FREEZE_KEY.
         * Once executed the Account is marked as Frozen and will not be able to receive or send tokens
         * unless unfrozen. The operation is idempotent.
         * @implements ITokenFreezeAccountTransactionBody
         * @constructor
         * @param {proto.ITokenFreezeAccountTransactionBody=} [p] Properties to set
         */
        function TokenFreezeAccountTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The token for which this account will be frozen. If token does not exist, transaction results
         * in INVALID_TOKEN_ID
         * @member {proto.ITokenID|null|undefined} token
         * @memberof proto.TokenFreezeAccountTransactionBody
         * @instance
         */
        TokenFreezeAccountTransactionBody.prototype.token = null;

        /**
         * The account to be frozen
         * @member {proto.IAccountID|null|undefined} account
         * @memberof proto.TokenFreezeAccountTransactionBody
         * @instance
         */
        TokenFreezeAccountTransactionBody.prototype.account = null;

        /**
         * Creates a new TokenFreezeAccountTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.TokenFreezeAccountTransactionBody
         * @static
         * @param {proto.ITokenFreezeAccountTransactionBody=} [properties] Properties to set
         * @returns {proto.TokenFreezeAccountTransactionBody} TokenFreezeAccountTransactionBody instance
         */
        TokenFreezeAccountTransactionBody.create = function create(properties) {
            return new TokenFreezeAccountTransactionBody(properties);
        };

        /**
         * Encodes the specified TokenFreezeAccountTransactionBody message. Does not implicitly {@link proto.TokenFreezeAccountTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenFreezeAccountTransactionBody
         * @static
         * @param {proto.ITokenFreezeAccountTransactionBody} m TokenFreezeAccountTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenFreezeAccountTransactionBody.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.token != null && Object.hasOwnProperty.call(m, "token"))
                $root.proto.TokenID.encode(m.token, w.uint32(10).fork()).ldelim();
            if (m.account != null && Object.hasOwnProperty.call(m, "account"))
                $root.proto.AccountID.encode(m.account, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a TokenFreezeAccountTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenFreezeAccountTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenFreezeAccountTransactionBody} TokenFreezeAccountTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenFreezeAccountTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.TokenFreezeAccountTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.token = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.account = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenFreezeAccountTransactionBody
         * @function getTypeUrl
         * @memberof proto.TokenFreezeAccountTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenFreezeAccountTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenFreezeAccountTransactionBody";
        };

        return TokenFreezeAccountTransactionBody;
    })();

    proto.TokenUnfreezeAccountTransactionBody = (function () {
        /**
         * Properties of a TokenUnfreezeAccountTransactionBody.
         * @memberof proto
         * @interface ITokenUnfreezeAccountTransactionBody
         * @property {proto.ITokenID|null} [token] The token for which this account will be unfrozen. If token does not exist, transaction
         * results in INVALID_TOKEN_ID
         * @property {proto.IAccountID|null} [account] The account to be unfrozen
         */

        /**
         * Constructs a new TokenUnfreezeAccountTransactionBody.
         * @memberof proto
         * @classdesc Unfreezes transfers of the specified token for the account. Must be signed by the Token's
         * freezeKey.
         * If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.
         * If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.
         * If the provided token is not found, the transaction will resolve to INVALID_TOKEN_ID.
         * If the provided token has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.
         * If an Association between the provided token and account is not found, the transaction will
         * resolve to TOKEN_NOT_ASSOCIATED_TO_ACCOUNT.
         * If no Freeze Key is defined, the transaction will resolve to TOKEN_HAS_NO_FREEZE_KEY.
         * Once executed the Account is marked as Unfrozen and will be able to receive or send tokens. The
         * operation is idempotent.
         * @implements ITokenUnfreezeAccountTransactionBody
         * @constructor
         * @param {proto.ITokenUnfreezeAccountTransactionBody=} [p] Properties to set
         */
        function TokenUnfreezeAccountTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The token for which this account will be unfrozen. If token does not exist, transaction
         * results in INVALID_TOKEN_ID
         * @member {proto.ITokenID|null|undefined} token
         * @memberof proto.TokenUnfreezeAccountTransactionBody
         * @instance
         */
        TokenUnfreezeAccountTransactionBody.prototype.token = null;

        /**
         * The account to be unfrozen
         * @member {proto.IAccountID|null|undefined} account
         * @memberof proto.TokenUnfreezeAccountTransactionBody
         * @instance
         */
        TokenUnfreezeAccountTransactionBody.prototype.account = null;

        /**
         * Creates a new TokenUnfreezeAccountTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.TokenUnfreezeAccountTransactionBody
         * @static
         * @param {proto.ITokenUnfreezeAccountTransactionBody=} [properties] Properties to set
         * @returns {proto.TokenUnfreezeAccountTransactionBody} TokenUnfreezeAccountTransactionBody instance
         */
        TokenUnfreezeAccountTransactionBody.create = function create(properties) {
            return new TokenUnfreezeAccountTransactionBody(properties);
        };

        /**
         * Encodes the specified TokenUnfreezeAccountTransactionBody message. Does not implicitly {@link proto.TokenUnfreezeAccountTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenUnfreezeAccountTransactionBody
         * @static
         * @param {proto.ITokenUnfreezeAccountTransactionBody} m TokenUnfreezeAccountTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenUnfreezeAccountTransactionBody.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.token != null && Object.hasOwnProperty.call(m, "token"))
                $root.proto.TokenID.encode(m.token, w.uint32(10).fork()).ldelim();
            if (m.account != null && Object.hasOwnProperty.call(m, "account"))
                $root.proto.AccountID.encode(m.account, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a TokenUnfreezeAccountTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenUnfreezeAccountTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenUnfreezeAccountTransactionBody} TokenUnfreezeAccountTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenUnfreezeAccountTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.TokenUnfreezeAccountTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.token = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.account = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenUnfreezeAccountTransactionBody
         * @function getTypeUrl
         * @memberof proto.TokenUnfreezeAccountTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenUnfreezeAccountTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenUnfreezeAccountTransactionBody";
        };

        return TokenUnfreezeAccountTransactionBody;
    })();

    proto.TokenGrantKycTransactionBody = (function () {
        /**
         * Properties of a TokenGrantKycTransactionBody.
         * @memberof proto
         * @interface ITokenGrantKycTransactionBody
         * @property {proto.ITokenID|null} [token] The token for which this account will be granted KYC. If token does not exist, transaction
         * results in INVALID_TOKEN_ID
         * @property {proto.IAccountID|null} [account] The account to be KYCed
         */

        /**
         * Constructs a new TokenGrantKycTransactionBody.
         * @memberof proto
         * @classdesc Grants KYC to the account for the given token. Must be signed by the Token's kycKey.
         * If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.
         * If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.
         * If the provided token is not found, the transaction will resolve to INVALID_TOKEN_ID.
         * If the provided token has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.
         * If an Association between the provided token and account is not found, the transaction will
         * resolve to TOKEN_NOT_ASSOCIATED_TO_ACCOUNT.
         * If no KYC Key is defined, the transaction will resolve to TOKEN_HAS_NO_KYC_KEY.
         * Once executed the Account is marked as KYC Granted.
         * @implements ITokenGrantKycTransactionBody
         * @constructor
         * @param {proto.ITokenGrantKycTransactionBody=} [p] Properties to set
         */
        function TokenGrantKycTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The token for which this account will be granted KYC. If token does not exist, transaction
         * results in INVALID_TOKEN_ID
         * @member {proto.ITokenID|null|undefined} token
         * @memberof proto.TokenGrantKycTransactionBody
         * @instance
         */
        TokenGrantKycTransactionBody.prototype.token = null;

        /**
         * The account to be KYCed
         * @member {proto.IAccountID|null|undefined} account
         * @memberof proto.TokenGrantKycTransactionBody
         * @instance
         */
        TokenGrantKycTransactionBody.prototype.account = null;

        /**
         * Creates a new TokenGrantKycTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.TokenGrantKycTransactionBody
         * @static
         * @param {proto.ITokenGrantKycTransactionBody=} [properties] Properties to set
         * @returns {proto.TokenGrantKycTransactionBody} TokenGrantKycTransactionBody instance
         */
        TokenGrantKycTransactionBody.create = function create(properties) {
            return new TokenGrantKycTransactionBody(properties);
        };

        /**
         * Encodes the specified TokenGrantKycTransactionBody message. Does not implicitly {@link proto.TokenGrantKycTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenGrantKycTransactionBody
         * @static
         * @param {proto.ITokenGrantKycTransactionBody} m TokenGrantKycTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenGrantKycTransactionBody.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.token != null && Object.hasOwnProperty.call(m, "token"))
                $root.proto.TokenID.encode(m.token, w.uint32(10).fork()).ldelim();
            if (m.account != null && Object.hasOwnProperty.call(m, "account"))
                $root.proto.AccountID.encode(m.account, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a TokenGrantKycTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenGrantKycTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenGrantKycTransactionBody} TokenGrantKycTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenGrantKycTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.TokenGrantKycTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.token = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.account = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenGrantKycTransactionBody
         * @function getTypeUrl
         * @memberof proto.TokenGrantKycTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenGrantKycTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenGrantKycTransactionBody";
        };

        return TokenGrantKycTransactionBody;
    })();

    proto.TokenRevokeKycTransactionBody = (function () {
        /**
         * Properties of a TokenRevokeKycTransactionBody.
         * @memberof proto
         * @interface ITokenRevokeKycTransactionBody
         * @property {proto.ITokenID|null} [token] The token for which this account will get his KYC revoked. If token does not exist,
         * transaction results in INVALID_TOKEN_ID
         * @property {proto.IAccountID|null} [account] The account to be KYC Revoked
         */

        /**
         * Constructs a new TokenRevokeKycTransactionBody.
         * @memberof proto
         * @classdesc Revokes KYC to the account for the given token. Must be signed by the Token's kycKey.
         * If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.
         * If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.
         * If the provided token is not found, the transaction will resolve to INVALID_TOKEN_ID.
         * If the provided token has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.
         * If an Association between the provided token and account is not found, the transaction will
         * resolve to TOKEN_NOT_ASSOCIATED_TO_ACCOUNT.
         * If no KYC Key is defined, the transaction will resolve to TOKEN_HAS_NO_KYC_KEY.
         * Once executed the Account is marked as KYC Revoked
         * @implements ITokenRevokeKycTransactionBody
         * @constructor
         * @param {proto.ITokenRevokeKycTransactionBody=} [p] Properties to set
         */
        function TokenRevokeKycTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The token for which this account will get his KYC revoked. If token does not exist,
         * transaction results in INVALID_TOKEN_ID
         * @member {proto.ITokenID|null|undefined} token
         * @memberof proto.TokenRevokeKycTransactionBody
         * @instance
         */
        TokenRevokeKycTransactionBody.prototype.token = null;

        /**
         * The account to be KYC Revoked
         * @member {proto.IAccountID|null|undefined} account
         * @memberof proto.TokenRevokeKycTransactionBody
         * @instance
         */
        TokenRevokeKycTransactionBody.prototype.account = null;

        /**
         * Creates a new TokenRevokeKycTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.TokenRevokeKycTransactionBody
         * @static
         * @param {proto.ITokenRevokeKycTransactionBody=} [properties] Properties to set
         * @returns {proto.TokenRevokeKycTransactionBody} TokenRevokeKycTransactionBody instance
         */
        TokenRevokeKycTransactionBody.create = function create(properties) {
            return new TokenRevokeKycTransactionBody(properties);
        };

        /**
         * Encodes the specified TokenRevokeKycTransactionBody message. Does not implicitly {@link proto.TokenRevokeKycTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenRevokeKycTransactionBody
         * @static
         * @param {proto.ITokenRevokeKycTransactionBody} m TokenRevokeKycTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenRevokeKycTransactionBody.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.token != null && Object.hasOwnProperty.call(m, "token"))
                $root.proto.TokenID.encode(m.token, w.uint32(10).fork()).ldelim();
            if (m.account != null && Object.hasOwnProperty.call(m, "account"))
                $root.proto.AccountID.encode(m.account, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a TokenRevokeKycTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenRevokeKycTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenRevokeKycTransactionBody} TokenRevokeKycTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenRevokeKycTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.TokenRevokeKycTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.token = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.account = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenRevokeKycTransactionBody
         * @function getTypeUrl
         * @memberof proto.TokenRevokeKycTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenRevokeKycTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenRevokeKycTransactionBody";
        };

        return TokenRevokeKycTransactionBody;
    })();

    proto.TokenDeleteTransactionBody = (function () {
        /**
         * Properties of a TokenDeleteTransactionBody.
         * @memberof proto
         * @interface ITokenDeleteTransactionBody
         * @property {proto.ITokenID|null} [token] The token to be deleted. If invalid token is specified, transaction will
         * result in INVALID_TOKEN_ID
         */

        /**
         * Constructs a new TokenDeleteTransactionBody.
         * @memberof proto
         * @classdesc Marks a token as deleted, though it will remain in the ledger.
         * The operation must be signed by the specified Admin Key of the Token. If
         * admin key is not set, Transaction will result in TOKEN_IS_IMMUTABlE.
         * Once deleted update, mint, burn, wipe, freeze, unfreeze, grant kyc, revoke
         * kyc and token transfer transactions will resolve to TOKEN_WAS_DELETED.
         * @implements ITokenDeleteTransactionBody
         * @constructor
         * @param {proto.ITokenDeleteTransactionBody=} [p] Properties to set
         */
        function TokenDeleteTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The token to be deleted. If invalid token is specified, transaction will
         * result in INVALID_TOKEN_ID
         * @member {proto.ITokenID|null|undefined} token
         * @memberof proto.TokenDeleteTransactionBody
         * @instance
         */
        TokenDeleteTransactionBody.prototype.token = null;

        /**
         * Creates a new TokenDeleteTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.TokenDeleteTransactionBody
         * @static
         * @param {proto.ITokenDeleteTransactionBody=} [properties] Properties to set
         * @returns {proto.TokenDeleteTransactionBody} TokenDeleteTransactionBody instance
         */
        TokenDeleteTransactionBody.create = function create(properties) {
            return new TokenDeleteTransactionBody(properties);
        };

        /**
         * Encodes the specified TokenDeleteTransactionBody message. Does not implicitly {@link proto.TokenDeleteTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenDeleteTransactionBody
         * @static
         * @param {proto.ITokenDeleteTransactionBody} m TokenDeleteTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenDeleteTransactionBody.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.token != null && Object.hasOwnProperty.call(m, "token"))
                $root.proto.TokenID.encode(m.token, w.uint32(10).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a TokenDeleteTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenDeleteTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenDeleteTransactionBody} TokenDeleteTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenDeleteTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.TokenDeleteTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.token = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenDeleteTransactionBody
         * @function getTypeUrl
         * @memberof proto.TokenDeleteTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenDeleteTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenDeleteTransactionBody";
        };

        return TokenDeleteTransactionBody;
    })();

    proto.TokenUpdateTransactionBody = (function () {
        /**
         * Properties of a TokenUpdateTransactionBody.
         * @memberof proto
         * @interface ITokenUpdateTransactionBody
         * @property {proto.ITokenID|null} [token] The Token to be updated
         * @property {string|null} [symbol] The new publicly visible token symbol. The token symbol is specified as a Unicode string.
         * Its UTF-8 encoding cannot exceed 100 bytes, and cannot contain the 0 byte (NUL).
         * @property {string|null} [name] The new publicly visible name of the token. The token name is specified as a Unicode string.
         * Its UTF-8 encoding cannot exceed 100 bytes, and cannot contain the 0 byte (NUL).
         * @property {proto.IAccountID|null} [treasury] The new Treasury account of the Token. If the provided treasury account is not existing or
         * deleted, the response will be INVALID_TREASURY_ACCOUNT_FOR_TOKEN. If successful, the Token
         * balance held in the previous Treasury Account is transferred to the new one.
         * @property {proto.IKey|null} [adminKey] The new admin key of the Token. If Token is immutable, transaction will resolve to
         * TOKEN_IS_IMMUTABlE.
         * @property {proto.IKey|null} [kycKey] The new KYC key of the Token. If Token does not have currently a KYC key, transaction will
         * resolve to TOKEN_HAS_NO_KYC_KEY.
         * @property {proto.IKey|null} [freezeKey] The new Freeze key of the Token. If the Token does not have currently a Freeze key,
         * transaction will resolve to TOKEN_HAS_NO_FREEZE_KEY.
         * @property {proto.IKey|null} [wipeKey] The new Wipe key of the Token. If the Token does not have currently a Wipe key, transaction
         * will resolve to TOKEN_HAS_NO_WIPE_KEY.
         * @property {proto.IKey|null} [supplyKey] The new Supply key of the Token. If the Token does not have currently a Supply key,
         * transaction will resolve to TOKEN_HAS_NO_SUPPLY_KEY.
         * @property {proto.IAccountID|null} [autoRenewAccount] The new account which will be automatically charged to renew the token's expiration, at
         * autoRenewPeriod interval.
         * @property {proto.IDuration|null} [autoRenewPeriod] The new interval at which the auto-renew account will be charged to extend the token's
         * expiry.
         * @property {proto.ITimestamp|null} [expiry] The new expiry time of the token. Expiry can be updated even if admin key is not set. If the
         * provided expiry is earlier than the current token expiry, transaction wil resolve to
         * INVALID_EXPIRATION_TIME
         * @property {google.protobuf.IStringValue|null} [memo] If set, the new memo to be associated with the token (UTF-8 encoding max 100 bytes)
         * @property {proto.IKey|null} [feeScheduleKey] If set, the new key to use to update the token's custom fee schedule; if the token does not
         * currently have this key, transaction will resolve to TOKEN_HAS_NO_FEE_SCHEDULE_KEY
         * @property {proto.IKey|null} [pauseKey] The Key which can pause and unpause the Token. If the Token does not currently have a pause key,
         * transaction will resolve to TOKEN_HAS_NO_PAUSE_KEY
         */

        /**
         * Constructs a new TokenUpdateTransactionBody.
         * @memberof proto
         * @classdesc At consensus, updates an already created token to the given values.
         *
         * If no value is given for a field, that field is left unchanged. For an immutable tokens (that is,
         * a token without an admin key), only the expiry may be updated. Setting any other field in that
         * case will cause the transaction status to resolve to TOKEN_IS_IMMUTABLE.
         *
         * --- Signing Requirements ---
         * 1. Whether or not a token has an admin key, its expiry can be extended with only the transaction
         * payer's signature.
         * 2. Updating any other field of a mutable token requires the admin key's signature.
         * 3. If a new admin key is set, this new key must sign <b>unless</b> it is exactly an empty
         * <tt>KeyList</tt>. This special sentinel key removes the existing admin key and causes the
         * token to become immutable. (Other <tt>Key</tt> structures without a constituent
         * <tt>Ed25519</tt> key will be rejected with <tt>INVALID_ADMIN_KEY</tt>.)
         * 4. If a new treasury is set, the new treasury account's key must sign the transaction.
         *
         * --- Nft Requirements ---
         * 1. If a non fungible token has a positive treasury balance, the operation will abort with
         * CURRENT_TREASURY_STILL_OWNS_NFTS.
         * @implements ITokenUpdateTransactionBody
         * @constructor
         * @param {proto.ITokenUpdateTransactionBody=} [p] Properties to set
         */
        function TokenUpdateTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The Token to be updated
         * @member {proto.ITokenID|null|undefined} token
         * @memberof proto.TokenUpdateTransactionBody
         * @instance
         */
        TokenUpdateTransactionBody.prototype.token = null;

        /**
         * The new publicly visible token symbol. The token symbol is specified as a Unicode string.
         * Its UTF-8 encoding cannot exceed 100 bytes, and cannot contain the 0 byte (NUL).
         * @member {string} symbol
         * @memberof proto.TokenUpdateTransactionBody
         * @instance
         */
        TokenUpdateTransactionBody.prototype.symbol = "";

        /**
         * The new publicly visible name of the token. The token name is specified as a Unicode string.
         * Its UTF-8 encoding cannot exceed 100 bytes, and cannot contain the 0 byte (NUL).
         * @member {string} name
         * @memberof proto.TokenUpdateTransactionBody
         * @instance
         */
        TokenUpdateTransactionBody.prototype.name = "";

        /**
         * The new Treasury account of the Token. If the provided treasury account is not existing or
         * deleted, the response will be INVALID_TREASURY_ACCOUNT_FOR_TOKEN. If successful, the Token
         * balance held in the previous Treasury Account is transferred to the new one.
         * @member {proto.IAccountID|null|undefined} treasury
         * @memberof proto.TokenUpdateTransactionBody
         * @instance
         */
        TokenUpdateTransactionBody.prototype.treasury = null;

        /**
         * The new admin key of the Token. If Token is immutable, transaction will resolve to
         * TOKEN_IS_IMMUTABlE.
         * @member {proto.IKey|null|undefined} adminKey
         * @memberof proto.TokenUpdateTransactionBody
         * @instance
         */
        TokenUpdateTransactionBody.prototype.adminKey = null;

        /**
         * The new KYC key of the Token. If Token does not have currently a KYC key, transaction will
         * resolve to TOKEN_HAS_NO_KYC_KEY.
         * @member {proto.IKey|null|undefined} kycKey
         * @memberof proto.TokenUpdateTransactionBody
         * @instance
         */
        TokenUpdateTransactionBody.prototype.kycKey = null;

        /**
         * The new Freeze key of the Token. If the Token does not have currently a Freeze key,
         * transaction will resolve to TOKEN_HAS_NO_FREEZE_KEY.
         * @member {proto.IKey|null|undefined} freezeKey
         * @memberof proto.TokenUpdateTransactionBody
         * @instance
         */
        TokenUpdateTransactionBody.prototype.freezeKey = null;

        /**
         * The new Wipe key of the Token. If the Token does not have currently a Wipe key, transaction
         * will resolve to TOKEN_HAS_NO_WIPE_KEY.
         * @member {proto.IKey|null|undefined} wipeKey
         * @memberof proto.TokenUpdateTransactionBody
         * @instance
         */
        TokenUpdateTransactionBody.prototype.wipeKey = null;

        /**
         * The new Supply key of the Token. If the Token does not have currently a Supply key,
         * transaction will resolve to TOKEN_HAS_NO_SUPPLY_KEY.
         * @member {proto.IKey|null|undefined} supplyKey
         * @memberof proto.TokenUpdateTransactionBody
         * @instance
         */
        TokenUpdateTransactionBody.prototype.supplyKey = null;

        /**
         * The new account which will be automatically charged to renew the token's expiration, at
         * autoRenewPeriod interval.
         * @member {proto.IAccountID|null|undefined} autoRenewAccount
         * @memberof proto.TokenUpdateTransactionBody
         * @instance
         */
        TokenUpdateTransactionBody.prototype.autoRenewAccount = null;

        /**
         * The new interval at which the auto-renew account will be charged to extend the token's
         * expiry.
         * @member {proto.IDuration|null|undefined} autoRenewPeriod
         * @memberof proto.TokenUpdateTransactionBody
         * @instance
         */
        TokenUpdateTransactionBody.prototype.autoRenewPeriod = null;

        /**
         * The new expiry time of the token. Expiry can be updated even if admin key is not set. If the
         * provided expiry is earlier than the current token expiry, transaction wil resolve to
         * INVALID_EXPIRATION_TIME
         * @member {proto.ITimestamp|null|undefined} expiry
         * @memberof proto.TokenUpdateTransactionBody
         * @instance
         */
        TokenUpdateTransactionBody.prototype.expiry = null;

        /**
         * If set, the new memo to be associated with the token (UTF-8 encoding max 100 bytes)
         * @member {google.protobuf.IStringValue|null|undefined} memo
         * @memberof proto.TokenUpdateTransactionBody
         * @instance
         */
        TokenUpdateTransactionBody.prototype.memo = null;

        /**
         * If set, the new key to use to update the token's custom fee schedule; if the token does not
         * currently have this key, transaction will resolve to TOKEN_HAS_NO_FEE_SCHEDULE_KEY
         * @member {proto.IKey|null|undefined} feeScheduleKey
         * @memberof proto.TokenUpdateTransactionBody
         * @instance
         */
        TokenUpdateTransactionBody.prototype.feeScheduleKey = null;

        /**
         * The Key which can pause and unpause the Token. If the Token does not currently have a pause key,
         * transaction will resolve to TOKEN_HAS_NO_PAUSE_KEY
         * @member {proto.IKey|null|undefined} pauseKey
         * @memberof proto.TokenUpdateTransactionBody
         * @instance
         */
        TokenUpdateTransactionBody.prototype.pauseKey = null;

        /**
         * Creates a new TokenUpdateTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.TokenUpdateTransactionBody
         * @static
         * @param {proto.ITokenUpdateTransactionBody=} [properties] Properties to set
         * @returns {proto.TokenUpdateTransactionBody} TokenUpdateTransactionBody instance
         */
        TokenUpdateTransactionBody.create = function create(properties) {
            return new TokenUpdateTransactionBody(properties);
        };

        /**
         * Encodes the specified TokenUpdateTransactionBody message. Does not implicitly {@link proto.TokenUpdateTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenUpdateTransactionBody
         * @static
         * @param {proto.ITokenUpdateTransactionBody} m TokenUpdateTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenUpdateTransactionBody.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.token != null && Object.hasOwnProperty.call(m, "token"))
                $root.proto.TokenID.encode(m.token, w.uint32(10).fork()).ldelim();
            if (m.symbol != null && Object.hasOwnProperty.call(m, "symbol")) w.uint32(18).string(m.symbol);
            if (m.name != null && Object.hasOwnProperty.call(m, "name")) w.uint32(26).string(m.name);
            if (m.treasury != null && Object.hasOwnProperty.call(m, "treasury"))
                $root.proto.AccountID.encode(m.treasury, w.uint32(34).fork()).ldelim();
            if (m.adminKey != null && Object.hasOwnProperty.call(m, "adminKey"))
                $root.proto.Key.encode(m.adminKey, w.uint32(42).fork()).ldelim();
            if (m.kycKey != null && Object.hasOwnProperty.call(m, "kycKey"))
                $root.proto.Key.encode(m.kycKey, w.uint32(50).fork()).ldelim();
            if (m.freezeKey != null && Object.hasOwnProperty.call(m, "freezeKey"))
                $root.proto.Key.encode(m.freezeKey, w.uint32(58).fork()).ldelim();
            if (m.wipeKey != null && Object.hasOwnProperty.call(m, "wipeKey"))
                $root.proto.Key.encode(m.wipeKey, w.uint32(66).fork()).ldelim();
            if (m.supplyKey != null && Object.hasOwnProperty.call(m, "supplyKey"))
                $root.proto.Key.encode(m.supplyKey, w.uint32(74).fork()).ldelim();
            if (m.autoRenewAccount != null && Object.hasOwnProperty.call(m, "autoRenewAccount"))
                $root.proto.AccountID.encode(m.autoRenewAccount, w.uint32(82).fork()).ldelim();
            if (m.autoRenewPeriod != null && Object.hasOwnProperty.call(m, "autoRenewPeriod"))
                $root.proto.Duration.encode(m.autoRenewPeriod, w.uint32(90).fork()).ldelim();
            if (m.expiry != null && Object.hasOwnProperty.call(m, "expiry"))
                $root.proto.Timestamp.encode(m.expiry, w.uint32(98).fork()).ldelim();
            if (m.memo != null && Object.hasOwnProperty.call(m, "memo"))
                $root.google.protobuf.StringValue.encode(m.memo, w.uint32(106).fork()).ldelim();
            if (m.feeScheduleKey != null && Object.hasOwnProperty.call(m, "feeScheduleKey"))
                $root.proto.Key.encode(m.feeScheduleKey, w.uint32(114).fork()).ldelim();
            if (m.pauseKey != null && Object.hasOwnProperty.call(m, "pauseKey"))
                $root.proto.Key.encode(m.pauseKey, w.uint32(122).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a TokenUpdateTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenUpdateTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenUpdateTransactionBody} TokenUpdateTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenUpdateTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.TokenUpdateTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.token = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.symbol = r.string();
                        break;
                    }
                    case 3: {
                        m.name = r.string();
                        break;
                    }
                    case 4: {
                        m.treasury = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    case 5: {
                        m.adminKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                    case 6: {
                        m.kycKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                    case 7: {
                        m.freezeKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                    case 8: {
                        m.wipeKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                    case 9: {
                        m.supplyKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                    case 10: {
                        m.autoRenewAccount = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    case 11: {
                        m.autoRenewPeriod = $root.proto.Duration.decode(r, r.uint32());
                        break;
                    }
                    case 12: {
                        m.expiry = $root.proto.Timestamp.decode(r, r.uint32());
                        break;
                    }
                    case 13: {
                        m.memo = $root.google.protobuf.StringValue.decode(r, r.uint32());
                        break;
                    }
                    case 14: {
                        m.feeScheduleKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                    case 15: {
                        m.pauseKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenUpdateTransactionBody
         * @function getTypeUrl
         * @memberof proto.TokenUpdateTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenUpdateTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenUpdateTransactionBody";
        };

        return TokenUpdateTransactionBody;
    })();

    proto.TokenMintTransactionBody = (function () {
        /**
         * Properties of a TokenMintTransactionBody.
         * @memberof proto
         * @interface ITokenMintTransactionBody
         * @property {proto.ITokenID|null} [token] The token for which to mint tokens. If token does not exist, transaction results in
         * INVALID_TOKEN_ID
         * @property {Long|null} [amount] Applicable to tokens of type FUNGIBLE_COMMON. The amount to mint to the Treasury Account.
         * Amount must be a positive non-zero number represented in the lowest denomination of the
         * token. The new supply must be lower than 2^63.
         * @property {Array.<Uint8Array>|null} [metadata] Applicable to tokens of type NON_FUNGIBLE_UNIQUE. A list of metadata that are being created.
         * Maximum allowed size of each metadata is 100 bytes
         */

        /**
         * Constructs a new TokenMintTransactionBody.
         * @memberof proto
         * @classdesc Mints tokens to the Token's treasury Account. If no Supply Key is defined, the transaction will
         * resolve to TOKEN_HAS_NO_SUPPLY_KEY.
         * The operation increases the Total Supply of the Token. The maximum total supply a token can have
         * is 2^63-1.
         * The amount provided must be in the lowest denomination possible. Example:
         * Token A has 2 decimals. In order to mint 100 tokens, one must provide amount of 10000. In order
         * to mint 100.55 tokens, one must provide amount of 10055.
         * If both amount and metadata list get filled, a INVALID_TRANSACTION_BODY response code will be
         * returned.
         * If the metadata list contains metadata which is too large, a METADATA_TOO_LONG response code will
         * be returned.
         * If the metadata list is not filled for a non-fungible token type, a INVALID_TOKEN_MINT_AMOUNT response
         * code will be returned.
         * If a zero amount is provided for a fungible token type, it will be treated as a regular transaction.
         * If the metadata list count is greater than the batch size limit global dynamic property, a
         * BATCH_SIZE_LIMIT_EXCEEDED response code will be returned.
         * @implements ITokenMintTransactionBody
         * @constructor
         * @param {proto.ITokenMintTransactionBody=} [p] Properties to set
         */
        function TokenMintTransactionBody(p) {
            this.metadata = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The token for which to mint tokens. If token does not exist, transaction results in
         * INVALID_TOKEN_ID
         * @member {proto.ITokenID|null|undefined} token
         * @memberof proto.TokenMintTransactionBody
         * @instance
         */
        TokenMintTransactionBody.prototype.token = null;

        /**
         * Applicable to tokens of type FUNGIBLE_COMMON. The amount to mint to the Treasury Account.
         * Amount must be a positive non-zero number represented in the lowest denomination of the
         * token. The new supply must be lower than 2^63.
         * @member {Long} amount
         * @memberof proto.TokenMintTransactionBody
         * @instance
         */
        TokenMintTransactionBody.prototype.amount = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * Applicable to tokens of type NON_FUNGIBLE_UNIQUE. A list of metadata that are being created.
         * Maximum allowed size of each metadata is 100 bytes
         * @member {Array.<Uint8Array>} metadata
         * @memberof proto.TokenMintTransactionBody
         * @instance
         */
        TokenMintTransactionBody.prototype.metadata = $util.emptyArray;

        /**
         * Creates a new TokenMintTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.TokenMintTransactionBody
         * @static
         * @param {proto.ITokenMintTransactionBody=} [properties] Properties to set
         * @returns {proto.TokenMintTransactionBody} TokenMintTransactionBody instance
         */
        TokenMintTransactionBody.create = function create(properties) {
            return new TokenMintTransactionBody(properties);
        };

        /**
         * Encodes the specified TokenMintTransactionBody message. Does not implicitly {@link proto.TokenMintTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenMintTransactionBody
         * @static
         * @param {proto.ITokenMintTransactionBody} m TokenMintTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenMintTransactionBody.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.token != null && Object.hasOwnProperty.call(m, "token"))
                $root.proto.TokenID.encode(m.token, w.uint32(10).fork()).ldelim();
            if (m.amount != null && Object.hasOwnProperty.call(m, "amount")) w.uint32(16).uint64(m.amount);
            if (m.metadata != null && m.metadata.length) {
                for (var i = 0; i < m.metadata.length; ++i) w.uint32(26).bytes(m.metadata[i]);
            }
            return w;
        };

        /**
         * Decodes a TokenMintTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenMintTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenMintTransactionBody} TokenMintTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenMintTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.TokenMintTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.token = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.amount = r.uint64();
                        break;
                    }
                    case 3: {
                        if (!(m.metadata && m.metadata.length)) m.metadata = [];
                        m.metadata.push(r.bytes());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenMintTransactionBody
         * @function getTypeUrl
         * @memberof proto.TokenMintTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenMintTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenMintTransactionBody";
        };

        return TokenMintTransactionBody;
    })();

    proto.TokenBurnTransactionBody = (function () {
        /**
         * Properties of a TokenBurnTransactionBody.
         * @memberof proto
         * @interface ITokenBurnTransactionBody
         * @property {proto.ITokenID|null} [token] The token for which to burn tokens. If token does not exist, transaction results in
         * INVALID_TOKEN_ID
         * @property {Long|null} [amount] Applicable to tokens of type FUNGIBLE_COMMON. The amount to burn from the Treasury Account.
         * Amount must be a positive non-zero number, not bigger than the token balance of the treasury
         * account (0; balance], represented in the lowest denomination.
         * @property {Array.<Long>|null} [serialNumbers] Applicable to tokens of type NON_FUNGIBLE_UNIQUE. The list of serial numbers to be burned.
         */

        /**
         * Constructs a new TokenBurnTransactionBody.
         * @memberof proto
         * @classdesc Burns tokens from the Token's treasury Account. If no Supply Key is defined, the transaction will
         * resolve to TOKEN_HAS_NO_SUPPLY_KEY.
         * The operation decreases the Total Supply of the Token. Total supply cannot go below zero.
         * The amount provided must be in the lowest denomination possible. Example:
         * Token A has 2 decimals. In order to burn 100 tokens, one must provide amount of 10000. In order
         * to burn 100.55 tokens, one must provide amount of 10055.
         * For non fungible tokens the transaction body accepts serialNumbers list of integers as a parameter.
         *
         * If the serialNumbers don't get filled for non-fungible token type, a INVALID_TOKEN_BURN_AMOUNT response
         * code will be returned.
         * If a zero amount is provided for a fungible token type, it will be treated as a regular transaction.
         * If both amount and serialNumbers get filled, a INVALID_TRANSACTION_BODY response code will be
         * returned.
         * If the serialNumbers' list count is greater than the batch size limit global dynamic property, a
         * BATCH_SIZE_LIMIT_EXCEEDED response code will be returned.
         * If the serialNumbers list contains a non-positive integer as a serial number, a INVALID_NFT_ID
         * response code will be returned.
         * @implements ITokenBurnTransactionBody
         * @constructor
         * @param {proto.ITokenBurnTransactionBody=} [p] Properties to set
         */
        function TokenBurnTransactionBody(p) {
            this.serialNumbers = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The token for which to burn tokens. If token does not exist, transaction results in
         * INVALID_TOKEN_ID
         * @member {proto.ITokenID|null|undefined} token
         * @memberof proto.TokenBurnTransactionBody
         * @instance
         */
        TokenBurnTransactionBody.prototype.token = null;

        /**
         * Applicable to tokens of type FUNGIBLE_COMMON. The amount to burn from the Treasury Account.
         * Amount must be a positive non-zero number, not bigger than the token balance of the treasury
         * account (0; balance], represented in the lowest denomination.
         * @member {Long} amount
         * @memberof proto.TokenBurnTransactionBody
         * @instance
         */
        TokenBurnTransactionBody.prototype.amount = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * Applicable to tokens of type NON_FUNGIBLE_UNIQUE. The list of serial numbers to be burned.
         * @member {Array.<Long>} serialNumbers
         * @memberof proto.TokenBurnTransactionBody
         * @instance
         */
        TokenBurnTransactionBody.prototype.serialNumbers = $util.emptyArray;

        /**
         * Creates a new TokenBurnTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.TokenBurnTransactionBody
         * @static
         * @param {proto.ITokenBurnTransactionBody=} [properties] Properties to set
         * @returns {proto.TokenBurnTransactionBody} TokenBurnTransactionBody instance
         */
        TokenBurnTransactionBody.create = function create(properties) {
            return new TokenBurnTransactionBody(properties);
        };

        /**
         * Encodes the specified TokenBurnTransactionBody message. Does not implicitly {@link proto.TokenBurnTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenBurnTransactionBody
         * @static
         * @param {proto.ITokenBurnTransactionBody} m TokenBurnTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenBurnTransactionBody.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.token != null && Object.hasOwnProperty.call(m, "token"))
                $root.proto.TokenID.encode(m.token, w.uint32(10).fork()).ldelim();
            if (m.amount != null && Object.hasOwnProperty.call(m, "amount")) w.uint32(16).uint64(m.amount);
            if (m.serialNumbers != null && m.serialNumbers.length) {
                w.uint32(26).fork();
                for (var i = 0; i < m.serialNumbers.length; ++i) w.int64(m.serialNumbers[i]);
                w.ldelim();
            }
            return w;
        };

        /**
         * Decodes a TokenBurnTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenBurnTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenBurnTransactionBody} TokenBurnTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenBurnTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.TokenBurnTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.token = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.amount = r.uint64();
                        break;
                    }
                    case 3: {
                        if (!(m.serialNumbers && m.serialNumbers.length)) m.serialNumbers = [];
                        if ((t & 7) === 2) {
                            var c2 = r.uint32() + r.pos;
                            while (r.pos < c2) m.serialNumbers.push(r.int64());
                        } else m.serialNumbers.push(r.int64());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenBurnTransactionBody
         * @function getTypeUrl
         * @memberof proto.TokenBurnTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenBurnTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenBurnTransactionBody";
        };

        return TokenBurnTransactionBody;
    })();

    proto.TokenWipeAccountTransactionBody = (function () {
        /**
         * Properties of a TokenWipeAccountTransactionBody.
         * @memberof proto
         * @interface ITokenWipeAccountTransactionBody
         * @property {proto.ITokenID|null} [token] The token for which the account will be wiped. If token does not exist, transaction results
         * in INVALID_TOKEN_ID
         * @property {proto.IAccountID|null} [account] The account to be wiped
         * @property {Long|null} [amount] Applicable to tokens of type FUNGIBLE_COMMON. The amount of tokens to wipe from the specified
         * account. Amount must be a positive non-zero number in the lowest denomination possible, not
         * bigger than the token balance of the account (0; balance]
         * @property {Array.<Long>|null} [serialNumbers] Applicable to tokens of type NON_FUNGIBLE_UNIQUE. The list of serial numbers to be wiped.
         */

        /**
         * Constructs a new TokenWipeAccountTransactionBody.
         * @memberof proto
         * @classdesc Wipes the provided amount of tokens from the specified Account. Must be signed by the Token's
         * Wipe key.
         * If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.
         * If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.
         * If the provided token is not found, the transaction will resolve to INVALID_TOKEN_ID.
         * If the provided token has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.
         * If an Association between the provided token and account is not found, the transaction will
         * resolve to TOKEN_NOT_ASSOCIATED_TO_ACCOUNT.
         * If Wipe Key is not present in the Token, transaction results in TOKEN_HAS_NO_WIPE_KEY.
         * If the provided account is the Token's Treasury Account, transaction results in
         * CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT
         * On success, tokens are removed from the account and the total supply of the token is decreased by
         * the wiped amount.
         *
         * If both amount and serialNumbers get filled, a INVALID_TRANSACTION_BODY response code will be
         * returned.
         * If the serialNumbers don't get filled for a non-fungible token type, a INVALID_WIPING_AMOUNT response
         * code will be returned.
         * If a zero amount is provided for a fungible token type, it will be treated as a regular transaction.
         * If the serialNumbers list contains a non-positive integer as a serial number, a INVALID_NFT_ID
         * response code will be returned.
         * If the serialNumbers' list count is greater than the batch size limit global dynamic property, a
         * BATCH_SIZE_LIMIT_EXCEEDED response code will be returned.
         *
         * The amount provided is in the lowest denomination possible. Example:
         * Token A has 2 decimals. In order to wipe 100 tokens from account, one must provide amount of
         * 10000. In order to wipe 100.55 tokens, one must provide amount of 10055.
         * @implements ITokenWipeAccountTransactionBody
         * @constructor
         * @param {proto.ITokenWipeAccountTransactionBody=} [p] Properties to set
         */
        function TokenWipeAccountTransactionBody(p) {
            this.serialNumbers = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The token for which the account will be wiped. If token does not exist, transaction results
         * in INVALID_TOKEN_ID
         * @member {proto.ITokenID|null|undefined} token
         * @memberof proto.TokenWipeAccountTransactionBody
         * @instance
         */
        TokenWipeAccountTransactionBody.prototype.token = null;

        /**
         * The account to be wiped
         * @member {proto.IAccountID|null|undefined} account
         * @memberof proto.TokenWipeAccountTransactionBody
         * @instance
         */
        TokenWipeAccountTransactionBody.prototype.account = null;

        /**
         * Applicable to tokens of type FUNGIBLE_COMMON. The amount of tokens to wipe from the specified
         * account. Amount must be a positive non-zero number in the lowest denomination possible, not
         * bigger than the token balance of the account (0; balance]
         * @member {Long} amount
         * @memberof proto.TokenWipeAccountTransactionBody
         * @instance
         */
        TokenWipeAccountTransactionBody.prototype.amount = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * Applicable to tokens of type NON_FUNGIBLE_UNIQUE. The list of serial numbers to be wiped.
         * @member {Array.<Long>} serialNumbers
         * @memberof proto.TokenWipeAccountTransactionBody
         * @instance
         */
        TokenWipeAccountTransactionBody.prototype.serialNumbers = $util.emptyArray;

        /**
         * Creates a new TokenWipeAccountTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.TokenWipeAccountTransactionBody
         * @static
         * @param {proto.ITokenWipeAccountTransactionBody=} [properties] Properties to set
         * @returns {proto.TokenWipeAccountTransactionBody} TokenWipeAccountTransactionBody instance
         */
        TokenWipeAccountTransactionBody.create = function create(properties) {
            return new TokenWipeAccountTransactionBody(properties);
        };

        /**
         * Encodes the specified TokenWipeAccountTransactionBody message. Does not implicitly {@link proto.TokenWipeAccountTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenWipeAccountTransactionBody
         * @static
         * @param {proto.ITokenWipeAccountTransactionBody} m TokenWipeAccountTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenWipeAccountTransactionBody.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.token != null && Object.hasOwnProperty.call(m, "token"))
                $root.proto.TokenID.encode(m.token, w.uint32(10).fork()).ldelim();
            if (m.account != null && Object.hasOwnProperty.call(m, "account"))
                $root.proto.AccountID.encode(m.account, w.uint32(18).fork()).ldelim();
            if (m.amount != null && Object.hasOwnProperty.call(m, "amount")) w.uint32(24).uint64(m.amount);
            if (m.serialNumbers != null && m.serialNumbers.length) {
                w.uint32(34).fork();
                for (var i = 0; i < m.serialNumbers.length; ++i) w.int64(m.serialNumbers[i]);
                w.ldelim();
            }
            return w;
        };

        /**
         * Decodes a TokenWipeAccountTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenWipeAccountTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenWipeAccountTransactionBody} TokenWipeAccountTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenWipeAccountTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.TokenWipeAccountTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.token = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.account = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    case 3: {
                        m.amount = r.uint64();
                        break;
                    }
                    case 4: {
                        if (!(m.serialNumbers && m.serialNumbers.length)) m.serialNumbers = [];
                        if ((t & 7) === 2) {
                            var c2 = r.uint32() + r.pos;
                            while (r.pos < c2) m.serialNumbers.push(r.int64());
                        } else m.serialNumbers.push(r.int64());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenWipeAccountTransactionBody
         * @function getTypeUrl
         * @memberof proto.TokenWipeAccountTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenWipeAccountTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenWipeAccountTransactionBody";
        };

        return TokenWipeAccountTransactionBody;
    })();

    proto.TokenAssociateTransactionBody = (function () {
        /**
         * Properties of a TokenAssociateTransactionBody.
         * @memberof proto
         * @interface ITokenAssociateTransactionBody
         * @property {proto.IAccountID|null} [account] The account to be associated with the provided tokens
         * @property {Array.<proto.ITokenID>|null} [tokens] The tokens to be associated with the provided account. In the case of NON_FUNGIBLE_UNIQUE
         * Type, once an account is associated, it can hold any number of NFTs (serial numbers) of that
         * token type
         */

        /**
         * Constructs a new TokenAssociateTransactionBody.
         * @memberof proto
         * @classdesc Associates the provided account with the provided tokens. Must be signed by the provided
         * Account's key.
         * If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.
         * If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.
         * If any of the provided tokens is not found, the transaction will resolve to INVALID_TOKEN_REF.
         * If any of the provided tokens has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.
         * If an association between the provided account and any of the tokens already exists, the
         * transaction will resolve to TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT.
         * If the provided account's associations count exceed the constraint of maximum token associations
         * per account, the transaction will resolve to TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED.
         * On success, associations between the provided account and tokens are made and the account is
         * ready to interact with the tokens.
         * @implements ITokenAssociateTransactionBody
         * @constructor
         * @param {proto.ITokenAssociateTransactionBody=} [p] Properties to set
         */
        function TokenAssociateTransactionBody(p) {
            this.tokens = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The account to be associated with the provided tokens
         * @member {proto.IAccountID|null|undefined} account
         * @memberof proto.TokenAssociateTransactionBody
         * @instance
         */
        TokenAssociateTransactionBody.prototype.account = null;

        /**
         * The tokens to be associated with the provided account. In the case of NON_FUNGIBLE_UNIQUE
         * Type, once an account is associated, it can hold any number of NFTs (serial numbers) of that
         * token type
         * @member {Array.<proto.ITokenID>} tokens
         * @memberof proto.TokenAssociateTransactionBody
         * @instance
         */
        TokenAssociateTransactionBody.prototype.tokens = $util.emptyArray;

        /**
         * Creates a new TokenAssociateTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.TokenAssociateTransactionBody
         * @static
         * @param {proto.ITokenAssociateTransactionBody=} [properties] Properties to set
         * @returns {proto.TokenAssociateTransactionBody} TokenAssociateTransactionBody instance
         */
        TokenAssociateTransactionBody.create = function create(properties) {
            return new TokenAssociateTransactionBody(properties);
        };

        /**
         * Encodes the specified TokenAssociateTransactionBody message. Does not implicitly {@link proto.TokenAssociateTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenAssociateTransactionBody
         * @static
         * @param {proto.ITokenAssociateTransactionBody} m TokenAssociateTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenAssociateTransactionBody.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.account != null && Object.hasOwnProperty.call(m, "account"))
                $root.proto.AccountID.encode(m.account, w.uint32(10).fork()).ldelim();
            if (m.tokens != null && m.tokens.length) {
                for (var i = 0; i < m.tokens.length; ++i)
                    $root.proto.TokenID.encode(m.tokens[i], w.uint32(18).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a TokenAssociateTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenAssociateTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenAssociateTransactionBody} TokenAssociateTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenAssociateTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.TokenAssociateTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.account = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        if (!(m.tokens && m.tokens.length)) m.tokens = [];
                        m.tokens.push($root.proto.TokenID.decode(r, r.uint32()));
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenAssociateTransactionBody
         * @function getTypeUrl
         * @memberof proto.TokenAssociateTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenAssociateTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenAssociateTransactionBody";
        };

        return TokenAssociateTransactionBody;
    })();

    proto.TokenDissociateTransactionBody = (function () {
        /**
         * Properties of a TokenDissociateTransactionBody.
         * @memberof proto
         * @interface ITokenDissociateTransactionBody
         * @property {proto.IAccountID|null} [account] The account to be dissociated with the provided tokens
         * @property {Array.<proto.ITokenID>|null} [tokens] The tokens to be dissociated with the provided account
         */

        /**
         * Constructs a new TokenDissociateTransactionBody.
         * @memberof proto
         * @classdesc Dissociates the provided account with the provided tokens. Must be signed by the provided
         * Account's key.
         * If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.
         * If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.
         * If any of the provided tokens is not found, the transaction will resolve to INVALID_TOKEN_REF.
         * If any of the provided tokens has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.
         * If an association between the provided account and any of the tokens does not exist, the
         * transaction will resolve to TOKEN_NOT_ASSOCIATED_TO_ACCOUNT.
         * If a token has not been deleted and has not expired, and the user has a nonzero balance, the
         * transaction will resolve to TRANSACTION_REQUIRES_ZERO_TOKEN_BALANCES.
         * If a <b>fungible token</b> has expired, the user can disassociate even if their token balance is
         * not zero.
         * If a <b>non fungible token</b> has expired, the user can <b>not</b> disassociate if their token
         * balance is not zero. The transaction will resolve to TRANSACTION_REQUIRED_ZERO_TOKEN_BALANCES.
         * On success, associations between the provided account and tokens are removed.
         * @implements ITokenDissociateTransactionBody
         * @constructor
         * @param {proto.ITokenDissociateTransactionBody=} [p] Properties to set
         */
        function TokenDissociateTransactionBody(p) {
            this.tokens = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The account to be dissociated with the provided tokens
         * @member {proto.IAccountID|null|undefined} account
         * @memberof proto.TokenDissociateTransactionBody
         * @instance
         */
        TokenDissociateTransactionBody.prototype.account = null;

        /**
         * The tokens to be dissociated with the provided account
         * @member {Array.<proto.ITokenID>} tokens
         * @memberof proto.TokenDissociateTransactionBody
         * @instance
         */
        TokenDissociateTransactionBody.prototype.tokens = $util.emptyArray;

        /**
         * Creates a new TokenDissociateTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.TokenDissociateTransactionBody
         * @static
         * @param {proto.ITokenDissociateTransactionBody=} [properties] Properties to set
         * @returns {proto.TokenDissociateTransactionBody} TokenDissociateTransactionBody instance
         */
        TokenDissociateTransactionBody.create = function create(properties) {
            return new TokenDissociateTransactionBody(properties);
        };

        /**
         * Encodes the specified TokenDissociateTransactionBody message. Does not implicitly {@link proto.TokenDissociateTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenDissociateTransactionBody
         * @static
         * @param {proto.ITokenDissociateTransactionBody} m TokenDissociateTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenDissociateTransactionBody.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.account != null && Object.hasOwnProperty.call(m, "account"))
                $root.proto.AccountID.encode(m.account, w.uint32(10).fork()).ldelim();
            if (m.tokens != null && m.tokens.length) {
                for (var i = 0; i < m.tokens.length; ++i)
                    $root.proto.TokenID.encode(m.tokens[i], w.uint32(18).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a TokenDissociateTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenDissociateTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenDissociateTransactionBody} TokenDissociateTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenDissociateTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.TokenDissociateTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.account = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        if (!(m.tokens && m.tokens.length)) m.tokens = [];
                        m.tokens.push($root.proto.TokenID.decode(r, r.uint32()));
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenDissociateTransactionBody
         * @function getTypeUrl
         * @memberof proto.TokenDissociateTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenDissociateTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenDissociateTransactionBody";
        };

        return TokenDissociateTransactionBody;
    })();

    proto.TokenFeeScheduleUpdateTransactionBody = (function () {
        /**
         * Properties of a TokenFeeScheduleUpdateTransactionBody.
         * @memberof proto
         * @interface ITokenFeeScheduleUpdateTransactionBody
         * @property {proto.ITokenID|null} [tokenId] The token whose fee schedule is to be updated
         * @property {Array.<proto.ICustomFee>|null} [customFees] The new custom fees to be assessed during a CryptoTransfer that transfers units of this token
         */

        /**
         * Constructs a new TokenFeeScheduleUpdateTransactionBody.
         * @memberof proto
         * @classdesc At consensus, updates a token type's fee schedule to the given list of custom fees.
         *
         * If the target token type has no fee_schedule_key, resolves to TOKEN_HAS_NO_FEE_SCHEDULE_KEY.
         * Otherwise this transaction must be signed to the fee_schedule_key, or the transaction will
         * resolve to INVALID_SIGNATURE.
         *
         * If the custom_fees list is empty, clears the fee schedule or resolves to
         * CUSTOM_SCHEDULE_ALREADY_HAS_NO_FEES if the fee schedule was already empty.
         * @implements ITokenFeeScheduleUpdateTransactionBody
         * @constructor
         * @param {proto.ITokenFeeScheduleUpdateTransactionBody=} [p] Properties to set
         */
        function TokenFeeScheduleUpdateTransactionBody(p) {
            this.customFees = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The token whose fee schedule is to be updated
         * @member {proto.ITokenID|null|undefined} tokenId
         * @memberof proto.TokenFeeScheduleUpdateTransactionBody
         * @instance
         */
        TokenFeeScheduleUpdateTransactionBody.prototype.tokenId = null;

        /**
         * The new custom fees to be assessed during a CryptoTransfer that transfers units of this token
         * @member {Array.<proto.ICustomFee>} customFees
         * @memberof proto.TokenFeeScheduleUpdateTransactionBody
         * @instance
         */
        TokenFeeScheduleUpdateTransactionBody.prototype.customFees = $util.emptyArray;

        /**
         * Creates a new TokenFeeScheduleUpdateTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.TokenFeeScheduleUpdateTransactionBody
         * @static
         * @param {proto.ITokenFeeScheduleUpdateTransactionBody=} [properties] Properties to set
         * @returns {proto.TokenFeeScheduleUpdateTransactionBody} TokenFeeScheduleUpdateTransactionBody instance
         */
        TokenFeeScheduleUpdateTransactionBody.create = function create(properties) {
            return new TokenFeeScheduleUpdateTransactionBody(properties);
        };

        /**
         * Encodes the specified TokenFeeScheduleUpdateTransactionBody message. Does not implicitly {@link proto.TokenFeeScheduleUpdateTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenFeeScheduleUpdateTransactionBody
         * @static
         * @param {proto.ITokenFeeScheduleUpdateTransactionBody} m TokenFeeScheduleUpdateTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenFeeScheduleUpdateTransactionBody.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.tokenId != null && Object.hasOwnProperty.call(m, "tokenId"))
                $root.proto.TokenID.encode(m.tokenId, w.uint32(10).fork()).ldelim();
            if (m.customFees != null && m.customFees.length) {
                for (var i = 0; i < m.customFees.length; ++i)
                    $root.proto.CustomFee.encode(m.customFees[i], w.uint32(18).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a TokenFeeScheduleUpdateTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenFeeScheduleUpdateTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenFeeScheduleUpdateTransactionBody} TokenFeeScheduleUpdateTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenFeeScheduleUpdateTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.TokenFeeScheduleUpdateTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.tokenId = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        if (!(m.customFees && m.customFees.length)) m.customFees = [];
                        m.customFees.push($root.proto.CustomFee.decode(r, r.uint32()));
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenFeeScheduleUpdateTransactionBody
         * @function getTypeUrl
         * @memberof proto.TokenFeeScheduleUpdateTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenFeeScheduleUpdateTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenFeeScheduleUpdateTransactionBody";
        };

        return TokenFeeScheduleUpdateTransactionBody;
    })();

    proto.TokenPauseTransactionBody = (function () {
        /**
         * Properties of a TokenPauseTransactionBody.
         * @memberof proto
         * @interface ITokenPauseTransactionBody
         * @property {proto.ITokenID|null} [token] The token to be paused.
         */

        /**
         * Constructs a new TokenPauseTransactionBody.
         * @memberof proto
         * @classdesc Pauses the Token from being involved in any kind of Transaction until it is unpaused.
         * Must be signed with the Token's pause key.
         * If the provided token is not found, the transaction will resolve to INVALID_TOKEN_ID.
         * If the provided token has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.
         * If no Pause Key is defined, the transaction will resolve to TOKEN_HAS_NO_PAUSE_KEY.
         * Once executed the Token is marked as paused and will be not able to be a part of any transaction.
         * The operation is idempotent - becomes a no-op if the Token is already Paused.
         * @implements ITokenPauseTransactionBody
         * @constructor
         * @param {proto.ITokenPauseTransactionBody=} [p] Properties to set
         */
        function TokenPauseTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The token to be paused.
         * @member {proto.ITokenID|null|undefined} token
         * @memberof proto.TokenPauseTransactionBody
         * @instance
         */
        TokenPauseTransactionBody.prototype.token = null;

        /**
         * Creates a new TokenPauseTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.TokenPauseTransactionBody
         * @static
         * @param {proto.ITokenPauseTransactionBody=} [properties] Properties to set
         * @returns {proto.TokenPauseTransactionBody} TokenPauseTransactionBody instance
         */
        TokenPauseTransactionBody.create = function create(properties) {
            return new TokenPauseTransactionBody(properties);
        };

        /**
         * Encodes the specified TokenPauseTransactionBody message. Does not implicitly {@link proto.TokenPauseTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenPauseTransactionBody
         * @static
         * @param {proto.ITokenPauseTransactionBody} m TokenPauseTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenPauseTransactionBody.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.token != null && Object.hasOwnProperty.call(m, "token"))
                $root.proto.TokenID.encode(m.token, w.uint32(10).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a TokenPauseTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenPauseTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenPauseTransactionBody} TokenPauseTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenPauseTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.TokenPauseTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.token = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenPauseTransactionBody
         * @function getTypeUrl
         * @memberof proto.TokenPauseTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenPauseTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenPauseTransactionBody";
        };

        return TokenPauseTransactionBody;
    })();

    proto.TokenUnpauseTransactionBody = (function () {
        /**
         * Properties of a TokenUnpauseTransactionBody.
         * @memberof proto
         * @interface ITokenUnpauseTransactionBody
         * @property {proto.ITokenID|null} [token] The token to be unpaused.
         */

        /**
         * Constructs a new TokenUnpauseTransactionBody.
         * @memberof proto
         * @classdesc Unpauses the Token. Must be signed with the Token's pause key.
         * If the provided token is not found, the transaction will resolve to INVALID_TOKEN_ID.
         * If the provided token has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.
         * If no Pause Key is defined, the transaction will resolve to TOKEN_HAS_NO_PAUSE_KEY.
         * Once executed the Token is marked as Unpaused and can be used in Transactions.
         * The operation is idempotent - becomes a no-op if the Token is already unpaused.
         * @implements ITokenUnpauseTransactionBody
         * @constructor
         * @param {proto.ITokenUnpauseTransactionBody=} [p] Properties to set
         */
        function TokenUnpauseTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The token to be unpaused.
         * @member {proto.ITokenID|null|undefined} token
         * @memberof proto.TokenUnpauseTransactionBody
         * @instance
         */
        TokenUnpauseTransactionBody.prototype.token = null;

        /**
         * Creates a new TokenUnpauseTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.TokenUnpauseTransactionBody
         * @static
         * @param {proto.ITokenUnpauseTransactionBody=} [properties] Properties to set
         * @returns {proto.TokenUnpauseTransactionBody} TokenUnpauseTransactionBody instance
         */
        TokenUnpauseTransactionBody.create = function create(properties) {
            return new TokenUnpauseTransactionBody(properties);
        };

        /**
         * Encodes the specified TokenUnpauseTransactionBody message. Does not implicitly {@link proto.TokenUnpauseTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenUnpauseTransactionBody
         * @static
         * @param {proto.ITokenUnpauseTransactionBody} m TokenUnpauseTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenUnpauseTransactionBody.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.token != null && Object.hasOwnProperty.call(m, "token"))
                $root.proto.TokenID.encode(m.token, w.uint32(10).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a TokenUnpauseTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenUnpauseTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenUnpauseTransactionBody} TokenUnpauseTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenUnpauseTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.TokenUnpauseTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.token = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenUnpauseTransactionBody
         * @function getTypeUrl
         * @memberof proto.TokenUnpauseTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenUnpauseTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenUnpauseTransactionBody";
        };

        return TokenUnpauseTransactionBody;
    })();

    proto.ScheduleCreateTransactionBody = (function () {
        /**
         * Properties of a ScheduleCreateTransactionBody.
         * @memberof proto
         * @interface IScheduleCreateTransactionBody
         * @property {proto.ISchedulableTransactionBody|null} [scheduledTransactionBody] The scheduled transaction
         * @property {string|null} [memo] An optional memo with a UTF-8 encoding of no more than 100 bytes which does not contain the
         * zero byte
         * @property {proto.IKey|null} [adminKey] An optional Hedera key which can be used to sign a ScheduleDelete and remove the schedule
         * @property {proto.IAccountID|null} [payerAccountID] An optional id of the account to be charged the service fee for the scheduled transaction at
         * the consensus time that it executes (if ever); defaults to the ScheduleCreate payer if not
         * given
         * @property {proto.ITimestamp|null} [expirationTime] An optional timestamp for specifying when the transaction should be evaluated for execution and then expire.
         * Defaults to 30 minutes after the transaction's consensus timestamp.
         *
         * Note: This field is unused and forced to be unset until Long Term Scheduled Transactions are enabled - Transactions will always
         * expire in 30 minutes if Long Term Scheduled Transactions are not enabled.
         * @property {boolean|null} [waitForExpiry] When set to true, the transaction will be evaluated for execution at expiration_time instead
         * of when all required signatures are received.
         * When set to false, the transaction will execute immediately after sufficient signatures are received
         * to sign the contained transaction. During the initial ScheduleCreate transaction or via ScheduleSign transactions.
         *
         * Defaults to false.
         *
         * Setting this to false does not necessarily mean that the transaction will never execute at expiration_time.
         * For Example - If the signature requirements for a Scheduled Transaction change via external means (e.g. CryptoUpdate)
         * such that the Scheduled Transaction would be allowed to execute, it will do so autonomously at expiration_time, unless a
         * ScheduleSign comes in to “poke” it and force it to go through immediately.
         *
         * Note: This field is unused and forced to be unset until Long Term Scheduled Transactions are enabled. Before Long Term
         * Scheduled Transactions are enabled, Scheduled Transactions will _never_ execute at expiration  - they will _only_
         * execute during the initial ScheduleCreate transaction or via ScheduleSign transactions and will _always_
         * expire at expiration_time.
         */

        /**
         * Constructs a new ScheduleCreateTransactionBody.
         * @memberof proto
         * @classdesc Create a new <i>schedule entity</i> (or simply, <i>schedule</i>) in the network's action queue.
         * Upon <tt>SUCCESS</tt>, the receipt contains the `ScheduleID` of the created schedule. A schedule
         * entity includes a <tt>scheduledTransactionBody</tt> to be executed.
         * When the schedule has collected enough signing Ed25519 keys to satisfy the schedule's signing
         * requirements, the schedule can be executed.
         *
         * If Long Term Scheduled Transactions are enabled and <tt>wait_for_expiry</tt> is set to <tt>true</tt>, then the schedule
         * will execute at it's <tt>expiration_time</tt>.
         *
         * Otherwise it will execute immediately after the transaction that provided enough Ed25519 keys, a <tt>ScheduleCreate</tt>
         * or <tt>ScheduleSign</tt>.
         *
         * Upon `SUCCESS`, the receipt also includes the <tt>scheduledTransactionID</tt> to
         * use to query for the record of the scheduled transaction's execution (if it occurs).
         *
         * The expiration time of a schedule is controlled by it's <tt>expiration_time</tt>. It remains in state and can be queried
         * using <tt>GetScheduleInfo</tt> until expiration, no matter if the scheduled transaction has
         * executed or marked deleted. If Long Term Scheduled Transactions are disabled, the <tt>expiration_time</tt> is always
         * 30 minutes in the future.
         *
         * If the <tt>adminKey</tt> field is omitted, the resulting schedule is immutable. If the
         * <tt>adminKey</tt> is set, the <tt>ScheduleDelete</tt> transaction can be used to mark it as
         * deleted. The creator may also specify an optional <tt>memo</tt> whose UTF-8 encoding is at most
         * 100 bytes and does not include the zero byte is also supported.
         *
         * When a <tt>scheduledTransactionBody</tt> is executed, the
         * network only charges its payer the service fee, and not the node and network fees. If the
         * optional <tt>payerAccountID</tt> is set, the network charges this account. Otherwise it charges
         * the payer of the originating <tt>ScheduleCreate</tt>.
         *
         * Two <tt>ScheduleCreate</tt> transactions are <i>identical</i> if they are equal in all their
         * fields other than <tt>payerAccountID</tt>.  (For the <tt>scheduledTransactionBody</tt> field,
         * "equal" should be understood in the sense of
         * gRPC object equality in the network software runtime. In particular, a gRPC object with <a
         * href="https://developers.google.com/protocol-buffers/docs/proto3#unknowns">unknown fields</a> is
         * not equal to a gRPC object without unknown fields, even if they agree on all known fields.)
         *
         * A <tt>ScheduleCreate</tt> transaction that attempts to re-create an identical schedule already in
         * state will receive a receipt with status <tt>IDENTICAL_SCHEDULE_ALREADY_CREATED</tt>; the receipt
         * will include the <tt>ScheduleID</tt> of the extant schedule, which may be used in a subsequent
         * <tt>ScheduleSign</tt> transaction. (The receipt will also include the <tt>TransactionID</tt> to
         * use in querying for the receipt or record of the scheduled transaction.)
         *
         * Other notable response codes include, <tt>INVALID_ACCOUNT_ID</tt>,
         * <tt>UNSCHEDULABLE_TRANSACTION</tt>, <tt>UNRESOLVABLE_REQUIRED_SIGNERS</tt>,
         * <tt>INVALID_SIGNATURE</tt>. For more information please see the section of this documentation on
         * the <tt>ResponseCode</tt> enum.
         * @implements IScheduleCreateTransactionBody
         * @constructor
         * @param {proto.IScheduleCreateTransactionBody=} [p] Properties to set
         */
        function ScheduleCreateTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The scheduled transaction
         * @member {proto.ISchedulableTransactionBody|null|undefined} scheduledTransactionBody
         * @memberof proto.ScheduleCreateTransactionBody
         * @instance
         */
        ScheduleCreateTransactionBody.prototype.scheduledTransactionBody = null;

        /**
         * An optional memo with a UTF-8 encoding of no more than 100 bytes which does not contain the
         * zero byte
         * @member {string} memo
         * @memberof proto.ScheduleCreateTransactionBody
         * @instance
         */
        ScheduleCreateTransactionBody.prototype.memo = "";

        /**
         * An optional Hedera key which can be used to sign a ScheduleDelete and remove the schedule
         * @member {proto.IKey|null|undefined} adminKey
         * @memberof proto.ScheduleCreateTransactionBody
         * @instance
         */
        ScheduleCreateTransactionBody.prototype.adminKey = null;

        /**
         * An optional id of the account to be charged the service fee for the scheduled transaction at
         * the consensus time that it executes (if ever); defaults to the ScheduleCreate payer if not
         * given
         * @member {proto.IAccountID|null|undefined} payerAccountID
         * @memberof proto.ScheduleCreateTransactionBody
         * @instance
         */
        ScheduleCreateTransactionBody.prototype.payerAccountID = null;

        /**
         * An optional timestamp for specifying when the transaction should be evaluated for execution and then expire.
         * Defaults to 30 minutes after the transaction's consensus timestamp.
         *
         * Note: This field is unused and forced to be unset until Long Term Scheduled Transactions are enabled - Transactions will always
         * expire in 30 minutes if Long Term Scheduled Transactions are not enabled.
         * @member {proto.ITimestamp|null|undefined} expirationTime
         * @memberof proto.ScheduleCreateTransactionBody
         * @instance
         */
        ScheduleCreateTransactionBody.prototype.expirationTime = null;

        /**
         * When set to true, the transaction will be evaluated for execution at expiration_time instead
         * of when all required signatures are received.
         * When set to false, the transaction will execute immediately after sufficient signatures are received
         * to sign the contained transaction. During the initial ScheduleCreate transaction or via ScheduleSign transactions.
         *
         * Defaults to false.
         *
         * Setting this to false does not necessarily mean that the transaction will never execute at expiration_time.
         * For Example - If the signature requirements for a Scheduled Transaction change via external means (e.g. CryptoUpdate)
         * such that the Scheduled Transaction would be allowed to execute, it will do so autonomously at expiration_time, unless a
         * ScheduleSign comes in to “poke” it and force it to go through immediately.
         *
         * Note: This field is unused and forced to be unset until Long Term Scheduled Transactions are enabled. Before Long Term
         * Scheduled Transactions are enabled, Scheduled Transactions will _never_ execute at expiration  - they will _only_
         * execute during the initial ScheduleCreate transaction or via ScheduleSign transactions and will _always_
         * expire at expiration_time.
         * @member {boolean} waitForExpiry
         * @memberof proto.ScheduleCreateTransactionBody
         * @instance
         */
        ScheduleCreateTransactionBody.prototype.waitForExpiry = false;

        /**
         * Creates a new ScheduleCreateTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.ScheduleCreateTransactionBody
         * @static
         * @param {proto.IScheduleCreateTransactionBody=} [properties] Properties to set
         * @returns {proto.ScheduleCreateTransactionBody} ScheduleCreateTransactionBody instance
         */
        ScheduleCreateTransactionBody.create = function create(properties) {
            return new ScheduleCreateTransactionBody(properties);
        };

        /**
         * Encodes the specified ScheduleCreateTransactionBody message. Does not implicitly {@link proto.ScheduleCreateTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.ScheduleCreateTransactionBody
         * @static
         * @param {proto.IScheduleCreateTransactionBody} m ScheduleCreateTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ScheduleCreateTransactionBody.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.scheduledTransactionBody != null && Object.hasOwnProperty.call(m, "scheduledTransactionBody"))
                $root.proto.SchedulableTransactionBody.encode(m.scheduledTransactionBody, w.uint32(10).fork()).ldelim();
            if (m.memo != null && Object.hasOwnProperty.call(m, "memo")) w.uint32(18).string(m.memo);
            if (m.adminKey != null && Object.hasOwnProperty.call(m, "adminKey"))
                $root.proto.Key.encode(m.adminKey, w.uint32(26).fork()).ldelim();
            if (m.payerAccountID != null && Object.hasOwnProperty.call(m, "payerAccountID"))
                $root.proto.AccountID.encode(m.payerAccountID, w.uint32(34).fork()).ldelim();
            if (m.expirationTime != null && Object.hasOwnProperty.call(m, "expirationTime"))
                $root.proto.Timestamp.encode(m.expirationTime, w.uint32(42).fork()).ldelim();
            if (m.waitForExpiry != null && Object.hasOwnProperty.call(m, "waitForExpiry"))
                w.uint32(104).bool(m.waitForExpiry);
            return w;
        };

        /**
         * Decodes a ScheduleCreateTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ScheduleCreateTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ScheduleCreateTransactionBody} ScheduleCreateTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ScheduleCreateTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.ScheduleCreateTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.scheduledTransactionBody = $root.proto.SchedulableTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.memo = r.string();
                        break;
                    }
                    case 3: {
                        m.adminKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                    case 4: {
                        m.payerAccountID = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    case 5: {
                        m.expirationTime = $root.proto.Timestamp.decode(r, r.uint32());
                        break;
                    }
                    case 13: {
                        m.waitForExpiry = r.bool();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ScheduleCreateTransactionBody
         * @function getTypeUrl
         * @memberof proto.ScheduleCreateTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ScheduleCreateTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ScheduleCreateTransactionBody";
        };

        return ScheduleCreateTransactionBody;
    })();

    proto.SchedulableTransactionBody = (function () {
        /**
         * Properties of a SchedulableTransactionBody.
         * @memberof proto
         * @interface ISchedulableTransactionBody
         * @property {Long|null} [transactionFee] The maximum transaction fee the client is willing to pay
         * @property {string|null} [memo] A memo to include the execution record; the UTF-8 encoding may be up to 100 bytes and must not
         * include the zero byte
         * @property {proto.IContractCallTransactionBody|null} [contractCall] Calls a function of a contract instance
         * @property {proto.IContractCreateTransactionBody|null} [contractCreateInstance] Creates a contract instance
         * @property {proto.IContractUpdateTransactionBody|null} [contractUpdateInstance] Updates a contract
         * @property {proto.IContractDeleteTransactionBody|null} [contractDeleteInstance] Delete contract and transfer remaining balance into specified account
         * @property {proto.ICryptoApproveAllowanceTransactionBody|null} [cryptoApproveAllowance] Adds one or more approved allowances for spenders to transfer the paying account's hbar or tokens.
         * @property {proto.ICryptoDeleteAllowanceTransactionBody|null} [cryptoDeleteAllowance] Deletes one or more of the specific approved NFT serial numbers on an owner account.
         * @property {proto.ICryptoCreateTransactionBody|null} [cryptoCreateAccount] Create a new cryptocurrency account
         * @property {proto.ICryptoDeleteTransactionBody|null} [cryptoDelete] Delete a cryptocurrency account (mark as deleted, and transfer hbars out)
         * @property {proto.ICryptoTransferTransactionBody|null} [cryptoTransfer] Transfer amount between accounts
         * @property {proto.ICryptoUpdateTransactionBody|null} [cryptoUpdateAccount] Modify information such as the expiration date for an account
         * @property {proto.IFileAppendTransactionBody|null} [fileAppend] Add bytes to the end of the contents of a file
         * @property {proto.IFileCreateTransactionBody|null} [fileCreate] Create a new file
         * @property {proto.IFileDeleteTransactionBody|null} [fileDelete] Delete a file (remove contents and mark as deleted until it expires)
         * @property {proto.IFileUpdateTransactionBody|null} [fileUpdate] Modify information such as the expiration date for a file
         * @property {proto.ISystemDeleteTransactionBody|null} [systemDelete] Hedera administrative deletion of a file or smart contract
         * @property {proto.ISystemUndeleteTransactionBody|null} [systemUndelete] To undelete an entity deleted by SystemDelete
         * @property {proto.IFreezeTransactionBody|null} [freeze] Freeze the nodes
         * @property {proto.IConsensusCreateTopicTransactionBody|null} [consensusCreateTopic] Creates a topic
         * @property {proto.IConsensusUpdateTopicTransactionBody|null} [consensusUpdateTopic] Updates a topic
         * @property {proto.IConsensusDeleteTopicTransactionBody|null} [consensusDeleteTopic] Deletes a topic
         * @property {proto.IConsensusSubmitMessageTransactionBody|null} [consensusSubmitMessage] Submits message to a topic
         * @property {proto.ITokenCreateTransactionBody|null} [tokenCreation] Creates a token instance
         * @property {proto.ITokenFreezeAccountTransactionBody|null} [tokenFreeze] Freezes account not to be able to transact with a token
         * @property {proto.ITokenUnfreezeAccountTransactionBody|null} [tokenUnfreeze] Unfreezes account for a token
         * @property {proto.ITokenGrantKycTransactionBody|null} [tokenGrantKyc] Grants KYC to an account for a token
         * @property {proto.ITokenRevokeKycTransactionBody|null} [tokenRevokeKyc] Revokes KYC of an account for a token
         * @property {proto.ITokenDeleteTransactionBody|null} [tokenDeletion] Deletes a token instance
         * @property {proto.ITokenUpdateTransactionBody|null} [tokenUpdate] Updates a token instance
         * @property {proto.ITokenMintTransactionBody|null} [tokenMint] Mints new tokens to a token's treasury account
         * @property {proto.ITokenBurnTransactionBody|null} [tokenBurn] Burns tokens from a token's treasury account
         * @property {proto.ITokenWipeAccountTransactionBody|null} [tokenWipe] Wipes amount of tokens from an account
         * @property {proto.ITokenAssociateTransactionBody|null} [tokenAssociate] Associate tokens to an account
         * @property {proto.ITokenDissociateTransactionBody|null} [tokenDissociate] Dissociate tokens from an account
         * @property {proto.ITokenFeeScheduleUpdateTransactionBody|null} [tokenFeeScheduleUpdate] Updates a token's custom fee schedule
         * @property {proto.ITokenPauseTransactionBody|null} [tokenPause] Pauses the Token
         * @property {proto.ITokenUnpauseTransactionBody|null} [tokenUnpause] Unpauses the Token
         * @property {proto.IScheduleDeleteTransactionBody|null} [scheduleDelete] Marks a schedule in the network's action queue as deleted, preventing it from executing
         * @property {proto.IUtilPrngTransactionBody|null} [utilPrng] Generates a pseudorandom number.
         */

        /**
         * Constructs a new SchedulableTransactionBody.
         * @memberof proto
         * @classdesc A schedulable transaction. Note that the global/dynamic system property
         * <tt>scheduling.whitelist</tt> controls which transaction types may be scheduled. As of Hedera
         * Services 0.24.0 this list includes <tt>ConsensusSubmitMessage</tt>, <tt>CryptoTransfer</tt>, <tt>TokenMint</tt>, and <tt>TokenBurn</tt>
         * functions.
         * @implements ISchedulableTransactionBody
         * @constructor
         * @param {proto.ISchedulableTransactionBody=} [p] Properties to set
         */
        function SchedulableTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The maximum transaction fee the client is willing to pay
         * @member {Long} transactionFee
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.transactionFee = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * A memo to include the execution record; the UTF-8 encoding may be up to 100 bytes and must not
         * include the zero byte
         * @member {string} memo
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.memo = "";

        /**
         * Calls a function of a contract instance
         * @member {proto.IContractCallTransactionBody|null|undefined} contractCall
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.contractCall = null;

        /**
         * Creates a contract instance
         * @member {proto.IContractCreateTransactionBody|null|undefined} contractCreateInstance
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.contractCreateInstance = null;

        /**
         * Updates a contract
         * @member {proto.IContractUpdateTransactionBody|null|undefined} contractUpdateInstance
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.contractUpdateInstance = null;

        /**
         * Delete contract and transfer remaining balance into specified account
         * @member {proto.IContractDeleteTransactionBody|null|undefined} contractDeleteInstance
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.contractDeleteInstance = null;

        /**
         * Adds one or more approved allowances for spenders to transfer the paying account's hbar or tokens.
         * @member {proto.ICryptoApproveAllowanceTransactionBody|null|undefined} cryptoApproveAllowance
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.cryptoApproveAllowance = null;

        /**
         * Deletes one or more of the specific approved NFT serial numbers on an owner account.
         * @member {proto.ICryptoDeleteAllowanceTransactionBody|null|undefined} cryptoDeleteAllowance
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.cryptoDeleteAllowance = null;

        /**
         * Create a new cryptocurrency account
         * @member {proto.ICryptoCreateTransactionBody|null|undefined} cryptoCreateAccount
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.cryptoCreateAccount = null;

        /**
         * Delete a cryptocurrency account (mark as deleted, and transfer hbars out)
         * @member {proto.ICryptoDeleteTransactionBody|null|undefined} cryptoDelete
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.cryptoDelete = null;

        /**
         * Transfer amount between accounts
         * @member {proto.ICryptoTransferTransactionBody|null|undefined} cryptoTransfer
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.cryptoTransfer = null;

        /**
         * Modify information such as the expiration date for an account
         * @member {proto.ICryptoUpdateTransactionBody|null|undefined} cryptoUpdateAccount
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.cryptoUpdateAccount = null;

        /**
         * Add bytes to the end of the contents of a file
         * @member {proto.IFileAppendTransactionBody|null|undefined} fileAppend
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.fileAppend = null;

        /**
         * Create a new file
         * @member {proto.IFileCreateTransactionBody|null|undefined} fileCreate
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.fileCreate = null;

        /**
         * Delete a file (remove contents and mark as deleted until it expires)
         * @member {proto.IFileDeleteTransactionBody|null|undefined} fileDelete
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.fileDelete = null;

        /**
         * Modify information such as the expiration date for a file
         * @member {proto.IFileUpdateTransactionBody|null|undefined} fileUpdate
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.fileUpdate = null;

        /**
         * Hedera administrative deletion of a file or smart contract
         * @member {proto.ISystemDeleteTransactionBody|null|undefined} systemDelete
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.systemDelete = null;

        /**
         * To undelete an entity deleted by SystemDelete
         * @member {proto.ISystemUndeleteTransactionBody|null|undefined} systemUndelete
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.systemUndelete = null;

        /**
         * Freeze the nodes
         * @member {proto.IFreezeTransactionBody|null|undefined} freeze
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.freeze = null;

        /**
         * Creates a topic
         * @member {proto.IConsensusCreateTopicTransactionBody|null|undefined} consensusCreateTopic
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.consensusCreateTopic = null;

        /**
         * Updates a topic
         * @member {proto.IConsensusUpdateTopicTransactionBody|null|undefined} consensusUpdateTopic
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.consensusUpdateTopic = null;

        /**
         * Deletes a topic
         * @member {proto.IConsensusDeleteTopicTransactionBody|null|undefined} consensusDeleteTopic
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.consensusDeleteTopic = null;

        /**
         * Submits message to a topic
         * @member {proto.IConsensusSubmitMessageTransactionBody|null|undefined} consensusSubmitMessage
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.consensusSubmitMessage = null;

        /**
         * Creates a token instance
         * @member {proto.ITokenCreateTransactionBody|null|undefined} tokenCreation
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.tokenCreation = null;

        /**
         * Freezes account not to be able to transact with a token
         * @member {proto.ITokenFreezeAccountTransactionBody|null|undefined} tokenFreeze
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.tokenFreeze = null;

        /**
         * Unfreezes account for a token
         * @member {proto.ITokenUnfreezeAccountTransactionBody|null|undefined} tokenUnfreeze
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.tokenUnfreeze = null;

        /**
         * Grants KYC to an account for a token
         * @member {proto.ITokenGrantKycTransactionBody|null|undefined} tokenGrantKyc
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.tokenGrantKyc = null;

        /**
         * Revokes KYC of an account for a token
         * @member {proto.ITokenRevokeKycTransactionBody|null|undefined} tokenRevokeKyc
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.tokenRevokeKyc = null;

        /**
         * Deletes a token instance
         * @member {proto.ITokenDeleteTransactionBody|null|undefined} tokenDeletion
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.tokenDeletion = null;

        /**
         * Updates a token instance
         * @member {proto.ITokenUpdateTransactionBody|null|undefined} tokenUpdate
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.tokenUpdate = null;

        /**
         * Mints new tokens to a token's treasury account
         * @member {proto.ITokenMintTransactionBody|null|undefined} tokenMint
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.tokenMint = null;

        /**
         * Burns tokens from a token's treasury account
         * @member {proto.ITokenBurnTransactionBody|null|undefined} tokenBurn
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.tokenBurn = null;

        /**
         * Wipes amount of tokens from an account
         * @member {proto.ITokenWipeAccountTransactionBody|null|undefined} tokenWipe
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.tokenWipe = null;

        /**
         * Associate tokens to an account
         * @member {proto.ITokenAssociateTransactionBody|null|undefined} tokenAssociate
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.tokenAssociate = null;

        /**
         * Dissociate tokens from an account
         * @member {proto.ITokenDissociateTransactionBody|null|undefined} tokenDissociate
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.tokenDissociate = null;

        /**
         * Updates a token's custom fee schedule
         * @member {proto.ITokenFeeScheduleUpdateTransactionBody|null|undefined} tokenFeeScheduleUpdate
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.tokenFeeScheduleUpdate = null;

        /**
         * Pauses the Token
         * @member {proto.ITokenPauseTransactionBody|null|undefined} tokenPause
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.tokenPause = null;

        /**
         * Unpauses the Token
         * @member {proto.ITokenUnpauseTransactionBody|null|undefined} tokenUnpause
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.tokenUnpause = null;

        /**
         * Marks a schedule in the network's action queue as deleted, preventing it from executing
         * @member {proto.IScheduleDeleteTransactionBody|null|undefined} scheduleDelete
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.scheduleDelete = null;

        /**
         * Generates a pseudorandom number.
         * @member {proto.IUtilPrngTransactionBody|null|undefined} utilPrng
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.utilPrng = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * The choices here are arranged by service in roughly lexicographical order. The field ordinals are non-sequential, and a result of the historical order of implementation.
         * @member {"contractCall"|"contractCreateInstance"|"contractUpdateInstance"|"contractDeleteInstance"|"cryptoApproveAllowance"|"cryptoDeleteAllowance"|"cryptoCreateAccount"|"cryptoDelete"|"cryptoTransfer"|"cryptoUpdateAccount"|"fileAppend"|"fileCreate"|"fileDelete"|"fileUpdate"|"systemDelete"|"systemUndelete"|"freeze"|"consensusCreateTopic"|"consensusUpdateTopic"|"consensusDeleteTopic"|"consensusSubmitMessage"|"tokenCreation"|"tokenFreeze"|"tokenUnfreeze"|"tokenGrantKyc"|"tokenRevokeKyc"|"tokenDeletion"|"tokenUpdate"|"tokenMint"|"tokenBurn"|"tokenWipe"|"tokenAssociate"|"tokenDissociate"|"tokenFeeScheduleUpdate"|"tokenPause"|"tokenUnpause"|"scheduleDelete"|"utilPrng"|undefined} data
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        Object.defineProperty(SchedulableTransactionBody.prototype, "data", {
            get: $util.oneOfGetter(
                ($oneOfFields = [
                    "contractCall",
                    "contractCreateInstance",
                    "contractUpdateInstance",
                    "contractDeleteInstance",
                    "cryptoApproveAllowance",
                    "cryptoDeleteAllowance",
                    "cryptoCreateAccount",
                    "cryptoDelete",
                    "cryptoTransfer",
                    "cryptoUpdateAccount",
                    "fileAppend",
                    "fileCreate",
                    "fileDelete",
                    "fileUpdate",
                    "systemDelete",
                    "systemUndelete",
                    "freeze",
                    "consensusCreateTopic",
                    "consensusUpdateTopic",
                    "consensusDeleteTopic",
                    "consensusSubmitMessage",
                    "tokenCreation",
                    "tokenFreeze",
                    "tokenUnfreeze",
                    "tokenGrantKyc",
                    "tokenRevokeKyc",
                    "tokenDeletion",
                    "tokenUpdate",
                    "tokenMint",
                    "tokenBurn",
                    "tokenWipe",
                    "tokenAssociate",
                    "tokenDissociate",
                    "tokenFeeScheduleUpdate",
                    "tokenPause",
                    "tokenUnpause",
                    "scheduleDelete",
                    "utilPrng",
                ])
            ),
            set: $util.oneOfSetter($oneOfFields),
        });

        /**
         * Creates a new SchedulableTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.SchedulableTransactionBody
         * @static
         * @param {proto.ISchedulableTransactionBody=} [properties] Properties to set
         * @returns {proto.SchedulableTransactionBody} SchedulableTransactionBody instance
         */
        SchedulableTransactionBody.create = function create(properties) {
            return new SchedulableTransactionBody(properties);
        };

        /**
         * Encodes the specified SchedulableTransactionBody message. Does not implicitly {@link proto.SchedulableTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.SchedulableTransactionBody
         * @static
         * @param {proto.ISchedulableTransactionBody} m SchedulableTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SchedulableTransactionBody.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.transactionFee != null && Object.hasOwnProperty.call(m, "transactionFee"))
                w.uint32(8).uint64(m.transactionFee);
            if (m.memo != null && Object.hasOwnProperty.call(m, "memo")) w.uint32(18).string(m.memo);
            if (m.contractCall != null && Object.hasOwnProperty.call(m, "contractCall"))
                $root.proto.ContractCallTransactionBody.encode(m.contractCall, w.uint32(26).fork()).ldelim();
            if (m.contractCreateInstance != null && Object.hasOwnProperty.call(m, "contractCreateInstance"))
                $root.proto.ContractCreateTransactionBody.encode(
                    m.contractCreateInstance,
                    w.uint32(34).fork()
                ).ldelim();
            if (m.contractUpdateInstance != null && Object.hasOwnProperty.call(m, "contractUpdateInstance"))
                $root.proto.ContractUpdateTransactionBody.encode(
                    m.contractUpdateInstance,
                    w.uint32(42).fork()
                ).ldelim();
            if (m.contractDeleteInstance != null && Object.hasOwnProperty.call(m, "contractDeleteInstance"))
                $root.proto.ContractDeleteTransactionBody.encode(
                    m.contractDeleteInstance,
                    w.uint32(50).fork()
                ).ldelim();
            if (m.cryptoCreateAccount != null && Object.hasOwnProperty.call(m, "cryptoCreateAccount"))
                $root.proto.CryptoCreateTransactionBody.encode(m.cryptoCreateAccount, w.uint32(58).fork()).ldelim();
            if (m.cryptoDelete != null && Object.hasOwnProperty.call(m, "cryptoDelete"))
                $root.proto.CryptoDeleteTransactionBody.encode(m.cryptoDelete, w.uint32(66).fork()).ldelim();
            if (m.cryptoTransfer != null && Object.hasOwnProperty.call(m, "cryptoTransfer"))
                $root.proto.CryptoTransferTransactionBody.encode(m.cryptoTransfer, w.uint32(74).fork()).ldelim();
            if (m.cryptoUpdateAccount != null && Object.hasOwnProperty.call(m, "cryptoUpdateAccount"))
                $root.proto.CryptoUpdateTransactionBody.encode(m.cryptoUpdateAccount, w.uint32(82).fork()).ldelim();
            if (m.fileAppend != null && Object.hasOwnProperty.call(m, "fileAppend"))
                $root.proto.FileAppendTransactionBody.encode(m.fileAppend, w.uint32(90).fork()).ldelim();
            if (m.fileCreate != null && Object.hasOwnProperty.call(m, "fileCreate"))
                $root.proto.FileCreateTransactionBody.encode(m.fileCreate, w.uint32(98).fork()).ldelim();
            if (m.fileDelete != null && Object.hasOwnProperty.call(m, "fileDelete"))
                $root.proto.FileDeleteTransactionBody.encode(m.fileDelete, w.uint32(106).fork()).ldelim();
            if (m.fileUpdate != null && Object.hasOwnProperty.call(m, "fileUpdate"))
                $root.proto.FileUpdateTransactionBody.encode(m.fileUpdate, w.uint32(114).fork()).ldelim();
            if (m.systemDelete != null && Object.hasOwnProperty.call(m, "systemDelete"))
                $root.proto.SystemDeleteTransactionBody.encode(m.systemDelete, w.uint32(122).fork()).ldelim();
            if (m.systemUndelete != null && Object.hasOwnProperty.call(m, "systemUndelete"))
                $root.proto.SystemUndeleteTransactionBody.encode(m.systemUndelete, w.uint32(130).fork()).ldelim();
            if (m.freeze != null && Object.hasOwnProperty.call(m, "freeze"))
                $root.proto.FreezeTransactionBody.encode(m.freeze, w.uint32(138).fork()).ldelim();
            if (m.consensusCreateTopic != null && Object.hasOwnProperty.call(m, "consensusCreateTopic"))
                $root.proto.ConsensusCreateTopicTransactionBody.encode(
                    m.consensusCreateTopic,
                    w.uint32(146).fork()
                ).ldelim();
            if (m.consensusUpdateTopic != null && Object.hasOwnProperty.call(m, "consensusUpdateTopic"))
                $root.proto.ConsensusUpdateTopicTransactionBody.encode(
                    m.consensusUpdateTopic,
                    w.uint32(154).fork()
                ).ldelim();
            if (m.consensusDeleteTopic != null && Object.hasOwnProperty.call(m, "consensusDeleteTopic"))
                $root.proto.ConsensusDeleteTopicTransactionBody.encode(
                    m.consensusDeleteTopic,
                    w.uint32(162).fork()
                ).ldelim();
            if (m.consensusSubmitMessage != null && Object.hasOwnProperty.call(m, "consensusSubmitMessage"))
                $root.proto.ConsensusSubmitMessageTransactionBody.encode(
                    m.consensusSubmitMessage,
                    w.uint32(170).fork()
                ).ldelim();
            if (m.tokenCreation != null && Object.hasOwnProperty.call(m, "tokenCreation"))
                $root.proto.TokenCreateTransactionBody.encode(m.tokenCreation, w.uint32(178).fork()).ldelim();
            if (m.tokenFreeze != null && Object.hasOwnProperty.call(m, "tokenFreeze"))
                $root.proto.TokenFreezeAccountTransactionBody.encode(m.tokenFreeze, w.uint32(186).fork()).ldelim();
            if (m.tokenUnfreeze != null && Object.hasOwnProperty.call(m, "tokenUnfreeze"))
                $root.proto.TokenUnfreezeAccountTransactionBody.encode(m.tokenUnfreeze, w.uint32(194).fork()).ldelim();
            if (m.tokenGrantKyc != null && Object.hasOwnProperty.call(m, "tokenGrantKyc"))
                $root.proto.TokenGrantKycTransactionBody.encode(m.tokenGrantKyc, w.uint32(202).fork()).ldelim();
            if (m.tokenRevokeKyc != null && Object.hasOwnProperty.call(m, "tokenRevokeKyc"))
                $root.proto.TokenRevokeKycTransactionBody.encode(m.tokenRevokeKyc, w.uint32(210).fork()).ldelim();
            if (m.tokenDeletion != null && Object.hasOwnProperty.call(m, "tokenDeletion"))
                $root.proto.TokenDeleteTransactionBody.encode(m.tokenDeletion, w.uint32(218).fork()).ldelim();
            if (m.tokenUpdate != null && Object.hasOwnProperty.call(m, "tokenUpdate"))
                $root.proto.TokenUpdateTransactionBody.encode(m.tokenUpdate, w.uint32(226).fork()).ldelim();
            if (m.tokenMint != null && Object.hasOwnProperty.call(m, "tokenMint"))
                $root.proto.TokenMintTransactionBody.encode(m.tokenMint, w.uint32(234).fork()).ldelim();
            if (m.tokenBurn != null && Object.hasOwnProperty.call(m, "tokenBurn"))
                $root.proto.TokenBurnTransactionBody.encode(m.tokenBurn, w.uint32(242).fork()).ldelim();
            if (m.tokenWipe != null && Object.hasOwnProperty.call(m, "tokenWipe"))
                $root.proto.TokenWipeAccountTransactionBody.encode(m.tokenWipe, w.uint32(250).fork()).ldelim();
            if (m.tokenAssociate != null && Object.hasOwnProperty.call(m, "tokenAssociate"))
                $root.proto.TokenAssociateTransactionBody.encode(m.tokenAssociate, w.uint32(258).fork()).ldelim();
            if (m.tokenDissociate != null && Object.hasOwnProperty.call(m, "tokenDissociate"))
                $root.proto.TokenDissociateTransactionBody.encode(m.tokenDissociate, w.uint32(266).fork()).ldelim();
            if (m.scheduleDelete != null && Object.hasOwnProperty.call(m, "scheduleDelete"))
                $root.proto.ScheduleDeleteTransactionBody.encode(m.scheduleDelete, w.uint32(274).fork()).ldelim();
            if (m.tokenPause != null && Object.hasOwnProperty.call(m, "tokenPause"))
                $root.proto.TokenPauseTransactionBody.encode(m.tokenPause, w.uint32(282).fork()).ldelim();
            if (m.tokenUnpause != null && Object.hasOwnProperty.call(m, "tokenUnpause"))
                $root.proto.TokenUnpauseTransactionBody.encode(m.tokenUnpause, w.uint32(290).fork()).ldelim();
            if (m.cryptoApproveAllowance != null && Object.hasOwnProperty.call(m, "cryptoApproveAllowance"))
                $root.proto.CryptoApproveAllowanceTransactionBody.encode(
                    m.cryptoApproveAllowance,
                    w.uint32(298).fork()
                ).ldelim();
            if (m.cryptoDeleteAllowance != null && Object.hasOwnProperty.call(m, "cryptoDeleteAllowance"))
                $root.proto.CryptoDeleteAllowanceTransactionBody.encode(
                    m.cryptoDeleteAllowance,
                    w.uint32(306).fork()
                ).ldelim();
            if (m.tokenFeeScheduleUpdate != null && Object.hasOwnProperty.call(m, "tokenFeeScheduleUpdate"))
                $root.proto.TokenFeeScheduleUpdateTransactionBody.encode(
                    m.tokenFeeScheduleUpdate,
                    w.uint32(314).fork()
                ).ldelim();
            if (m.utilPrng != null && Object.hasOwnProperty.call(m, "utilPrng"))
                $root.proto.UtilPrngTransactionBody.encode(m.utilPrng, w.uint32(322).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a SchedulableTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SchedulableTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.SchedulableTransactionBody} SchedulableTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SchedulableTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.SchedulableTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.transactionFee = r.uint64();
                        break;
                    }
                    case 2: {
                        m.memo = r.string();
                        break;
                    }
                    case 3: {
                        m.contractCall = $root.proto.ContractCallTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 4: {
                        m.contractCreateInstance = $root.proto.ContractCreateTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 5: {
                        m.contractUpdateInstance = $root.proto.ContractUpdateTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 6: {
                        m.contractDeleteInstance = $root.proto.ContractDeleteTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 37: {
                        m.cryptoApproveAllowance = $root.proto.CryptoApproveAllowanceTransactionBody.decode(
                            r,
                            r.uint32()
                        );
                        break;
                    }
                    case 38: {
                        m.cryptoDeleteAllowance = $root.proto.CryptoDeleteAllowanceTransactionBody.decode(
                            r,
                            r.uint32()
                        );
                        break;
                    }
                    case 7: {
                        m.cryptoCreateAccount = $root.proto.CryptoCreateTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 8: {
                        m.cryptoDelete = $root.proto.CryptoDeleteTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 9: {
                        m.cryptoTransfer = $root.proto.CryptoTransferTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 10: {
                        m.cryptoUpdateAccount = $root.proto.CryptoUpdateTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 11: {
                        m.fileAppend = $root.proto.FileAppendTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 12: {
                        m.fileCreate = $root.proto.FileCreateTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 13: {
                        m.fileDelete = $root.proto.FileDeleteTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 14: {
                        m.fileUpdate = $root.proto.FileUpdateTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 15: {
                        m.systemDelete = $root.proto.SystemDeleteTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 16: {
                        m.systemUndelete = $root.proto.SystemUndeleteTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 17: {
                        m.freeze = $root.proto.FreezeTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 18: {
                        m.consensusCreateTopic = $root.proto.ConsensusCreateTopicTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 19: {
                        m.consensusUpdateTopic = $root.proto.ConsensusUpdateTopicTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 20: {
                        m.consensusDeleteTopic = $root.proto.ConsensusDeleteTopicTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 21: {
                        m.consensusSubmitMessage = $root.proto.ConsensusSubmitMessageTransactionBody.decode(
                            r,
                            r.uint32()
                        );
                        break;
                    }
                    case 22: {
                        m.tokenCreation = $root.proto.TokenCreateTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 23: {
                        m.tokenFreeze = $root.proto.TokenFreezeAccountTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 24: {
                        m.tokenUnfreeze = $root.proto.TokenUnfreezeAccountTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 25: {
                        m.tokenGrantKyc = $root.proto.TokenGrantKycTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 26: {
                        m.tokenRevokeKyc = $root.proto.TokenRevokeKycTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 27: {
                        m.tokenDeletion = $root.proto.TokenDeleteTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 28: {
                        m.tokenUpdate = $root.proto.TokenUpdateTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 29: {
                        m.tokenMint = $root.proto.TokenMintTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 30: {
                        m.tokenBurn = $root.proto.TokenBurnTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 31: {
                        m.tokenWipe = $root.proto.TokenWipeAccountTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 32: {
                        m.tokenAssociate = $root.proto.TokenAssociateTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 33: {
                        m.tokenDissociate = $root.proto.TokenDissociateTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 39: {
                        m.tokenFeeScheduleUpdate = $root.proto.TokenFeeScheduleUpdateTransactionBody.decode(
                            r,
                            r.uint32()
                        );
                        break;
                    }
                    case 35: {
                        m.tokenPause = $root.proto.TokenPauseTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 36: {
                        m.tokenUnpause = $root.proto.TokenUnpauseTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 34: {
                        m.scheduleDelete = $root.proto.ScheduleDeleteTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 40: {
                        m.utilPrng = $root.proto.UtilPrngTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for SchedulableTransactionBody
         * @function getTypeUrl
         * @memberof proto.SchedulableTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SchedulableTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.SchedulableTransactionBody";
        };

        return SchedulableTransactionBody;
    })();

    proto.ScheduleDeleteTransactionBody = (function () {
        /**
         * Properties of a ScheduleDeleteTransactionBody.
         * @memberof proto
         * @interface IScheduleDeleteTransactionBody
         * @property {proto.IScheduleID|null} [scheduleID] The ID of the Scheduled Entity
         */

        /**
         * Constructs a new ScheduleDeleteTransactionBody.
         * @memberof proto
         * @classdesc Marks a schedule in the network's action queue as deleted. Must be signed by the admin key of the
         * target schedule.  A deleted schedule cannot receive any additional signing keys, nor will it be
         * executed.
         *
         * Other notable response codes include, <tt>INVALID_SCHEDULE_ID</tt>, <tt>SCHEDULE_PENDING_EXPIRATION</tt>,
         * <tt>SCHEDULE_ALREADY_DELETED</tt>, <tt>SCHEDULE_ALREADY_EXECUTED</tt>, <tt>SCHEDULE_IS_IMMUTABLE</tt>.
         * For more information please see the section of this documentation on the <tt>ResponseCode</tt>
         * enum.
         * @implements IScheduleDeleteTransactionBody
         * @constructor
         * @param {proto.IScheduleDeleteTransactionBody=} [p] Properties to set
         */
        function ScheduleDeleteTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The ID of the Scheduled Entity
         * @member {proto.IScheduleID|null|undefined} scheduleID
         * @memberof proto.ScheduleDeleteTransactionBody
         * @instance
         */
        ScheduleDeleteTransactionBody.prototype.scheduleID = null;

        /**
         * Creates a new ScheduleDeleteTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.ScheduleDeleteTransactionBody
         * @static
         * @param {proto.IScheduleDeleteTransactionBody=} [properties] Properties to set
         * @returns {proto.ScheduleDeleteTransactionBody} ScheduleDeleteTransactionBody instance
         */
        ScheduleDeleteTransactionBody.create = function create(properties) {
            return new ScheduleDeleteTransactionBody(properties);
        };

        /**
         * Encodes the specified ScheduleDeleteTransactionBody message. Does not implicitly {@link proto.ScheduleDeleteTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.ScheduleDeleteTransactionBody
         * @static
         * @param {proto.IScheduleDeleteTransactionBody} m ScheduleDeleteTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ScheduleDeleteTransactionBody.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.scheduleID != null && Object.hasOwnProperty.call(m, "scheduleID"))
                $root.proto.ScheduleID.encode(m.scheduleID, w.uint32(10).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a ScheduleDeleteTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ScheduleDeleteTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ScheduleDeleteTransactionBody} ScheduleDeleteTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ScheduleDeleteTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.ScheduleDeleteTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.scheduleID = $root.proto.ScheduleID.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ScheduleDeleteTransactionBody
         * @function getTypeUrl
         * @memberof proto.ScheduleDeleteTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ScheduleDeleteTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ScheduleDeleteTransactionBody";
        };

        return ScheduleDeleteTransactionBody;
    })();

    proto.UtilPrngTransactionBody = (function () {
        /**
         * Properties of an UtilPrngTransactionBody.
         * @memberof proto
         * @interface IUtilPrngTransactionBody
         * @property {number|null} [range] If provided and is positive, returns a 32-bit pseudorandom number from the given range in the transaction record.
         * If not set or set to zero, will return a 384-bit pseudorandom number in the record.
         */

        /**
         * Constructs a new UtilPrngTransactionBody.
         * @memberof proto
         * @classdesc Generates a pseudorandom number
         * @implements IUtilPrngTransactionBody
         * @constructor
         * @param {proto.IUtilPrngTransactionBody=} [p] Properties to set
         */
        function UtilPrngTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * If provided and is positive, returns a 32-bit pseudorandom number from the given range in the transaction record.
         * If not set or set to zero, will return a 384-bit pseudorandom number in the record.
         * @member {number} range
         * @memberof proto.UtilPrngTransactionBody
         * @instance
         */
        UtilPrngTransactionBody.prototype.range = 0;

        /**
         * Creates a new UtilPrngTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.UtilPrngTransactionBody
         * @static
         * @param {proto.IUtilPrngTransactionBody=} [properties] Properties to set
         * @returns {proto.UtilPrngTransactionBody} UtilPrngTransactionBody instance
         */
        UtilPrngTransactionBody.create = function create(properties) {
            return new UtilPrngTransactionBody(properties);
        };

        /**
         * Encodes the specified UtilPrngTransactionBody message. Does not implicitly {@link proto.UtilPrngTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.UtilPrngTransactionBody
         * @static
         * @param {proto.IUtilPrngTransactionBody} m UtilPrngTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UtilPrngTransactionBody.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.range != null && Object.hasOwnProperty.call(m, "range")) w.uint32(8).int32(m.range);
            return w;
        };

        /**
         * Decodes an UtilPrngTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UtilPrngTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.UtilPrngTransactionBody} UtilPrngTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UtilPrngTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.UtilPrngTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.range = r.int32();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for UtilPrngTransactionBody
         * @function getTypeUrl
         * @memberof proto.UtilPrngTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        UtilPrngTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.UtilPrngTransactionBody";
        };

        return UtilPrngTransactionBody;
    })();

    proto.ScheduleSignTransactionBody = (function () {
        /**
         * Properties of a ScheduleSignTransactionBody.
         * @memberof proto
         * @interface IScheduleSignTransactionBody
         * @property {proto.IScheduleID|null} [scheduleID] The id of the schedule to add signing keys to
         */

        /**
         * Constructs a new ScheduleSignTransactionBody.
         * @memberof proto
         * @classdesc Adds zero or more signing keys to a schedule.
         *
         * If Long Term Scheduled Transactions are enabled and <tt>wait_for_expiry</tt> was set to <tt>true</tt> on the
         * <tt>ScheduleCreate</tt> then the transaction will always wait till it's `expiration_time` to execute.
         *
         * Otherwise, if the resulting set of signing keys satisfy the
         * scheduled transaction's signing requirements, it will be executed immediately after the
         * triggering <tt>ScheduleSign</tt>.
         *
         * Upon <tt>SUCCESS</tt>, the receipt includes the <tt>scheduledTransactionID</tt> to use to query
         * for the record of the scheduled transaction's execution (if it occurs).
         *
         * Other notable response codes include <tt>INVALID_SCHEDULE_ID</tt>, <tt>SCHEDULE_ALREADY_DELETED</tt>,
         * <tt>SCHEDULE_PENDING_EXPIRATION</tt>, <tt>SCHEDULE_ALREADY_EXPIRED</tt>,
         * <tt>INVALID_ACCOUNT_ID</tt>, <tt>UNRESOLVABLE_REQUIRED_SIGNERS</tt>,
         * <tt>SOME_SIGNATURES_WERE_INVALID</tt>, and <tt>NO_NEW_VALID_SIGNATURES</tt>. For more information
         * please see the section of this documentation on the <tt>ResponseCode</tt> enum.
         * @implements IScheduleSignTransactionBody
         * @constructor
         * @param {proto.IScheduleSignTransactionBody=} [p] Properties to set
         */
        function ScheduleSignTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The id of the schedule to add signing keys to
         * @member {proto.IScheduleID|null|undefined} scheduleID
         * @memberof proto.ScheduleSignTransactionBody
         * @instance
         */
        ScheduleSignTransactionBody.prototype.scheduleID = null;

        /**
         * Creates a new ScheduleSignTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.ScheduleSignTransactionBody
         * @static
         * @param {proto.IScheduleSignTransactionBody=} [properties] Properties to set
         * @returns {proto.ScheduleSignTransactionBody} ScheduleSignTransactionBody instance
         */
        ScheduleSignTransactionBody.create = function create(properties) {
            return new ScheduleSignTransactionBody(properties);
        };

        /**
         * Encodes the specified ScheduleSignTransactionBody message. Does not implicitly {@link proto.ScheduleSignTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.ScheduleSignTransactionBody
         * @static
         * @param {proto.IScheduleSignTransactionBody} m ScheduleSignTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ScheduleSignTransactionBody.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.scheduleID != null && Object.hasOwnProperty.call(m, "scheduleID"))
                $root.proto.ScheduleID.encode(m.scheduleID, w.uint32(10).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a ScheduleSignTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ScheduleSignTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ScheduleSignTransactionBody} ScheduleSignTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ScheduleSignTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.ScheduleSignTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.scheduleID = $root.proto.ScheduleID.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ScheduleSignTransactionBody
         * @function getTypeUrl
         * @memberof proto.ScheduleSignTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ScheduleSignTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ScheduleSignTransactionBody";
        };

        return ScheduleSignTransactionBody;
    })();

    proto.NodeStakeUpdateTransactionBody = (function () {
        /**
         * Properties of a NodeStakeUpdateTransactionBody.
         * @memberof proto
         * @interface INodeStakeUpdateTransactionBody
         * @property {proto.ITimestamp|null} [endOfStakingPeriod] Time and date of the end of the staking period that is ending
         * @property {Array.<proto.INodeStake>|null} [nodeStake] Staking info of each node at the beginning of the new staking period
         * @property {Long|null} [maxStakingRewardRatePerHbar] The maximum reward rate, in tinybars per whole hbar, that any account can receive in a day.
         * @property {proto.IFraction|null} [nodeRewardFeeFraction] The fraction of the network and service fees paid to the node reward account 0.0.801.
         * @property {Long|null} [stakingPeriodsStored] The maximum number of trailing periods for which a user can collect rewards. For example, if this
         * is 365 with a UTC calendar day period, then users must collect rewards at least once per calendar
         * year to avoid missing any value.
         * @property {Long|null} [stakingPeriod] The number of minutes in a staking period. Note for the special case of 1440 minutes, periods are
         * treated as UTC calendar days, rather than repeating 1440 minute periods left-aligned at the epoch.
         * @property {proto.IFraction|null} [stakingRewardFeeFraction] The fraction of the network and service fees paid to the staking reward account 0.0.800.
         * @property {Long|null} [stakingStartThreshold] The minimum balance of staking reward account 0.0.800 required to active rewards.
         * @property {Long|null} [stakingRewardRate] The total number of tinybars to be distributed as staking rewards each period.
         */

        /**
         * Constructs a new NodeStakeUpdateTransactionBody.
         * @memberof proto
         * @classdesc Updates the staking info at the end of staking period to indicate new staking period has started.
         * @implements INodeStakeUpdateTransactionBody
         * @constructor
         * @param {proto.INodeStakeUpdateTransactionBody=} [p] Properties to set
         */
        function NodeStakeUpdateTransactionBody(p) {
            this.nodeStake = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * Time and date of the end of the staking period that is ending
         * @member {proto.ITimestamp|null|undefined} endOfStakingPeriod
         * @memberof proto.NodeStakeUpdateTransactionBody
         * @instance
         */
        NodeStakeUpdateTransactionBody.prototype.endOfStakingPeriod = null;

        /**
         * Staking info of each node at the beginning of the new staking period
         * @member {Array.<proto.INodeStake>} nodeStake
         * @memberof proto.NodeStakeUpdateTransactionBody
         * @instance
         */
        NodeStakeUpdateTransactionBody.prototype.nodeStake = $util.emptyArray;

        /**
         * The maximum reward rate, in tinybars per whole hbar, that any account can receive in a day.
         * @member {Long} maxStakingRewardRatePerHbar
         * @memberof proto.NodeStakeUpdateTransactionBody
         * @instance
         */
        NodeStakeUpdateTransactionBody.prototype.maxStakingRewardRatePerHbar = $util.Long
            ? $util.Long.fromBits(0, 0, false)
            : 0;

        /**
         * The fraction of the network and service fees paid to the node reward account 0.0.801.
         * @member {proto.IFraction|null|undefined} nodeRewardFeeFraction
         * @memberof proto.NodeStakeUpdateTransactionBody
         * @instance
         */
        NodeStakeUpdateTransactionBody.prototype.nodeRewardFeeFraction = null;

        /**
         * The maximum number of trailing periods for which a user can collect rewards. For example, if this
         * is 365 with a UTC calendar day period, then users must collect rewards at least once per calendar
         * year to avoid missing any value.
         * @member {Long} stakingPeriodsStored
         * @memberof proto.NodeStakeUpdateTransactionBody
         * @instance
         */
        NodeStakeUpdateTransactionBody.prototype.stakingPeriodsStored = $util.Long
            ? $util.Long.fromBits(0, 0, false)
            : 0;

        /**
         * The number of minutes in a staking period. Note for the special case of 1440 minutes, periods are
         * treated as UTC calendar days, rather than repeating 1440 minute periods left-aligned at the epoch.
         * @member {Long} stakingPeriod
         * @memberof proto.NodeStakeUpdateTransactionBody
         * @instance
         */
        NodeStakeUpdateTransactionBody.prototype.stakingPeriod = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * The fraction of the network and service fees paid to the staking reward account 0.0.800.
         * @member {proto.IFraction|null|undefined} stakingRewardFeeFraction
         * @memberof proto.NodeStakeUpdateTransactionBody
         * @instance
         */
        NodeStakeUpdateTransactionBody.prototype.stakingRewardFeeFraction = null;

        /**
         * The minimum balance of staking reward account 0.0.800 required to active rewards.
         * @member {Long} stakingStartThreshold
         * @memberof proto.NodeStakeUpdateTransactionBody
         * @instance
         */
        NodeStakeUpdateTransactionBody.prototype.stakingStartThreshold = $util.Long
            ? $util.Long.fromBits(0, 0, false)
            : 0;

        /**
         * The total number of tinybars to be distributed as staking rewards each period.
         * @member {Long} stakingRewardRate
         * @memberof proto.NodeStakeUpdateTransactionBody
         * @instance
         */
        NodeStakeUpdateTransactionBody.prototype.stakingRewardRate = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * Creates a new NodeStakeUpdateTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.NodeStakeUpdateTransactionBody
         * @static
         * @param {proto.INodeStakeUpdateTransactionBody=} [properties] Properties to set
         * @returns {proto.NodeStakeUpdateTransactionBody} NodeStakeUpdateTransactionBody instance
         */
        NodeStakeUpdateTransactionBody.create = function create(properties) {
            return new NodeStakeUpdateTransactionBody(properties);
        };

        /**
         * Encodes the specified NodeStakeUpdateTransactionBody message. Does not implicitly {@link proto.NodeStakeUpdateTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.NodeStakeUpdateTransactionBody
         * @static
         * @param {proto.INodeStakeUpdateTransactionBody} m NodeStakeUpdateTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeStakeUpdateTransactionBody.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.endOfStakingPeriod != null && Object.hasOwnProperty.call(m, "endOfStakingPeriod"))
                $root.proto.Timestamp.encode(m.endOfStakingPeriod, w.uint32(10).fork()).ldelim();
            if (m.nodeStake != null && m.nodeStake.length) {
                for (var i = 0; i < m.nodeStake.length; ++i)
                    $root.proto.NodeStake.encode(m.nodeStake[i], w.uint32(18).fork()).ldelim();
            }
            if (m.maxStakingRewardRatePerHbar != null && Object.hasOwnProperty.call(m, "maxStakingRewardRatePerHbar"))
                w.uint32(24).int64(m.maxStakingRewardRatePerHbar);
            if (m.nodeRewardFeeFraction != null && Object.hasOwnProperty.call(m, "nodeRewardFeeFraction"))
                $root.proto.Fraction.encode(m.nodeRewardFeeFraction, w.uint32(34).fork()).ldelim();
            if (m.stakingPeriodsStored != null && Object.hasOwnProperty.call(m, "stakingPeriodsStored"))
                w.uint32(40).int64(m.stakingPeriodsStored);
            if (m.stakingPeriod != null && Object.hasOwnProperty.call(m, "stakingPeriod"))
                w.uint32(48).int64(m.stakingPeriod);
            if (m.stakingRewardFeeFraction != null && Object.hasOwnProperty.call(m, "stakingRewardFeeFraction"))
                $root.proto.Fraction.encode(m.stakingRewardFeeFraction, w.uint32(58).fork()).ldelim();
            if (m.stakingStartThreshold != null && Object.hasOwnProperty.call(m, "stakingStartThreshold"))
                w.uint32(64).int64(m.stakingStartThreshold);
            if (m.stakingRewardRate != null && Object.hasOwnProperty.call(m, "stakingRewardRate"))
                w.uint32(72).int64(m.stakingRewardRate);
            return w;
        };

        /**
         * Decodes a NodeStakeUpdateTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.NodeStakeUpdateTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.NodeStakeUpdateTransactionBody} NodeStakeUpdateTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeStakeUpdateTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.NodeStakeUpdateTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.endOfStakingPeriod = $root.proto.Timestamp.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        if (!(m.nodeStake && m.nodeStake.length)) m.nodeStake = [];
                        m.nodeStake.push($root.proto.NodeStake.decode(r, r.uint32()));
                        break;
                    }
                    case 3: {
                        m.maxStakingRewardRatePerHbar = r.int64();
                        break;
                    }
                    case 4: {
                        m.nodeRewardFeeFraction = $root.proto.Fraction.decode(r, r.uint32());
                        break;
                    }
                    case 5: {
                        m.stakingPeriodsStored = r.int64();
                        break;
                    }
                    case 6: {
                        m.stakingPeriod = r.int64();
                        break;
                    }
                    case 7: {
                        m.stakingRewardFeeFraction = $root.proto.Fraction.decode(r, r.uint32());
                        break;
                    }
                    case 8: {
                        m.stakingStartThreshold = r.int64();
                        break;
                    }
                    case 9: {
                        m.stakingRewardRate = r.int64();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for NodeStakeUpdateTransactionBody
         * @function getTypeUrl
         * @memberof proto.NodeStakeUpdateTransactionBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        NodeStakeUpdateTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.NodeStakeUpdateTransactionBody";
        };

        return NodeStakeUpdateTransactionBody;
    })();

    proto.NodeStake = (function () {
        /**
         * Properties of a NodeStake.
         * @memberof proto
         * @interface INodeStake
         * @property {Long|null} [maxStake] The maximum stake (rewarded or not rewarded) this node can have as consensus weight. If its stake to
         * reward is above this maximum at the start of a period, then accounts staking to the node in that
         * period will be rewarded at a lower rate scaled by (maxStake / stakeRewardStart).
         * @property {Long|null} [minStake] The minimum stake (rewarded or not rewarded) this node must reach before having non-zero consensus weight.
         * If its total stake is below this minimum at the start of a period, then accounts staking to the node in
         * that period will receive no rewards.
         * @property {Long|null} [nodeId] The id of this node.
         * @property {Long|null} [rewardRate] The reward rate _per whole hbar_ that was staked to this node with declineReward=false from the start of
         * the staking period that is ending.
         * @property {Long|null} [stake] Consensus weight of this node for the new staking period.
         * @property {Long|null} [stakeNotRewarded] Total of (balance + stakedToMe) for all accounts staked to this node with declineReward=true, at the
         * beginning of the new staking period.
         * @property {Long|null} [stakeRewarded] Total of (balance + stakedToMe) for all accounts staked to this node with declineReward=false, at the
         * beginning of the new staking period.
         */

        /**
         * Constructs a new NodeStake.
         * @memberof proto
         * @classdesc Staking info for each node at the end of a staking period.
         * @implements INodeStake
         * @constructor
         * @param {proto.INodeStake=} [p] Properties to set
         */
        function NodeStake(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The maximum stake (rewarded or not rewarded) this node can have as consensus weight. If its stake to
         * reward is above this maximum at the start of a period, then accounts staking to the node in that
         * period will be rewarded at a lower rate scaled by (maxStake / stakeRewardStart).
         * @member {Long} maxStake
         * @memberof proto.NodeStake
         * @instance
         */
        NodeStake.prototype.maxStake = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * The minimum stake (rewarded or not rewarded) this node must reach before having non-zero consensus weight.
         * If its total stake is below this minimum at the start of a period, then accounts staking to the node in
         * that period will receive no rewards.
         * @member {Long} minStake
         * @memberof proto.NodeStake
         * @instance
         */
        NodeStake.prototype.minStake = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * The id of this node.
         * @member {Long} nodeId
         * @memberof proto.NodeStake
         * @instance
         */
        NodeStake.prototype.nodeId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * The reward rate _per whole hbar_ that was staked to this node with declineReward=false from the start of
         * the staking period that is ending.
         * @member {Long} rewardRate
         * @memberof proto.NodeStake
         * @instance
         */
        NodeStake.prototype.rewardRate = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * Consensus weight of this node for the new staking period.
         * @member {Long} stake
         * @memberof proto.NodeStake
         * @instance
         */
        NodeStake.prototype.stake = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * Total of (balance + stakedToMe) for all accounts staked to this node with declineReward=true, at the
         * beginning of the new staking period.
         * @member {Long} stakeNotRewarded
         * @memberof proto.NodeStake
         * @instance
         */
        NodeStake.prototype.stakeNotRewarded = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * Total of (balance + stakedToMe) for all accounts staked to this node with declineReward=false, at the
         * beginning of the new staking period.
         * @member {Long} stakeRewarded
         * @memberof proto.NodeStake
         * @instance
         */
        NodeStake.prototype.stakeRewarded = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * Creates a new NodeStake instance using the specified properties.
         * @function create
         * @memberof proto.NodeStake
         * @static
         * @param {proto.INodeStake=} [properties] Properties to set
         * @returns {proto.NodeStake} NodeStake instance
         */
        NodeStake.create = function create(properties) {
            return new NodeStake(properties);
        };

        /**
         * Encodes the specified NodeStake message. Does not implicitly {@link proto.NodeStake.verify|verify} messages.
         * @function encode
         * @memberof proto.NodeStake
         * @static
         * @param {proto.INodeStake} m NodeStake message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeStake.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.maxStake != null && Object.hasOwnProperty.call(m, "maxStake")) w.uint32(8).int64(m.maxStake);
            if (m.minStake != null && Object.hasOwnProperty.call(m, "minStake")) w.uint32(16).int64(m.minStake);
            if (m.nodeId != null && Object.hasOwnProperty.call(m, "nodeId")) w.uint32(24).int64(m.nodeId);
            if (m.rewardRate != null && Object.hasOwnProperty.call(m, "rewardRate")) w.uint32(32).int64(m.rewardRate);
            if (m.stake != null && Object.hasOwnProperty.call(m, "stake")) w.uint32(40).int64(m.stake);
            if (m.stakeNotRewarded != null && Object.hasOwnProperty.call(m, "stakeNotRewarded"))
                w.uint32(48).int64(m.stakeNotRewarded);
            if (m.stakeRewarded != null && Object.hasOwnProperty.call(m, "stakeRewarded"))
                w.uint32(56).int64(m.stakeRewarded);
            return w;
        };

        /**
         * Decodes a NodeStake message from the specified reader or buffer.
         * @function decode
         * @memberof proto.NodeStake
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.NodeStake} NodeStake
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeStake.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.NodeStake();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.maxStake = r.int64();
                        break;
                    }
                    case 2: {
                        m.minStake = r.int64();
                        break;
                    }
                    case 3: {
                        m.nodeId = r.int64();
                        break;
                    }
                    case 4: {
                        m.rewardRate = r.int64();
                        break;
                    }
                    case 5: {
                        m.stake = r.int64();
                        break;
                    }
                    case 6: {
                        m.stakeNotRewarded = r.int64();
                        break;
                    }
                    case 7: {
                        m.stakeRewarded = r.int64();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for NodeStake
         * @function getTypeUrl
         * @memberof proto.NodeStake
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        NodeStake.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.NodeStake";
        };

        return NodeStake;
    })();

    proto.ResponseHeader = (function () {
        /**
         * Properties of a ResponseHeader.
         * @memberof proto
         * @interface IResponseHeader
         * @property {proto.ResponseCodeEnum|null} [nodeTransactionPrecheckCode] Result of fee transaction precheck, saying it passed, or why it failed
         * @property {proto.ResponseType|null} [responseType] The requested response is repeated back here, for convenience
         * @property {Long|null} [cost] The fee that would be charged to get the requested information (if a cost was requested).
         * Note: This cost only includes the query fee and does not include the transfer fee(which is
         * required to execute the transfer transaction to debit the payer account and credit the node
         * account with query fee)
         * @property {Uint8Array|null} [stateProof] The state proof for this information (if a state proof was requested, and is available)
         */

        /**
         * Constructs a new ResponseHeader.
         * @memberof proto
         * @classdesc Every query receives a response containing the QueryResponseHeader. Either or both of the cost
         * and stateProof fields may be blank, if the responseType didn't ask for the cost or stateProof.
         * @implements IResponseHeader
         * @constructor
         * @param {proto.IResponseHeader=} [p] Properties to set
         */
        function ResponseHeader(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * Result of fee transaction precheck, saying it passed, or why it failed
         * @member {proto.ResponseCodeEnum} nodeTransactionPrecheckCode
         * @memberof proto.ResponseHeader
         * @instance
         */
        ResponseHeader.prototype.nodeTransactionPrecheckCode = 0;

        /**
         * The requested response is repeated back here, for convenience
         * @member {proto.ResponseType} responseType
         * @memberof proto.ResponseHeader
         * @instance
         */
        ResponseHeader.prototype.responseType = 0;

        /**
         * The fee that would be charged to get the requested information (if a cost was requested).
         * Note: This cost only includes the query fee and does not include the transfer fee(which is
         * required to execute the transfer transaction to debit the payer account and credit the node
         * account with query fee)
         * @member {Long} cost
         * @memberof proto.ResponseHeader
         * @instance
         */
        ResponseHeader.prototype.cost = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * The state proof for this information (if a state proof was requested, and is available)
         * @member {Uint8Array} stateProof
         * @memberof proto.ResponseHeader
         * @instance
         */
        ResponseHeader.prototype.stateProof = $util.newBuffer([]);

        /**
         * Creates a new ResponseHeader instance using the specified properties.
         * @function create
         * @memberof proto.ResponseHeader
         * @static
         * @param {proto.IResponseHeader=} [properties] Properties to set
         * @returns {proto.ResponseHeader} ResponseHeader instance
         */
        ResponseHeader.create = function create(properties) {
            return new ResponseHeader(properties);
        };

        /**
         * Encodes the specified ResponseHeader message. Does not implicitly {@link proto.ResponseHeader.verify|verify} messages.
         * @function encode
         * @memberof proto.ResponseHeader
         * @static
         * @param {proto.IResponseHeader} m ResponseHeader message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseHeader.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.nodeTransactionPrecheckCode != null && Object.hasOwnProperty.call(m, "nodeTransactionPrecheckCode"))
                w.uint32(8).int32(m.nodeTransactionPrecheckCode);
            if (m.responseType != null && Object.hasOwnProperty.call(m, "responseType"))
                w.uint32(16).int32(m.responseType);
            if (m.cost != null && Object.hasOwnProperty.call(m, "cost")) w.uint32(24).uint64(m.cost);
            if (m.stateProof != null && Object.hasOwnProperty.call(m, "stateProof")) w.uint32(34).bytes(m.stateProof);
            return w;
        };

        /**
         * Decodes a ResponseHeader message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ResponseHeader
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ResponseHeader} ResponseHeader
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseHeader.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.ResponseHeader();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.nodeTransactionPrecheckCode = r.int32();
                        break;
                    }
                    case 2: {
                        m.responseType = r.int32();
                        break;
                    }
                    case 3: {
                        m.cost = r.uint64();
                        break;
                    }
                    case 4: {
                        m.stateProof = r.bytes();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ResponseHeader
         * @function getTypeUrl
         * @memberof proto.ResponseHeader
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ResponseHeader.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ResponseHeader";
        };

        return ResponseHeader;
    })();

    proto.TransactionResponse = (function () {
        /**
         * Properties of a TransactionResponse.
         * @memberof proto
         * @interface ITransactionResponse
         * @property {proto.ResponseCodeEnum|null} [nodeTransactionPrecheckCode] * The response code that indicates the current status of the transaction.
         * @property {Long|null} [cost] If the response code was INSUFFICIENT_TX_FEE, the actual transaction fee that would be
         * required to execute the transaction.
         */

        /**
         * Constructs a new TransactionResponse.
         * @memberof proto
         * @classdesc When the client sends the node a transaction of any kind, the node replies with this, which
         * simply says that the transaction passed the precheck (so the node will submit it to the network)
         * or it failed (so it won't). If the fee offered was insufficient, this will also contain the
         * amount of the required fee. To learn the consensus result, the client should later obtain a
         * receipt (free), or can buy a more detailed record (not free).
         * @implements ITransactionResponse
         * @constructor
         * @param {proto.ITransactionResponse=} [p] Properties to set
         */
        function TransactionResponse(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * * The response code that indicates the current status of the transaction.
         * @member {proto.ResponseCodeEnum} nodeTransactionPrecheckCode
         * @memberof proto.TransactionResponse
         * @instance
         */
        TransactionResponse.prototype.nodeTransactionPrecheckCode = 0;

        /**
         * If the response code was INSUFFICIENT_TX_FEE, the actual transaction fee that would be
         * required to execute the transaction.
         * @member {Long} cost
         * @memberof proto.TransactionResponse
         * @instance
         */
        TransactionResponse.prototype.cost = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * Creates a new TransactionResponse instance using the specified properties.
         * @function create
         * @memberof proto.TransactionResponse
         * @static
         * @param {proto.ITransactionResponse=} [properties] Properties to set
         * @returns {proto.TransactionResponse} TransactionResponse instance
         */
        TransactionResponse.create = function create(properties) {
            return new TransactionResponse(properties);
        };

        /**
         * Encodes the specified TransactionResponse message. Does not implicitly {@link proto.TransactionResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.TransactionResponse
         * @static
         * @param {proto.ITransactionResponse} m TransactionResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionResponse.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.nodeTransactionPrecheckCode != null && Object.hasOwnProperty.call(m, "nodeTransactionPrecheckCode"))
                w.uint32(8).int32(m.nodeTransactionPrecheckCode);
            if (m.cost != null && Object.hasOwnProperty.call(m, "cost")) w.uint32(16).uint64(m.cost);
            return w;
        };

        /**
         * Decodes a TransactionResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TransactionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TransactionResponse} TransactionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionResponse.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.TransactionResponse();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.nodeTransactionPrecheckCode = r.int32();
                        break;
                    }
                    case 2: {
                        m.cost = r.uint64();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TransactionResponse
         * @function getTypeUrl
         * @memberof proto.TransactionResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TransactionResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TransactionResponse";
        };

        return TransactionResponse;
    })();

    /**
     * UNDOCUMENTED
     * @name proto.ResponseCodeEnum
     * @enum {number}
     * @property {number} OK=0 The transaction passed the precheck validations.
     * @property {number} INVALID_TRANSACTION=1 For any error not handled by specific error codes listed below.
     * @property {number} PAYER_ACCOUNT_NOT_FOUND=2 Payer account does not exist.
     * @property {number} INVALID_NODE_ACCOUNT=3 Node Account provided does not match the node account of the node the transaction was submitted
     * to.
     * @property {number} TRANSACTION_EXPIRED=4 Pre-Check error when TransactionValidStart + transactionValidDuration is less than current
     * consensus time.
     * @property {number} INVALID_TRANSACTION_START=5 Transaction start time is greater than current consensus time
     * @property {number} INVALID_TRANSACTION_DURATION=6 The given transactionValidDuration was either non-positive, or greater than the maximum
     * valid duration of 180 secs.
     * @property {number} INVALID_SIGNATURE=7 The transaction signature is not valid
     * @property {number} MEMO_TOO_LONG=8 Transaction memo size exceeded 100 bytes
     * @property {number} INSUFFICIENT_TX_FEE=9 The fee provided in the transaction is insufficient for this type of transaction
     * @property {number} INSUFFICIENT_PAYER_BALANCE=10 The payer account has insufficient cryptocurrency to pay the transaction fee
     * @property {number} DUPLICATE_TRANSACTION=11 This transaction ID is a duplicate of one that was submitted to this node or reached consensus
     * in the last 180 seconds (receipt period)
     * @property {number} BUSY=12 If API is throttled out
     * @property {number} NOT_SUPPORTED=13 The API is not currently supported
     * @property {number} INVALID_FILE_ID=14 The file id is invalid or does not exist
     * @property {number} INVALID_ACCOUNT_ID=15 The account id is invalid or does not exist
     * @property {number} INVALID_CONTRACT_ID=16 The contract id is invalid or does not exist
     * @property {number} INVALID_TRANSACTION_ID=17 Transaction id is not valid
     * @property {number} RECEIPT_NOT_FOUND=18 Receipt for given transaction id does not exist
     * @property {number} RECORD_NOT_FOUND=19 Record for given transaction id does not exist
     * @property {number} INVALID_SOLIDITY_ID=20 The solidity id is invalid or entity with this solidity id does not exist
     * @property {number} UNKNOWN=21 The responding node has submitted the transaction to the network. Its final status is still
     * unknown.
     * @property {number} SUCCESS=22 The transaction succeeded
     * @property {number} FAIL_INVALID=23 There was a system error and the transaction failed because of invalid request parameters.
     * @property {number} FAIL_FEE=24 There was a system error while performing fee calculation, reserved for future.
     * @property {number} FAIL_BALANCE=25 There was a system error while performing balance checks, reserved for future.
     * @property {number} KEY_REQUIRED=26 Key not provided in the transaction body
     * @property {number} BAD_ENCODING=27 Unsupported algorithm/encoding used for keys in the transaction
     * @property {number} INSUFFICIENT_ACCOUNT_BALANCE=28 When the account balance is not sufficient for the transfer
     * @property {number} INVALID_SOLIDITY_ADDRESS=29 During an update transaction when the system is not able to find the Users Solidity address
     * @property {number} INSUFFICIENT_GAS=30 Not enough gas was supplied to execute transaction
     * @property {number} CONTRACT_SIZE_LIMIT_EXCEEDED=31 contract byte code size is over the limit
     * @property {number} LOCAL_CALL_MODIFICATION_EXCEPTION=32 local execution (query) is requested for a function which changes state
     * @property {number} CONTRACT_REVERT_EXECUTED=33 Contract REVERT OPCODE executed
     * @property {number} CONTRACT_EXECUTION_EXCEPTION=34 For any contract execution related error not handled by specific error codes listed above.
     * @property {number} INVALID_RECEIVING_NODE_ACCOUNT=35 In Query validation, account with +ve(amount) value should be Receiving node account, the
     * receiver account should be only one account in the list
     * @property {number} MISSING_QUERY_HEADER=36 Header is missing in Query request
     * @property {number} ACCOUNT_UPDATE_FAILED=37 The update of the account failed
     * @property {number} INVALID_KEY_ENCODING=38 Provided key encoding was not supported by the system
     * @property {number} NULL_SOLIDITY_ADDRESS=39 null solidity address
     * @property {number} CONTRACT_UPDATE_FAILED=40 update of the contract failed
     * @property {number} INVALID_QUERY_HEADER=41 the query header is invalid
     * @property {number} INVALID_FEE_SUBMITTED=42 Invalid fee submitted
     * @property {number} INVALID_PAYER_SIGNATURE=43 Payer signature is invalid
     * @property {number} KEY_NOT_PROVIDED=44 The keys were not provided in the request.
     * @property {number} INVALID_EXPIRATION_TIME=45 Expiration time provided in the transaction was invalid.
     * @property {number} NO_WACL_KEY=46 WriteAccess Control Keys are not provided for the file
     * @property {number} FILE_CONTENT_EMPTY=47 The contents of file are provided as empty.
     * @property {number} INVALID_ACCOUNT_AMOUNTS=48 The crypto transfer credit and debit do not sum equal to 0
     * @property {number} EMPTY_TRANSACTION_BODY=49 Transaction body provided is empty
     * @property {number} INVALID_TRANSACTION_BODY=50 Invalid transaction body provided
     * @property {number} INVALID_SIGNATURE_TYPE_MISMATCHING_KEY=51 the type of key (base ed25519 key, KeyList, or ThresholdKey) does not match the type of
     * signature (base ed25519 signature, SignatureList, or ThresholdKeySignature)
     * @property {number} INVALID_SIGNATURE_COUNT_MISMATCHING_KEY=52 the number of key (KeyList, or ThresholdKey) does not match that of signature (SignatureList,
     * or ThresholdKeySignature). e.g. if a keyList has 3 base keys, then the corresponding
     * signatureList should also have 3 base signatures.
     * @property {number} EMPTY_LIVE_HASH_BODY=53 the livehash body is empty
     * @property {number} EMPTY_LIVE_HASH=54 the livehash data is missing
     * @property {number} EMPTY_LIVE_HASH_KEYS=55 the keys for a livehash are missing
     * @property {number} INVALID_LIVE_HASH_SIZE=56 the livehash data is not the output of a SHA-384 digest
     * @property {number} EMPTY_QUERY_BODY=57 the query body is empty
     * @property {number} EMPTY_LIVE_HASH_QUERY=58 the crypto livehash query is empty
     * @property {number} LIVE_HASH_NOT_FOUND=59 the livehash is not present
     * @property {number} ACCOUNT_ID_DOES_NOT_EXIST=60 the account id passed has not yet been created.
     * @property {number} LIVE_HASH_ALREADY_EXISTS=61 the livehash already exists for a given account
     * @property {number} INVALID_FILE_WACL=62 File WACL keys are invalid
     * @property {number} SERIALIZATION_FAILED=63 Serialization failure
     * @property {number} TRANSACTION_OVERSIZE=64 The size of the Transaction is greater than transactionMaxBytes
     * @property {number} TRANSACTION_TOO_MANY_LAYERS=65 The Transaction has more than 50 levels
     * @property {number} CONTRACT_DELETED=66 Contract is marked as deleted
     * @property {number} PLATFORM_NOT_ACTIVE=67 the platform node is either disconnected or lagging behind.
     * @property {number} KEY_PREFIX_MISMATCH=68 one public key matches more than one prefixes on the signature map
     * @property {number} PLATFORM_TRANSACTION_NOT_CREATED=69 transaction not created by platform due to large backlog
     * @property {number} INVALID_RENEWAL_PERIOD=70 auto renewal period is not a positive number of seconds
     * @property {number} INVALID_PAYER_ACCOUNT_ID=71 the response code when a smart contract id is passed for a crypto API request
     * @property {number} ACCOUNT_DELETED=72 the account has been marked as deleted
     * @property {number} FILE_DELETED=73 the file has been marked as deleted
     * @property {number} ACCOUNT_REPEATED_IN_ACCOUNT_AMOUNTS=74 same accounts repeated in the transfer account list
     * @property {number} SETTING_NEGATIVE_ACCOUNT_BALANCE=75 attempting to set negative balance value for crypto account
     * @property {number} OBTAINER_REQUIRED=76 when deleting smart contract that has crypto balance either transfer account or transfer smart
     * contract is required
     * @property {number} OBTAINER_SAME_CONTRACT_ID=77 when deleting smart contract that has crypto balance you can not use the same contract id as
     * transferContractId as the one being deleted
     * @property {number} OBTAINER_DOES_NOT_EXIST=78 transferAccountId or transferContractId specified for contract delete does not exist
     * @property {number} MODIFYING_IMMUTABLE_CONTRACT=79 attempting to modify (update or delete a immutable smart contract, i.e. one created without a
     * admin key)
     * @property {number} FILE_SYSTEM_EXCEPTION=80 Unexpected exception thrown by file system functions
     * @property {number} AUTORENEW_DURATION_NOT_IN_RANGE=81 the duration is not a subset of [MINIMUM_AUTORENEW_DURATION,MAXIMUM_AUTORENEW_DURATION]
     * @property {number} ERROR_DECODING_BYTESTRING=82 Decoding the smart contract binary to a byte array failed. Check that the input is a valid hex
     * string.
     * @property {number} CONTRACT_FILE_EMPTY=83 File to create a smart contract was of length zero
     * @property {number} CONTRACT_BYTECODE_EMPTY=84 Bytecode for smart contract is of length zero
     * @property {number} INVALID_INITIAL_BALANCE=85 Attempt to set negative initial balance
     * @property {number} INVALID_RECEIVE_RECORD_THRESHOLD=86 [Deprecated]. attempt to set negative receive record threshold
     * @property {number} INVALID_SEND_RECORD_THRESHOLD=87 [Deprecated]. attempt to set negative send record threshold
     * @property {number} ACCOUNT_IS_NOT_GENESIS_ACCOUNT=88 Special Account Operations should be performed by only Genesis account, return this code if it
     * is not Genesis Account
     * @property {number} PAYER_ACCOUNT_UNAUTHORIZED=89 The fee payer account doesn't have permission to submit such Transaction
     * @property {number} INVALID_FREEZE_TRANSACTION_BODY=90 FreezeTransactionBody is invalid
     * @property {number} FREEZE_TRANSACTION_BODY_NOT_FOUND=91 FreezeTransactionBody does not exist
     * @property {number} TRANSFER_LIST_SIZE_LIMIT_EXCEEDED=92 Exceeded the number of accounts (both from and to) allowed for crypto transfer list
     * @property {number} RESULT_SIZE_LIMIT_EXCEEDED=93 Smart contract result size greater than specified maxResultSize
     * @property {number} NOT_SPECIAL_ACCOUNT=94 The payer account is not a special account(account 0.0.55)
     * @property {number} CONTRACT_NEGATIVE_GAS=95 Negative gas was offered in smart contract call
     * @property {number} CONTRACT_NEGATIVE_VALUE=96 Negative value / initial balance was specified in a smart contract call / create
     * @property {number} INVALID_FEE_FILE=97 Failed to update fee file
     * @property {number} INVALID_EXCHANGE_RATE_FILE=98 Failed to update exchange rate file
     * @property {number} INSUFFICIENT_LOCAL_CALL_GAS=99 Payment tendered for contract local call cannot cover both the fee and the gas
     * @property {number} ENTITY_NOT_ALLOWED_TO_DELETE=100 Entities with Entity ID below 1000 are not allowed to be deleted
     * @property {number} AUTHORIZATION_FAILED=101 Violating one of these rules: 1) treasury account can update all entities below 0.0.1000, 2)
     * account 0.0.50 can update all entities from 0.0.51 - 0.0.80, 3) Network Function Master Account
     * A/c 0.0.50 - Update all Network Function accounts & perform all the Network Functions listed
     * below, 4) Network Function Accounts: i) A/c 0.0.55 - Update Address Book files (0.0.101/102),
     * ii) A/c 0.0.56 - Update Fee schedule (0.0.111), iii) A/c 0.0.57 - Update Exchange Rate
     * (0.0.112).
     * @property {number} FILE_UPLOADED_PROTO_INVALID=102 Fee Schedule Proto uploaded but not valid (append or update is required)
     * @property {number} FILE_UPLOADED_PROTO_NOT_SAVED_TO_DISK=103 Fee Schedule Proto uploaded but not valid (append or update is required)
     * @property {number} FEE_SCHEDULE_FILE_PART_UPLOADED=104 Fee Schedule Proto File Part uploaded
     * @property {number} EXCHANGE_RATE_CHANGE_LIMIT_EXCEEDED=105 The change on Exchange Rate exceeds Exchange_Rate_Allowed_Percentage
     * @property {number} MAX_CONTRACT_STORAGE_EXCEEDED=106 Contract permanent storage exceeded the currently allowable limit
     * @property {number} TRANSFER_ACCOUNT_SAME_AS_DELETE_ACCOUNT=107 Transfer Account should not be same as Account to be deleted
     * @property {number} TOTAL_LEDGER_BALANCE_INVALID=108 TOTAL_LEDGER_BALANCE_INVALID value
     * @property {number} EXPIRATION_REDUCTION_NOT_ALLOWED=110 The expiration date/time on a smart contract may not be reduced
     * @property {number} MAX_GAS_LIMIT_EXCEEDED=111 Gas exceeded currently allowable gas limit per transaction
     * @property {number} MAX_FILE_SIZE_EXCEEDED=112 File size exceeded the currently allowable limit
     * @property {number} RECEIVER_SIG_REQUIRED=113 When a valid signature is not provided for operations on account with receiverSigRequired=true
     * @property {number} INVALID_TOPIC_ID=150 The Topic ID specified is not in the system.
     * @property {number} INVALID_ADMIN_KEY=155 A provided admin key was invalid. Verify the bytes for an Ed25519 public key are exactly 32 bytes; and the bytes for a compressed ECDSA(secp256k1) key are exactly 33 bytes, with the first byte either 0x02 or 0x03..
     * @property {number} INVALID_SUBMIT_KEY=156 A provided submit key was invalid.
     * @property {number} UNAUTHORIZED=157 An attempted operation was not authorized (ie - a deleteTopic for a topic with no adminKey).
     * @property {number} INVALID_TOPIC_MESSAGE=158 A ConsensusService message is empty.
     * @property {number} INVALID_AUTORENEW_ACCOUNT=159 The autoRenewAccount specified is not a valid, active account.
     * @property {number} AUTORENEW_ACCOUNT_NOT_ALLOWED=160 An adminKey was not specified on the topic, so there must not be an autoRenewAccount.
     * @property {number} TOPIC_EXPIRED=162 The topic has expired, was not automatically renewed, and is in a 7 day grace period before the
     * topic will be deleted unrecoverably. This error response code will not be returned until
     * autoRenew functionality is supported by HAPI.
     * @property {number} INVALID_CHUNK_NUMBER=163 INVALID_CHUNK_NUMBER value
     * @property {number} INVALID_CHUNK_TRANSACTION_ID=164 INVALID_CHUNK_TRANSACTION_ID value
     * @property {number} ACCOUNT_FROZEN_FOR_TOKEN=165 ACCOUNT_FROZEN_FOR_TOKEN value
     * @property {number} TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED=166 TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED value
     * @property {number} INVALID_TOKEN_ID=167 INVALID_TOKEN_ID value
     * @property {number} INVALID_TOKEN_DECIMALS=168 INVALID_TOKEN_DECIMALS value
     * @property {number} INVALID_TOKEN_INITIAL_SUPPLY=169 INVALID_TOKEN_INITIAL_SUPPLY value
     * @property {number} INVALID_TREASURY_ACCOUNT_FOR_TOKEN=170 INVALID_TREASURY_ACCOUNT_FOR_TOKEN value
     * @property {number} INVALID_TOKEN_SYMBOL=171 INVALID_TOKEN_SYMBOL value
     * @property {number} TOKEN_HAS_NO_FREEZE_KEY=172 TOKEN_HAS_NO_FREEZE_KEY value
     * @property {number} TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN=173 TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN value
     * @property {number} MISSING_TOKEN_SYMBOL=174 MISSING_TOKEN_SYMBOL value
     * @property {number} TOKEN_SYMBOL_TOO_LONG=175 TOKEN_SYMBOL_TOO_LONG value
     * @property {number} ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN=176 ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN value
     * @property {number} TOKEN_HAS_NO_KYC_KEY=177 TOKEN_HAS_NO_KYC_KEY value
     * @property {number} INSUFFICIENT_TOKEN_BALANCE=178 INSUFFICIENT_TOKEN_BALANCE value
     * @property {number} TOKEN_WAS_DELETED=179 TOKEN_WAS_DELETED value
     * @property {number} TOKEN_HAS_NO_SUPPLY_KEY=180 TOKEN_HAS_NO_SUPPLY_KEY value
     * @property {number} TOKEN_HAS_NO_WIPE_KEY=181 TOKEN_HAS_NO_WIPE_KEY value
     * @property {number} INVALID_TOKEN_MINT_AMOUNT=182 INVALID_TOKEN_MINT_AMOUNT value
     * @property {number} INVALID_TOKEN_BURN_AMOUNT=183 INVALID_TOKEN_BURN_AMOUNT value
     * @property {number} TOKEN_NOT_ASSOCIATED_TO_ACCOUNT=184 TOKEN_NOT_ASSOCIATED_TO_ACCOUNT value
     * @property {number} CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT=185 CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT value
     * @property {number} INVALID_KYC_KEY=186 INVALID_KYC_KEY value
     * @property {number} INVALID_WIPE_KEY=187 INVALID_WIPE_KEY value
     * @property {number} INVALID_FREEZE_KEY=188 INVALID_FREEZE_KEY value
     * @property {number} INVALID_SUPPLY_KEY=189 INVALID_SUPPLY_KEY value
     * @property {number} MISSING_TOKEN_NAME=190 MISSING_TOKEN_NAME value
     * @property {number} TOKEN_NAME_TOO_LONG=191 TOKEN_NAME_TOO_LONG value
     * @property {number} INVALID_WIPING_AMOUNT=192 INVALID_WIPING_AMOUNT value
     * @property {number} TOKEN_IS_IMMUTABLE=193 TOKEN_IS_IMMUTABLE value
     * @property {number} TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT=194 TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT value
     * @property {number} TRANSACTION_REQUIRES_ZERO_TOKEN_BALANCES=195 TRANSACTION_REQUIRES_ZERO_TOKEN_BALANCES value
     * @property {number} ACCOUNT_IS_TREASURY=196 ACCOUNT_IS_TREASURY value
     * @property {number} TOKEN_ID_REPEATED_IN_TOKEN_LIST=197 TOKEN_ID_REPEATED_IN_TOKEN_LIST value
     * @property {number} TOKEN_TRANSFER_LIST_SIZE_LIMIT_EXCEEDED=198 TOKEN_TRANSFER_LIST_SIZE_LIMIT_EXCEEDED value
     * @property {number} EMPTY_TOKEN_TRANSFER_BODY=199 EMPTY_TOKEN_TRANSFER_BODY value
     * @property {number} EMPTY_TOKEN_TRANSFER_ACCOUNT_AMOUNTS=200 EMPTY_TOKEN_TRANSFER_ACCOUNT_AMOUNTS value
     * @property {number} INVALID_SCHEDULE_ID=201 The Scheduled entity does not exist; or has now expired, been deleted, or been executed
     * @property {number} SCHEDULE_IS_IMMUTABLE=202 The Scheduled entity cannot be modified. Admin key not set
     * @property {number} INVALID_SCHEDULE_PAYER_ID=203 The provided Scheduled Payer does not exist
     * @property {number} INVALID_SCHEDULE_ACCOUNT_ID=204 The Schedule Create Transaction TransactionID account does not exist
     * @property {number} NO_NEW_VALID_SIGNATURES=205 The provided sig map did not contain any new valid signatures from required signers of the scheduled transaction
     * @property {number} UNRESOLVABLE_REQUIRED_SIGNERS=206 The required signers for a scheduled transaction cannot be resolved, for example because they do not exist or have been deleted
     * @property {number} SCHEDULED_TRANSACTION_NOT_IN_WHITELIST=207 Only whitelisted transaction types may be scheduled
     * @property {number} SOME_SIGNATURES_WERE_INVALID=208 At least one of the signatures in the provided sig map did not represent a valid signature for any required signer
     * @property {number} TRANSACTION_ID_FIELD_NOT_ALLOWED=209 The scheduled field in the TransactionID may not be set to true
     * @property {number} IDENTICAL_SCHEDULE_ALREADY_CREATED=210 A schedule already exists with the same identifying fields of an attempted ScheduleCreate (that is, all fields other than scheduledPayerAccountID)
     * @property {number} INVALID_ZERO_BYTE_IN_STRING=211 A string field in the transaction has a UTF-8 encoding with the prohibited zero byte
     * @property {number} SCHEDULE_ALREADY_DELETED=212 A schedule being signed or deleted has already been deleted
     * @property {number} SCHEDULE_ALREADY_EXECUTED=213 A schedule being signed or deleted has already been executed
     * @property {number} MESSAGE_SIZE_TOO_LARGE=214 ConsensusSubmitMessage request's message size is larger than allowed.
     * @property {number} OPERATION_REPEATED_IN_BUCKET_GROUPS=215 An operation was assigned to more than one throttle group in a given bucket
     * @property {number} BUCKET_CAPACITY_OVERFLOW=216 The capacity needed to satisfy all opsPerSec groups in a bucket overflowed a signed 8-byte integral type
     * @property {number} NODE_CAPACITY_NOT_SUFFICIENT_FOR_OPERATION=217 Given the network size in the address book, the node-level capacity for an operation would never be enough to accept a single request; usually means a bucket burstPeriod should be increased
     * @property {number} BUCKET_HAS_NO_THROTTLE_GROUPS=218 A bucket was defined without any throttle groups
     * @property {number} THROTTLE_GROUP_HAS_ZERO_OPS_PER_SEC=219 A throttle group was granted zero opsPerSec
     * @property {number} SUCCESS_BUT_MISSING_EXPECTED_OPERATION=220 The throttle definitions file was updated, but some supported operations were not assigned a bucket
     * @property {number} UNPARSEABLE_THROTTLE_DEFINITIONS=221 The new contents for the throttle definitions system file were not valid protobuf
     * @property {number} INVALID_THROTTLE_DEFINITIONS=222 The new throttle definitions system file were invalid, and no more specific error could be divined
     * @property {number} ACCOUNT_EXPIRED_AND_PENDING_REMOVAL=223 The transaction references an account which has passed its expiration without renewal funds available, and currently remains in the ledger only because of the grace period given to expired entities
     * @property {number} INVALID_TOKEN_MAX_SUPPLY=224 Invalid token max supply
     * @property {number} INVALID_TOKEN_NFT_SERIAL_NUMBER=225 Invalid token nft serial number
     * @property {number} INVALID_NFT_ID=226 Invalid nft id
     * @property {number} METADATA_TOO_LONG=227 Nft metadata is too long
     * @property {number} BATCH_SIZE_LIMIT_EXCEEDED=228 Repeated operations count exceeds the limit
     * @property {number} INVALID_QUERY_RANGE=229 The range of data to be gathered is out of the set boundaries
     * @property {number} FRACTION_DIVIDES_BY_ZERO=230 A custom fractional fee set a denominator of zero
     * @property {number} INSUFFICIENT_PAYER_BALANCE_FOR_CUSTOM_FEE=231 The transaction payer could not afford a custom fee
     * @property {number} CUSTOM_FEES_LIST_TOO_LONG=232 More than 10 custom fees were specified
     * @property {number} INVALID_CUSTOM_FEE_COLLECTOR=233 Any of the feeCollector accounts for customFees is invalid
     * @property {number} INVALID_TOKEN_ID_IN_CUSTOM_FEES=234 Any of the token Ids in customFees is invalid
     * @property {number} TOKEN_NOT_ASSOCIATED_TO_FEE_COLLECTOR=235 Any of the token Ids in customFees are not associated to feeCollector
     * @property {number} TOKEN_MAX_SUPPLY_REACHED=236 A token cannot have more units minted due to its configured supply ceiling
     * @property {number} SENDER_DOES_NOT_OWN_NFT_SERIAL_NO=237 The transaction attempted to move an NFT serial number from an account other than its owner
     * @property {number} CUSTOM_FEE_NOT_FULLY_SPECIFIED=238 A custom fee schedule entry did not specify either a fixed or fractional fee
     * @property {number} CUSTOM_FEE_MUST_BE_POSITIVE=239 Only positive fees may be assessed at this time
     * @property {number} TOKEN_HAS_NO_FEE_SCHEDULE_KEY=240 Fee schedule key is not set on token
     * @property {number} CUSTOM_FEE_OUTSIDE_NUMERIC_RANGE=241 A fractional custom fee exceeded the range of a 64-bit signed integer
     * @property {number} ROYALTY_FRACTION_CANNOT_EXCEED_ONE=242 A royalty cannot exceed the total fungible value exchanged for an NFT
     * @property {number} FRACTIONAL_FEE_MAX_AMOUNT_LESS_THAN_MIN_AMOUNT=243 Each fractional custom fee must have its maximum_amount, if specified, at least its minimum_amount
     * @property {number} CUSTOM_SCHEDULE_ALREADY_HAS_NO_FEES=244 A fee schedule update tried to clear the custom fees from a token whose fee schedule was already empty
     * @property {number} CUSTOM_FEE_DENOMINATION_MUST_BE_FUNGIBLE_COMMON=245 Only tokens of type FUNGIBLE_COMMON can be used to as fee schedule denominations
     * @property {number} CUSTOM_FRACTIONAL_FEE_ONLY_ALLOWED_FOR_FUNGIBLE_COMMON=246 Only tokens of type FUNGIBLE_COMMON can have fractional fees
     * @property {number} INVALID_CUSTOM_FEE_SCHEDULE_KEY=247 The provided custom fee schedule key was invalid
     * @property {number} INVALID_TOKEN_MINT_METADATA=248 The requested token mint metadata was invalid
     * @property {number} INVALID_TOKEN_BURN_METADATA=249 The requested token burn metadata was invalid
     * @property {number} CURRENT_TREASURY_STILL_OWNS_NFTS=250 The treasury for a unique token cannot be changed until it owns no NFTs
     * @property {number} ACCOUNT_STILL_OWNS_NFTS=251 An account cannot be dissociated from a unique token if it owns NFTs for the token
     * @property {number} TREASURY_MUST_OWN_BURNED_NFT=252 A NFT can only be burned when owned by the unique token's treasury
     * @property {number} ACCOUNT_DOES_NOT_OWN_WIPED_NFT=253 An account did not own the NFT to be wiped
     * @property {number} ACCOUNT_AMOUNT_TRANSFERS_ONLY_ALLOWED_FOR_FUNGIBLE_COMMON=254 An AccountAmount token transfers list referenced a token type other than FUNGIBLE_COMMON
     * @property {number} MAX_NFTS_IN_PRICE_REGIME_HAVE_BEEN_MINTED=255 All the NFTs allowed in the current price regime have already been minted
     * @property {number} PAYER_ACCOUNT_DELETED=256 The payer account has been marked as deleted
     * @property {number} CUSTOM_FEE_CHARGING_EXCEEDED_MAX_RECURSION_DEPTH=257 The reference chain of custom fees for a transferred token exceeded the maximum length of 2
     * @property {number} CUSTOM_FEE_CHARGING_EXCEEDED_MAX_ACCOUNT_AMOUNTS=258 More than 20 balance adjustments were to satisfy a CryptoTransfer and its implied custom fee payments
     * @property {number} INSUFFICIENT_SENDER_ACCOUNT_BALANCE_FOR_CUSTOM_FEE=259 The sender account in the token transfer transaction could not afford a custom fee
     * @property {number} SERIAL_NUMBER_LIMIT_REACHED=260 Currently no more than 4,294,967,295 NFTs may be minted for a given unique token type
     * @property {number} CUSTOM_ROYALTY_FEE_ONLY_ALLOWED_FOR_NON_FUNGIBLE_UNIQUE=261 Only tokens of type NON_FUNGIBLE_UNIQUE can have royalty fees
     * @property {number} NO_REMAINING_AUTOMATIC_ASSOCIATIONS=262 The account has reached the limit on the automatic associations count.
     * @property {number} EXISTING_AUTOMATIC_ASSOCIATIONS_EXCEED_GIVEN_LIMIT=263 Already existing automatic associations are more than the new maximum automatic associations.
     * @property {number} REQUESTED_NUM_AUTOMATIC_ASSOCIATIONS_EXCEEDS_ASSOCIATION_LIMIT=264 Cannot set the number of automatic associations for an account more than the maximum allowed
     * token associations <tt>tokens.maxPerAccount</tt>.
     * @property {number} TOKEN_IS_PAUSED=265 Token is paused. This Token cannot be a part of any kind of Transaction until unpaused.
     * @property {number} TOKEN_HAS_NO_PAUSE_KEY=266 Pause key is not set on token
     * @property {number} INVALID_PAUSE_KEY=267 The provided pause key was invalid
     * @property {number} FREEZE_UPDATE_FILE_DOES_NOT_EXIST=268 The update file in a freeze transaction body must exist.
     * @property {number} FREEZE_UPDATE_FILE_HASH_DOES_NOT_MATCH=269 The hash of the update file in a freeze transaction body must match the in-memory hash.
     * @property {number} NO_UPGRADE_HAS_BEEN_PREPARED=270 A FREEZE_UPGRADE transaction was handled with no previous update prepared.
     * @property {number} NO_FREEZE_IS_SCHEDULED=271 A FREEZE_ABORT transaction was handled with no scheduled freeze.
     * @property {number} UPDATE_FILE_HASH_CHANGED_SINCE_PREPARE_UPGRADE=272 The update file hash when handling a FREEZE_UPGRADE transaction differs from the file
     * hash at the time of handling the PREPARE_UPGRADE transaction.
     * @property {number} FREEZE_START_TIME_MUST_BE_FUTURE=273 The given freeze start time was in the (consensus) past.
     * @property {number} PREPARED_UPDATE_FILE_IS_IMMUTABLE=274 The prepared update file cannot be updated or appended until either the upgrade has
     * been completed, or a FREEZE_ABORT has been handled.
     * @property {number} FREEZE_ALREADY_SCHEDULED=275 Once a freeze is scheduled, it must be aborted before any other type of freeze can
     * can be performed.
     * @property {number} FREEZE_UPGRADE_IN_PROGRESS=276 If an NMT upgrade has been prepared, the following operation must be a FREEZE_UPGRADE.
     * (To issue a FREEZE_ONLY, submit a FREEZE_ABORT first.)
     * @property {number} UPDATE_FILE_ID_DOES_NOT_MATCH_PREPARED=277 If an NMT upgrade has been prepared, the subsequent FREEZE_UPGRADE transaction must
     * confirm the id of the file to be used in the upgrade.
     * @property {number} UPDATE_FILE_HASH_DOES_NOT_MATCH_PREPARED=278 If an NMT upgrade has been prepared, the subsequent FREEZE_UPGRADE transaction must
     * confirm the hash of the file to be used in the upgrade.
     * @property {number} CONSENSUS_GAS_EXHAUSTED=279 Consensus throttle did not allow execution of this transaction. System is throttled at
     * consensus level.
     * @property {number} REVERTED_SUCCESS=280 A precompiled contract succeeded, but was later reverted.
     * @property {number} MAX_STORAGE_IN_PRICE_REGIME_HAS_BEEN_USED=281 All contract storage allocated to the current price regime has been consumed.
     * @property {number} INVALID_ALIAS_KEY=282 An alias used in a CryptoTransfer transaction is not the serialization of a primitive Key
     * message--that is, a Key with a single Ed25519 or ECDSA(secp256k1) public key and no
     * unknown protobuf fields.
     * @property {number} UNEXPECTED_TOKEN_DECIMALS=283 A fungible token transfer expected a different number of decimals than the involved
     * type actually has.
     * @property {number} INVALID_PROXY_ACCOUNT_ID=284 [Deprecated] The proxy account id is invalid or does not exist.
     * @property {number} INVALID_TRANSFER_ACCOUNT_ID=285 The transfer account id in CryptoDelete transaction is invalid or does not exist.
     * @property {number} INVALID_FEE_COLLECTOR_ACCOUNT_ID=286 The fee collector account id in TokenFeeScheduleUpdate is invalid or does not exist.
     * @property {number} ALIAS_IS_IMMUTABLE=287 The alias already set on an account cannot be updated using CryptoUpdate transaction.
     * @property {number} SPENDER_ACCOUNT_SAME_AS_OWNER=288 An approved allowance specifies a spender account that is the same as the hbar/token
     * owner account.
     * @property {number} AMOUNT_EXCEEDS_TOKEN_MAX_SUPPLY=289 The establishment or adjustment of an approved allowance cause the token allowance
     * to exceed the token maximum supply.
     * @property {number} NEGATIVE_ALLOWANCE_AMOUNT=290 The specified amount for an approved allowance cannot be negative.
     * @property {number} CANNOT_APPROVE_FOR_ALL_FUNGIBLE_COMMON=291 [Deprecated] The approveForAll flag cannot be set for a fungible token.
     * @property {number} SPENDER_DOES_NOT_HAVE_ALLOWANCE=292 The spender does not have an existing approved allowance with the hbar/token owner.
     * @property {number} AMOUNT_EXCEEDS_ALLOWANCE=293 The transfer amount exceeds the current approved allowance for the spender account.
     * @property {number} MAX_ALLOWANCES_EXCEEDED=294 The payer account of an approveAllowances or adjustAllowance transaction is attempting
     * to go beyond the maximum allowed number of allowances.
     * @property {number} EMPTY_ALLOWANCES=295 No allowances have been specified in the approval transaction.
     * @property {number} SPENDER_ACCOUNT_REPEATED_IN_ALLOWANCES=296 [Deprecated] Spender is repeated more than once in Crypto or Token or NFT allowance lists in a single
     * CryptoApproveAllowance transaction.
     * @property {number} REPEATED_SERIAL_NUMS_IN_NFT_ALLOWANCES=297 [Deprecated] Serial numbers are repeated in nft allowance for a single spender account
     * @property {number} FUNGIBLE_TOKEN_IN_NFT_ALLOWANCES=298 Fungible common token used in NFT allowances
     * @property {number} NFT_IN_FUNGIBLE_TOKEN_ALLOWANCES=299 Non fungible token used in fungible token allowances
     * @property {number} INVALID_ALLOWANCE_OWNER_ID=300 The account id specified as the owner is invalid or does not exist.
     * @property {number} INVALID_ALLOWANCE_SPENDER_ID=301 The account id specified as the spender is invalid or does not exist.
     * @property {number} REPEATED_ALLOWANCES_TO_DELETE=302 [Deprecated] If the CryptoDeleteAllowance transaction has repeated crypto or token or Nft allowances to delete.
     * @property {number} INVALID_DELEGATING_SPENDER=303 If the account Id specified as the delegating spender is invalid or does not exist.
     * @property {number} DELEGATING_SPENDER_CANNOT_GRANT_APPROVE_FOR_ALL=304 The delegating Spender cannot grant approveForAll allowance on a NFT token type for another spender.
     * @property {number} DELEGATING_SPENDER_DOES_NOT_HAVE_APPROVE_FOR_ALL=305 The delegating Spender cannot grant allowance on a NFT serial for another spender as it doesnt not have approveForAll
     * granted on token-owner.
     * @property {number} SCHEDULE_EXPIRATION_TIME_TOO_FAR_IN_FUTURE=306 The scheduled transaction could not be created because it's expiration_time was too far in the future.
     * @property {number} SCHEDULE_EXPIRATION_TIME_MUST_BE_HIGHER_THAN_CONSENSUS_TIME=307 The scheduled transaction could not be created because it's expiration_time was less than or equal to the consensus time.
     * @property {number} SCHEDULE_FUTURE_THROTTLE_EXCEEDED=308 The scheduled transaction could not be created because it would cause throttles to be violated on the specified expiration_time.
     * @property {number} SCHEDULE_FUTURE_GAS_LIMIT_EXCEEDED=309 The scheduled transaction could not be created because it would cause the gas limit to be violated on the specified expiration_time.
     * @property {number} INVALID_ETHEREUM_TRANSACTION=310 The ethereum transaction either failed parsing or failed signature validation, or some other EthereumTransaction error not covered by another response code.
     * @property {number} WRONG_CHAIN_ID=311 EthereumTransaction was signed against a chainId that this network does not support.
     * @property {number} WRONG_NONCE=312 This transaction specified an ethereumNonce that is not the current ethereumNonce of the account.
     * @property {number} ACCESS_LIST_UNSUPPORTED=313 The ethereum transaction specified an access list, which the network does not support.
     * @property {number} SCHEDULE_PENDING_EXPIRATION=314 A schedule being signed or deleted has passed it's expiration date and is pending execution if needed and then expiration.
     * @property {number} CONTRACT_IS_TOKEN_TREASURY=315 A selfdestruct or ContractDelete targeted a contract that is a token treasury.
     * @property {number} CONTRACT_HAS_NON_ZERO_TOKEN_BALANCES=316 A selfdestruct or ContractDelete targeted a contract with non-zero token balances.
     * @property {number} CONTRACT_EXPIRED_AND_PENDING_REMOVAL=317 A contract referenced by a transaction is "detached"; that is, expired and lacking any
     * hbar funds for auto-renewal payment---but still within its post-expiry grace period.
     * @property {number} CONTRACT_HAS_NO_AUTO_RENEW_ACCOUNT=318 A ContractUpdate requested removal of a contract's auto-renew account, but that contract has
     * no auto-renew account.
     * @property {number} PERMANENT_REMOVAL_REQUIRES_SYSTEM_INITIATION=319 A delete transaction submitted via HAPI set permanent_removal=true
     * @property {number} PROXY_ACCOUNT_ID_FIELD_IS_DEPRECATED=320 PROXY_ACCOUNT_ID_FIELD_IS_DEPRECATED value
     * @property {number} SELF_STAKING_IS_NOT_ALLOWED=321 An account set the staked_account_id to itself in CryptoUpdate or ContractUpdate transactions.
     * @property {number} INVALID_STAKING_ID=322 The staking account id or staking node id given is invalid or does not exist.
     * @property {number} STAKING_NOT_ENABLED=323 Native staking, while implemented, has not yet enabled by the council.
     * @property {number} INVALID_PRNG_RANGE=324 The range provided in UtilPrng transaction is negative.
     * @property {number} MAX_ENTITIES_IN_PRICE_REGIME_HAVE_BEEN_CREATED=325 The maximum number of entities allowed in the current price regime have been created.
     * @property {number} INVALID_FULL_PREFIX_SIGNATURE_FOR_PRECOMPILE=326 The full prefix signature for precompile is not valid
     * @property {number} INSUFFICIENT_BALANCES_FOR_STORAGE_RENT=327 The combined balances of a contract and its auto-renew account (if any) did not cover
     * the rent charged for net new storage used in a transaction.
     * @property {number} MAX_CHILD_RECORDS_EXCEEDED=328 A contract transaction tried to use more than the allowed number of child records, via
     * either system contract records or internal contract creations.
     * @property {number} INSUFFICIENT_BALANCES_FOR_RENEWAL_FEES=329 The combined balances of a contract and its auto-renew account (if any) or balance of an account did not cover
     * the auto-renewal fees in a transaction.
     * @property {number} TRANSACTION_HAS_UNKNOWN_FIELDS=330 A transaction's protobuf message includes unknown fields; could mean that a client
     * expects not-yet-released functionality to be available.
     * @property {number} ACCOUNT_IS_IMMUTABLE=331 The account cannot be modified. Account's key is not set
     * @property {number} ALIAS_ALREADY_ASSIGNED=332 An alias that is assigned to an account or contract cannot be assigned to another account or contract.
     */
    proto.ResponseCodeEnum = (function () {
        const valuesById = {},
            values = Object.create(valuesById);
        values[(valuesById[0] = "OK")] = 0;
        values[(valuesById[1] = "INVALID_TRANSACTION")] = 1;
        values[(valuesById[2] = "PAYER_ACCOUNT_NOT_FOUND")] = 2;
        values[(valuesById[3] = "INVALID_NODE_ACCOUNT")] = 3;
        values[(valuesById[4] = "TRANSACTION_EXPIRED")] = 4;
        values[(valuesById[5] = "INVALID_TRANSACTION_START")] = 5;
        values[(valuesById[6] = "INVALID_TRANSACTION_DURATION")] = 6;
        values[(valuesById[7] = "INVALID_SIGNATURE")] = 7;
        values[(valuesById[8] = "MEMO_TOO_LONG")] = 8;
        values[(valuesById[9] = "INSUFFICIENT_TX_FEE")] = 9;
        values[(valuesById[10] = "INSUFFICIENT_PAYER_BALANCE")] = 10;
        values[(valuesById[11] = "DUPLICATE_TRANSACTION")] = 11;
        values[(valuesById[12] = "BUSY")] = 12;
        values[(valuesById[13] = "NOT_SUPPORTED")] = 13;
        values[(valuesById[14] = "INVALID_FILE_ID")] = 14;
        values[(valuesById[15] = "INVALID_ACCOUNT_ID")] = 15;
        values[(valuesById[16] = "INVALID_CONTRACT_ID")] = 16;
        values[(valuesById[17] = "INVALID_TRANSACTION_ID")] = 17;
        values[(valuesById[18] = "RECEIPT_NOT_FOUND")] = 18;
        values[(valuesById[19] = "RECORD_NOT_FOUND")] = 19;
        values[(valuesById[20] = "INVALID_SOLIDITY_ID")] = 20;
        values[(valuesById[21] = "UNKNOWN")] = 21;
        values[(valuesById[22] = "SUCCESS")] = 22;
        values[(valuesById[23] = "FAIL_INVALID")] = 23;
        values[(valuesById[24] = "FAIL_FEE")] = 24;
        values[(valuesById[25] = "FAIL_BALANCE")] = 25;
        values[(valuesById[26] = "KEY_REQUIRED")] = 26;
        values[(valuesById[27] = "BAD_ENCODING")] = 27;
        values[(valuesById[28] = "INSUFFICIENT_ACCOUNT_BALANCE")] = 28;
        values[(valuesById[29] = "INVALID_SOLIDITY_ADDRESS")] = 29;
        values[(valuesById[30] = "INSUFFICIENT_GAS")] = 30;
        values[(valuesById[31] = "CONTRACT_SIZE_LIMIT_EXCEEDED")] = 31;
        values[(valuesById[32] = "LOCAL_CALL_MODIFICATION_EXCEPTION")] = 32;
        values[(valuesById[33] = "CONTRACT_REVERT_EXECUTED")] = 33;
        values[(valuesById[34] = "CONTRACT_EXECUTION_EXCEPTION")] = 34;
        values[(valuesById[35] = "INVALID_RECEIVING_NODE_ACCOUNT")] = 35;
        values[(valuesById[36] = "MISSING_QUERY_HEADER")] = 36;
        values[(valuesById[37] = "ACCOUNT_UPDATE_FAILED")] = 37;
        values[(valuesById[38] = "INVALID_KEY_ENCODING")] = 38;
        values[(valuesById[39] = "NULL_SOLIDITY_ADDRESS")] = 39;
        values[(valuesById[40] = "CONTRACT_UPDATE_FAILED")] = 40;
        values[(valuesById[41] = "INVALID_QUERY_HEADER")] = 41;
        values[(valuesById[42] = "INVALID_FEE_SUBMITTED")] = 42;
        values[(valuesById[43] = "INVALID_PAYER_SIGNATURE")] = 43;
        values[(valuesById[44] = "KEY_NOT_PROVIDED")] = 44;
        values[(valuesById[45] = "INVALID_EXPIRATION_TIME")] = 45;
        values[(valuesById[46] = "NO_WACL_KEY")] = 46;
        values[(valuesById[47] = "FILE_CONTENT_EMPTY")] = 47;
        values[(valuesById[48] = "INVALID_ACCOUNT_AMOUNTS")] = 48;
        values[(valuesById[49] = "EMPTY_TRANSACTION_BODY")] = 49;
        values[(valuesById[50] = "INVALID_TRANSACTION_BODY")] = 50;
        values[(valuesById[51] = "INVALID_SIGNATURE_TYPE_MISMATCHING_KEY")] = 51;
        values[(valuesById[52] = "INVALID_SIGNATURE_COUNT_MISMATCHING_KEY")] = 52;
        values[(valuesById[53] = "EMPTY_LIVE_HASH_BODY")] = 53;
        values[(valuesById[54] = "EMPTY_LIVE_HASH")] = 54;
        values[(valuesById[55] = "EMPTY_LIVE_HASH_KEYS")] = 55;
        values[(valuesById[56] = "INVALID_LIVE_HASH_SIZE")] = 56;
        values[(valuesById[57] = "EMPTY_QUERY_BODY")] = 57;
        values[(valuesById[58] = "EMPTY_LIVE_HASH_QUERY")] = 58;
        values[(valuesById[59] = "LIVE_HASH_NOT_FOUND")] = 59;
        values[(valuesById[60] = "ACCOUNT_ID_DOES_NOT_EXIST")] = 60;
        values[(valuesById[61] = "LIVE_HASH_ALREADY_EXISTS")] = 61;
        values[(valuesById[62] = "INVALID_FILE_WACL")] = 62;
        values[(valuesById[63] = "SERIALIZATION_FAILED")] = 63;
        values[(valuesById[64] = "TRANSACTION_OVERSIZE")] = 64;
        values[(valuesById[65] = "TRANSACTION_TOO_MANY_LAYERS")] = 65;
        values[(valuesById[66] = "CONTRACT_DELETED")] = 66;
        values[(valuesById[67] = "PLATFORM_NOT_ACTIVE")] = 67;
        values[(valuesById[68] = "KEY_PREFIX_MISMATCH")] = 68;
        values[(valuesById[69] = "PLATFORM_TRANSACTION_NOT_CREATED")] = 69;
        values[(valuesById[70] = "INVALID_RENEWAL_PERIOD")] = 70;
        values[(valuesById[71] = "INVALID_PAYER_ACCOUNT_ID")] = 71;
        values[(valuesById[72] = "ACCOUNT_DELETED")] = 72;
        values[(valuesById[73] = "FILE_DELETED")] = 73;
        values[(valuesById[74] = "ACCOUNT_REPEATED_IN_ACCOUNT_AMOUNTS")] = 74;
        values[(valuesById[75] = "SETTING_NEGATIVE_ACCOUNT_BALANCE")] = 75;
        values[(valuesById[76] = "OBTAINER_REQUIRED")] = 76;
        values[(valuesById[77] = "OBTAINER_SAME_CONTRACT_ID")] = 77;
        values[(valuesById[78] = "OBTAINER_DOES_NOT_EXIST")] = 78;
        values[(valuesById[79] = "MODIFYING_IMMUTABLE_CONTRACT")] = 79;
        values[(valuesById[80] = "FILE_SYSTEM_EXCEPTION")] = 80;
        values[(valuesById[81] = "AUTORENEW_DURATION_NOT_IN_RANGE")] = 81;
        values[(valuesById[82] = "ERROR_DECODING_BYTESTRING")] = 82;
        values[(valuesById[83] = "CONTRACT_FILE_EMPTY")] = 83;
        values[(valuesById[84] = "CONTRACT_BYTECODE_EMPTY")] = 84;
        values[(valuesById[85] = "INVALID_INITIAL_BALANCE")] = 85;
        values[(valuesById[86] = "INVALID_RECEIVE_RECORD_THRESHOLD")] = 86;
        values[(valuesById[87] = "INVALID_SEND_RECORD_THRESHOLD")] = 87;
        values[(valuesById[88] = "ACCOUNT_IS_NOT_GENESIS_ACCOUNT")] = 88;
        values[(valuesById[89] = "PAYER_ACCOUNT_UNAUTHORIZED")] = 89;
        values[(valuesById[90] = "INVALID_FREEZE_TRANSACTION_BODY")] = 90;
        values[(valuesById[91] = "FREEZE_TRANSACTION_BODY_NOT_FOUND")] = 91;
        values[(valuesById[92] = "TRANSFER_LIST_SIZE_LIMIT_EXCEEDED")] = 92;
        values[(valuesById[93] = "RESULT_SIZE_LIMIT_EXCEEDED")] = 93;
        values[(valuesById[94] = "NOT_SPECIAL_ACCOUNT")] = 94;
        values[(valuesById[95] = "CONTRACT_NEGATIVE_GAS")] = 95;
        values[(valuesById[96] = "CONTRACT_NEGATIVE_VALUE")] = 96;
        values[(valuesById[97] = "INVALID_FEE_FILE")] = 97;
        values[(valuesById[98] = "INVALID_EXCHANGE_RATE_FILE")] = 98;
        values[(valuesById[99] = "INSUFFICIENT_LOCAL_CALL_GAS")] = 99;
        values[(valuesById[100] = "ENTITY_NOT_ALLOWED_TO_DELETE")] = 100;
        values[(valuesById[101] = "AUTHORIZATION_FAILED")] = 101;
        values[(valuesById[102] = "FILE_UPLOADED_PROTO_INVALID")] = 102;
        values[(valuesById[103] = "FILE_UPLOADED_PROTO_NOT_SAVED_TO_DISK")] = 103;
        values[(valuesById[104] = "FEE_SCHEDULE_FILE_PART_UPLOADED")] = 104;
        values[(valuesById[105] = "EXCHANGE_RATE_CHANGE_LIMIT_EXCEEDED")] = 105;
        values[(valuesById[106] = "MAX_CONTRACT_STORAGE_EXCEEDED")] = 106;
        values[(valuesById[107] = "TRANSFER_ACCOUNT_SAME_AS_DELETE_ACCOUNT")] = 107;
        values[(valuesById[108] = "TOTAL_LEDGER_BALANCE_INVALID")] = 108;
        values[(valuesById[110] = "EXPIRATION_REDUCTION_NOT_ALLOWED")] = 110;
        values[(valuesById[111] = "MAX_GAS_LIMIT_EXCEEDED")] = 111;
        values[(valuesById[112] = "MAX_FILE_SIZE_EXCEEDED")] = 112;
        values[(valuesById[113] = "RECEIVER_SIG_REQUIRED")] = 113;
        values[(valuesById[150] = "INVALID_TOPIC_ID")] = 150;
        values[(valuesById[155] = "INVALID_ADMIN_KEY")] = 155;
        values[(valuesById[156] = "INVALID_SUBMIT_KEY")] = 156;
        values[(valuesById[157] = "UNAUTHORIZED")] = 157;
        values[(valuesById[158] = "INVALID_TOPIC_MESSAGE")] = 158;
        values[(valuesById[159] = "INVALID_AUTORENEW_ACCOUNT")] = 159;
        values[(valuesById[160] = "AUTORENEW_ACCOUNT_NOT_ALLOWED")] = 160;
        values[(valuesById[162] = "TOPIC_EXPIRED")] = 162;
        values[(valuesById[163] = "INVALID_CHUNK_NUMBER")] = 163;
        values[(valuesById[164] = "INVALID_CHUNK_TRANSACTION_ID")] = 164;
        values[(valuesById[165] = "ACCOUNT_FROZEN_FOR_TOKEN")] = 165;
        values[(valuesById[166] = "TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED")] = 166;
        values[(valuesById[167] = "INVALID_TOKEN_ID")] = 167;
        values[(valuesById[168] = "INVALID_TOKEN_DECIMALS")] = 168;
        values[(valuesById[169] = "INVALID_TOKEN_INITIAL_SUPPLY")] = 169;
        values[(valuesById[170] = "INVALID_TREASURY_ACCOUNT_FOR_TOKEN")] = 170;
        values[(valuesById[171] = "INVALID_TOKEN_SYMBOL")] = 171;
        values[(valuesById[172] = "TOKEN_HAS_NO_FREEZE_KEY")] = 172;
        values[(valuesById[173] = "TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN")] = 173;
        values[(valuesById[174] = "MISSING_TOKEN_SYMBOL")] = 174;
        values[(valuesById[175] = "TOKEN_SYMBOL_TOO_LONG")] = 175;
        values[(valuesById[176] = "ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN")] = 176;
        values[(valuesById[177] = "TOKEN_HAS_NO_KYC_KEY")] = 177;
        values[(valuesById[178] = "INSUFFICIENT_TOKEN_BALANCE")] = 178;
        values[(valuesById[179] = "TOKEN_WAS_DELETED")] = 179;
        values[(valuesById[180] = "TOKEN_HAS_NO_SUPPLY_KEY")] = 180;
        values[(valuesById[181] = "TOKEN_HAS_NO_WIPE_KEY")] = 181;
        values[(valuesById[182] = "INVALID_TOKEN_MINT_AMOUNT")] = 182;
        values[(valuesById[183] = "INVALID_TOKEN_BURN_AMOUNT")] = 183;
        values[(valuesById[184] = "TOKEN_NOT_ASSOCIATED_TO_ACCOUNT")] = 184;
        values[(valuesById[185] = "CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT")] = 185;
        values[(valuesById[186] = "INVALID_KYC_KEY")] = 186;
        values[(valuesById[187] = "INVALID_WIPE_KEY")] = 187;
        values[(valuesById[188] = "INVALID_FREEZE_KEY")] = 188;
        values[(valuesById[189] = "INVALID_SUPPLY_KEY")] = 189;
        values[(valuesById[190] = "MISSING_TOKEN_NAME")] = 190;
        values[(valuesById[191] = "TOKEN_NAME_TOO_LONG")] = 191;
        values[(valuesById[192] = "INVALID_WIPING_AMOUNT")] = 192;
        values[(valuesById[193] = "TOKEN_IS_IMMUTABLE")] = 193;
        values[(valuesById[194] = "TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT")] = 194;
        values[(valuesById[195] = "TRANSACTION_REQUIRES_ZERO_TOKEN_BALANCES")] = 195;
        values[(valuesById[196] = "ACCOUNT_IS_TREASURY")] = 196;
        values[(valuesById[197] = "TOKEN_ID_REPEATED_IN_TOKEN_LIST")] = 197;
        values[(valuesById[198] = "TOKEN_TRANSFER_LIST_SIZE_LIMIT_EXCEEDED")] = 198;
        values[(valuesById[199] = "EMPTY_TOKEN_TRANSFER_BODY")] = 199;
        values[(valuesById[200] = "EMPTY_TOKEN_TRANSFER_ACCOUNT_AMOUNTS")] = 200;
        values[(valuesById[201] = "INVALID_SCHEDULE_ID")] = 201;
        values[(valuesById[202] = "SCHEDULE_IS_IMMUTABLE")] = 202;
        values[(valuesById[203] = "INVALID_SCHEDULE_PAYER_ID")] = 203;
        values[(valuesById[204] = "INVALID_SCHEDULE_ACCOUNT_ID")] = 204;
        values[(valuesById[205] = "NO_NEW_VALID_SIGNATURES")] = 205;
        values[(valuesById[206] = "UNRESOLVABLE_REQUIRED_SIGNERS")] = 206;
        values[(valuesById[207] = "SCHEDULED_TRANSACTION_NOT_IN_WHITELIST")] = 207;
        values[(valuesById[208] = "SOME_SIGNATURES_WERE_INVALID")] = 208;
        values[(valuesById[209] = "TRANSACTION_ID_FIELD_NOT_ALLOWED")] = 209;
        values[(valuesById[210] = "IDENTICAL_SCHEDULE_ALREADY_CREATED")] = 210;
        values[(valuesById[211] = "INVALID_ZERO_BYTE_IN_STRING")] = 211;
        values[(valuesById[212] = "SCHEDULE_ALREADY_DELETED")] = 212;
        values[(valuesById[213] = "SCHEDULE_ALREADY_EXECUTED")] = 213;
        values[(valuesById[214] = "MESSAGE_SIZE_TOO_LARGE")] = 214;
        values[(valuesById[215] = "OPERATION_REPEATED_IN_BUCKET_GROUPS")] = 215;
        values[(valuesById[216] = "BUCKET_CAPACITY_OVERFLOW")] = 216;
        values[(valuesById[217] = "NODE_CAPACITY_NOT_SUFFICIENT_FOR_OPERATION")] = 217;
        values[(valuesById[218] = "BUCKET_HAS_NO_THROTTLE_GROUPS")] = 218;
        values[(valuesById[219] = "THROTTLE_GROUP_HAS_ZERO_OPS_PER_SEC")] = 219;
        values[(valuesById[220] = "SUCCESS_BUT_MISSING_EXPECTED_OPERATION")] = 220;
        values[(valuesById[221] = "UNPARSEABLE_THROTTLE_DEFINITIONS")] = 221;
        values[(valuesById[222] = "INVALID_THROTTLE_DEFINITIONS")] = 222;
        values[(valuesById[223] = "ACCOUNT_EXPIRED_AND_PENDING_REMOVAL")] = 223;
        values[(valuesById[224] = "INVALID_TOKEN_MAX_SUPPLY")] = 224;
        values[(valuesById[225] = "INVALID_TOKEN_NFT_SERIAL_NUMBER")] = 225;
        values[(valuesById[226] = "INVALID_NFT_ID")] = 226;
        values[(valuesById[227] = "METADATA_TOO_LONG")] = 227;
        values[(valuesById[228] = "BATCH_SIZE_LIMIT_EXCEEDED")] = 228;
        values[(valuesById[229] = "INVALID_QUERY_RANGE")] = 229;
        values[(valuesById[230] = "FRACTION_DIVIDES_BY_ZERO")] = 230;
        values[(valuesById[231] = "INSUFFICIENT_PAYER_BALANCE_FOR_CUSTOM_FEE")] = 231;
        values[(valuesById[232] = "CUSTOM_FEES_LIST_TOO_LONG")] = 232;
        values[(valuesById[233] = "INVALID_CUSTOM_FEE_COLLECTOR")] = 233;
        values[(valuesById[234] = "INVALID_TOKEN_ID_IN_CUSTOM_FEES")] = 234;
        values[(valuesById[235] = "TOKEN_NOT_ASSOCIATED_TO_FEE_COLLECTOR")] = 235;
        values[(valuesById[236] = "TOKEN_MAX_SUPPLY_REACHED")] = 236;
        values[(valuesById[237] = "SENDER_DOES_NOT_OWN_NFT_SERIAL_NO")] = 237;
        values[(valuesById[238] = "CUSTOM_FEE_NOT_FULLY_SPECIFIED")] = 238;
        values[(valuesById[239] = "CUSTOM_FEE_MUST_BE_POSITIVE")] = 239;
        values[(valuesById[240] = "TOKEN_HAS_NO_FEE_SCHEDULE_KEY")] = 240;
        values[(valuesById[241] = "CUSTOM_FEE_OUTSIDE_NUMERIC_RANGE")] = 241;
        values[(valuesById[242] = "ROYALTY_FRACTION_CANNOT_EXCEED_ONE")] = 242;
        values[(valuesById[243] = "FRACTIONAL_FEE_MAX_AMOUNT_LESS_THAN_MIN_AMOUNT")] = 243;
        values[(valuesById[244] = "CUSTOM_SCHEDULE_ALREADY_HAS_NO_FEES")] = 244;
        values[(valuesById[245] = "CUSTOM_FEE_DENOMINATION_MUST_BE_FUNGIBLE_COMMON")] = 245;
        values[(valuesById[246] = "CUSTOM_FRACTIONAL_FEE_ONLY_ALLOWED_FOR_FUNGIBLE_COMMON")] = 246;
        values[(valuesById[247] = "INVALID_CUSTOM_FEE_SCHEDULE_KEY")] = 247;
        values[(valuesById[248] = "INVALID_TOKEN_MINT_METADATA")] = 248;
        values[(valuesById[249] = "INVALID_TOKEN_BURN_METADATA")] = 249;
        values[(valuesById[250] = "CURRENT_TREASURY_STILL_OWNS_NFTS")] = 250;
        values[(valuesById[251] = "ACCOUNT_STILL_OWNS_NFTS")] = 251;
        values[(valuesById[252] = "TREASURY_MUST_OWN_BURNED_NFT")] = 252;
        values[(valuesById[253] = "ACCOUNT_DOES_NOT_OWN_WIPED_NFT")] = 253;
        values[(valuesById[254] = "ACCOUNT_AMOUNT_TRANSFERS_ONLY_ALLOWED_FOR_FUNGIBLE_COMMON")] = 254;
        values[(valuesById[255] = "MAX_NFTS_IN_PRICE_REGIME_HAVE_BEEN_MINTED")] = 255;
        values[(valuesById[256] = "PAYER_ACCOUNT_DELETED")] = 256;
        values[(valuesById[257] = "CUSTOM_FEE_CHARGING_EXCEEDED_MAX_RECURSION_DEPTH")] = 257;
        values[(valuesById[258] = "CUSTOM_FEE_CHARGING_EXCEEDED_MAX_ACCOUNT_AMOUNTS")] = 258;
        values[(valuesById[259] = "INSUFFICIENT_SENDER_ACCOUNT_BALANCE_FOR_CUSTOM_FEE")] = 259;
        values[(valuesById[260] = "SERIAL_NUMBER_LIMIT_REACHED")] = 260;
        values[(valuesById[261] = "CUSTOM_ROYALTY_FEE_ONLY_ALLOWED_FOR_NON_FUNGIBLE_UNIQUE")] = 261;
        values[(valuesById[262] = "NO_REMAINING_AUTOMATIC_ASSOCIATIONS")] = 262;
        values[(valuesById[263] = "EXISTING_AUTOMATIC_ASSOCIATIONS_EXCEED_GIVEN_LIMIT")] = 263;
        values[(valuesById[264] = "REQUESTED_NUM_AUTOMATIC_ASSOCIATIONS_EXCEEDS_ASSOCIATION_LIMIT")] = 264;
        values[(valuesById[265] = "TOKEN_IS_PAUSED")] = 265;
        values[(valuesById[266] = "TOKEN_HAS_NO_PAUSE_KEY")] = 266;
        values[(valuesById[267] = "INVALID_PAUSE_KEY")] = 267;
        values[(valuesById[268] = "FREEZE_UPDATE_FILE_DOES_NOT_EXIST")] = 268;
        values[(valuesById[269] = "FREEZE_UPDATE_FILE_HASH_DOES_NOT_MATCH")] = 269;
        values[(valuesById[270] = "NO_UPGRADE_HAS_BEEN_PREPARED")] = 270;
        values[(valuesById[271] = "NO_FREEZE_IS_SCHEDULED")] = 271;
        values[(valuesById[272] = "UPDATE_FILE_HASH_CHANGED_SINCE_PREPARE_UPGRADE")] = 272;
        values[(valuesById[273] = "FREEZE_START_TIME_MUST_BE_FUTURE")] = 273;
        values[(valuesById[274] = "PREPARED_UPDATE_FILE_IS_IMMUTABLE")] = 274;
        values[(valuesById[275] = "FREEZE_ALREADY_SCHEDULED")] = 275;
        values[(valuesById[276] = "FREEZE_UPGRADE_IN_PROGRESS")] = 276;
        values[(valuesById[277] = "UPDATE_FILE_ID_DOES_NOT_MATCH_PREPARED")] = 277;
        values[(valuesById[278] = "UPDATE_FILE_HASH_DOES_NOT_MATCH_PREPARED")] = 278;
        values[(valuesById[279] = "CONSENSUS_GAS_EXHAUSTED")] = 279;
        values[(valuesById[280] = "REVERTED_SUCCESS")] = 280;
        values[(valuesById[281] = "MAX_STORAGE_IN_PRICE_REGIME_HAS_BEEN_USED")] = 281;
        values[(valuesById[282] = "INVALID_ALIAS_KEY")] = 282;
        values[(valuesById[283] = "UNEXPECTED_TOKEN_DECIMALS")] = 283;
        values[(valuesById[284] = "INVALID_PROXY_ACCOUNT_ID")] = 284;
        values[(valuesById[285] = "INVALID_TRANSFER_ACCOUNT_ID")] = 285;
        values[(valuesById[286] = "INVALID_FEE_COLLECTOR_ACCOUNT_ID")] = 286;
        values[(valuesById[287] = "ALIAS_IS_IMMUTABLE")] = 287;
        values[(valuesById[288] = "SPENDER_ACCOUNT_SAME_AS_OWNER")] = 288;
        values[(valuesById[289] = "AMOUNT_EXCEEDS_TOKEN_MAX_SUPPLY")] = 289;
        values[(valuesById[290] = "NEGATIVE_ALLOWANCE_AMOUNT")] = 290;
        values[(valuesById[291] = "CANNOT_APPROVE_FOR_ALL_FUNGIBLE_COMMON")] = 291;
        values[(valuesById[292] = "SPENDER_DOES_NOT_HAVE_ALLOWANCE")] = 292;
        values[(valuesById[293] = "AMOUNT_EXCEEDS_ALLOWANCE")] = 293;
        values[(valuesById[294] = "MAX_ALLOWANCES_EXCEEDED")] = 294;
        values[(valuesById[295] = "EMPTY_ALLOWANCES")] = 295;
        values[(valuesById[296] = "SPENDER_ACCOUNT_REPEATED_IN_ALLOWANCES")] = 296;
        values[(valuesById[297] = "REPEATED_SERIAL_NUMS_IN_NFT_ALLOWANCES")] = 297;
        values[(valuesById[298] = "FUNGIBLE_TOKEN_IN_NFT_ALLOWANCES")] = 298;
        values[(valuesById[299] = "NFT_IN_FUNGIBLE_TOKEN_ALLOWANCES")] = 299;
        values[(valuesById[300] = "INVALID_ALLOWANCE_OWNER_ID")] = 300;
        values[(valuesById[301] = "INVALID_ALLOWANCE_SPENDER_ID")] = 301;
        values[(valuesById[302] = "REPEATED_ALLOWANCES_TO_DELETE")] = 302;
        values[(valuesById[303] = "INVALID_DELEGATING_SPENDER")] = 303;
        values[(valuesById[304] = "DELEGATING_SPENDER_CANNOT_GRANT_APPROVE_FOR_ALL")] = 304;
        values[(valuesById[305] = "DELEGATING_SPENDER_DOES_NOT_HAVE_APPROVE_FOR_ALL")] = 305;
        values[(valuesById[306] = "SCHEDULE_EXPIRATION_TIME_TOO_FAR_IN_FUTURE")] = 306;
        values[(valuesById[307] = "SCHEDULE_EXPIRATION_TIME_MUST_BE_HIGHER_THAN_CONSENSUS_TIME")] = 307;
        values[(valuesById[308] = "SCHEDULE_FUTURE_THROTTLE_EXCEEDED")] = 308;
        values[(valuesById[309] = "SCHEDULE_FUTURE_GAS_LIMIT_EXCEEDED")] = 309;
        values[(valuesById[310] = "INVALID_ETHEREUM_TRANSACTION")] = 310;
        values[(valuesById[311] = "WRONG_CHAIN_ID")] = 311;
        values[(valuesById[312] = "WRONG_NONCE")] = 312;
        values[(valuesById[313] = "ACCESS_LIST_UNSUPPORTED")] = 313;
        values[(valuesById[314] = "SCHEDULE_PENDING_EXPIRATION")] = 314;
        values[(valuesById[315] = "CONTRACT_IS_TOKEN_TREASURY")] = 315;
        values[(valuesById[316] = "CONTRACT_HAS_NON_ZERO_TOKEN_BALANCES")] = 316;
        values[(valuesById[317] = "CONTRACT_EXPIRED_AND_PENDING_REMOVAL")] = 317;
        values[(valuesById[318] = "CONTRACT_HAS_NO_AUTO_RENEW_ACCOUNT")] = 318;
        values[(valuesById[319] = "PERMANENT_REMOVAL_REQUIRES_SYSTEM_INITIATION")] = 319;
        values[(valuesById[320] = "PROXY_ACCOUNT_ID_FIELD_IS_DEPRECATED")] = 320;
        values[(valuesById[321] = "SELF_STAKING_IS_NOT_ALLOWED")] = 321;
        values[(valuesById[322] = "INVALID_STAKING_ID")] = 322;
        values[(valuesById[323] = "STAKING_NOT_ENABLED")] = 323;
        values[(valuesById[324] = "INVALID_PRNG_RANGE")] = 324;
        values[(valuesById[325] = "MAX_ENTITIES_IN_PRICE_REGIME_HAVE_BEEN_CREATED")] = 325;
        values[(valuesById[326] = "INVALID_FULL_PREFIX_SIGNATURE_FOR_PRECOMPILE")] = 326;
        values[(valuesById[327] = "INSUFFICIENT_BALANCES_FOR_STORAGE_RENT")] = 327;
        values[(valuesById[328] = "MAX_CHILD_RECORDS_EXCEEDED")] = 328;
        values[(valuesById[329] = "INSUFFICIENT_BALANCES_FOR_RENEWAL_FEES")] = 329;
        values[(valuesById[330] = "TRANSACTION_HAS_UNKNOWN_FIELDS")] = 330;
        values[(valuesById[331] = "ACCOUNT_IS_IMMUTABLE")] = 331;
        values[(valuesById[332] = "ALIAS_ALREADY_ASSIGNED")] = 332;
        return values;
    })();

    proto.ConsensusTopicInfo = (function () {
        /**
         * Properties of a ConsensusTopicInfo.
         * @memberof proto
         * @interface IConsensusTopicInfo
         * @property {string|null} [memo] The memo associated with the topic (UTF-8 encoding max 100 bytes)
         * @property {Uint8Array|null} [runningHash] When a topic is created, its running hash is initialized to 48 bytes of binary zeros.
         * For each submitted message, the topic's running hash is then updated to the output
         * of a particular SHA-384 digest whose input data include the previous running hash.
         *
         * See the TransactionReceipt.proto documentation for an exact description of the
         * data included in the SHA-384 digest used for the update.
         * @property {Long|null} [sequenceNumber] Sequence number (starting at 1 for the first submitMessage) of messages on the topic.
         * @property {proto.ITimestamp|null} [expirationTime] Effective consensus timestamp at (and after) which submitMessage calls will no longer succeed on the topic
         * and the topic will expire and after AUTORENEW_GRACE_PERIOD be automatically deleted.
         * @property {proto.IKey|null} [adminKey] Access control for update/delete of the topic. Null if there is no key.
         * @property {proto.IKey|null} [submitKey] Access control for ConsensusService.submitMessage. Null if there is no key.
         * @property {proto.IDuration|null} [autoRenewPeriod] If an auto-renew account is specified, when the topic expires, its lifetime will be extended
         * by up to this duration (depending on the solvency of the auto-renew account). If the
         * auto-renew account has no funds at all, the topic will be deleted instead.
         * @property {proto.IAccountID|null} [autoRenewAccount] The account, if any, to charge for automatic renewal of the topic's lifetime upon expiry.
         * @property {Uint8Array|null} [ledgerId] The ledger ID the response was returned from; please see <a href="https://github.com/hashgraph/hedera-improvement-proposal/blob/master/HIP/hip-198.md">HIP-198</a> for the network-specific IDs.
         */

        /**
         * Constructs a new ConsensusTopicInfo.
         * @memberof proto
         * @classdesc Current state of a topic.
         * @implements IConsensusTopicInfo
         * @constructor
         * @param {proto.IConsensusTopicInfo=} [p] Properties to set
         */
        function ConsensusTopicInfo(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The memo associated with the topic (UTF-8 encoding max 100 bytes)
         * @member {string} memo
         * @memberof proto.ConsensusTopicInfo
         * @instance
         */
        ConsensusTopicInfo.prototype.memo = "";

        /**
         * When a topic is created, its running hash is initialized to 48 bytes of binary zeros.
         * For each submitted message, the topic's running hash is then updated to the output
         * of a particular SHA-384 digest whose input data include the previous running hash.
         *
         * See the TransactionReceipt.proto documentation for an exact description of the
         * data included in the SHA-384 digest used for the update.
         * @member {Uint8Array} runningHash
         * @memberof proto.ConsensusTopicInfo
         * @instance
         */
        ConsensusTopicInfo.prototype.runningHash = $util.newBuffer([]);

        /**
         * Sequence number (starting at 1 for the first submitMessage) of messages on the topic.
         * @member {Long} sequenceNumber
         * @memberof proto.ConsensusTopicInfo
         * @instance
         */
        ConsensusTopicInfo.prototype.sequenceNumber = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * Effective consensus timestamp at (and after) which submitMessage calls will no longer succeed on the topic
         * and the topic will expire and after AUTORENEW_GRACE_PERIOD be automatically deleted.
         * @member {proto.ITimestamp|null|undefined} expirationTime
         * @memberof proto.ConsensusTopicInfo
         * @instance
         */
        ConsensusTopicInfo.prototype.expirationTime = null;

        /**
         * Access control for update/delete of the topic. Null if there is no key.
         * @member {proto.IKey|null|undefined} adminKey
         * @memberof proto.ConsensusTopicInfo
         * @instance
         */
        ConsensusTopicInfo.prototype.adminKey = null;

        /**
         * Access control for ConsensusService.submitMessage. Null if there is no key.
         * @member {proto.IKey|null|undefined} submitKey
         * @memberof proto.ConsensusTopicInfo
         * @instance
         */
        ConsensusTopicInfo.prototype.submitKey = null;

        /**
         * If an auto-renew account is specified, when the topic expires, its lifetime will be extended
         * by up to this duration (depending on the solvency of the auto-renew account). If the
         * auto-renew account has no funds at all, the topic will be deleted instead.
         * @member {proto.IDuration|null|undefined} autoRenewPeriod
         * @memberof proto.ConsensusTopicInfo
         * @instance
         */
        ConsensusTopicInfo.prototype.autoRenewPeriod = null;

        /**
         * The account, if any, to charge for automatic renewal of the topic's lifetime upon expiry.
         * @member {proto.IAccountID|null|undefined} autoRenewAccount
         * @memberof proto.ConsensusTopicInfo
         * @instance
         */
        ConsensusTopicInfo.prototype.autoRenewAccount = null;

        /**
         * The ledger ID the response was returned from; please see <a href="https://github.com/hashgraph/hedera-improvement-proposal/blob/master/HIP/hip-198.md">HIP-198</a> for the network-specific IDs.
         * @member {Uint8Array} ledgerId
         * @memberof proto.ConsensusTopicInfo
         * @instance
         */
        ConsensusTopicInfo.prototype.ledgerId = $util.newBuffer([]);

        /**
         * Creates a new ConsensusTopicInfo instance using the specified properties.
         * @function create
         * @memberof proto.ConsensusTopicInfo
         * @static
         * @param {proto.IConsensusTopicInfo=} [properties] Properties to set
         * @returns {proto.ConsensusTopicInfo} ConsensusTopicInfo instance
         */
        ConsensusTopicInfo.create = function create(properties) {
            return new ConsensusTopicInfo(properties);
        };

        /**
         * Encodes the specified ConsensusTopicInfo message. Does not implicitly {@link proto.ConsensusTopicInfo.verify|verify} messages.
         * @function encode
         * @memberof proto.ConsensusTopicInfo
         * @static
         * @param {proto.IConsensusTopicInfo} m ConsensusTopicInfo message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConsensusTopicInfo.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.memo != null && Object.hasOwnProperty.call(m, "memo")) w.uint32(10).string(m.memo);
            if (m.runningHash != null && Object.hasOwnProperty.call(m, "runningHash"))
                w.uint32(18).bytes(m.runningHash);
            if (m.sequenceNumber != null && Object.hasOwnProperty.call(m, "sequenceNumber"))
                w.uint32(24).uint64(m.sequenceNumber);
            if (m.expirationTime != null && Object.hasOwnProperty.call(m, "expirationTime"))
                $root.proto.Timestamp.encode(m.expirationTime, w.uint32(34).fork()).ldelim();
            if (m.adminKey != null && Object.hasOwnProperty.call(m, "adminKey"))
                $root.proto.Key.encode(m.adminKey, w.uint32(42).fork()).ldelim();
            if (m.submitKey != null && Object.hasOwnProperty.call(m, "submitKey"))
                $root.proto.Key.encode(m.submitKey, w.uint32(50).fork()).ldelim();
            if (m.autoRenewPeriod != null && Object.hasOwnProperty.call(m, "autoRenewPeriod"))
                $root.proto.Duration.encode(m.autoRenewPeriod, w.uint32(58).fork()).ldelim();
            if (m.autoRenewAccount != null && Object.hasOwnProperty.call(m, "autoRenewAccount"))
                $root.proto.AccountID.encode(m.autoRenewAccount, w.uint32(66).fork()).ldelim();
            if (m.ledgerId != null && Object.hasOwnProperty.call(m, "ledgerId")) w.uint32(74).bytes(m.ledgerId);
            return w;
        };

        /**
         * Decodes a ConsensusTopicInfo message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ConsensusTopicInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ConsensusTopicInfo} ConsensusTopicInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConsensusTopicInfo.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.ConsensusTopicInfo();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.memo = r.string();
                        break;
                    }
                    case 2: {
                        m.runningHash = r.bytes();
                        break;
                    }
                    case 3: {
                        m.sequenceNumber = r.uint64();
                        break;
                    }
                    case 4: {
                        m.expirationTime = $root.proto.Timestamp.decode(r, r.uint32());
                        break;
                    }
                    case 5: {
                        m.adminKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                    case 6: {
                        m.submitKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                    case 7: {
                        m.autoRenewPeriod = $root.proto.Duration.decode(r, r.uint32());
                        break;
                    }
                    case 8: {
                        m.autoRenewAccount = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    case 9: {
                        m.ledgerId = r.bytes();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ConsensusTopicInfo
         * @function getTypeUrl
         * @memberof proto.ConsensusTopicInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ConsensusTopicInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ConsensusTopicInfo";
        };

        return ConsensusTopicInfo;
    })();

    proto.ConsensusService = (function () {
        /**
         * Constructs a new ConsensusService service.
         * @memberof proto
         * @classdesc The Consensus Service provides the ability for Hedera Hashgraph to provide aBFT consensus as to
         * the order and validity of messages submitted to a *topic*, as well as a *consensus timestamp* for
         * those messages.
         *
         * Automatic renewal can be configured via an autoRenewAccount.
         * Any time an autoRenewAccount is added to a topic, that createTopic/updateTopic transaction must
         * be signed by the autoRenewAccount.
         *
         * The autoRenewPeriod on an account must currently be set a value in createTopic between
         * MIN_AUTORENEW_PERIOD (6999999 seconds) and MAX_AUTORENEW_PERIOD (8000001 seconds). During
         * creation this sets the initial expirationTime of the topic (see more below).
         *
         * If no adminKey is on a topic, there may not be an autoRenewAccount on the topic, deleteTopic is
         * not allowed, and the only change allowed via an updateTopic is to extend the expirationTime.
         *
         * If an adminKey is on a topic, every updateTopic and deleteTopic transaction must be signed by the
         * adminKey, except for updateTopics which only extend the topic's expirationTime (no adminKey
         * authorization required).
         *
         * If an updateTopic modifies the adminKey of a topic, the transaction signatures on the updateTopic
         * must fulfill both the pre-update and post-update adminKey signature requirements.
         *
         * Mirrornet ConsensusService may be used to subscribe to changes on the topic, including changes to
         * the topic definition and the consensus ordering and timestamp of submitted messages.
         *
         * Until autoRenew functionality is supported by HAPI, the topic will not expire, the
         * autoRenewAccount will not be charged, and the topic will not automatically be deleted.
         *
         * Once autoRenew functionality is supported by HAPI:
         *
         * 1. Once the expirationTime is encountered, if an autoRenewAccount is configured on the topic, the
         * account will be charged automatically at the expirationTime, to extend the expirationTime of the
         * topic up to the topic's autoRenewPeriod (or as much extension as the account's balance will
         * supply).
         *
         * 2. If the topic expires and is not automatically renewed, the topic will enter the EXPIRED state.
         * All transactions on the topic will fail with TOPIC_EXPIRED, except an updateTopic() call that
         * modifies only the expirationTime.  getTopicInfo() will succeed. This state will be available for
         * a AUTORENEW_GRACE_PERIOD grace period (7 days).
         *
         * 3. After the grace period, if the topic's expirationTime is not extended, the topic will be
         * automatically deleted and no transactions or queries on the topic will succeed after that point.
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function ConsensusService(rpcImpl, requestDelimited, responseDelimited) {
            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (ConsensusService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = ConsensusService;

        /**
         * Creates new ConsensusService service using the specified rpc implementation.
         * @function create
         * @memberof proto.ConsensusService
         * @static
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         * @returns {ConsensusService} RPC service. Useful where requests and/or responses are streamed.
         */
        ConsensusService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
            return new this(rpcImpl, requestDelimited, responseDelimited);
        };

        /**
         * Callback as used by {@link proto.ConsensusService#createTopic}.
         * @memberof proto.ConsensusService
         * @typedef createTopicCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Create a topic to be used for consensus.
         * If an autoRenewAccount is specified, that account must also sign this transaction.
         * If an adminKey is specified, the adminKey must sign the transaction.
         * On success, the resulting TransactionReceipt contains the newly created TopicId.
         * Request is [ConsensusCreateTopicTransactionBody](#proto.ConsensusCreateTopicTransactionBody)
         * @function createTopic
         * @memberof proto.ConsensusService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.ConsensusService.createTopicCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (ConsensusService.prototype.createTopic = function createTopic(request, callback) {
                return this.rpcCall(
                    createTopic,
                    $root.proto.Transaction,
                    $root.proto.TransactionResponse,
                    request,
                    callback
                );
            }),
            "name",
            { value: "createTopic" }
        );

        /**
         * Create a topic to be used for consensus.
         * If an autoRenewAccount is specified, that account must also sign this transaction.
         * If an adminKey is specified, the adminKey must sign the transaction.
         * On success, the resulting TransactionReceipt contains the newly created TopicId.
         * Request is [ConsensusCreateTopicTransactionBody](#proto.ConsensusCreateTopicTransactionBody)
         * @function createTopic
         * @memberof proto.ConsensusService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.ConsensusService#updateTopic}.
         * @memberof proto.ConsensusService
         * @typedef updateTopicCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Update a topic.
         * If there is no adminKey, the only authorized update (available to anyone) is to extend the expirationTime.
         * Otherwise transaction must be signed by the adminKey.
         * If an adminKey is updated, the transaction must be signed by the pre-update adminKey and post-update adminKey.
         * If a new autoRenewAccount is specified (not just being removed), that account must also sign the transaction.
         * Request is [ConsensusUpdateTopicTransactionBody](#proto.ConsensusUpdateTopicTransactionBody)
         * @function updateTopic
         * @memberof proto.ConsensusService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.ConsensusService.updateTopicCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (ConsensusService.prototype.updateTopic = function updateTopic(request, callback) {
                return this.rpcCall(
                    updateTopic,
                    $root.proto.Transaction,
                    $root.proto.TransactionResponse,
                    request,
                    callback
                );
            }),
            "name",
            { value: "updateTopic" }
        );

        /**
         * Update a topic.
         * If there is no adminKey, the only authorized update (available to anyone) is to extend the expirationTime.
         * Otherwise transaction must be signed by the adminKey.
         * If an adminKey is updated, the transaction must be signed by the pre-update adminKey and post-update adminKey.
         * If a new autoRenewAccount is specified (not just being removed), that account must also sign the transaction.
         * Request is [ConsensusUpdateTopicTransactionBody](#proto.ConsensusUpdateTopicTransactionBody)
         * @function updateTopic
         * @memberof proto.ConsensusService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.ConsensusService#deleteTopic}.
         * @memberof proto.ConsensusService
         * @typedef deleteTopicCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Delete a topic. No more transactions or queries on the topic (via HAPI) will succeed.
         * If an adminKey is set, this transaction must be signed by that key.
         * If there is no adminKey, this transaction will fail UNAUTHORIZED.
         * Request is [ConsensusDeleteTopicTransactionBody](#proto.ConsensusDeleteTopicTransactionBody)
         * @function deleteTopic
         * @memberof proto.ConsensusService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.ConsensusService.deleteTopicCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (ConsensusService.prototype.deleteTopic = function deleteTopic(request, callback) {
                return this.rpcCall(
                    deleteTopic,
                    $root.proto.Transaction,
                    $root.proto.TransactionResponse,
                    request,
                    callback
                );
            }),
            "name",
            { value: "deleteTopic" }
        );

        /**
         * Delete a topic. No more transactions or queries on the topic (via HAPI) will succeed.
         * If an adminKey is set, this transaction must be signed by that key.
         * If there is no adminKey, this transaction will fail UNAUTHORIZED.
         * Request is [ConsensusDeleteTopicTransactionBody](#proto.ConsensusDeleteTopicTransactionBody)
         * @function deleteTopic
         * @memberof proto.ConsensusService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.ConsensusService#getTopicInfo}.
         * @memberof proto.ConsensusService
         * @typedef getTopicInfoCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.Response} [response] Response
         */

        /**
         * Retrieve the latest state of a topic. This method is unrestricted and allowed on any topic by any payer account.
         * Deleted accounts will not be returned.
         * Request is [ConsensusGetTopicInfoQuery](#proto.ConsensusGetTopicInfoQuery)
         * Response is [ConsensusGetTopicInfoResponse](#proto.ConsensusGetTopicInfoResponse)
         * @function getTopicInfo
         * @memberof proto.ConsensusService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @param {proto.ConsensusService.getTopicInfoCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (ConsensusService.prototype.getTopicInfo = function getTopicInfo(request, callback) {
                return this.rpcCall(getTopicInfo, $root.proto.Query, $root.proto.Response, request, callback);
            }),
            "name",
            { value: "getTopicInfo" }
        );

        /**
         * Retrieve the latest state of a topic. This method is unrestricted and allowed on any topic by any payer account.
         * Deleted accounts will not be returned.
         * Request is [ConsensusGetTopicInfoQuery](#proto.ConsensusGetTopicInfoQuery)
         * Response is [ConsensusGetTopicInfoResponse](#proto.ConsensusGetTopicInfoResponse)
         * @function getTopicInfo
         * @memberof proto.ConsensusService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @returns {Promise<proto.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.ConsensusService#submitMessage}.
         * @memberof proto.ConsensusService
         * @typedef submitMessageCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Submit a message for consensus.
         * Valid and authorized messages on valid topics will be ordered by the consensus service, gossipped to the
         * mirror net, and published (in order) to all subscribers (from the mirror net) on this topic.
         * The submitKey (if any) must sign this transaction.
         * On success, the resulting TransactionReceipt contains the topic's updated topicSequenceNumber and
         * topicRunningHash.
         * Request is [ConsensusSubmitMessageTransactionBody](#proto.ConsensusSubmitMessageTransactionBody)
         * @function submitMessage
         * @memberof proto.ConsensusService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.ConsensusService.submitMessageCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (ConsensusService.prototype.submitMessage = function submitMessage(request, callback) {
                return this.rpcCall(
                    submitMessage,
                    $root.proto.Transaction,
                    $root.proto.TransactionResponse,
                    request,
                    callback
                );
            }),
            "name",
            { value: "submitMessage" }
        );

        /**
         * Submit a message for consensus.
         * Valid and authorized messages on valid topics will be ordered by the consensus service, gossipped to the
         * mirror net, and published (in order) to all subscribers (from the mirror net) on this topic.
         * The submitKey (if any) must sign this transaction.
         * On success, the resulting TransactionReceipt contains the topic's updated topicSequenceNumber and
         * topicRunningHash.
         * Request is [ConsensusSubmitMessageTransactionBody](#proto.ConsensusSubmitMessageTransactionBody)
         * @function submitMessage
         * @memberof proto.ConsensusService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        return ConsensusService;
    })();

    proto.Query = (function () {
        /**
         * Properties of a Query.
         * @memberof proto
         * @interface IQuery
         * @property {proto.IGetByKeyQuery|null} [getByKey] Get all entities associated with a given key
         * @property {proto.IGetBySolidityIDQuery|null} [getBySolidityID] Get the IDs in the format used in transactions, given the format used in Solidity
         * @property {proto.IContractCallLocalQuery|null} [contractCallLocal] Call a function of a smart contract instance
         * @property {proto.IContractGetInfoQuery|null} [contractGetInfo] Get information about a smart contract instance
         * @property {proto.IContractGetBytecodeQuery|null} [contractGetBytecode] Get runtime code used by a smart contract instance
         * @property {proto.IContractGetRecordsQuery|null} [ContractGetRecords] Get Records of the contract instance
         * @property {proto.ICryptoGetAccountBalanceQuery|null} [cryptogetAccountBalance] Get the current balance in a cryptocurrency account
         * @property {proto.ICryptoGetAccountRecordsQuery|null} [cryptoGetAccountRecords] Get all the records that currently exist for transactions involving an account
         * @property {proto.ICryptoGetInfoQuery|null} [cryptoGetInfo] Get all information about an account
         * @property {proto.ICryptoGetLiveHashQuery|null} [cryptoGetLiveHash] Get a single livehash from a single account, if present
         * @property {proto.ICryptoGetStakersQuery|null} [cryptoGetProxyStakers] Get all the accounts that proxy stake to a given account, and how much they proxy stake
         * (not yet implemented in the current API)
         * @property {proto.IFileGetContentsQuery|null} [fileGetContents] Get the contents of a file (the bytes stored in it)
         * @property {proto.IFileGetInfoQuery|null} [fileGetInfo] Get information about a file, such as its expiration date
         * @property {proto.ITransactionGetReceiptQuery|null} [transactionGetReceipt] Get a receipt for a transaction (lasts 180 seconds)
         * @property {proto.ITransactionGetRecordQuery|null} [transactionGetRecord] Get a record for a transaction
         * @property {proto.ITransactionGetFastRecordQuery|null} [transactionGetFastRecord] Get a record for a transaction (lasts 180 seconds)
         * @property {proto.IConsensusGetTopicInfoQuery|null} [consensusGetTopicInfo] Get the parameters of and state of a consensus topic.
         * @property {proto.INetworkGetVersionInfoQuery|null} [networkGetVersionInfo] Get the versions of the HAPI protobuf and Hedera Services software deployed on the
         * responding node.
         * @property {proto.ITokenGetInfoQuery|null} [tokenGetInfo] Get all information about a token
         * @property {proto.IScheduleGetInfoQuery|null} [scheduleGetInfo] Get all information about a scheduled entity
         * @property {proto.ITokenGetAccountNftInfosQuery|null} [tokenGetAccountNftInfos] Get a list of NFTs associated with the account
         * @property {proto.ITokenGetNftInfoQuery|null} [tokenGetNftInfo] Get all information about a NFT
         * @property {proto.ITokenGetNftInfosQuery|null} [tokenGetNftInfos] Get a list of NFTs for the token
         * @property {proto.INetworkGetExecutionTimeQuery|null} [networkGetExecutionTime] Gets <tt>handleTransaction</tt> times for one or more "sufficiently recent" TransactionIDs
         * @property {proto.IGetAccountDetailsQuery|null} [accountDetails] Gets all information about an account including allowances granted by the account
         */

        /**
         * Constructs a new Query.
         * @memberof proto
         * @classdesc A single query, which is sent from the client to a node. This includes all possible queries. Each
         * Query should not have more than 50 levels.
         * @implements IQuery
         * @constructor
         * @param {proto.IQuery=} [p] Properties to set
         */
        function Query(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * Get all entities associated with a given key
         * @member {proto.IGetByKeyQuery|null|undefined} getByKey
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.getByKey = null;

        /**
         * Get the IDs in the format used in transactions, given the format used in Solidity
         * @member {proto.IGetBySolidityIDQuery|null|undefined} getBySolidityID
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.getBySolidityID = null;

        /**
         * Call a function of a smart contract instance
         * @member {proto.IContractCallLocalQuery|null|undefined} contractCallLocal
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.contractCallLocal = null;

        /**
         * Get information about a smart contract instance
         * @member {proto.IContractGetInfoQuery|null|undefined} contractGetInfo
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.contractGetInfo = null;

        /**
         * Get runtime code used by a smart contract instance
         * @member {proto.IContractGetBytecodeQuery|null|undefined} contractGetBytecode
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.contractGetBytecode = null;

        /**
         * Get Records of the contract instance
         * @member {proto.IContractGetRecordsQuery|null|undefined} ContractGetRecords
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.ContractGetRecords = null;

        /**
         * Get the current balance in a cryptocurrency account
         * @member {proto.ICryptoGetAccountBalanceQuery|null|undefined} cryptogetAccountBalance
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.cryptogetAccountBalance = null;

        /**
         * Get all the records that currently exist for transactions involving an account
         * @member {proto.ICryptoGetAccountRecordsQuery|null|undefined} cryptoGetAccountRecords
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.cryptoGetAccountRecords = null;

        /**
         * Get all information about an account
         * @member {proto.ICryptoGetInfoQuery|null|undefined} cryptoGetInfo
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.cryptoGetInfo = null;

        /**
         * Get a single livehash from a single account, if present
         * @member {proto.ICryptoGetLiveHashQuery|null|undefined} cryptoGetLiveHash
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.cryptoGetLiveHash = null;

        /**
         * Get all the accounts that proxy stake to a given account, and how much they proxy stake
         * (not yet implemented in the current API)
         * @member {proto.ICryptoGetStakersQuery|null|undefined} cryptoGetProxyStakers
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.cryptoGetProxyStakers = null;

        /**
         * Get the contents of a file (the bytes stored in it)
         * @member {proto.IFileGetContentsQuery|null|undefined} fileGetContents
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.fileGetContents = null;

        /**
         * Get information about a file, such as its expiration date
         * @member {proto.IFileGetInfoQuery|null|undefined} fileGetInfo
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.fileGetInfo = null;

        /**
         * Get a receipt for a transaction (lasts 180 seconds)
         * @member {proto.ITransactionGetReceiptQuery|null|undefined} transactionGetReceipt
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.transactionGetReceipt = null;

        /**
         * Get a record for a transaction
         * @member {proto.ITransactionGetRecordQuery|null|undefined} transactionGetRecord
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.transactionGetRecord = null;

        /**
         * Get a record for a transaction (lasts 180 seconds)
         * @member {proto.ITransactionGetFastRecordQuery|null|undefined} transactionGetFastRecord
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.transactionGetFastRecord = null;

        /**
         * Get the parameters of and state of a consensus topic.
         * @member {proto.IConsensusGetTopicInfoQuery|null|undefined} consensusGetTopicInfo
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.consensusGetTopicInfo = null;

        /**
         * Get the versions of the HAPI protobuf and Hedera Services software deployed on the
         * responding node.
         * @member {proto.INetworkGetVersionInfoQuery|null|undefined} networkGetVersionInfo
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.networkGetVersionInfo = null;

        /**
         * Get all information about a token
         * @member {proto.ITokenGetInfoQuery|null|undefined} tokenGetInfo
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.tokenGetInfo = null;

        /**
         * Get all information about a scheduled entity
         * @member {proto.IScheduleGetInfoQuery|null|undefined} scheduleGetInfo
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.scheduleGetInfo = null;

        /**
         * Get a list of NFTs associated with the account
         * @member {proto.ITokenGetAccountNftInfosQuery|null|undefined} tokenGetAccountNftInfos
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.tokenGetAccountNftInfos = null;

        /**
         * Get all information about a NFT
         * @member {proto.ITokenGetNftInfoQuery|null|undefined} tokenGetNftInfo
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.tokenGetNftInfo = null;

        /**
         * Get a list of NFTs for the token
         * @member {proto.ITokenGetNftInfosQuery|null|undefined} tokenGetNftInfos
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.tokenGetNftInfos = null;

        /**
         * Gets <tt>handleTransaction</tt> times for one or more "sufficiently recent" TransactionIDs
         * @member {proto.INetworkGetExecutionTimeQuery|null|undefined} networkGetExecutionTime
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.networkGetExecutionTime = null;

        /**
         * Gets all information about an account including allowances granted by the account
         * @member {proto.IGetAccountDetailsQuery|null|undefined} accountDetails
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.accountDetails = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * Query query.
         * @member {"getByKey"|"getBySolidityID"|"contractCallLocal"|"contractGetInfo"|"contractGetBytecode"|"ContractGetRecords"|"cryptogetAccountBalance"|"cryptoGetAccountRecords"|"cryptoGetInfo"|"cryptoGetLiveHash"|"cryptoGetProxyStakers"|"fileGetContents"|"fileGetInfo"|"transactionGetReceipt"|"transactionGetRecord"|"transactionGetFastRecord"|"consensusGetTopicInfo"|"networkGetVersionInfo"|"tokenGetInfo"|"scheduleGetInfo"|"tokenGetAccountNftInfos"|"tokenGetNftInfo"|"tokenGetNftInfos"|"networkGetExecutionTime"|"accountDetails"|undefined} query
         * @memberof proto.Query
         * @instance
         */
        Object.defineProperty(Query.prototype, "query", {
            get: $util.oneOfGetter(
                ($oneOfFields = [
                    "getByKey",
                    "getBySolidityID",
                    "contractCallLocal",
                    "contractGetInfo",
                    "contractGetBytecode",
                    "ContractGetRecords",
                    "cryptogetAccountBalance",
                    "cryptoGetAccountRecords",
                    "cryptoGetInfo",
                    "cryptoGetLiveHash",
                    "cryptoGetProxyStakers",
                    "fileGetContents",
                    "fileGetInfo",
                    "transactionGetReceipt",
                    "transactionGetRecord",
                    "transactionGetFastRecord",
                    "consensusGetTopicInfo",
                    "networkGetVersionInfo",
                    "tokenGetInfo",
                    "scheduleGetInfo",
                    "tokenGetAccountNftInfos",
                    "tokenGetNftInfo",
                    "tokenGetNftInfos",
                    "networkGetExecutionTime",
                    "accountDetails",
                ])
            ),
            set: $util.oneOfSetter($oneOfFields),
        });

        /**
         * Creates a new Query instance using the specified properties.
         * @function create
         * @memberof proto.Query
         * @static
         * @param {proto.IQuery=} [properties] Properties to set
         * @returns {proto.Query} Query instance
         */
        Query.create = function create(properties) {
            return new Query(properties);
        };

        /**
         * Encodes the specified Query message. Does not implicitly {@link proto.Query.verify|verify} messages.
         * @function encode
         * @memberof proto.Query
         * @static
         * @param {proto.IQuery} m Query message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Query.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.getByKey != null && Object.hasOwnProperty.call(m, "getByKey"))
                $root.proto.GetByKeyQuery.encode(m.getByKey, w.uint32(10).fork()).ldelim();
            if (m.getBySolidityID != null && Object.hasOwnProperty.call(m, "getBySolidityID"))
                $root.proto.GetBySolidityIDQuery.encode(m.getBySolidityID, w.uint32(18).fork()).ldelim();
            if (m.contractCallLocal != null && Object.hasOwnProperty.call(m, "contractCallLocal"))
                $root.proto.ContractCallLocalQuery.encode(m.contractCallLocal, w.uint32(26).fork()).ldelim();
            if (m.contractGetInfo != null && Object.hasOwnProperty.call(m, "contractGetInfo"))
                $root.proto.ContractGetInfoQuery.encode(m.contractGetInfo, w.uint32(34).fork()).ldelim();
            if (m.contractGetBytecode != null && Object.hasOwnProperty.call(m, "contractGetBytecode"))
                $root.proto.ContractGetBytecodeQuery.encode(m.contractGetBytecode, w.uint32(42).fork()).ldelim();
            if (m.ContractGetRecords != null && Object.hasOwnProperty.call(m, "ContractGetRecords"))
                $root.proto.ContractGetRecordsQuery.encode(m.ContractGetRecords, w.uint32(50).fork()).ldelim();
            if (m.cryptogetAccountBalance != null && Object.hasOwnProperty.call(m, "cryptogetAccountBalance"))
                $root.proto.CryptoGetAccountBalanceQuery.encode(
                    m.cryptogetAccountBalance,
                    w.uint32(58).fork()
                ).ldelim();
            if (m.cryptoGetAccountRecords != null && Object.hasOwnProperty.call(m, "cryptoGetAccountRecords"))
                $root.proto.CryptoGetAccountRecordsQuery.encode(
                    m.cryptoGetAccountRecords,
                    w.uint32(66).fork()
                ).ldelim();
            if (m.cryptoGetInfo != null && Object.hasOwnProperty.call(m, "cryptoGetInfo"))
                $root.proto.CryptoGetInfoQuery.encode(m.cryptoGetInfo, w.uint32(74).fork()).ldelim();
            if (m.cryptoGetLiveHash != null && Object.hasOwnProperty.call(m, "cryptoGetLiveHash"))
                $root.proto.CryptoGetLiveHashQuery.encode(m.cryptoGetLiveHash, w.uint32(82).fork()).ldelim();
            if (m.cryptoGetProxyStakers != null && Object.hasOwnProperty.call(m, "cryptoGetProxyStakers"))
                $root.proto.CryptoGetStakersQuery.encode(m.cryptoGetProxyStakers, w.uint32(90).fork()).ldelim();
            if (m.fileGetContents != null && Object.hasOwnProperty.call(m, "fileGetContents"))
                $root.proto.FileGetContentsQuery.encode(m.fileGetContents, w.uint32(98).fork()).ldelim();
            if (m.fileGetInfo != null && Object.hasOwnProperty.call(m, "fileGetInfo"))
                $root.proto.FileGetInfoQuery.encode(m.fileGetInfo, w.uint32(106).fork()).ldelim();
            if (m.transactionGetReceipt != null && Object.hasOwnProperty.call(m, "transactionGetReceipt"))
                $root.proto.TransactionGetReceiptQuery.encode(m.transactionGetReceipt, w.uint32(114).fork()).ldelim();
            if (m.transactionGetRecord != null && Object.hasOwnProperty.call(m, "transactionGetRecord"))
                $root.proto.TransactionGetRecordQuery.encode(m.transactionGetRecord, w.uint32(122).fork()).ldelim();
            if (m.transactionGetFastRecord != null && Object.hasOwnProperty.call(m, "transactionGetFastRecord"))
                $root.proto.TransactionGetFastRecordQuery.encode(
                    m.transactionGetFastRecord,
                    w.uint32(130).fork()
                ).ldelim();
            if (m.consensusGetTopicInfo != null && Object.hasOwnProperty.call(m, "consensusGetTopicInfo"))
                $root.proto.ConsensusGetTopicInfoQuery.encode(m.consensusGetTopicInfo, w.uint32(402).fork()).ldelim();
            if (m.networkGetVersionInfo != null && Object.hasOwnProperty.call(m, "networkGetVersionInfo"))
                $root.proto.NetworkGetVersionInfoQuery.encode(m.networkGetVersionInfo, w.uint32(410).fork()).ldelim();
            if (m.tokenGetInfo != null && Object.hasOwnProperty.call(m, "tokenGetInfo"))
                $root.proto.TokenGetInfoQuery.encode(m.tokenGetInfo, w.uint32(418).fork()).ldelim();
            if (m.scheduleGetInfo != null && Object.hasOwnProperty.call(m, "scheduleGetInfo"))
                $root.proto.ScheduleGetInfoQuery.encode(m.scheduleGetInfo, w.uint32(426).fork()).ldelim();
            if (m.tokenGetAccountNftInfos != null && Object.hasOwnProperty.call(m, "tokenGetAccountNftInfos"))
                $root.proto.TokenGetAccountNftInfosQuery.encode(
                    m.tokenGetAccountNftInfos,
                    w.uint32(434).fork()
                ).ldelim();
            if (m.tokenGetNftInfo != null && Object.hasOwnProperty.call(m, "tokenGetNftInfo"))
                $root.proto.TokenGetNftInfoQuery.encode(m.tokenGetNftInfo, w.uint32(442).fork()).ldelim();
            if (m.tokenGetNftInfos != null && Object.hasOwnProperty.call(m, "tokenGetNftInfos"))
                $root.proto.TokenGetNftInfosQuery.encode(m.tokenGetNftInfos, w.uint32(450).fork()).ldelim();
            if (m.networkGetExecutionTime != null && Object.hasOwnProperty.call(m, "networkGetExecutionTime"))
                $root.proto.NetworkGetExecutionTimeQuery.encode(
                    m.networkGetExecutionTime,
                    w.uint32(458).fork()
                ).ldelim();
            if (m.accountDetails != null && Object.hasOwnProperty.call(m, "accountDetails"))
                $root.proto.GetAccountDetailsQuery.encode(m.accountDetails, w.uint32(466).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a Query message from the specified reader or buffer.
         * @function decode
         * @memberof proto.Query
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.Query} Query
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Query.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.Query();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.getByKey = $root.proto.GetByKeyQuery.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.getBySolidityID = $root.proto.GetBySolidityIDQuery.decode(r, r.uint32());
                        break;
                    }
                    case 3: {
                        m.contractCallLocal = $root.proto.ContractCallLocalQuery.decode(r, r.uint32());
                        break;
                    }
                    case 4: {
                        m.contractGetInfo = $root.proto.ContractGetInfoQuery.decode(r, r.uint32());
                        break;
                    }
                    case 5: {
                        m.contractGetBytecode = $root.proto.ContractGetBytecodeQuery.decode(r, r.uint32());
                        break;
                    }
                    case 6: {
                        m.ContractGetRecords = $root.proto.ContractGetRecordsQuery.decode(r, r.uint32());
                        break;
                    }
                    case 7: {
                        m.cryptogetAccountBalance = $root.proto.CryptoGetAccountBalanceQuery.decode(r, r.uint32());
                        break;
                    }
                    case 8: {
                        m.cryptoGetAccountRecords = $root.proto.CryptoGetAccountRecordsQuery.decode(r, r.uint32());
                        break;
                    }
                    case 9: {
                        m.cryptoGetInfo = $root.proto.CryptoGetInfoQuery.decode(r, r.uint32());
                        break;
                    }
                    case 10: {
                        m.cryptoGetLiveHash = $root.proto.CryptoGetLiveHashQuery.decode(r, r.uint32());
                        break;
                    }
                    case 11: {
                        m.cryptoGetProxyStakers = $root.proto.CryptoGetStakersQuery.decode(r, r.uint32());
                        break;
                    }
                    case 12: {
                        m.fileGetContents = $root.proto.FileGetContentsQuery.decode(r, r.uint32());
                        break;
                    }
                    case 13: {
                        m.fileGetInfo = $root.proto.FileGetInfoQuery.decode(r, r.uint32());
                        break;
                    }
                    case 14: {
                        m.transactionGetReceipt = $root.proto.TransactionGetReceiptQuery.decode(r, r.uint32());
                        break;
                    }
                    case 15: {
                        m.transactionGetRecord = $root.proto.TransactionGetRecordQuery.decode(r, r.uint32());
                        break;
                    }
                    case 16: {
                        m.transactionGetFastRecord = $root.proto.TransactionGetFastRecordQuery.decode(r, r.uint32());
                        break;
                    }
                    case 50: {
                        m.consensusGetTopicInfo = $root.proto.ConsensusGetTopicInfoQuery.decode(r, r.uint32());
                        break;
                    }
                    case 51: {
                        m.networkGetVersionInfo = $root.proto.NetworkGetVersionInfoQuery.decode(r, r.uint32());
                        break;
                    }
                    case 52: {
                        m.tokenGetInfo = $root.proto.TokenGetInfoQuery.decode(r, r.uint32());
                        break;
                    }
                    case 53: {
                        m.scheduleGetInfo = $root.proto.ScheduleGetInfoQuery.decode(r, r.uint32());
                        break;
                    }
                    case 54: {
                        m.tokenGetAccountNftInfos = $root.proto.TokenGetAccountNftInfosQuery.decode(r, r.uint32());
                        break;
                    }
                    case 55: {
                        m.tokenGetNftInfo = $root.proto.TokenGetNftInfoQuery.decode(r, r.uint32());
                        break;
                    }
                    case 56: {
                        m.tokenGetNftInfos = $root.proto.TokenGetNftInfosQuery.decode(r, r.uint32());
                        break;
                    }
                    case 57: {
                        m.networkGetExecutionTime = $root.proto.NetworkGetExecutionTimeQuery.decode(r, r.uint32());
                        break;
                    }
                    case 58: {
                        m.accountDetails = $root.proto.GetAccountDetailsQuery.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for Query
         * @function getTypeUrl
         * @memberof proto.Query
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Query.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.Query";
        };

        return Query;
    })();

    proto.GetByKeyQuery = (function () {
        /**
         * Properties of a GetByKeyQuery.
         * @memberof proto
         * @interface IGetByKeyQuery
         * @property {proto.IQueryHeader|null} [header] Standard info sent from client to node, including the signed payment, and what kind of
         * response is requested (cost, state proof, both, or neither).
         * @property {proto.IKey|null} [key] The key to search for. It must not contain a contractID nor a ThresholdSignature.
         */

        /**
         * Constructs a new GetByKeyQuery.
         * @memberof proto
         * @classdesc Get all accounts, claims, files, and smart contract instances whose associated keys include the
         * given Key. The given Key must not be a contractID or a ThresholdKey. This is not yet implemented
         * in the API, but will be in the future.
         * @implements IGetByKeyQuery
         * @constructor
         * @param {proto.IGetByKeyQuery=} [p] Properties to set
         */
        function GetByKeyQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * Standard info sent from client to node, including the signed payment, and what kind of
         * response is requested (cost, state proof, both, or neither).
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.GetByKeyQuery
         * @instance
         */
        GetByKeyQuery.prototype.header = null;

        /**
         * The key to search for. It must not contain a contractID nor a ThresholdSignature.
         * @member {proto.IKey|null|undefined} key
         * @memberof proto.GetByKeyQuery
         * @instance
         */
        GetByKeyQuery.prototype.key = null;

        /**
         * Creates a new GetByKeyQuery instance using the specified properties.
         * @function create
         * @memberof proto.GetByKeyQuery
         * @static
         * @param {proto.IGetByKeyQuery=} [properties] Properties to set
         * @returns {proto.GetByKeyQuery} GetByKeyQuery instance
         */
        GetByKeyQuery.create = function create(properties) {
            return new GetByKeyQuery(properties);
        };

        /**
         * Encodes the specified GetByKeyQuery message. Does not implicitly {@link proto.GetByKeyQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.GetByKeyQuery
         * @static
         * @param {proto.IGetByKeyQuery} m GetByKeyQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetByKeyQuery.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.key != null && Object.hasOwnProperty.call(m, "key"))
                $root.proto.Key.encode(m.key, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a GetByKeyQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GetByKeyQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.GetByKeyQuery} GetByKeyQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetByKeyQuery.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.GetByKeyQuery();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.key = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for GetByKeyQuery
         * @function getTypeUrl
         * @memberof proto.GetByKeyQuery
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetByKeyQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.GetByKeyQuery";
        };

        return GetByKeyQuery;
    })();

    proto.EntityID = (function () {
        /**
         * Properties of an EntityID.
         * @memberof proto
         * @interface IEntityID
         * @property {proto.IAccountID|null} [accountID] The Account ID for the cryptocurrency account
         * @property {proto.ILiveHash|null} [liveHash] A uniquely identifying livehash of an acount
         * @property {proto.IFileID|null} [fileID] The file ID of the file
         * @property {proto.IContractID|null} [contractID] The smart contract ID that identifies instance
         */

        /**
         * Constructs a new EntityID.
         * @memberof proto
         * @classdesc the ID for a single entity (account, livehash, file, or smart contract instance)
         * @implements IEntityID
         * @constructor
         * @param {proto.IEntityID=} [p] Properties to set
         */
        function EntityID(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The Account ID for the cryptocurrency account
         * @member {proto.IAccountID|null|undefined} accountID
         * @memberof proto.EntityID
         * @instance
         */
        EntityID.prototype.accountID = null;

        /**
         * A uniquely identifying livehash of an acount
         * @member {proto.ILiveHash|null|undefined} liveHash
         * @memberof proto.EntityID
         * @instance
         */
        EntityID.prototype.liveHash = null;

        /**
         * The file ID of the file
         * @member {proto.IFileID|null|undefined} fileID
         * @memberof proto.EntityID
         * @instance
         */
        EntityID.prototype.fileID = null;

        /**
         * The smart contract ID that identifies instance
         * @member {proto.IContractID|null|undefined} contractID
         * @memberof proto.EntityID
         * @instance
         */
        EntityID.prototype.contractID = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * EntityID entity.
         * @member {"accountID"|"liveHash"|"fileID"|"contractID"|undefined} entity
         * @memberof proto.EntityID
         * @instance
         */
        Object.defineProperty(EntityID.prototype, "entity", {
            get: $util.oneOfGetter(($oneOfFields = ["accountID", "liveHash", "fileID", "contractID"])),
            set: $util.oneOfSetter($oneOfFields),
        });

        /**
         * Creates a new EntityID instance using the specified properties.
         * @function create
         * @memberof proto.EntityID
         * @static
         * @param {proto.IEntityID=} [properties] Properties to set
         * @returns {proto.EntityID} EntityID instance
         */
        EntityID.create = function create(properties) {
            return new EntityID(properties);
        };

        /**
         * Encodes the specified EntityID message. Does not implicitly {@link proto.EntityID.verify|verify} messages.
         * @function encode
         * @memberof proto.EntityID
         * @static
         * @param {proto.IEntityID} m EntityID message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EntityID.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.accountID != null && Object.hasOwnProperty.call(m, "accountID"))
                $root.proto.AccountID.encode(m.accountID, w.uint32(10).fork()).ldelim();
            if (m.liveHash != null && Object.hasOwnProperty.call(m, "liveHash"))
                $root.proto.LiveHash.encode(m.liveHash, w.uint32(18).fork()).ldelim();
            if (m.fileID != null && Object.hasOwnProperty.call(m, "fileID"))
                $root.proto.FileID.encode(m.fileID, w.uint32(26).fork()).ldelim();
            if (m.contractID != null && Object.hasOwnProperty.call(m, "contractID"))
                $root.proto.ContractID.encode(m.contractID, w.uint32(34).fork()).ldelim();
            return w;
        };

        /**
         * Decodes an EntityID message from the specified reader or buffer.
         * @function decode
         * @memberof proto.EntityID
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.EntityID} EntityID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EntityID.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.EntityID();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.accountID = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.liveHash = $root.proto.LiveHash.decode(r, r.uint32());
                        break;
                    }
                    case 3: {
                        m.fileID = $root.proto.FileID.decode(r, r.uint32());
                        break;
                    }
                    case 4: {
                        m.contractID = $root.proto.ContractID.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for EntityID
         * @function getTypeUrl
         * @memberof proto.EntityID
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        EntityID.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.EntityID";
        };

        return EntityID;
    })();

    proto.GetByKeyResponse = (function () {
        /**
         * Properties of a GetByKeyResponse.
         * @memberof proto
         * @interface IGetByKeyResponse
         * @property {proto.IResponseHeader|null} [header] Standard response from node to client, including the requested fields: cost, or state proof,
         * or both, or neither
         * @property {Array.<proto.IEntityID>|null} [entities] The list of entities that include this public key in their associated Key list
         */

        /**
         * Constructs a new GetByKeyResponse.
         * @memberof proto
         * @classdesc Response when the client sends the node GetByKeyQuery
         * @implements IGetByKeyResponse
         * @constructor
         * @param {proto.IGetByKeyResponse=} [p] Properties to set
         */
        function GetByKeyResponse(p) {
            this.entities = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * Standard response from node to client, including the requested fields: cost, or state proof,
         * or both, or neither
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.GetByKeyResponse
         * @instance
         */
        GetByKeyResponse.prototype.header = null;

        /**
         * The list of entities that include this public key in their associated Key list
         * @member {Array.<proto.IEntityID>} entities
         * @memberof proto.GetByKeyResponse
         * @instance
         */
        GetByKeyResponse.prototype.entities = $util.emptyArray;

        /**
         * Creates a new GetByKeyResponse instance using the specified properties.
         * @function create
         * @memberof proto.GetByKeyResponse
         * @static
         * @param {proto.IGetByKeyResponse=} [properties] Properties to set
         * @returns {proto.GetByKeyResponse} GetByKeyResponse instance
         */
        GetByKeyResponse.create = function create(properties) {
            return new GetByKeyResponse(properties);
        };

        /**
         * Encodes the specified GetByKeyResponse message. Does not implicitly {@link proto.GetByKeyResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.GetByKeyResponse
         * @static
         * @param {proto.IGetByKeyResponse} m GetByKeyResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetByKeyResponse.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.entities != null && m.entities.length) {
                for (var i = 0; i < m.entities.length; ++i)
                    $root.proto.EntityID.encode(m.entities[i], w.uint32(18).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a GetByKeyResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GetByKeyResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.GetByKeyResponse} GetByKeyResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetByKeyResponse.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.GetByKeyResponse();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        if (!(m.entities && m.entities.length)) m.entities = [];
                        m.entities.push($root.proto.EntityID.decode(r, r.uint32()));
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for GetByKeyResponse
         * @function getTypeUrl
         * @memberof proto.GetByKeyResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetByKeyResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.GetByKeyResponse";
        };

        return GetByKeyResponse;
    })();

    proto.GetBySolidityIDQuery = (function () {
        /**
         * Properties of a GetBySolidityIDQuery.
         * @memberof proto
         * @interface IGetBySolidityIDQuery
         * @property {proto.IQueryHeader|null} [header] Standard info sent from client to node, including the signed payment, and what kind of
         * response is requested (cost, state proof, both, or neither).
         * @property {string|null} [solidityID] The ID in the format used by Solidity
         */

        /**
         * Constructs a new GetBySolidityIDQuery.
         * @memberof proto
         * @classdesc Get the IDs in the format used by transactions, given the ID in the format used by Solidity. If
         * the Solidity ID is for a smart contract instance, then both the ContractID and associated
         * AccountID will be returned.
         * @implements IGetBySolidityIDQuery
         * @constructor
         * @param {proto.IGetBySolidityIDQuery=} [p] Properties to set
         */
        function GetBySolidityIDQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * Standard info sent from client to node, including the signed payment, and what kind of
         * response is requested (cost, state proof, both, or neither).
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.GetBySolidityIDQuery
         * @instance
         */
        GetBySolidityIDQuery.prototype.header = null;

        /**
         * The ID in the format used by Solidity
         * @member {string} solidityID
         * @memberof proto.GetBySolidityIDQuery
         * @instance
         */
        GetBySolidityIDQuery.prototype.solidityID = "";

        /**
         * Creates a new GetBySolidityIDQuery instance using the specified properties.
         * @function create
         * @memberof proto.GetBySolidityIDQuery
         * @static
         * @param {proto.IGetBySolidityIDQuery=} [properties] Properties to set
         * @returns {proto.GetBySolidityIDQuery} GetBySolidityIDQuery instance
         */
        GetBySolidityIDQuery.create = function create(properties) {
            return new GetBySolidityIDQuery(properties);
        };

        /**
         * Encodes the specified GetBySolidityIDQuery message. Does not implicitly {@link proto.GetBySolidityIDQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.GetBySolidityIDQuery
         * @static
         * @param {proto.IGetBySolidityIDQuery} m GetBySolidityIDQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetBySolidityIDQuery.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.solidityID != null && Object.hasOwnProperty.call(m, "solidityID")) w.uint32(18).string(m.solidityID);
            return w;
        };

        /**
         * Decodes a GetBySolidityIDQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GetBySolidityIDQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.GetBySolidityIDQuery} GetBySolidityIDQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetBySolidityIDQuery.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.GetBySolidityIDQuery();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.solidityID = r.string();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for GetBySolidityIDQuery
         * @function getTypeUrl
         * @memberof proto.GetBySolidityIDQuery
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetBySolidityIDQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.GetBySolidityIDQuery";
        };

        return GetBySolidityIDQuery;
    })();

    proto.GetBySolidityIDResponse = (function () {
        /**
         * Properties of a GetBySolidityIDResponse.
         * @memberof proto
         * @interface IGetBySolidityIDResponse
         * @property {proto.IResponseHeader|null} [header] Standard response from node to client, including the requested fields: cost, or state proof,
         * or both, or neither
         * @property {proto.IAccountID|null} [accountID] The Account ID for the cryptocurrency account
         * @property {proto.IFileID|null} [fileID] The file Id for the file
         * @property {proto.IContractID|null} [contractID] A smart contract ID for the instance (if this is included, then the associated accountID will
         * also be included)
         */

        /**
         * Constructs a new GetBySolidityIDResponse.
         * @memberof proto
         * @classdesc Response when the client sends the node GetBySolidityIDQuery
         * @implements IGetBySolidityIDResponse
         * @constructor
         * @param {proto.IGetBySolidityIDResponse=} [p] Properties to set
         */
        function GetBySolidityIDResponse(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * Standard response from node to client, including the requested fields: cost, or state proof,
         * or both, or neither
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.GetBySolidityIDResponse
         * @instance
         */
        GetBySolidityIDResponse.prototype.header = null;

        /**
         * The Account ID for the cryptocurrency account
         * @member {proto.IAccountID|null|undefined} accountID
         * @memberof proto.GetBySolidityIDResponse
         * @instance
         */
        GetBySolidityIDResponse.prototype.accountID = null;

        /**
         * The file Id for the file
         * @member {proto.IFileID|null|undefined} fileID
         * @memberof proto.GetBySolidityIDResponse
         * @instance
         */
        GetBySolidityIDResponse.prototype.fileID = null;

        /**
         * A smart contract ID for the instance (if this is included, then the associated accountID will
         * also be included)
         * @member {proto.IContractID|null|undefined} contractID
         * @memberof proto.GetBySolidityIDResponse
         * @instance
         */
        GetBySolidityIDResponse.prototype.contractID = null;

        /**
         * Creates a new GetBySolidityIDResponse instance using the specified properties.
         * @function create
         * @memberof proto.GetBySolidityIDResponse
         * @static
         * @param {proto.IGetBySolidityIDResponse=} [properties] Properties to set
         * @returns {proto.GetBySolidityIDResponse} GetBySolidityIDResponse instance
         */
        GetBySolidityIDResponse.create = function create(properties) {
            return new GetBySolidityIDResponse(properties);
        };

        /**
         * Encodes the specified GetBySolidityIDResponse message. Does not implicitly {@link proto.GetBySolidityIDResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.GetBySolidityIDResponse
         * @static
         * @param {proto.IGetBySolidityIDResponse} m GetBySolidityIDResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetBySolidityIDResponse.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.accountID != null && Object.hasOwnProperty.call(m, "accountID"))
                $root.proto.AccountID.encode(m.accountID, w.uint32(18).fork()).ldelim();
            if (m.fileID != null && Object.hasOwnProperty.call(m, "fileID"))
                $root.proto.FileID.encode(m.fileID, w.uint32(26).fork()).ldelim();
            if (m.contractID != null && Object.hasOwnProperty.call(m, "contractID"))
                $root.proto.ContractID.encode(m.contractID, w.uint32(34).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a GetBySolidityIDResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GetBySolidityIDResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.GetBySolidityIDResponse} GetBySolidityIDResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetBySolidityIDResponse.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.GetBySolidityIDResponse();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.accountID = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    case 3: {
                        m.fileID = $root.proto.FileID.decode(r, r.uint32());
                        break;
                    }
                    case 4: {
                        m.contractID = $root.proto.ContractID.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for GetBySolidityIDResponse
         * @function getTypeUrl
         * @memberof proto.GetBySolidityIDResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetBySolidityIDResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.GetBySolidityIDResponse";
        };

        return GetBySolidityIDResponse;
    })();

    proto.ContractLoginfo = (function () {
        /**
         * Properties of a ContractLoginfo.
         * @memberof proto
         * @interface IContractLoginfo
         * @property {proto.IContractID|null} [contractID] address of a contract that emitted the event
         * @property {Uint8Array|null} [bloom] bloom filter for a particular log
         * @property {Array.<Uint8Array>|null} [topic] topics of a particular event
         * @property {Uint8Array|null} [data] event data
         */

        /**
         * Constructs a new ContractLoginfo.
         * @memberof proto
         * @classdesc The log information for an event returned by a smart contract function call. One function call
         * may return several such events.
         * @implements IContractLoginfo
         * @constructor
         * @param {proto.IContractLoginfo=} [p] Properties to set
         */
        function ContractLoginfo(p) {
            this.topic = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * address of a contract that emitted the event
         * @member {proto.IContractID|null|undefined} contractID
         * @memberof proto.ContractLoginfo
         * @instance
         */
        ContractLoginfo.prototype.contractID = null;

        /**
         * bloom filter for a particular log
         * @member {Uint8Array} bloom
         * @memberof proto.ContractLoginfo
         * @instance
         */
        ContractLoginfo.prototype.bloom = $util.newBuffer([]);

        /**
         * topics of a particular event
         * @member {Array.<Uint8Array>} topic
         * @memberof proto.ContractLoginfo
         * @instance
         */
        ContractLoginfo.prototype.topic = $util.emptyArray;

        /**
         * event data
         * @member {Uint8Array} data
         * @memberof proto.ContractLoginfo
         * @instance
         */
        ContractLoginfo.prototype.data = $util.newBuffer([]);

        /**
         * Creates a new ContractLoginfo instance using the specified properties.
         * @function create
         * @memberof proto.ContractLoginfo
         * @static
         * @param {proto.IContractLoginfo=} [properties] Properties to set
         * @returns {proto.ContractLoginfo} ContractLoginfo instance
         */
        ContractLoginfo.create = function create(properties) {
            return new ContractLoginfo(properties);
        };

        /**
         * Encodes the specified ContractLoginfo message. Does not implicitly {@link proto.ContractLoginfo.verify|verify} messages.
         * @function encode
         * @memberof proto.ContractLoginfo
         * @static
         * @param {proto.IContractLoginfo} m ContractLoginfo message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractLoginfo.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.contractID != null && Object.hasOwnProperty.call(m, "contractID"))
                $root.proto.ContractID.encode(m.contractID, w.uint32(10).fork()).ldelim();
            if (m.bloom != null && Object.hasOwnProperty.call(m, "bloom")) w.uint32(18).bytes(m.bloom);
            if (m.topic != null && m.topic.length) {
                for (var i = 0; i < m.topic.length; ++i) w.uint32(26).bytes(m.topic[i]);
            }
            if (m.data != null && Object.hasOwnProperty.call(m, "data")) w.uint32(34).bytes(m.data);
            return w;
        };

        /**
         * Decodes a ContractLoginfo message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ContractLoginfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ContractLoginfo} ContractLoginfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractLoginfo.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.ContractLoginfo();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.contractID = $root.proto.ContractID.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.bloom = r.bytes();
                        break;
                    }
                    case 3: {
                        if (!(m.topic && m.topic.length)) m.topic = [];
                        m.topic.push(r.bytes());
                        break;
                    }
                    case 4: {
                        m.data = r.bytes();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ContractLoginfo
         * @function getTypeUrl
         * @memberof proto.ContractLoginfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ContractLoginfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ContractLoginfo";
        };

        return ContractLoginfo;
    })();

    proto.ContractFunctionResult = (function () {
        /**
         * Properties of a ContractFunctionResult.
         * @memberof proto
         * @interface IContractFunctionResult
         * @property {proto.IContractID|null} [contractID] the smart contract instance whose function was called
         * @property {Uint8Array|null} [contractCallResult] the result returned by the function
         * @property {string|null} [errorMessage] message In case there was an error during smart contract execution
         * @property {Uint8Array|null} [bloom] bloom filter for record
         * @property {Long|null} [gasUsed] units of gas used to execute contract
         * @property {Array.<proto.IContractLoginfo>|null} [logInfo] the log info for events returned by the function
         * @property {Array.<proto.IContractID>|null} [createdContractIDs] [DEPRECATED] the list of smart contracts that were created by the function call.
         *
         * The created ids will now _also_ be externalized through internal transaction
         * records, where each record has its alias field populated with the new contract's
         * EVM address. (This is needed for contracts created with CREATE2, since
         * there is no longer a simple relationship between the new contract's 0.0.X id
         * and its Solidity address.)
         * @property {google.protobuf.IBytesValue|null} [evmAddress] The new contract's 20-byte EVM address. Only populated after release 0.23,
         * where each created contract will have its own record. (This is an important
         * point--the field is not <tt>repeated</tt> because there will be a separate
         * child record for each created contract.)
         *
         * Every contract has an EVM address determined by its <tt>shard.realm.num</tt> id.
         * This address is as follows:
         * <ol>
         * <li>The first 4 bytes are the big-endian representation of the shard.</li>
         * <li>The next 8 bytes are the big-endian representation of the realm.</li>
         * <li>The final 8 bytes are the big-endian representation of the number.</li>
         * </ol>
         *
         * Contracts created via CREATE2 have an <b>additional, primary address</b> that is
         * derived from the <a href="https://eips.ethereum.org/EIPS/eip-1014">EIP-1014</a>
         * specification, and does not have a simple relation to a <tt>shard.realm.num</tt> id.
         *
         * (Please do note that CREATE2 contracts can also be referenced by the three-part
         * EVM address described above.)
         * @property {Long|null} [gas] The amount of gas available for the call, aka the gasLimit.
         *
         * This field should only be populated when the paired TransactionBody in the record stream is not a
         * ContractCreateTransactionBody or a ContractCallTransactionBody.
         * @property {Long|null} [amount] Number of tinybars sent (the function must be payable if this is nonzero).
         *
         * This field should only be populated when the paired TransactionBody in the record stream is not a
         * ContractCreateTransactionBody or a ContractCallTransactionBody.
         * @property {Uint8Array|null} [functionParameters] The parameters passed into the contract call.
         *
         * This field should only be populated when the paired TransactionBody in the record stream is not a
         * ContractCreateTransactionBody or a ContractCallTransactionBody.
         * @property {proto.IAccountID|null} [senderId] The account that is the "sender." If not present it is the accountId from the transactionId.
         *
         * This field should only be populated when the paired TransactionBody in the record stream is not a
         * ContractCreateTransactionBody or a ContractCallTransactionBody.
         */

        /**
         * Constructs a new ContractFunctionResult.
         * @memberof proto
         * @classdesc The result returned by a call to a smart contract function. This is part of the response to a
         * ContractCallLocal query, and is in the record for a ContractCall or ContractCreateInstance
         * transaction. The ContractCreateInstance transaction record has the results of the call to the
         * constructor.
         * @implements IContractFunctionResult
         * @constructor
         * @param {proto.IContractFunctionResult=} [p] Properties to set
         */
        function ContractFunctionResult(p) {
            this.logInfo = [];
            this.createdContractIDs = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * the smart contract instance whose function was called
         * @member {proto.IContractID|null|undefined} contractID
         * @memberof proto.ContractFunctionResult
         * @instance
         */
        ContractFunctionResult.prototype.contractID = null;

        /**
         * the result returned by the function
         * @member {Uint8Array} contractCallResult
         * @memberof proto.ContractFunctionResult
         * @instance
         */
        ContractFunctionResult.prototype.contractCallResult = $util.newBuffer([]);

        /**
         * message In case there was an error during smart contract execution
         * @member {string} errorMessage
         * @memberof proto.ContractFunctionResult
         * @instance
         */
        ContractFunctionResult.prototype.errorMessage = "";

        /**
         * bloom filter for record
         * @member {Uint8Array} bloom
         * @memberof proto.ContractFunctionResult
         * @instance
         */
        ContractFunctionResult.prototype.bloom = $util.newBuffer([]);

        /**
         * units of gas used to execute contract
         * @member {Long} gasUsed
         * @memberof proto.ContractFunctionResult
         * @instance
         */
        ContractFunctionResult.prototype.gasUsed = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * the log info for events returned by the function
         * @member {Array.<proto.IContractLoginfo>} logInfo
         * @memberof proto.ContractFunctionResult
         * @instance
         */
        ContractFunctionResult.prototype.logInfo = $util.emptyArray;

        /**
         * [DEPRECATED] the list of smart contracts that were created by the function call.
         *
         * The created ids will now _also_ be externalized through internal transaction
         * records, where each record has its alias field populated with the new contract's
         * EVM address. (This is needed for contracts created with CREATE2, since
         * there is no longer a simple relationship between the new contract's 0.0.X id
         * and its Solidity address.)
         * @member {Array.<proto.IContractID>} createdContractIDs
         * @memberof proto.ContractFunctionResult
         * @instance
         */
        ContractFunctionResult.prototype.createdContractIDs = $util.emptyArray;

        /**
         * The new contract's 20-byte EVM address. Only populated after release 0.23,
         * where each created contract will have its own record. (This is an important
         * point--the field is not <tt>repeated</tt> because there will be a separate
         * child record for each created contract.)
         *
         * Every contract has an EVM address determined by its <tt>shard.realm.num</tt> id.
         * This address is as follows:
         * <ol>
         * <li>The first 4 bytes are the big-endian representation of the shard.</li>
         * <li>The next 8 bytes are the big-endian representation of the realm.</li>
         * <li>The final 8 bytes are the big-endian representation of the number.</li>
         * </ol>
         *
         * Contracts created via CREATE2 have an <b>additional, primary address</b> that is
         * derived from the <a href="https://eips.ethereum.org/EIPS/eip-1014">EIP-1014</a>
         * specification, and does not have a simple relation to a <tt>shard.realm.num</tt> id.
         *
         * (Please do note that CREATE2 contracts can also be referenced by the three-part
         * EVM address described above.)
         * @member {google.protobuf.IBytesValue|null|undefined} evmAddress
         * @memberof proto.ContractFunctionResult
         * @instance
         */
        ContractFunctionResult.prototype.evmAddress = null;

        /**
         * The amount of gas available for the call, aka the gasLimit.
         *
         * This field should only be populated when the paired TransactionBody in the record stream is not a
         * ContractCreateTransactionBody or a ContractCallTransactionBody.
         * @member {Long} gas
         * @memberof proto.ContractFunctionResult
         * @instance
         */
        ContractFunctionResult.prototype.gas = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * Number of tinybars sent (the function must be payable if this is nonzero).
         *
         * This field should only be populated when the paired TransactionBody in the record stream is not a
         * ContractCreateTransactionBody or a ContractCallTransactionBody.
         * @member {Long} amount
         * @memberof proto.ContractFunctionResult
         * @instance
         */
        ContractFunctionResult.prototype.amount = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * The parameters passed into the contract call.
         *
         * This field should only be populated when the paired TransactionBody in the record stream is not a
         * ContractCreateTransactionBody or a ContractCallTransactionBody.
         * @member {Uint8Array} functionParameters
         * @memberof proto.ContractFunctionResult
         * @instance
         */
        ContractFunctionResult.prototype.functionParameters = $util.newBuffer([]);

        /**
         * The account that is the "sender." If not present it is the accountId from the transactionId.
         *
         * This field should only be populated when the paired TransactionBody in the record stream is not a
         * ContractCreateTransactionBody or a ContractCallTransactionBody.
         * @member {proto.IAccountID|null|undefined} senderId
         * @memberof proto.ContractFunctionResult
         * @instance
         */
        ContractFunctionResult.prototype.senderId = null;

        /**
         * Creates a new ContractFunctionResult instance using the specified properties.
         * @function create
         * @memberof proto.ContractFunctionResult
         * @static
         * @param {proto.IContractFunctionResult=} [properties] Properties to set
         * @returns {proto.ContractFunctionResult} ContractFunctionResult instance
         */
        ContractFunctionResult.create = function create(properties) {
            return new ContractFunctionResult(properties);
        };

        /**
         * Encodes the specified ContractFunctionResult message. Does not implicitly {@link proto.ContractFunctionResult.verify|verify} messages.
         * @function encode
         * @memberof proto.ContractFunctionResult
         * @static
         * @param {proto.IContractFunctionResult} m ContractFunctionResult message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractFunctionResult.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.contractID != null && Object.hasOwnProperty.call(m, "contractID"))
                $root.proto.ContractID.encode(m.contractID, w.uint32(10).fork()).ldelim();
            if (m.contractCallResult != null && Object.hasOwnProperty.call(m, "contractCallResult"))
                w.uint32(18).bytes(m.contractCallResult);
            if (m.errorMessage != null && Object.hasOwnProperty.call(m, "errorMessage"))
                w.uint32(26).string(m.errorMessage);
            if (m.bloom != null && Object.hasOwnProperty.call(m, "bloom")) w.uint32(34).bytes(m.bloom);
            if (m.gasUsed != null && Object.hasOwnProperty.call(m, "gasUsed")) w.uint32(40).uint64(m.gasUsed);
            if (m.logInfo != null && m.logInfo.length) {
                for (var i = 0; i < m.logInfo.length; ++i)
                    $root.proto.ContractLoginfo.encode(m.logInfo[i], w.uint32(50).fork()).ldelim();
            }
            if (m.createdContractIDs != null && m.createdContractIDs.length) {
                for (var i = 0; i < m.createdContractIDs.length; ++i)
                    $root.proto.ContractID.encode(m.createdContractIDs[i], w.uint32(58).fork()).ldelim();
            }
            if (m.evmAddress != null && Object.hasOwnProperty.call(m, "evmAddress"))
                $root.google.protobuf.BytesValue.encode(m.evmAddress, w.uint32(74).fork()).ldelim();
            if (m.gas != null && Object.hasOwnProperty.call(m, "gas")) w.uint32(80).int64(m.gas);
            if (m.amount != null && Object.hasOwnProperty.call(m, "amount")) w.uint32(88).int64(m.amount);
            if (m.functionParameters != null && Object.hasOwnProperty.call(m, "functionParameters"))
                w.uint32(98).bytes(m.functionParameters);
            if (m.senderId != null && Object.hasOwnProperty.call(m, "senderId"))
                $root.proto.AccountID.encode(m.senderId, w.uint32(106).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a ContractFunctionResult message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ContractFunctionResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ContractFunctionResult} ContractFunctionResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractFunctionResult.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.ContractFunctionResult();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.contractID = $root.proto.ContractID.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.contractCallResult = r.bytes();
                        break;
                    }
                    case 3: {
                        m.errorMessage = r.string();
                        break;
                    }
                    case 4: {
                        m.bloom = r.bytes();
                        break;
                    }
                    case 5: {
                        m.gasUsed = r.uint64();
                        break;
                    }
                    case 6: {
                        if (!(m.logInfo && m.logInfo.length)) m.logInfo = [];
                        m.logInfo.push($root.proto.ContractLoginfo.decode(r, r.uint32()));
                        break;
                    }
                    case 7: {
                        if (!(m.createdContractIDs && m.createdContractIDs.length)) m.createdContractIDs = [];
                        m.createdContractIDs.push($root.proto.ContractID.decode(r, r.uint32()));
                        break;
                    }
                    case 9: {
                        m.evmAddress = $root.google.protobuf.BytesValue.decode(r, r.uint32());
                        break;
                    }
                    case 10: {
                        m.gas = r.int64();
                        break;
                    }
                    case 11: {
                        m.amount = r.int64();
                        break;
                    }
                    case 12: {
                        m.functionParameters = r.bytes();
                        break;
                    }
                    case 13: {
                        m.senderId = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ContractFunctionResult
         * @function getTypeUrl
         * @memberof proto.ContractFunctionResult
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ContractFunctionResult.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ContractFunctionResult";
        };

        return ContractFunctionResult;
    })();

    proto.ContractCallLocalQuery = (function () {
        /**
         * Properties of a ContractCallLocalQuery.
         * @memberof proto
         * @interface IContractCallLocalQuery
         * @property {proto.IQueryHeader|null} [header] standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither). The payment must cover the fees and all of the gas offered.
         * @property {proto.IContractID|null} [contractID] The contract to make a static call against
         * @property {Long|null} [gas] The amount of gas to use for the call; all of the gas offered will be used and charged a corresponding fee
         * @property {Uint8Array|null} [functionParameters] which function to call, and the parameters to pass to the function
         * @property {Long|null} [maxResultSize] max number of bytes that the result might include. The run will fail if it would have returned more than this number of bytes.
         * @property {proto.IAccountID|null} [senderId] The account that is the "sender." If not present it is the accountId from the transactionId.
         * Typically a different value than specified in the transactionId requires a valid signature
         * over either the hedera transaction or foreign transaction data.
         */

        /**
         * Constructs a new ContractCallLocalQuery.
         * @memberof proto
         * @classdesc Call a function of the given smart contract instance, giving it functionParameters as its inputs.
         * This is performed locally on the particular node that the client is communicating with.
         * It cannot change the state of the contract instance (and so, cannot spend anything from the instance's cryptocurrency account).
         * It will not have a consensus timestamp. It cannot generate a record or a receipt. The response will contain the output
         * returned by the function call.  This is useful for calling getter functions, which purely read the state and don't change it.
         * It is faster and cheaper than a normal call, because it is purely local to a single  node.
         *
         * Unlike a ContractCall transaction, the node will consume the entire amount of provided gas in determining
         * the fee for this query.
         * @implements IContractCallLocalQuery
         * @constructor
         * @param {proto.IContractCallLocalQuery=} [p] Properties to set
         */
        function ContractCallLocalQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither). The payment must cover the fees and all of the gas offered.
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.ContractCallLocalQuery
         * @instance
         */
        ContractCallLocalQuery.prototype.header = null;

        /**
         * The contract to make a static call against
         * @member {proto.IContractID|null|undefined} contractID
         * @memberof proto.ContractCallLocalQuery
         * @instance
         */
        ContractCallLocalQuery.prototype.contractID = null;

        /**
         * The amount of gas to use for the call; all of the gas offered will be used and charged a corresponding fee
         * @member {Long} gas
         * @memberof proto.ContractCallLocalQuery
         * @instance
         */
        ContractCallLocalQuery.prototype.gas = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * which function to call, and the parameters to pass to the function
         * @member {Uint8Array} functionParameters
         * @memberof proto.ContractCallLocalQuery
         * @instance
         */
        ContractCallLocalQuery.prototype.functionParameters = $util.newBuffer([]);

        /**
         * max number of bytes that the result might include. The run will fail if it would have returned more than this number of bytes.
         * @member {Long} maxResultSize
         * @memberof proto.ContractCallLocalQuery
         * @instance
         */
        ContractCallLocalQuery.prototype.maxResultSize = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * The account that is the "sender." If not present it is the accountId from the transactionId.
         * Typically a different value than specified in the transactionId requires a valid signature
         * over either the hedera transaction or foreign transaction data.
         * @member {proto.IAccountID|null|undefined} senderId
         * @memberof proto.ContractCallLocalQuery
         * @instance
         */
        ContractCallLocalQuery.prototype.senderId = null;

        /**
         * Creates a new ContractCallLocalQuery instance using the specified properties.
         * @function create
         * @memberof proto.ContractCallLocalQuery
         * @static
         * @param {proto.IContractCallLocalQuery=} [properties] Properties to set
         * @returns {proto.ContractCallLocalQuery} ContractCallLocalQuery instance
         */
        ContractCallLocalQuery.create = function create(properties) {
            return new ContractCallLocalQuery(properties);
        };

        /**
         * Encodes the specified ContractCallLocalQuery message. Does not implicitly {@link proto.ContractCallLocalQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.ContractCallLocalQuery
         * @static
         * @param {proto.IContractCallLocalQuery} m ContractCallLocalQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractCallLocalQuery.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.contractID != null && Object.hasOwnProperty.call(m, "contractID"))
                $root.proto.ContractID.encode(m.contractID, w.uint32(18).fork()).ldelim();
            if (m.gas != null && Object.hasOwnProperty.call(m, "gas")) w.uint32(24).int64(m.gas);
            if (m.functionParameters != null && Object.hasOwnProperty.call(m, "functionParameters"))
                w.uint32(34).bytes(m.functionParameters);
            if (m.maxResultSize != null && Object.hasOwnProperty.call(m, "maxResultSize"))
                w.uint32(40).int64(m.maxResultSize);
            if (m.senderId != null && Object.hasOwnProperty.call(m, "senderId"))
                $root.proto.AccountID.encode(m.senderId, w.uint32(50).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a ContractCallLocalQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ContractCallLocalQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ContractCallLocalQuery} ContractCallLocalQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractCallLocalQuery.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.ContractCallLocalQuery();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.contractID = $root.proto.ContractID.decode(r, r.uint32());
                        break;
                    }
                    case 3: {
                        m.gas = r.int64();
                        break;
                    }
                    case 4: {
                        m.functionParameters = r.bytes();
                        break;
                    }
                    case 5: {
                        m.maxResultSize = r.int64();
                        break;
                    }
                    case 6: {
                        m.senderId = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ContractCallLocalQuery
         * @function getTypeUrl
         * @memberof proto.ContractCallLocalQuery
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ContractCallLocalQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ContractCallLocalQuery";
        };

        return ContractCallLocalQuery;
    })();

    proto.ContractCallLocalResponse = (function () {
        /**
         * Properties of a ContractCallLocalResponse.
         * @memberof proto
         * @interface IContractCallLocalResponse
         * @property {proto.IResponseHeader|null} [header] standard response from node to client, including the requested fields: cost, or state proof, or both, or neither
         * @property {proto.IContractFunctionResult|null} [functionResult] the value returned by the function (if it completed and didn't fail)
         */

        /**
         * Constructs a new ContractCallLocalResponse.
         * @memberof proto
         * @classdesc Response when the client sends the node ContractCallLocalQuery
         * @implements IContractCallLocalResponse
         * @constructor
         * @param {proto.IContractCallLocalResponse=} [p] Properties to set
         */
        function ContractCallLocalResponse(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * standard response from node to client, including the requested fields: cost, or state proof, or both, or neither
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.ContractCallLocalResponse
         * @instance
         */
        ContractCallLocalResponse.prototype.header = null;

        /**
         * the value returned by the function (if it completed and didn't fail)
         * @member {proto.IContractFunctionResult|null|undefined} functionResult
         * @memberof proto.ContractCallLocalResponse
         * @instance
         */
        ContractCallLocalResponse.prototype.functionResult = null;

        /**
         * Creates a new ContractCallLocalResponse instance using the specified properties.
         * @function create
         * @memberof proto.ContractCallLocalResponse
         * @static
         * @param {proto.IContractCallLocalResponse=} [properties] Properties to set
         * @returns {proto.ContractCallLocalResponse} ContractCallLocalResponse instance
         */
        ContractCallLocalResponse.create = function create(properties) {
            return new ContractCallLocalResponse(properties);
        };

        /**
         * Encodes the specified ContractCallLocalResponse message. Does not implicitly {@link proto.ContractCallLocalResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ContractCallLocalResponse
         * @static
         * @param {proto.IContractCallLocalResponse} m ContractCallLocalResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractCallLocalResponse.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.functionResult != null && Object.hasOwnProperty.call(m, "functionResult"))
                $root.proto.ContractFunctionResult.encode(m.functionResult, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a ContractCallLocalResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ContractCallLocalResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ContractCallLocalResponse} ContractCallLocalResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractCallLocalResponse.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.ContractCallLocalResponse();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.functionResult = $root.proto.ContractFunctionResult.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ContractCallLocalResponse
         * @function getTypeUrl
         * @memberof proto.ContractCallLocalResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ContractCallLocalResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ContractCallLocalResponse";
        };

        return ContractCallLocalResponse;
    })();

    proto.ContractGetInfoQuery = (function () {
        /**
         * Properties of a ContractGetInfoQuery.
         * @memberof proto
         * @interface IContractGetInfoQuery
         * @property {proto.IQueryHeader|null} [header] standard info sent from client to node, including the signed payment, and what kind of
         * response is requested (cost, state proof, both, or neither).
         * @property {proto.IContractID|null} [contractID] the contract for which information is requested
         */

        /**
         * Constructs a new ContractGetInfoQuery.
         * @memberof proto
         * @classdesc Get information about a smart contract instance. This includes the account that it uses, the file
         * containing its initcode (if a file was used to initialize the contract), and the time when it will expire.
         * @implements IContractGetInfoQuery
         * @constructor
         * @param {proto.IContractGetInfoQuery=} [p] Properties to set
         */
        function ContractGetInfoQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * standard info sent from client to node, including the signed payment, and what kind of
         * response is requested (cost, state proof, both, or neither).
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.ContractGetInfoQuery
         * @instance
         */
        ContractGetInfoQuery.prototype.header = null;

        /**
         * the contract for which information is requested
         * @member {proto.IContractID|null|undefined} contractID
         * @memberof proto.ContractGetInfoQuery
         * @instance
         */
        ContractGetInfoQuery.prototype.contractID = null;

        /**
         * Creates a new ContractGetInfoQuery instance using the specified properties.
         * @function create
         * @memberof proto.ContractGetInfoQuery
         * @static
         * @param {proto.IContractGetInfoQuery=} [properties] Properties to set
         * @returns {proto.ContractGetInfoQuery} ContractGetInfoQuery instance
         */
        ContractGetInfoQuery.create = function create(properties) {
            return new ContractGetInfoQuery(properties);
        };

        /**
         * Encodes the specified ContractGetInfoQuery message. Does not implicitly {@link proto.ContractGetInfoQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.ContractGetInfoQuery
         * @static
         * @param {proto.IContractGetInfoQuery} m ContractGetInfoQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractGetInfoQuery.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.contractID != null && Object.hasOwnProperty.call(m, "contractID"))
                $root.proto.ContractID.encode(m.contractID, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a ContractGetInfoQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ContractGetInfoQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ContractGetInfoQuery} ContractGetInfoQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractGetInfoQuery.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.ContractGetInfoQuery();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.contractID = $root.proto.ContractID.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ContractGetInfoQuery
         * @function getTypeUrl
         * @memberof proto.ContractGetInfoQuery
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ContractGetInfoQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ContractGetInfoQuery";
        };

        return ContractGetInfoQuery;
    })();

    proto.ContractGetInfoResponse = (function () {
        /**
         * Properties of a ContractGetInfoResponse.
         * @memberof proto
         * @interface IContractGetInfoResponse
         * @property {proto.IResponseHeader|null} [header] standard response from node to client, including the requested fields: cost, or state proof,
         * or both, or neither
         * @property {proto.ContractGetInfoResponse.IContractInfo|null} [contractInfo] the information about this contract instance (a state proof can be generated for this)
         */

        /**
         * Constructs a new ContractGetInfoResponse.
         * @memberof proto
         * @classdesc Response when the client sends the node ContractGetInfoQuery
         * @implements IContractGetInfoResponse
         * @constructor
         * @param {proto.IContractGetInfoResponse=} [p] Properties to set
         */
        function ContractGetInfoResponse(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * standard response from node to client, including the requested fields: cost, or state proof,
         * or both, or neither
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.ContractGetInfoResponse
         * @instance
         */
        ContractGetInfoResponse.prototype.header = null;

        /**
         * the information about this contract instance (a state proof can be generated for this)
         * @member {proto.ContractGetInfoResponse.IContractInfo|null|undefined} contractInfo
         * @memberof proto.ContractGetInfoResponse
         * @instance
         */
        ContractGetInfoResponse.prototype.contractInfo = null;

        /**
         * Creates a new ContractGetInfoResponse instance using the specified properties.
         * @function create
         * @memberof proto.ContractGetInfoResponse
         * @static
         * @param {proto.IContractGetInfoResponse=} [properties] Properties to set
         * @returns {proto.ContractGetInfoResponse} ContractGetInfoResponse instance
         */
        ContractGetInfoResponse.create = function create(properties) {
            return new ContractGetInfoResponse(properties);
        };

        /**
         * Encodes the specified ContractGetInfoResponse message. Does not implicitly {@link proto.ContractGetInfoResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ContractGetInfoResponse
         * @static
         * @param {proto.IContractGetInfoResponse} m ContractGetInfoResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractGetInfoResponse.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.contractInfo != null && Object.hasOwnProperty.call(m, "contractInfo"))
                $root.proto.ContractGetInfoResponse.ContractInfo.encode(m.contractInfo, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a ContractGetInfoResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ContractGetInfoResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ContractGetInfoResponse} ContractGetInfoResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractGetInfoResponse.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.ContractGetInfoResponse();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.contractInfo = $root.proto.ContractGetInfoResponse.ContractInfo.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ContractGetInfoResponse
         * @function getTypeUrl
         * @memberof proto.ContractGetInfoResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ContractGetInfoResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ContractGetInfoResponse";
        };

        ContractGetInfoResponse.ContractInfo = (function () {
            /**
             * Properties of a ContractInfo.
             * @memberof proto.ContractGetInfoResponse
             * @interface IContractInfo
             * @property {proto.IContractID|null} [contractID] ID of the contract instance, in the format used in transactions
             * @property {proto.IAccountID|null} [accountID] ID of the cryptocurrency account owned by the contract instance, in the format used in
             * transactions
             * @property {string|null} [contractAccountID] ID of both the contract instance and the cryptocurrency account owned by the contract
             * instance, in the format used by Solidity
             * @property {proto.IKey|null} [adminKey] the state of the instance and its fields can be modified arbitrarily if this key signs a
             * transaction to modify it. If this is null, then such modifications are not possible, and
             * there is no administrator that can override the normal operation of this smart contract
             * instance. Note that if it is created with no admin keys, then there is no administrator
             * to authorize changing the admin keys, so there can never be any admin keys for that
             * instance.
             * @property {proto.ITimestamp|null} [expirationTime] the current time at which this contract instance (and its account) is set to expire
             * @property {proto.IDuration|null} [autoRenewPeriod] the expiration time will extend every this many seconds. If there are insufficient funds,
             * then it extends as long as possible. If the account is empty when it expires, then it is
             * deleted.
             * @property {Long|null} [storage] number of bytes of storage being used by this instance (which affects the cost to extend
             * the expiration time)
             * @property {string|null} [memo] the memo associated with the contract (max 100 bytes)
             * @property {Long|null} [balance] The current balance, in tinybars
             * @property {boolean|null} [deleted] Whether the contract has been deleted
             * @property {Array.<proto.ITokenRelationship>|null} [tokenRelationships] [DEPRECATED] The metadata of the tokens associated to the contract. This field was
             * deprecated by <a href="https://hips.hedera.com/hip/hip-367">HIP-367</a>, which allowed
             * an account to be associated to an unlimited number of tokens. This scale makes it more
             * efficient for users to consult mirror nodes to review their token associations.
             * @property {Uint8Array|null} [ledgerId] The ledger ID the response was returned from; please see <a href="https://github.com/hashgraph/hedera-improvement-proposal/blob/master/HIP/hip-198.md">HIP-198</a> for the network-specific IDs.
             * @property {proto.IAccountID|null} [autoRenewAccountId] ID of the an account to charge for auto-renewal of this contract. If not set, or set to an account with zero hbar
             * balance, the contract's own hbar balance will be used to cover auto-renewal fees.
             * @property {number|null} [maxAutomaticTokenAssociations] The maximum number of tokens that a contract can be implicitly associated with.
             * @property {proto.IStakingInfo|null} [stakingInfo] Staking metadata for this contract.
             */

            /**
             * Constructs a new ContractInfo.
             * @memberof proto.ContractGetInfoResponse
             * @classdesc Represents a ContractInfo.
             * @implements IContractInfo
             * @constructor
             * @param {proto.ContractGetInfoResponse.IContractInfo=} [p] Properties to set
             */
            function ContractInfo(p) {
                this.tokenRelationships = [];
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
            }

            /**
             * ID of the contract instance, in the format used in transactions
             * @member {proto.IContractID|null|undefined} contractID
             * @memberof proto.ContractGetInfoResponse.ContractInfo
             * @instance
             */
            ContractInfo.prototype.contractID = null;

            /**
             * ID of the cryptocurrency account owned by the contract instance, in the format used in
             * transactions
             * @member {proto.IAccountID|null|undefined} accountID
             * @memberof proto.ContractGetInfoResponse.ContractInfo
             * @instance
             */
            ContractInfo.prototype.accountID = null;

            /**
             * ID of both the contract instance and the cryptocurrency account owned by the contract
             * instance, in the format used by Solidity
             * @member {string} contractAccountID
             * @memberof proto.ContractGetInfoResponse.ContractInfo
             * @instance
             */
            ContractInfo.prototype.contractAccountID = "";

            /**
             * the state of the instance and its fields can be modified arbitrarily if this key signs a
             * transaction to modify it. If this is null, then such modifications are not possible, and
             * there is no administrator that can override the normal operation of this smart contract
             * instance. Note that if it is created with no admin keys, then there is no administrator
             * to authorize changing the admin keys, so there can never be any admin keys for that
             * instance.
             * @member {proto.IKey|null|undefined} adminKey
             * @memberof proto.ContractGetInfoResponse.ContractInfo
             * @instance
             */
            ContractInfo.prototype.adminKey = null;

            /**
             * the current time at which this contract instance (and its account) is set to expire
             * @member {proto.ITimestamp|null|undefined} expirationTime
             * @memberof proto.ContractGetInfoResponse.ContractInfo
             * @instance
             */
            ContractInfo.prototype.expirationTime = null;

            /**
             * the expiration time will extend every this many seconds. If there are insufficient funds,
             * then it extends as long as possible. If the account is empty when it expires, then it is
             * deleted.
             * @member {proto.IDuration|null|undefined} autoRenewPeriod
             * @memberof proto.ContractGetInfoResponse.ContractInfo
             * @instance
             */
            ContractInfo.prototype.autoRenewPeriod = null;

            /**
             * number of bytes of storage being used by this instance (which affects the cost to extend
             * the expiration time)
             * @member {Long} storage
             * @memberof proto.ContractGetInfoResponse.ContractInfo
             * @instance
             */
            ContractInfo.prototype.storage = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

            /**
             * the memo associated with the contract (max 100 bytes)
             * @member {string} memo
             * @memberof proto.ContractGetInfoResponse.ContractInfo
             * @instance
             */
            ContractInfo.prototype.memo = "";

            /**
             * The current balance, in tinybars
             * @member {Long} balance
             * @memberof proto.ContractGetInfoResponse.ContractInfo
             * @instance
             */
            ContractInfo.prototype.balance = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

            /**
             * Whether the contract has been deleted
             * @member {boolean} deleted
             * @memberof proto.ContractGetInfoResponse.ContractInfo
             * @instance
             */
            ContractInfo.prototype.deleted = false;

            /**
             * [DEPRECATED] The metadata of the tokens associated to the contract. This field was
             * deprecated by <a href="https://hips.hedera.com/hip/hip-367">HIP-367</a>, which allowed
             * an account to be associated to an unlimited number of tokens. This scale makes it more
             * efficient for users to consult mirror nodes to review their token associations.
             * @member {Array.<proto.ITokenRelationship>} tokenRelationships
             * @memberof proto.ContractGetInfoResponse.ContractInfo
             * @instance
             */
            ContractInfo.prototype.tokenRelationships = $util.emptyArray;

            /**
             * The ledger ID the response was returned from; please see <a href="https://github.com/hashgraph/hedera-improvement-proposal/blob/master/HIP/hip-198.md">HIP-198</a> for the network-specific IDs.
             * @member {Uint8Array} ledgerId
             * @memberof proto.ContractGetInfoResponse.ContractInfo
             * @instance
             */
            ContractInfo.prototype.ledgerId = $util.newBuffer([]);

            /**
             * ID of the an account to charge for auto-renewal of this contract. If not set, or set to an account with zero hbar
             * balance, the contract's own hbar balance will be used to cover auto-renewal fees.
             * @member {proto.IAccountID|null|undefined} autoRenewAccountId
             * @memberof proto.ContractGetInfoResponse.ContractInfo
             * @instance
             */
            ContractInfo.prototype.autoRenewAccountId = null;

            /**
             * The maximum number of tokens that a contract can be implicitly associated with.
             * @member {number} maxAutomaticTokenAssociations
             * @memberof proto.ContractGetInfoResponse.ContractInfo
             * @instance
             */
            ContractInfo.prototype.maxAutomaticTokenAssociations = 0;

            /**
             * Staking metadata for this contract.
             * @member {proto.IStakingInfo|null|undefined} stakingInfo
             * @memberof proto.ContractGetInfoResponse.ContractInfo
             * @instance
             */
            ContractInfo.prototype.stakingInfo = null;

            /**
             * Creates a new ContractInfo instance using the specified properties.
             * @function create
             * @memberof proto.ContractGetInfoResponse.ContractInfo
             * @static
             * @param {proto.ContractGetInfoResponse.IContractInfo=} [properties] Properties to set
             * @returns {proto.ContractGetInfoResponse.ContractInfo} ContractInfo instance
             */
            ContractInfo.create = function create(properties) {
                return new ContractInfo(properties);
            };

            /**
             * Encodes the specified ContractInfo message. Does not implicitly {@link proto.ContractGetInfoResponse.ContractInfo.verify|verify} messages.
             * @function encode
             * @memberof proto.ContractGetInfoResponse.ContractInfo
             * @static
             * @param {proto.ContractGetInfoResponse.IContractInfo} m ContractInfo message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ContractInfo.encode = function encode(m, w) {
                if (!w) w = $Writer.create();
                if (m.contractID != null && Object.hasOwnProperty.call(m, "contractID"))
                    $root.proto.ContractID.encode(m.contractID, w.uint32(10).fork()).ldelim();
                if (m.accountID != null && Object.hasOwnProperty.call(m, "accountID"))
                    $root.proto.AccountID.encode(m.accountID, w.uint32(18).fork()).ldelim();
                if (m.contractAccountID != null && Object.hasOwnProperty.call(m, "contractAccountID"))
                    w.uint32(26).string(m.contractAccountID);
                if (m.adminKey != null && Object.hasOwnProperty.call(m, "adminKey"))
                    $root.proto.Key.encode(m.adminKey, w.uint32(34).fork()).ldelim();
                if (m.expirationTime != null && Object.hasOwnProperty.call(m, "expirationTime"))
                    $root.proto.Timestamp.encode(m.expirationTime, w.uint32(42).fork()).ldelim();
                if (m.autoRenewPeriod != null && Object.hasOwnProperty.call(m, "autoRenewPeriod"))
                    $root.proto.Duration.encode(m.autoRenewPeriod, w.uint32(50).fork()).ldelim();
                if (m.storage != null && Object.hasOwnProperty.call(m, "storage")) w.uint32(56).int64(m.storage);
                if (m.memo != null && Object.hasOwnProperty.call(m, "memo")) w.uint32(66).string(m.memo);
                if (m.balance != null && Object.hasOwnProperty.call(m, "balance")) w.uint32(72).uint64(m.balance);
                if (m.deleted != null && Object.hasOwnProperty.call(m, "deleted")) w.uint32(80).bool(m.deleted);
                if (m.tokenRelationships != null && m.tokenRelationships.length) {
                    for (var i = 0; i < m.tokenRelationships.length; ++i)
                        $root.proto.TokenRelationship.encode(m.tokenRelationships[i], w.uint32(90).fork()).ldelim();
                }
                if (m.ledgerId != null && Object.hasOwnProperty.call(m, "ledgerId")) w.uint32(98).bytes(m.ledgerId);
                if (m.autoRenewAccountId != null && Object.hasOwnProperty.call(m, "autoRenewAccountId"))
                    $root.proto.AccountID.encode(m.autoRenewAccountId, w.uint32(106).fork()).ldelim();
                if (
                    m.maxAutomaticTokenAssociations != null &&
                    Object.hasOwnProperty.call(m, "maxAutomaticTokenAssociations")
                )
                    w.uint32(112).int32(m.maxAutomaticTokenAssociations);
                if (m.stakingInfo != null && Object.hasOwnProperty.call(m, "stakingInfo"))
                    $root.proto.StakingInfo.encode(m.stakingInfo, w.uint32(122).fork()).ldelim();
                return w;
            };

            /**
             * Decodes a ContractInfo message from the specified reader or buffer.
             * @function decode
             * @memberof proto.ContractGetInfoResponse.ContractInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {proto.ContractGetInfoResponse.ContractInfo} ContractInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ContractInfo.decode = function decode(r, l) {
                if (!(r instanceof $Reader)) r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l,
                    m = new $root.proto.ContractGetInfoResponse.ContractInfo();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                        case 1: {
                            m.contractID = $root.proto.ContractID.decode(r, r.uint32());
                            break;
                        }
                        case 2: {
                            m.accountID = $root.proto.AccountID.decode(r, r.uint32());
                            break;
                        }
                        case 3: {
                            m.contractAccountID = r.string();
                            break;
                        }
                        case 4: {
                            m.adminKey = $root.proto.Key.decode(r, r.uint32());
                            break;
                        }
                        case 5: {
                            m.expirationTime = $root.proto.Timestamp.decode(r, r.uint32());
                            break;
                        }
                        case 6: {
                            m.autoRenewPeriod = $root.proto.Duration.decode(r, r.uint32());
                            break;
                        }
                        case 7: {
                            m.storage = r.int64();
                            break;
                        }
                        case 8: {
                            m.memo = r.string();
                            break;
                        }
                        case 9: {
                            m.balance = r.uint64();
                            break;
                        }
                        case 10: {
                            m.deleted = r.bool();
                            break;
                        }
                        case 11: {
                            if (!(m.tokenRelationships && m.tokenRelationships.length)) m.tokenRelationships = [];
                            m.tokenRelationships.push($root.proto.TokenRelationship.decode(r, r.uint32()));
                            break;
                        }
                        case 12: {
                            m.ledgerId = r.bytes();
                            break;
                        }
                        case 13: {
                            m.autoRenewAccountId = $root.proto.AccountID.decode(r, r.uint32());
                            break;
                        }
                        case 14: {
                            m.maxAutomaticTokenAssociations = r.int32();
                            break;
                        }
                        case 15: {
                            m.stakingInfo = $root.proto.StakingInfo.decode(r, r.uint32());
                            break;
                        }
                        default:
                            r.skipType(t & 7);
                            break;
                    }
                }
                return m;
            };

            /**
             * Gets the default type url for ContractInfo
             * @function getTypeUrl
             * @memberof proto.ContractGetInfoResponse.ContractInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ContractInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/proto.ContractGetInfoResponse.ContractInfo";
            };

            return ContractInfo;
        })();

        return ContractGetInfoResponse;
    })();

    proto.ContractGetBytecodeQuery = (function () {
        /**
         * Properties of a ContractGetBytecodeQuery.
         * @memberof proto
         * @interface IContractGetBytecodeQuery
         * @property {proto.IQueryHeader|null} [header] standard info sent from client to node, including the signed payment, and what kind of
         * response is requested (cost, state proof, both, or neither).
         * @property {proto.IContractID|null} [contractID] the contract for which information is requested
         */

        /**
         * Constructs a new ContractGetBytecodeQuery.
         * @memberof proto
         * @classdesc Get the runtime bytecode for a smart contract instance
         * @implements IContractGetBytecodeQuery
         * @constructor
         * @param {proto.IContractGetBytecodeQuery=} [p] Properties to set
         */
        function ContractGetBytecodeQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * standard info sent from client to node, including the signed payment, and what kind of
         * response is requested (cost, state proof, both, or neither).
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.ContractGetBytecodeQuery
         * @instance
         */
        ContractGetBytecodeQuery.prototype.header = null;

        /**
         * the contract for which information is requested
         * @member {proto.IContractID|null|undefined} contractID
         * @memberof proto.ContractGetBytecodeQuery
         * @instance
         */
        ContractGetBytecodeQuery.prototype.contractID = null;

        /**
         * Creates a new ContractGetBytecodeQuery instance using the specified properties.
         * @function create
         * @memberof proto.ContractGetBytecodeQuery
         * @static
         * @param {proto.IContractGetBytecodeQuery=} [properties] Properties to set
         * @returns {proto.ContractGetBytecodeQuery} ContractGetBytecodeQuery instance
         */
        ContractGetBytecodeQuery.create = function create(properties) {
            return new ContractGetBytecodeQuery(properties);
        };

        /**
         * Encodes the specified ContractGetBytecodeQuery message. Does not implicitly {@link proto.ContractGetBytecodeQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.ContractGetBytecodeQuery
         * @static
         * @param {proto.IContractGetBytecodeQuery} m ContractGetBytecodeQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractGetBytecodeQuery.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.contractID != null && Object.hasOwnProperty.call(m, "contractID"))
                $root.proto.ContractID.encode(m.contractID, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a ContractGetBytecodeQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ContractGetBytecodeQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ContractGetBytecodeQuery} ContractGetBytecodeQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractGetBytecodeQuery.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.ContractGetBytecodeQuery();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.contractID = $root.proto.ContractID.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ContractGetBytecodeQuery
         * @function getTypeUrl
         * @memberof proto.ContractGetBytecodeQuery
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ContractGetBytecodeQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ContractGetBytecodeQuery";
        };

        return ContractGetBytecodeQuery;
    })();

    proto.ContractGetBytecodeResponse = (function () {
        /**
         * Properties of a ContractGetBytecodeResponse.
         * @memberof proto
         * @interface IContractGetBytecodeResponse
         * @property {proto.IResponseHeader|null} [header] standard response from node to client, including the requested fields: cost, or state proof,
         * or both, or neither
         * @property {Uint8Array|null} [bytecode] the runtime bytecode of the contract
         */

        /**
         * Constructs a new ContractGetBytecodeResponse.
         * @memberof proto
         * @classdesc Response when the client sends the node ContractGetBytecodeQuery
         * @implements IContractGetBytecodeResponse
         * @constructor
         * @param {proto.IContractGetBytecodeResponse=} [p] Properties to set
         */
        function ContractGetBytecodeResponse(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * standard response from node to client, including the requested fields: cost, or state proof,
         * or both, or neither
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.ContractGetBytecodeResponse
         * @instance
         */
        ContractGetBytecodeResponse.prototype.header = null;

        /**
         * the runtime bytecode of the contract
         * @member {Uint8Array} bytecode
         * @memberof proto.ContractGetBytecodeResponse
         * @instance
         */
        ContractGetBytecodeResponse.prototype.bytecode = $util.newBuffer([]);

        /**
         * Creates a new ContractGetBytecodeResponse instance using the specified properties.
         * @function create
         * @memberof proto.ContractGetBytecodeResponse
         * @static
         * @param {proto.IContractGetBytecodeResponse=} [properties] Properties to set
         * @returns {proto.ContractGetBytecodeResponse} ContractGetBytecodeResponse instance
         */
        ContractGetBytecodeResponse.create = function create(properties) {
            return new ContractGetBytecodeResponse(properties);
        };

        /**
         * Encodes the specified ContractGetBytecodeResponse message. Does not implicitly {@link proto.ContractGetBytecodeResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ContractGetBytecodeResponse
         * @static
         * @param {proto.IContractGetBytecodeResponse} m ContractGetBytecodeResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractGetBytecodeResponse.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.bytecode != null && Object.hasOwnProperty.call(m, "bytecode")) w.uint32(50).bytes(m.bytecode);
            return w;
        };

        /**
         * Decodes a ContractGetBytecodeResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ContractGetBytecodeResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ContractGetBytecodeResponse} ContractGetBytecodeResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractGetBytecodeResponse.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.ContractGetBytecodeResponse();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                        break;
                    }
                    case 6: {
                        m.bytecode = r.bytes();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ContractGetBytecodeResponse
         * @function getTypeUrl
         * @memberof proto.ContractGetBytecodeResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ContractGetBytecodeResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ContractGetBytecodeResponse";
        };

        return ContractGetBytecodeResponse;
    })();

    proto.ContractGetRecordsQuery = (function () {
        /**
         * Properties of a ContractGetRecordsQuery.
         * @memberof proto
         * @interface IContractGetRecordsQuery
         * @property {proto.IQueryHeader|null} [header] Standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither).
         * @property {proto.IContractID|null} [contractID] The smart contract instance for which the records should be retrieved
         */

        /**
         * Constructs a new ContractGetRecordsQuery.
         * @memberof proto
         * @classdesc Before v0.9.0, requested records of all transactions against the given contract in the last 25 hours.
         * @implements IContractGetRecordsQuery
         * @constructor
         * @param {proto.IContractGetRecordsQuery=} [p] Properties to set
         */
        function ContractGetRecordsQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * Standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither).
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.ContractGetRecordsQuery
         * @instance
         */
        ContractGetRecordsQuery.prototype.header = null;

        /**
         * The smart contract instance for which the records should be retrieved
         * @member {proto.IContractID|null|undefined} contractID
         * @memberof proto.ContractGetRecordsQuery
         * @instance
         */
        ContractGetRecordsQuery.prototype.contractID = null;

        /**
         * Creates a new ContractGetRecordsQuery instance using the specified properties.
         * @function create
         * @memberof proto.ContractGetRecordsQuery
         * @static
         * @param {proto.IContractGetRecordsQuery=} [properties] Properties to set
         * @returns {proto.ContractGetRecordsQuery} ContractGetRecordsQuery instance
         */
        ContractGetRecordsQuery.create = function create(properties) {
            return new ContractGetRecordsQuery(properties);
        };

        /**
         * Encodes the specified ContractGetRecordsQuery message. Does not implicitly {@link proto.ContractGetRecordsQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.ContractGetRecordsQuery
         * @static
         * @param {proto.IContractGetRecordsQuery} m ContractGetRecordsQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractGetRecordsQuery.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.contractID != null && Object.hasOwnProperty.call(m, "contractID"))
                $root.proto.ContractID.encode(m.contractID, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a ContractGetRecordsQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ContractGetRecordsQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ContractGetRecordsQuery} ContractGetRecordsQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractGetRecordsQuery.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.ContractGetRecordsQuery();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.contractID = $root.proto.ContractID.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ContractGetRecordsQuery
         * @function getTypeUrl
         * @memberof proto.ContractGetRecordsQuery
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ContractGetRecordsQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ContractGetRecordsQuery";
        };

        return ContractGetRecordsQuery;
    })();

    proto.ContractGetRecordsResponse = (function () {
        /**
         * Properties of a ContractGetRecordsResponse.
         * @memberof proto
         * @interface IContractGetRecordsResponse
         * @property {proto.IResponseHeader|null} [header] Standard response from node to client, including the requested fields: cost, or state proof, or both, or neither
         * @property {proto.IContractID|null} [contractID] The smart contract instance that this record is for
         * @property {Array.<proto.ITransactionRecord>|null} [records] List of records, each with contractCreateResult or contractCallResult as its body
         */

        /**
         * Constructs a new ContractGetRecordsResponse.
         * @memberof proto
         * @classdesc Before v0.9.0, returned records of all transactions against the given contract in the last 25 hours.
         * @implements IContractGetRecordsResponse
         * @constructor
         * @param {proto.IContractGetRecordsResponse=} [p] Properties to set
         */
        function ContractGetRecordsResponse(p) {
            this.records = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * Standard response from node to client, including the requested fields: cost, or state proof, or both, or neither
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.ContractGetRecordsResponse
         * @instance
         */
        ContractGetRecordsResponse.prototype.header = null;

        /**
         * The smart contract instance that this record is for
         * @member {proto.IContractID|null|undefined} contractID
         * @memberof proto.ContractGetRecordsResponse
         * @instance
         */
        ContractGetRecordsResponse.prototype.contractID = null;

        /**
         * List of records, each with contractCreateResult or contractCallResult as its body
         * @member {Array.<proto.ITransactionRecord>} records
         * @memberof proto.ContractGetRecordsResponse
         * @instance
         */
        ContractGetRecordsResponse.prototype.records = $util.emptyArray;

        /**
         * Creates a new ContractGetRecordsResponse instance using the specified properties.
         * @function create
         * @memberof proto.ContractGetRecordsResponse
         * @static
         * @param {proto.IContractGetRecordsResponse=} [properties] Properties to set
         * @returns {proto.ContractGetRecordsResponse} ContractGetRecordsResponse instance
         */
        ContractGetRecordsResponse.create = function create(properties) {
            return new ContractGetRecordsResponse(properties);
        };

        /**
         * Encodes the specified ContractGetRecordsResponse message. Does not implicitly {@link proto.ContractGetRecordsResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ContractGetRecordsResponse
         * @static
         * @param {proto.IContractGetRecordsResponse} m ContractGetRecordsResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractGetRecordsResponse.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.contractID != null && Object.hasOwnProperty.call(m, "contractID"))
                $root.proto.ContractID.encode(m.contractID, w.uint32(18).fork()).ldelim();
            if (m.records != null && m.records.length) {
                for (var i = 0; i < m.records.length; ++i)
                    $root.proto.TransactionRecord.encode(m.records[i], w.uint32(26).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a ContractGetRecordsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ContractGetRecordsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ContractGetRecordsResponse} ContractGetRecordsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractGetRecordsResponse.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.ContractGetRecordsResponse();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.contractID = $root.proto.ContractID.decode(r, r.uint32());
                        break;
                    }
                    case 3: {
                        if (!(m.records && m.records.length)) m.records = [];
                        m.records.push($root.proto.TransactionRecord.decode(r, r.uint32()));
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ContractGetRecordsResponse
         * @function getTypeUrl
         * @memberof proto.ContractGetRecordsResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ContractGetRecordsResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ContractGetRecordsResponse";
        };

        return ContractGetRecordsResponse;
    })();

    proto.TransactionRecord = (function () {
        /**
         * Properties of a TransactionRecord.
         * @memberof proto
         * @interface ITransactionRecord
         * @property {proto.ITransactionReceipt|null} [receipt] The status (reach consensus, or failed, or is unknown) and the ID of any new
         * account/file/instance created.
         * @property {Uint8Array|null} [transactionHash] The hash of the Transaction that executed (not the hash of any Transaction that failed for
         * having a duplicate TransactionID)
         * @property {proto.ITimestamp|null} [consensusTimestamp] The consensus timestamp (or null if didn't reach consensus yet)
         * @property {proto.ITransactionID|null} [transactionID] The ID of the transaction this record represents
         * @property {string|null} [memo] The memo that was submitted as part of the transaction (max 100 bytes)
         * @property {Long|null} [transactionFee] The actual transaction fee charged, not the original transactionFee value from
         * TransactionBody
         * @property {proto.IContractFunctionResult|null} [contractCallResult] Record of the value returned by the smart contract function (if it completed and didn't
         * fail) from ContractCallTransaction
         * @property {proto.IContractFunctionResult|null} [contractCreateResult] Record of the value returned by the smart contract constructor (if it completed and
         * didn't fail) from ContractCreateTransaction
         * @property {proto.ITransferList|null} [transferList] All hbar transfers as a result of this transaction, such as fees, or transfers performed by
         * the transaction, or by a smart contract it calls, or by the creation of threshold records
         * that it triggers.
         * @property {Array.<proto.ITokenTransferList>|null} [tokenTransferLists] All Token transfers as a result of this transaction
         * @property {proto.IScheduleID|null} [scheduleRef] Reference to the scheduled transaction ID that this transaction record represent
         * @property {Array.<proto.IAssessedCustomFee>|null} [assessedCustomFees] All custom fees that were assessed during a CryptoTransfer, and must be paid if the
         * transaction status resolved to SUCCESS
         * @property {Array.<proto.ITokenAssociation>|null} [automaticTokenAssociations] All token associations implicitly created while handling this transaction
         * @property {proto.ITimestamp|null} [parentConsensusTimestamp] In the record of an internal transaction, the consensus timestamp of the user
         * transaction that spawned it.
         * @property {Uint8Array|null} [alias] In the record of a CryptoCreate transaction triggered by a user transaction with a
         * (previously unused) alias, the new account's alias.
         * @property {Uint8Array|null} [ethereumHash] The keccak256 hash of the ethereumData. This field will only be populated for
         * EthereumTransaction.
         * @property {Array.<proto.IAccountAmount>|null} [paidStakingRewards] List of accounts with the corresponding staking rewards paid as a result of a transaction.
         * @property {Uint8Array|null} [prngBytes] In the record of a UtilPrng transaction with no output range, a pseudorandom 384-bit string.
         * @property {number|null} [prngNumber] In the record of a PRNG transaction with an output range, the output of a PRNG whose input was a 384-bit string.
         * @property {Uint8Array|null} [evmAddress] The new default EVM address of the account created by this transaction.
         * This field is populated only when the EVM address is not specified in the related transaction body.
         */

        /**
         * Constructs a new TransactionRecord.
         * @memberof proto
         * @classdesc Response when the client sends the node TransactionGetRecordResponse
         * @implements ITransactionRecord
         * @constructor
         * @param {proto.ITransactionRecord=} [p] Properties to set
         */
        function TransactionRecord(p) {
            this.tokenTransferLists = [];
            this.assessedCustomFees = [];
            this.automaticTokenAssociations = [];
            this.paidStakingRewards = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The status (reach consensus, or failed, or is unknown) and the ID of any new
         * account/file/instance created.
         * @member {proto.ITransactionReceipt|null|undefined} receipt
         * @memberof proto.TransactionRecord
         * @instance
         */
        TransactionRecord.prototype.receipt = null;

        /**
         * The hash of the Transaction that executed (not the hash of any Transaction that failed for
         * having a duplicate TransactionID)
         * @member {Uint8Array} transactionHash
         * @memberof proto.TransactionRecord
         * @instance
         */
        TransactionRecord.prototype.transactionHash = $util.newBuffer([]);

        /**
         * The consensus timestamp (or null if didn't reach consensus yet)
         * @member {proto.ITimestamp|null|undefined} consensusTimestamp
         * @memberof proto.TransactionRecord
         * @instance
         */
        TransactionRecord.prototype.consensusTimestamp = null;

        /**
         * The ID of the transaction this record represents
         * @member {proto.ITransactionID|null|undefined} transactionID
         * @memberof proto.TransactionRecord
         * @instance
         */
        TransactionRecord.prototype.transactionID = null;

        /**
         * The memo that was submitted as part of the transaction (max 100 bytes)
         * @member {string} memo
         * @memberof proto.TransactionRecord
         * @instance
         */
        TransactionRecord.prototype.memo = "";

        /**
         * The actual transaction fee charged, not the original transactionFee value from
         * TransactionBody
         * @member {Long} transactionFee
         * @memberof proto.TransactionRecord
         * @instance
         */
        TransactionRecord.prototype.transactionFee = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * Record of the value returned by the smart contract function (if it completed and didn't
         * fail) from ContractCallTransaction
         * @member {proto.IContractFunctionResult|null|undefined} contractCallResult
         * @memberof proto.TransactionRecord
         * @instance
         */
        TransactionRecord.prototype.contractCallResult = null;

        /**
         * Record of the value returned by the smart contract constructor (if it completed and
         * didn't fail) from ContractCreateTransaction
         * @member {proto.IContractFunctionResult|null|undefined} contractCreateResult
         * @memberof proto.TransactionRecord
         * @instance
         */
        TransactionRecord.prototype.contractCreateResult = null;

        /**
         * All hbar transfers as a result of this transaction, such as fees, or transfers performed by
         * the transaction, or by a smart contract it calls, or by the creation of threshold records
         * that it triggers.
         * @member {proto.ITransferList|null|undefined} transferList
         * @memberof proto.TransactionRecord
         * @instance
         */
        TransactionRecord.prototype.transferList = null;

        /**
         * All Token transfers as a result of this transaction
         * @member {Array.<proto.ITokenTransferList>} tokenTransferLists
         * @memberof proto.TransactionRecord
         * @instance
         */
        TransactionRecord.prototype.tokenTransferLists = $util.emptyArray;

        /**
         * Reference to the scheduled transaction ID that this transaction record represent
         * @member {proto.IScheduleID|null|undefined} scheduleRef
         * @memberof proto.TransactionRecord
         * @instance
         */
        TransactionRecord.prototype.scheduleRef = null;

        /**
         * All custom fees that were assessed during a CryptoTransfer, and must be paid if the
         * transaction status resolved to SUCCESS
         * @member {Array.<proto.IAssessedCustomFee>} assessedCustomFees
         * @memberof proto.TransactionRecord
         * @instance
         */
        TransactionRecord.prototype.assessedCustomFees = $util.emptyArray;

        /**
         * All token associations implicitly created while handling this transaction
         * @member {Array.<proto.ITokenAssociation>} automaticTokenAssociations
         * @memberof proto.TransactionRecord
         * @instance
         */
        TransactionRecord.prototype.automaticTokenAssociations = $util.emptyArray;

        /**
         * In the record of an internal transaction, the consensus timestamp of the user
         * transaction that spawned it.
         * @member {proto.ITimestamp|null|undefined} parentConsensusTimestamp
         * @memberof proto.TransactionRecord
         * @instance
         */
        TransactionRecord.prototype.parentConsensusTimestamp = null;

        /**
         * In the record of a CryptoCreate transaction triggered by a user transaction with a
         * (previously unused) alias, the new account's alias.
         * @member {Uint8Array} alias
         * @memberof proto.TransactionRecord
         * @instance
         */
        TransactionRecord.prototype.alias = $util.newBuffer([]);

        /**
         * The keccak256 hash of the ethereumData. This field will only be populated for
         * EthereumTransaction.
         * @member {Uint8Array} ethereumHash
         * @memberof proto.TransactionRecord
         * @instance
         */
        TransactionRecord.prototype.ethereumHash = $util.newBuffer([]);

        /**
         * List of accounts with the corresponding staking rewards paid as a result of a transaction.
         * @member {Array.<proto.IAccountAmount>} paidStakingRewards
         * @memberof proto.TransactionRecord
         * @instance
         */
        TransactionRecord.prototype.paidStakingRewards = $util.emptyArray;

        /**
         * In the record of a UtilPrng transaction with no output range, a pseudorandom 384-bit string.
         * @member {Uint8Array|null|undefined} prngBytes
         * @memberof proto.TransactionRecord
         * @instance
         */
        TransactionRecord.prototype.prngBytes = null;

        /**
         * In the record of a PRNG transaction with an output range, the output of a PRNG whose input was a 384-bit string.
         * @member {number|null|undefined} prngNumber
         * @memberof proto.TransactionRecord
         * @instance
         */
        TransactionRecord.prototype.prngNumber = null;

        /**
         * The new default EVM address of the account created by this transaction.
         * This field is populated only when the EVM address is not specified in the related transaction body.
         * @member {Uint8Array} evmAddress
         * @memberof proto.TransactionRecord
         * @instance
         */
        TransactionRecord.prototype.evmAddress = $util.newBuffer([]);

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * TransactionRecord body.
         * @member {"contractCallResult"|"contractCreateResult"|undefined} body
         * @memberof proto.TransactionRecord
         * @instance
         */
        Object.defineProperty(TransactionRecord.prototype, "body", {
            get: $util.oneOfGetter(($oneOfFields = ["contractCallResult", "contractCreateResult"])),
            set: $util.oneOfSetter($oneOfFields),
        });

        /**
         * TransactionRecord entropy.
         * @member {"prngBytes"|"prngNumber"|undefined} entropy
         * @memberof proto.TransactionRecord
         * @instance
         */
        Object.defineProperty(TransactionRecord.prototype, "entropy", {
            get: $util.oneOfGetter(($oneOfFields = ["prngBytes", "prngNumber"])),
            set: $util.oneOfSetter($oneOfFields),
        });

        /**
         * Creates a new TransactionRecord instance using the specified properties.
         * @function create
         * @memberof proto.TransactionRecord
         * @static
         * @param {proto.ITransactionRecord=} [properties] Properties to set
         * @returns {proto.TransactionRecord} TransactionRecord instance
         */
        TransactionRecord.create = function create(properties) {
            return new TransactionRecord(properties);
        };

        /**
         * Encodes the specified TransactionRecord message. Does not implicitly {@link proto.TransactionRecord.verify|verify} messages.
         * @function encode
         * @memberof proto.TransactionRecord
         * @static
         * @param {proto.ITransactionRecord} m TransactionRecord message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionRecord.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.receipt != null && Object.hasOwnProperty.call(m, "receipt"))
                $root.proto.TransactionReceipt.encode(m.receipt, w.uint32(10).fork()).ldelim();
            if (m.transactionHash != null && Object.hasOwnProperty.call(m, "transactionHash"))
                w.uint32(18).bytes(m.transactionHash);
            if (m.consensusTimestamp != null && Object.hasOwnProperty.call(m, "consensusTimestamp"))
                $root.proto.Timestamp.encode(m.consensusTimestamp, w.uint32(26).fork()).ldelim();
            if (m.transactionID != null && Object.hasOwnProperty.call(m, "transactionID"))
                $root.proto.TransactionID.encode(m.transactionID, w.uint32(34).fork()).ldelim();
            if (m.memo != null && Object.hasOwnProperty.call(m, "memo")) w.uint32(42).string(m.memo);
            if (m.transactionFee != null && Object.hasOwnProperty.call(m, "transactionFee"))
                w.uint32(48).uint64(m.transactionFee);
            if (m.contractCallResult != null && Object.hasOwnProperty.call(m, "contractCallResult"))
                $root.proto.ContractFunctionResult.encode(m.contractCallResult, w.uint32(58).fork()).ldelim();
            if (m.contractCreateResult != null && Object.hasOwnProperty.call(m, "contractCreateResult"))
                $root.proto.ContractFunctionResult.encode(m.contractCreateResult, w.uint32(66).fork()).ldelim();
            if (m.transferList != null && Object.hasOwnProperty.call(m, "transferList"))
                $root.proto.TransferList.encode(m.transferList, w.uint32(82).fork()).ldelim();
            if (m.tokenTransferLists != null && m.tokenTransferLists.length) {
                for (var i = 0; i < m.tokenTransferLists.length; ++i)
                    $root.proto.TokenTransferList.encode(m.tokenTransferLists[i], w.uint32(90).fork()).ldelim();
            }
            if (m.scheduleRef != null && Object.hasOwnProperty.call(m, "scheduleRef"))
                $root.proto.ScheduleID.encode(m.scheduleRef, w.uint32(98).fork()).ldelim();
            if (m.assessedCustomFees != null && m.assessedCustomFees.length) {
                for (var i = 0; i < m.assessedCustomFees.length; ++i)
                    $root.proto.AssessedCustomFee.encode(m.assessedCustomFees[i], w.uint32(106).fork()).ldelim();
            }
            if (m.automaticTokenAssociations != null && m.automaticTokenAssociations.length) {
                for (var i = 0; i < m.automaticTokenAssociations.length; ++i)
                    $root.proto.TokenAssociation.encode(m.automaticTokenAssociations[i], w.uint32(114).fork()).ldelim();
            }
            if (m.parentConsensusTimestamp != null && Object.hasOwnProperty.call(m, "parentConsensusTimestamp"))
                $root.proto.Timestamp.encode(m.parentConsensusTimestamp, w.uint32(122).fork()).ldelim();
            if (m.alias != null && Object.hasOwnProperty.call(m, "alias")) w.uint32(130).bytes(m.alias);
            if (m.ethereumHash != null && Object.hasOwnProperty.call(m, "ethereumHash"))
                w.uint32(138).bytes(m.ethereumHash);
            if (m.paidStakingRewards != null && m.paidStakingRewards.length) {
                for (var i = 0; i < m.paidStakingRewards.length; ++i)
                    $root.proto.AccountAmount.encode(m.paidStakingRewards[i], w.uint32(146).fork()).ldelim();
            }
            if (m.prngBytes != null && Object.hasOwnProperty.call(m, "prngBytes")) w.uint32(154).bytes(m.prngBytes);
            if (m.prngNumber != null && Object.hasOwnProperty.call(m, "prngNumber")) w.uint32(160).int32(m.prngNumber);
            if (m.evmAddress != null && Object.hasOwnProperty.call(m, "evmAddress")) w.uint32(170).bytes(m.evmAddress);
            return w;
        };

        /**
         * Decodes a TransactionRecord message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TransactionRecord
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TransactionRecord} TransactionRecord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionRecord.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.TransactionRecord();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.receipt = $root.proto.TransactionReceipt.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.transactionHash = r.bytes();
                        break;
                    }
                    case 3: {
                        m.consensusTimestamp = $root.proto.Timestamp.decode(r, r.uint32());
                        break;
                    }
                    case 4: {
                        m.transactionID = $root.proto.TransactionID.decode(r, r.uint32());
                        break;
                    }
                    case 5: {
                        m.memo = r.string();
                        break;
                    }
                    case 6: {
                        m.transactionFee = r.uint64();
                        break;
                    }
                    case 7: {
                        m.contractCallResult = $root.proto.ContractFunctionResult.decode(r, r.uint32());
                        break;
                    }
                    case 8: {
                        m.contractCreateResult = $root.proto.ContractFunctionResult.decode(r, r.uint32());
                        break;
                    }
                    case 10: {
                        m.transferList = $root.proto.TransferList.decode(r, r.uint32());
                        break;
                    }
                    case 11: {
                        if (!(m.tokenTransferLists && m.tokenTransferLists.length)) m.tokenTransferLists = [];
                        m.tokenTransferLists.push($root.proto.TokenTransferList.decode(r, r.uint32()));
                        break;
                    }
                    case 12: {
                        m.scheduleRef = $root.proto.ScheduleID.decode(r, r.uint32());
                        break;
                    }
                    case 13: {
                        if (!(m.assessedCustomFees && m.assessedCustomFees.length)) m.assessedCustomFees = [];
                        m.assessedCustomFees.push($root.proto.AssessedCustomFee.decode(r, r.uint32()));
                        break;
                    }
                    case 14: {
                        if (!(m.automaticTokenAssociations && m.automaticTokenAssociations.length))
                            m.automaticTokenAssociations = [];
                        m.automaticTokenAssociations.push($root.proto.TokenAssociation.decode(r, r.uint32()));
                        break;
                    }
                    case 15: {
                        m.parentConsensusTimestamp = $root.proto.Timestamp.decode(r, r.uint32());
                        break;
                    }
                    case 16: {
                        m.alias = r.bytes();
                        break;
                    }
                    case 17: {
                        m.ethereumHash = r.bytes();
                        break;
                    }
                    case 18: {
                        if (!(m.paidStakingRewards && m.paidStakingRewards.length)) m.paidStakingRewards = [];
                        m.paidStakingRewards.push($root.proto.AccountAmount.decode(r, r.uint32()));
                        break;
                    }
                    case 19: {
                        m.prngBytes = r.bytes();
                        break;
                    }
                    case 20: {
                        m.prngNumber = r.int32();
                        break;
                    }
                    case 21: {
                        m.evmAddress = r.bytes();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TransactionRecord
         * @function getTypeUrl
         * @memberof proto.TransactionRecord
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TransactionRecord.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TransactionRecord";
        };

        return TransactionRecord;
    })();

    proto.TransactionReceipt = (function () {
        /**
         * Properties of a TransactionReceipt.
         * @memberof proto
         * @interface ITransactionReceipt
         * @property {proto.ResponseCodeEnum|null} [status] The consensus status of the transaction; is UNKNOWN if consensus has not been reached, or if
         * the associated transaction did not have a valid payer signature
         * @property {proto.IAccountID|null} [accountID] In the receipt of a CryptoCreate, the id of the newly created account
         * @property {proto.IFileID|null} [fileID] In the receipt of a FileCreate, the id of the newly created file
         * @property {proto.IContractID|null} [contractID] In the receipt of a ContractCreate, the id of the newly created contract
         * @property {proto.IExchangeRateSet|null} [exchangeRate] The exchange rates in effect when the transaction reached consensus
         * @property {proto.ITopicID|null} [topicID] In the receipt of a ConsensusCreateTopic, the id of the newly created topic.
         * @property {Long|null} [topicSequenceNumber] In the receipt of a ConsensusSubmitMessage, the new sequence number of the topic that
         * received the message
         * @property {Uint8Array|null} [topicRunningHash] In the receipt of a ConsensusSubmitMessage, the new running hash of the topic that received
         * the message.  This 48-byte field is the output of a particular SHA-384 digest whose input
         * data are determined by the value of the topicRunningHashVersion below. The bytes of each
         * uint64 or uint32 are to be in Big-Endian format.
         *
         * IF the topicRunningHashVersion is '0' or '1', then the input data to the SHA-384 digest are,
         * in order:
         * ---
         * 1. The previous running hash of the topic (48 bytes)
         * 2. The topic's shard (8 bytes)
         * 3. The topic's realm (8 bytes)
         * 4. The topic's number (8 bytes)
         * 5. The number of seconds since the epoch before the ConsensusSubmitMessage reached
         * consensus (8 bytes)
         * 6. The number of nanoseconds since 5. before the ConsensusSubmitMessage reached
         * consensus (4 bytes)
         * 7. The topicSequenceNumber from above (8 bytes)
         * 8. The message bytes from the ConsensusSubmitMessage (variable).
         *
         * IF the topicRunningHashVersion is '2', then the input data to the SHA-384 digest are, in
         * order:
         * ---
         * 1. The previous running hash of the topic (48 bytes)
         * 2. The topicRunningHashVersion below (8 bytes)
         * 3. The topic's shard (8 bytes)
         * 4. The topic's realm (8 bytes)
         * 5. The topic's number (8 bytes)
         * 6. The number of seconds since the epoch before the ConsensusSubmitMessage reached
         * consensus (8 bytes)
         * 7. The number of nanoseconds since 6. before the ConsensusSubmitMessage reached
         * consensus (4 bytes)
         * 8. The topicSequenceNumber from above (8 bytes)
         * 9. The output of the SHA-384 digest of the message bytes from the
         * consensusSubmitMessage (48 bytes)
         *
         * Otherwise, IF the topicRunningHashVersion is '3', then the input data to the SHA-384 digest
         * are, in order:
         * ---
         * 1. The previous running hash of the topic (48 bytes)
         * 2. The topicRunningHashVersion below (8 bytes)
         * 3. The payer account's shard (8 bytes)
         * 4. The payer account's realm (8 bytes)
         * 5. The payer account's number (8 bytes)
         * 6. The topic's shard (8 bytes)
         * 7. The topic's realm (8 bytes)
         * 8. The topic's number (8 bytes)
         * 9. The number of seconds since the epoch before the ConsensusSubmitMessage reached
         * consensus (8 bytes)
         * 10. The number of nanoseconds since 9. before the ConsensusSubmitMessage reached
         * consensus (4 bytes)
         * 11. The topicSequenceNumber from above (8 bytes)
         * 12. The output of the SHA-384 digest of the message bytes from the
         * consensusSubmitMessage (48 bytes)
         * @property {Long|null} [topicRunningHashVersion] In the receipt of a ConsensusSubmitMessage, the version of the SHA-384 digest used to update
         * the running hash.
         * @property {proto.ITokenID|null} [tokenID] In the receipt of a CreateToken, the id of the newly created token
         * @property {Long|null} [newTotalSupply] In the receipt of TokenMint, TokenWipe, TokenBurn, For fungible tokens - the current total
         * supply of this token. For non fungible tokens - the total number of NFTs issued for a given
         * tokenID
         * @property {proto.IScheduleID|null} [scheduleID] In the receipt of a ScheduleCreate, the id of the newly created Scheduled Entity
         * @property {proto.ITransactionID|null} [scheduledTransactionID] In the receipt of a ScheduleCreate or ScheduleSign that resolves to SUCCESS, the
         * TransactionID that should be used to query for the receipt or record of the relevant
         * scheduled transaction
         * @property {Array.<Long>|null} [serialNumbers] In the receipt of a TokenMint for tokens of type NON_FUNGIBLE_UNIQUE, the serial numbers of
         * the newly created NFTs
         */

        /**
         * Constructs a new TransactionReceipt.
         * @memberof proto
         * @classdesc The summary of a transaction's result so far. If the transaction has not reached consensus, this
         * result will be necessarily incomplete.
         * @implements ITransactionReceipt
         * @constructor
         * @param {proto.ITransactionReceipt=} [p] Properties to set
         */
        function TransactionReceipt(p) {
            this.serialNumbers = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The consensus status of the transaction; is UNKNOWN if consensus has not been reached, or if
         * the associated transaction did not have a valid payer signature
         * @member {proto.ResponseCodeEnum} status
         * @memberof proto.TransactionReceipt
         * @instance
         */
        TransactionReceipt.prototype.status = 0;

        /**
         * In the receipt of a CryptoCreate, the id of the newly created account
         * @member {proto.IAccountID|null|undefined} accountID
         * @memberof proto.TransactionReceipt
         * @instance
         */
        TransactionReceipt.prototype.accountID = null;

        /**
         * In the receipt of a FileCreate, the id of the newly created file
         * @member {proto.IFileID|null|undefined} fileID
         * @memberof proto.TransactionReceipt
         * @instance
         */
        TransactionReceipt.prototype.fileID = null;

        /**
         * In the receipt of a ContractCreate, the id of the newly created contract
         * @member {proto.IContractID|null|undefined} contractID
         * @memberof proto.TransactionReceipt
         * @instance
         */
        TransactionReceipt.prototype.contractID = null;

        /**
         * The exchange rates in effect when the transaction reached consensus
         * @member {proto.IExchangeRateSet|null|undefined} exchangeRate
         * @memberof proto.TransactionReceipt
         * @instance
         */
        TransactionReceipt.prototype.exchangeRate = null;

        /**
         * In the receipt of a ConsensusCreateTopic, the id of the newly created topic.
         * @member {proto.ITopicID|null|undefined} topicID
         * @memberof proto.TransactionReceipt
         * @instance
         */
        TransactionReceipt.prototype.topicID = null;

        /**
         * In the receipt of a ConsensusSubmitMessage, the new sequence number of the topic that
         * received the message
         * @member {Long} topicSequenceNumber
         * @memberof proto.TransactionReceipt
         * @instance
         */
        TransactionReceipt.prototype.topicSequenceNumber = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * In the receipt of a ConsensusSubmitMessage, the new running hash of the topic that received
         * the message.  This 48-byte field is the output of a particular SHA-384 digest whose input
         * data are determined by the value of the topicRunningHashVersion below. The bytes of each
         * uint64 or uint32 are to be in Big-Endian format.
         *
         * IF the topicRunningHashVersion is '0' or '1', then the input data to the SHA-384 digest are,
         * in order:
         * ---
         * 1. The previous running hash of the topic (48 bytes)
         * 2. The topic's shard (8 bytes)
         * 3. The topic's realm (8 bytes)
         * 4. The topic's number (8 bytes)
         * 5. The number of seconds since the epoch before the ConsensusSubmitMessage reached
         * consensus (8 bytes)
         * 6. The number of nanoseconds since 5. before the ConsensusSubmitMessage reached
         * consensus (4 bytes)
         * 7. The topicSequenceNumber from above (8 bytes)
         * 8. The message bytes from the ConsensusSubmitMessage (variable).
         *
         * IF the topicRunningHashVersion is '2', then the input data to the SHA-384 digest are, in
         * order:
         * ---
         * 1. The previous running hash of the topic (48 bytes)
         * 2. The topicRunningHashVersion below (8 bytes)
         * 3. The topic's shard (8 bytes)
         * 4. The topic's realm (8 bytes)
         * 5. The topic's number (8 bytes)
         * 6. The number of seconds since the epoch before the ConsensusSubmitMessage reached
         * consensus (8 bytes)
         * 7. The number of nanoseconds since 6. before the ConsensusSubmitMessage reached
         * consensus (4 bytes)
         * 8. The topicSequenceNumber from above (8 bytes)
         * 9. The output of the SHA-384 digest of the message bytes from the
         * consensusSubmitMessage (48 bytes)
         *
         * Otherwise, IF the topicRunningHashVersion is '3', then the input data to the SHA-384 digest
         * are, in order:
         * ---
         * 1. The previous running hash of the topic (48 bytes)
         * 2. The topicRunningHashVersion below (8 bytes)
         * 3. The payer account's shard (8 bytes)
         * 4. The payer account's realm (8 bytes)
         * 5. The payer account's number (8 bytes)
         * 6. The topic's shard (8 bytes)
         * 7. The topic's realm (8 bytes)
         * 8. The topic's number (8 bytes)
         * 9. The number of seconds since the epoch before the ConsensusSubmitMessage reached
         * consensus (8 bytes)
         * 10. The number of nanoseconds since 9. before the ConsensusSubmitMessage reached
         * consensus (4 bytes)
         * 11. The topicSequenceNumber from above (8 bytes)
         * 12. The output of the SHA-384 digest of the message bytes from the
         * consensusSubmitMessage (48 bytes)
         * @member {Uint8Array} topicRunningHash
         * @memberof proto.TransactionReceipt
         * @instance
         */
        TransactionReceipt.prototype.topicRunningHash = $util.newBuffer([]);

        /**
         * In the receipt of a ConsensusSubmitMessage, the version of the SHA-384 digest used to update
         * the running hash.
         * @member {Long} topicRunningHashVersion
         * @memberof proto.TransactionReceipt
         * @instance
         */
        TransactionReceipt.prototype.topicRunningHashVersion = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * In the receipt of a CreateToken, the id of the newly created token
         * @member {proto.ITokenID|null|undefined} tokenID
         * @memberof proto.TransactionReceipt
         * @instance
         */
        TransactionReceipt.prototype.tokenID = null;

        /**
         * In the receipt of TokenMint, TokenWipe, TokenBurn, For fungible tokens - the current total
         * supply of this token. For non fungible tokens - the total number of NFTs issued for a given
         * tokenID
         * @member {Long} newTotalSupply
         * @memberof proto.TransactionReceipt
         * @instance
         */
        TransactionReceipt.prototype.newTotalSupply = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * In the receipt of a ScheduleCreate, the id of the newly created Scheduled Entity
         * @member {proto.IScheduleID|null|undefined} scheduleID
         * @memberof proto.TransactionReceipt
         * @instance
         */
        TransactionReceipt.prototype.scheduleID = null;

        /**
         * In the receipt of a ScheduleCreate or ScheduleSign that resolves to SUCCESS, the
         * TransactionID that should be used to query for the receipt or record of the relevant
         * scheduled transaction
         * @member {proto.ITransactionID|null|undefined} scheduledTransactionID
         * @memberof proto.TransactionReceipt
         * @instance
         */
        TransactionReceipt.prototype.scheduledTransactionID = null;

        /**
         * In the receipt of a TokenMint for tokens of type NON_FUNGIBLE_UNIQUE, the serial numbers of
         * the newly created NFTs
         * @member {Array.<Long>} serialNumbers
         * @memberof proto.TransactionReceipt
         * @instance
         */
        TransactionReceipt.prototype.serialNumbers = $util.emptyArray;

        /**
         * Creates a new TransactionReceipt instance using the specified properties.
         * @function create
         * @memberof proto.TransactionReceipt
         * @static
         * @param {proto.ITransactionReceipt=} [properties] Properties to set
         * @returns {proto.TransactionReceipt} TransactionReceipt instance
         */
        TransactionReceipt.create = function create(properties) {
            return new TransactionReceipt(properties);
        };

        /**
         * Encodes the specified TransactionReceipt message. Does not implicitly {@link proto.TransactionReceipt.verify|verify} messages.
         * @function encode
         * @memberof proto.TransactionReceipt
         * @static
         * @param {proto.ITransactionReceipt} m TransactionReceipt message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionReceipt.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.status != null && Object.hasOwnProperty.call(m, "status")) w.uint32(8).int32(m.status);
            if (m.accountID != null && Object.hasOwnProperty.call(m, "accountID"))
                $root.proto.AccountID.encode(m.accountID, w.uint32(18).fork()).ldelim();
            if (m.fileID != null && Object.hasOwnProperty.call(m, "fileID"))
                $root.proto.FileID.encode(m.fileID, w.uint32(26).fork()).ldelim();
            if (m.contractID != null && Object.hasOwnProperty.call(m, "contractID"))
                $root.proto.ContractID.encode(m.contractID, w.uint32(34).fork()).ldelim();
            if (m.exchangeRate != null && Object.hasOwnProperty.call(m, "exchangeRate"))
                $root.proto.ExchangeRateSet.encode(m.exchangeRate, w.uint32(42).fork()).ldelim();
            if (m.topicID != null && Object.hasOwnProperty.call(m, "topicID"))
                $root.proto.TopicID.encode(m.topicID, w.uint32(50).fork()).ldelim();
            if (m.topicSequenceNumber != null && Object.hasOwnProperty.call(m, "topicSequenceNumber"))
                w.uint32(56).uint64(m.topicSequenceNumber);
            if (m.topicRunningHash != null && Object.hasOwnProperty.call(m, "topicRunningHash"))
                w.uint32(66).bytes(m.topicRunningHash);
            if (m.topicRunningHashVersion != null && Object.hasOwnProperty.call(m, "topicRunningHashVersion"))
                w.uint32(72).uint64(m.topicRunningHashVersion);
            if (m.tokenID != null && Object.hasOwnProperty.call(m, "tokenID"))
                $root.proto.TokenID.encode(m.tokenID, w.uint32(82).fork()).ldelim();
            if (m.newTotalSupply != null && Object.hasOwnProperty.call(m, "newTotalSupply"))
                w.uint32(88).uint64(m.newTotalSupply);
            if (m.scheduleID != null && Object.hasOwnProperty.call(m, "scheduleID"))
                $root.proto.ScheduleID.encode(m.scheduleID, w.uint32(98).fork()).ldelim();
            if (m.scheduledTransactionID != null && Object.hasOwnProperty.call(m, "scheduledTransactionID"))
                $root.proto.TransactionID.encode(m.scheduledTransactionID, w.uint32(106).fork()).ldelim();
            if (m.serialNumbers != null && m.serialNumbers.length) {
                w.uint32(114).fork();
                for (var i = 0; i < m.serialNumbers.length; ++i) w.int64(m.serialNumbers[i]);
                w.ldelim();
            }
            return w;
        };

        /**
         * Decodes a TransactionReceipt message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TransactionReceipt
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TransactionReceipt} TransactionReceipt
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionReceipt.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.TransactionReceipt();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.status = r.int32();
                        break;
                    }
                    case 2: {
                        m.accountID = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    case 3: {
                        m.fileID = $root.proto.FileID.decode(r, r.uint32());
                        break;
                    }
                    case 4: {
                        m.contractID = $root.proto.ContractID.decode(r, r.uint32());
                        break;
                    }
                    case 5: {
                        m.exchangeRate = $root.proto.ExchangeRateSet.decode(r, r.uint32());
                        break;
                    }
                    case 6: {
                        m.topicID = $root.proto.TopicID.decode(r, r.uint32());
                        break;
                    }
                    case 7: {
                        m.topicSequenceNumber = r.uint64();
                        break;
                    }
                    case 8: {
                        m.topicRunningHash = r.bytes();
                        break;
                    }
                    case 9: {
                        m.topicRunningHashVersion = r.uint64();
                        break;
                    }
                    case 10: {
                        m.tokenID = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                    case 11: {
                        m.newTotalSupply = r.uint64();
                        break;
                    }
                    case 12: {
                        m.scheduleID = $root.proto.ScheduleID.decode(r, r.uint32());
                        break;
                    }
                    case 13: {
                        m.scheduledTransactionID = $root.proto.TransactionID.decode(r, r.uint32());
                        break;
                    }
                    case 14: {
                        if (!(m.serialNumbers && m.serialNumbers.length)) m.serialNumbers = [];
                        if ((t & 7) === 2) {
                            var c2 = r.uint32() + r.pos;
                            while (r.pos < c2) m.serialNumbers.push(r.int64());
                        } else m.serialNumbers.push(r.int64());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TransactionReceipt
         * @function getTypeUrl
         * @memberof proto.TransactionReceipt
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TransactionReceipt.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TransactionReceipt";
        };

        return TransactionReceipt;
    })();

    proto.ExchangeRate = (function () {
        /**
         * Properties of an ExchangeRate.
         * @memberof proto
         * @interface IExchangeRate
         * @property {number|null} [hbarEquiv] Denominator in calculation of exchange rate between hbar and cents
         * @property {number|null} [centEquiv] Numerator in calculation of exchange rate between hbar and cents
         * @property {proto.ITimestampSeconds|null} [expirationTime] Expiration time in seconds for this exchange rate
         */

        /**
         * Constructs a new ExchangeRate.
         * @memberof proto
         * @classdesc An exchange rate between hbar and cents (USD) and the time at which the exchange rate will
         * expire, and be superseded by a new exchange rate.
         * @implements IExchangeRate
         * @constructor
         * @param {proto.IExchangeRate=} [p] Properties to set
         */
        function ExchangeRate(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * Denominator in calculation of exchange rate between hbar and cents
         * @member {number} hbarEquiv
         * @memberof proto.ExchangeRate
         * @instance
         */
        ExchangeRate.prototype.hbarEquiv = 0;

        /**
         * Numerator in calculation of exchange rate between hbar and cents
         * @member {number} centEquiv
         * @memberof proto.ExchangeRate
         * @instance
         */
        ExchangeRate.prototype.centEquiv = 0;

        /**
         * Expiration time in seconds for this exchange rate
         * @member {proto.ITimestampSeconds|null|undefined} expirationTime
         * @memberof proto.ExchangeRate
         * @instance
         */
        ExchangeRate.prototype.expirationTime = null;

        /**
         * Creates a new ExchangeRate instance using the specified properties.
         * @function create
         * @memberof proto.ExchangeRate
         * @static
         * @param {proto.IExchangeRate=} [properties] Properties to set
         * @returns {proto.ExchangeRate} ExchangeRate instance
         */
        ExchangeRate.create = function create(properties) {
            return new ExchangeRate(properties);
        };

        /**
         * Encodes the specified ExchangeRate message. Does not implicitly {@link proto.ExchangeRate.verify|verify} messages.
         * @function encode
         * @memberof proto.ExchangeRate
         * @static
         * @param {proto.IExchangeRate} m ExchangeRate message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExchangeRate.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.hbarEquiv != null && Object.hasOwnProperty.call(m, "hbarEquiv")) w.uint32(8).int32(m.hbarEquiv);
            if (m.centEquiv != null && Object.hasOwnProperty.call(m, "centEquiv")) w.uint32(16).int32(m.centEquiv);
            if (m.expirationTime != null && Object.hasOwnProperty.call(m, "expirationTime"))
                $root.proto.TimestampSeconds.encode(m.expirationTime, w.uint32(26).fork()).ldelim();
            return w;
        };

        /**
         * Decodes an ExchangeRate message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ExchangeRate
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ExchangeRate} ExchangeRate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExchangeRate.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.ExchangeRate();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.hbarEquiv = r.int32();
                        break;
                    }
                    case 2: {
                        m.centEquiv = r.int32();
                        break;
                    }
                    case 3: {
                        m.expirationTime = $root.proto.TimestampSeconds.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ExchangeRate
         * @function getTypeUrl
         * @memberof proto.ExchangeRate
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ExchangeRate.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ExchangeRate";
        };

        return ExchangeRate;
    })();

    proto.ExchangeRateSet = (function () {
        /**
         * Properties of an ExchangeRateSet.
         * @memberof proto
         * @interface IExchangeRateSet
         * @property {proto.IExchangeRate|null} [currentRate] Current exchange rate
         * @property {proto.IExchangeRate|null} [nextRate] Next exchange rate which will take effect when current rate expires
         */

        /**
         * Constructs a new ExchangeRateSet.
         * @memberof proto
         * @classdesc Two sets of exchange rates
         * @implements IExchangeRateSet
         * @constructor
         * @param {proto.IExchangeRateSet=} [p] Properties to set
         */
        function ExchangeRateSet(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * Current exchange rate
         * @member {proto.IExchangeRate|null|undefined} currentRate
         * @memberof proto.ExchangeRateSet
         * @instance
         */
        ExchangeRateSet.prototype.currentRate = null;

        /**
         * Next exchange rate which will take effect when current rate expires
         * @member {proto.IExchangeRate|null|undefined} nextRate
         * @memberof proto.ExchangeRateSet
         * @instance
         */
        ExchangeRateSet.prototype.nextRate = null;

        /**
         * Creates a new ExchangeRateSet instance using the specified properties.
         * @function create
         * @memberof proto.ExchangeRateSet
         * @static
         * @param {proto.IExchangeRateSet=} [properties] Properties to set
         * @returns {proto.ExchangeRateSet} ExchangeRateSet instance
         */
        ExchangeRateSet.create = function create(properties) {
            return new ExchangeRateSet(properties);
        };

        /**
         * Encodes the specified ExchangeRateSet message. Does not implicitly {@link proto.ExchangeRateSet.verify|verify} messages.
         * @function encode
         * @memberof proto.ExchangeRateSet
         * @static
         * @param {proto.IExchangeRateSet} m ExchangeRateSet message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExchangeRateSet.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.currentRate != null && Object.hasOwnProperty.call(m, "currentRate"))
                $root.proto.ExchangeRate.encode(m.currentRate, w.uint32(10).fork()).ldelim();
            if (m.nextRate != null && Object.hasOwnProperty.call(m, "nextRate"))
                $root.proto.ExchangeRate.encode(m.nextRate, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes an ExchangeRateSet message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ExchangeRateSet
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ExchangeRateSet} ExchangeRateSet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExchangeRateSet.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.ExchangeRateSet();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.currentRate = $root.proto.ExchangeRate.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.nextRate = $root.proto.ExchangeRate.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ExchangeRateSet
         * @function getTypeUrl
         * @memberof proto.ExchangeRateSet
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ExchangeRateSet.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ExchangeRateSet";
        };

        return ExchangeRateSet;
    })();

    proto.CryptoGetAccountBalanceQuery = (function () {
        /**
         * Properties of a CryptoGetAccountBalanceQuery.
         * @memberof proto
         * @interface ICryptoGetAccountBalanceQuery
         * @property {proto.IQueryHeader|null} [header] Standard info sent from client to node, including the signed payment, and what kind of
         * response is requested (cost, state proof, both, or neither).
         * @property {proto.IAccountID|null} [accountID] * The account ID for which information is requested
         * @property {proto.IContractID|null} [contractID] * The account ID for which information is requested
         */

        /**
         * Constructs a new CryptoGetAccountBalanceQuery.
         * @memberof proto
         * @classdesc Get the balance of a cryptocurrency account. This returns only the balance, so it is a smaller
         * reply than CryptoGetInfo, which returns the balance plus additional information.
         * @implements ICryptoGetAccountBalanceQuery
         * @constructor
         * @param {proto.ICryptoGetAccountBalanceQuery=} [p] Properties to set
         */
        function CryptoGetAccountBalanceQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * Standard info sent from client to node, including the signed payment, and what kind of
         * response is requested (cost, state proof, both, or neither).
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.CryptoGetAccountBalanceQuery
         * @instance
         */
        CryptoGetAccountBalanceQuery.prototype.header = null;

        /**
         * * The account ID for which information is requested
         * @member {proto.IAccountID|null|undefined} accountID
         * @memberof proto.CryptoGetAccountBalanceQuery
         * @instance
         */
        CryptoGetAccountBalanceQuery.prototype.accountID = null;

        /**
         * * The account ID for which information is requested
         * @member {proto.IContractID|null|undefined} contractID
         * @memberof proto.CryptoGetAccountBalanceQuery
         * @instance
         */
        CryptoGetAccountBalanceQuery.prototype.contractID = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * CryptoGetAccountBalanceQuery balanceSource.
         * @member {"accountID"|"contractID"|undefined} balanceSource
         * @memberof proto.CryptoGetAccountBalanceQuery
         * @instance
         */
        Object.defineProperty(CryptoGetAccountBalanceQuery.prototype, "balanceSource", {
            get: $util.oneOfGetter(($oneOfFields = ["accountID", "contractID"])),
            set: $util.oneOfSetter($oneOfFields),
        });

        /**
         * Creates a new CryptoGetAccountBalanceQuery instance using the specified properties.
         * @function create
         * @memberof proto.CryptoGetAccountBalanceQuery
         * @static
         * @param {proto.ICryptoGetAccountBalanceQuery=} [properties] Properties to set
         * @returns {proto.CryptoGetAccountBalanceQuery} CryptoGetAccountBalanceQuery instance
         */
        CryptoGetAccountBalanceQuery.create = function create(properties) {
            return new CryptoGetAccountBalanceQuery(properties);
        };

        /**
         * Encodes the specified CryptoGetAccountBalanceQuery message. Does not implicitly {@link proto.CryptoGetAccountBalanceQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.CryptoGetAccountBalanceQuery
         * @static
         * @param {proto.ICryptoGetAccountBalanceQuery} m CryptoGetAccountBalanceQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CryptoGetAccountBalanceQuery.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.accountID != null && Object.hasOwnProperty.call(m, "accountID"))
                $root.proto.AccountID.encode(m.accountID, w.uint32(18).fork()).ldelim();
            if (m.contractID != null && Object.hasOwnProperty.call(m, "contractID"))
                $root.proto.ContractID.encode(m.contractID, w.uint32(26).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a CryptoGetAccountBalanceQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CryptoGetAccountBalanceQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.CryptoGetAccountBalanceQuery} CryptoGetAccountBalanceQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CryptoGetAccountBalanceQuery.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.CryptoGetAccountBalanceQuery();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.accountID = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    case 3: {
                        m.contractID = $root.proto.ContractID.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for CryptoGetAccountBalanceQuery
         * @function getTypeUrl
         * @memberof proto.CryptoGetAccountBalanceQuery
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CryptoGetAccountBalanceQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.CryptoGetAccountBalanceQuery";
        };

        return CryptoGetAccountBalanceQuery;
    })();

    proto.CryptoGetAccountBalanceResponse = (function () {
        /**
         * Properties of a CryptoGetAccountBalanceResponse.
         * @memberof proto
         * @interface ICryptoGetAccountBalanceResponse
         * @property {proto.IResponseHeader|null} [header] Standard response from node to client, including the requested fields: cost, or state proof,
         * or both, or neither.
         * @property {proto.IAccountID|null} [accountID] The account ID that is being described (this is useful with state proofs, for proving to a
         * third party)
         * @property {Long|null} [balance] The current balance, in tinybars.
         * @property {Array.<proto.ITokenBalance>|null} [tokenBalances] [DEPRECATED] The balances of the tokens associated to the account. This field was
         * deprecated by <a href="https://hips.hedera.com/hip/hip-367">HIP-367</a>, which allowed
         * an account to be associated to an unlimited number of tokens. This scale makes it more
         * efficient for users to consult mirror nodes to review their token balances.
         */

        /**
         * Constructs a new CryptoGetAccountBalanceResponse.
         * @memberof proto
         * @classdesc Response when the client sends the node CryptoGetAccountBalanceQuery
         * @implements ICryptoGetAccountBalanceResponse
         * @constructor
         * @param {proto.ICryptoGetAccountBalanceResponse=} [p] Properties to set
         */
        function CryptoGetAccountBalanceResponse(p) {
            this.tokenBalances = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * Standard response from node to client, including the requested fields: cost, or state proof,
         * or both, or neither.
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.CryptoGetAccountBalanceResponse
         * @instance
         */
        CryptoGetAccountBalanceResponse.prototype.header = null;

        /**
         * The account ID that is being described (this is useful with state proofs, for proving to a
         * third party)
         * @member {proto.IAccountID|null|undefined} accountID
         * @memberof proto.CryptoGetAccountBalanceResponse
         * @instance
         */
        CryptoGetAccountBalanceResponse.prototype.accountID = null;

        /**
         * The current balance, in tinybars.
         * @member {Long} balance
         * @memberof proto.CryptoGetAccountBalanceResponse
         * @instance
         */
        CryptoGetAccountBalanceResponse.prototype.balance = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * [DEPRECATED] The balances of the tokens associated to the account. This field was
         * deprecated by <a href="https://hips.hedera.com/hip/hip-367">HIP-367</a>, which allowed
         * an account to be associated to an unlimited number of tokens. This scale makes it more
         * efficient for users to consult mirror nodes to review their token balances.
         * @member {Array.<proto.ITokenBalance>} tokenBalances
         * @memberof proto.CryptoGetAccountBalanceResponse
         * @instance
         */
        CryptoGetAccountBalanceResponse.prototype.tokenBalances = $util.emptyArray;

        /**
         * Creates a new CryptoGetAccountBalanceResponse instance using the specified properties.
         * @function create
         * @memberof proto.CryptoGetAccountBalanceResponse
         * @static
         * @param {proto.ICryptoGetAccountBalanceResponse=} [properties] Properties to set
         * @returns {proto.CryptoGetAccountBalanceResponse} CryptoGetAccountBalanceResponse instance
         */
        CryptoGetAccountBalanceResponse.create = function create(properties) {
            return new CryptoGetAccountBalanceResponse(properties);
        };

        /**
         * Encodes the specified CryptoGetAccountBalanceResponse message. Does not implicitly {@link proto.CryptoGetAccountBalanceResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.CryptoGetAccountBalanceResponse
         * @static
         * @param {proto.ICryptoGetAccountBalanceResponse} m CryptoGetAccountBalanceResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CryptoGetAccountBalanceResponse.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.accountID != null && Object.hasOwnProperty.call(m, "accountID"))
                $root.proto.AccountID.encode(m.accountID, w.uint32(18).fork()).ldelim();
            if (m.balance != null && Object.hasOwnProperty.call(m, "balance")) w.uint32(24).uint64(m.balance);
            if (m.tokenBalances != null && m.tokenBalances.length) {
                for (var i = 0; i < m.tokenBalances.length; ++i)
                    $root.proto.TokenBalance.encode(m.tokenBalances[i], w.uint32(34).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a CryptoGetAccountBalanceResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CryptoGetAccountBalanceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.CryptoGetAccountBalanceResponse} CryptoGetAccountBalanceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CryptoGetAccountBalanceResponse.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.CryptoGetAccountBalanceResponse();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.accountID = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    case 3: {
                        m.balance = r.uint64();
                        break;
                    }
                    case 4: {
                        if (!(m.tokenBalances && m.tokenBalances.length)) m.tokenBalances = [];
                        m.tokenBalances.push($root.proto.TokenBalance.decode(r, r.uint32()));
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for CryptoGetAccountBalanceResponse
         * @function getTypeUrl
         * @memberof proto.CryptoGetAccountBalanceResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CryptoGetAccountBalanceResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.CryptoGetAccountBalanceResponse";
        };

        return CryptoGetAccountBalanceResponse;
    })();

    proto.CryptoGetAccountRecordsQuery = (function () {
        /**
         * Properties of a CryptoGetAccountRecordsQuery.
         * @memberof proto
         * @interface ICryptoGetAccountRecordsQuery
         * @property {proto.IQueryHeader|null} [header] Standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither).
         * @property {proto.IAccountID|null} [accountID] The account ID for which the records should be retrieved
         */

        /**
         * Constructs a new CryptoGetAccountRecordsQuery.
         * @memberof proto
         * @classdesc Requests records of all transactions for which the given account was the effective payer in the last 3 minutes of consensus time and <tt>ledger.keepRecordsInState=true</tt> was true during <tt>handleTransaction</tt>.
         * @implements ICryptoGetAccountRecordsQuery
         * @constructor
         * @param {proto.ICryptoGetAccountRecordsQuery=} [p] Properties to set
         */
        function CryptoGetAccountRecordsQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * Standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither).
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.CryptoGetAccountRecordsQuery
         * @instance
         */
        CryptoGetAccountRecordsQuery.prototype.header = null;

        /**
         * The account ID for which the records should be retrieved
         * @member {proto.IAccountID|null|undefined} accountID
         * @memberof proto.CryptoGetAccountRecordsQuery
         * @instance
         */
        CryptoGetAccountRecordsQuery.prototype.accountID = null;

        /**
         * Creates a new CryptoGetAccountRecordsQuery instance using the specified properties.
         * @function create
         * @memberof proto.CryptoGetAccountRecordsQuery
         * @static
         * @param {proto.ICryptoGetAccountRecordsQuery=} [properties] Properties to set
         * @returns {proto.CryptoGetAccountRecordsQuery} CryptoGetAccountRecordsQuery instance
         */
        CryptoGetAccountRecordsQuery.create = function create(properties) {
            return new CryptoGetAccountRecordsQuery(properties);
        };

        /**
         * Encodes the specified CryptoGetAccountRecordsQuery message. Does not implicitly {@link proto.CryptoGetAccountRecordsQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.CryptoGetAccountRecordsQuery
         * @static
         * @param {proto.ICryptoGetAccountRecordsQuery} m CryptoGetAccountRecordsQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CryptoGetAccountRecordsQuery.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.accountID != null && Object.hasOwnProperty.call(m, "accountID"))
                $root.proto.AccountID.encode(m.accountID, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a CryptoGetAccountRecordsQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CryptoGetAccountRecordsQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.CryptoGetAccountRecordsQuery} CryptoGetAccountRecordsQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CryptoGetAccountRecordsQuery.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.CryptoGetAccountRecordsQuery();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.accountID = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for CryptoGetAccountRecordsQuery
         * @function getTypeUrl
         * @memberof proto.CryptoGetAccountRecordsQuery
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CryptoGetAccountRecordsQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.CryptoGetAccountRecordsQuery";
        };

        return CryptoGetAccountRecordsQuery;
    })();

    proto.CryptoGetAccountRecordsResponse = (function () {
        /**
         * Properties of a CryptoGetAccountRecordsResponse.
         * @memberof proto
         * @interface ICryptoGetAccountRecordsResponse
         * @property {proto.IResponseHeader|null} [header] Standard response from node to client, including the requested fields: cost, or state proof, or both, or neither
         * @property {proto.IAccountID|null} [accountID] The account that this record is for
         * @property {Array.<proto.ITransactionRecord>|null} [records] List of records
         */

        /**
         * Constructs a new CryptoGetAccountRecordsResponse.
         * @memberof proto
         * @classdesc Returns records of all transactions for which the given account was the effective payer in the last 3 minutes of consensus time and <tt>ledger.keepRecordsInState=true</tt> was true during <tt>handleTransaction</tt>.
         * @implements ICryptoGetAccountRecordsResponse
         * @constructor
         * @param {proto.ICryptoGetAccountRecordsResponse=} [p] Properties to set
         */
        function CryptoGetAccountRecordsResponse(p) {
            this.records = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * Standard response from node to client, including the requested fields: cost, or state proof, or both, or neither
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.CryptoGetAccountRecordsResponse
         * @instance
         */
        CryptoGetAccountRecordsResponse.prototype.header = null;

        /**
         * The account that this record is for
         * @member {proto.IAccountID|null|undefined} accountID
         * @memberof proto.CryptoGetAccountRecordsResponse
         * @instance
         */
        CryptoGetAccountRecordsResponse.prototype.accountID = null;

        /**
         * List of records
         * @member {Array.<proto.ITransactionRecord>} records
         * @memberof proto.CryptoGetAccountRecordsResponse
         * @instance
         */
        CryptoGetAccountRecordsResponse.prototype.records = $util.emptyArray;

        /**
         * Creates a new CryptoGetAccountRecordsResponse instance using the specified properties.
         * @function create
         * @memberof proto.CryptoGetAccountRecordsResponse
         * @static
         * @param {proto.ICryptoGetAccountRecordsResponse=} [properties] Properties to set
         * @returns {proto.CryptoGetAccountRecordsResponse} CryptoGetAccountRecordsResponse instance
         */
        CryptoGetAccountRecordsResponse.create = function create(properties) {
            return new CryptoGetAccountRecordsResponse(properties);
        };

        /**
         * Encodes the specified CryptoGetAccountRecordsResponse message. Does not implicitly {@link proto.CryptoGetAccountRecordsResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.CryptoGetAccountRecordsResponse
         * @static
         * @param {proto.ICryptoGetAccountRecordsResponse} m CryptoGetAccountRecordsResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CryptoGetAccountRecordsResponse.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.accountID != null && Object.hasOwnProperty.call(m, "accountID"))
                $root.proto.AccountID.encode(m.accountID, w.uint32(18).fork()).ldelim();
            if (m.records != null && m.records.length) {
                for (var i = 0; i < m.records.length; ++i)
                    $root.proto.TransactionRecord.encode(m.records[i], w.uint32(26).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a CryptoGetAccountRecordsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CryptoGetAccountRecordsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.CryptoGetAccountRecordsResponse} CryptoGetAccountRecordsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CryptoGetAccountRecordsResponse.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.CryptoGetAccountRecordsResponse();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.accountID = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    case 3: {
                        if (!(m.records && m.records.length)) m.records = [];
                        m.records.push($root.proto.TransactionRecord.decode(r, r.uint32()));
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for CryptoGetAccountRecordsResponse
         * @function getTypeUrl
         * @memberof proto.CryptoGetAccountRecordsResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CryptoGetAccountRecordsResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.CryptoGetAccountRecordsResponse";
        };

        return CryptoGetAccountRecordsResponse;
    })();

    proto.CryptoGetInfoQuery = (function () {
        /**
         * Properties of a CryptoGetInfoQuery.
         * @memberof proto
         * @interface ICryptoGetInfoQuery
         * @property {proto.IQueryHeader|null} [header] Standard info sent from client to node, including the signed payment, and what kind of
         * response is requested (cost, state proof, both, or neither).
         * @property {proto.IAccountID|null} [accountID] The account ID for which information is requested
         */

        /**
         * Constructs a new CryptoGetInfoQuery.
         * @memberof proto
         * @classdesc Get all the information about an account, including the balance. This does not get the list of
         * account records.
         * @implements ICryptoGetInfoQuery
         * @constructor
         * @param {proto.ICryptoGetInfoQuery=} [p] Properties to set
         */
        function CryptoGetInfoQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * Standard info sent from client to node, including the signed payment, and what kind of
         * response is requested (cost, state proof, both, or neither).
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.CryptoGetInfoQuery
         * @instance
         */
        CryptoGetInfoQuery.prototype.header = null;

        /**
         * The account ID for which information is requested
         * @member {proto.IAccountID|null|undefined} accountID
         * @memberof proto.CryptoGetInfoQuery
         * @instance
         */
        CryptoGetInfoQuery.prototype.accountID = null;

        /**
         * Creates a new CryptoGetInfoQuery instance using the specified properties.
         * @function create
         * @memberof proto.CryptoGetInfoQuery
         * @static
         * @param {proto.ICryptoGetInfoQuery=} [properties] Properties to set
         * @returns {proto.CryptoGetInfoQuery} CryptoGetInfoQuery instance
         */
        CryptoGetInfoQuery.create = function create(properties) {
            return new CryptoGetInfoQuery(properties);
        };

        /**
         * Encodes the specified CryptoGetInfoQuery message. Does not implicitly {@link proto.CryptoGetInfoQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.CryptoGetInfoQuery
         * @static
         * @param {proto.ICryptoGetInfoQuery} m CryptoGetInfoQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CryptoGetInfoQuery.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.accountID != null && Object.hasOwnProperty.call(m, "accountID"))
                $root.proto.AccountID.encode(m.accountID, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a CryptoGetInfoQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CryptoGetInfoQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.CryptoGetInfoQuery} CryptoGetInfoQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CryptoGetInfoQuery.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.CryptoGetInfoQuery();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.accountID = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for CryptoGetInfoQuery
         * @function getTypeUrl
         * @memberof proto.CryptoGetInfoQuery
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CryptoGetInfoQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.CryptoGetInfoQuery";
        };

        return CryptoGetInfoQuery;
    })();

    proto.CryptoGetInfoResponse = (function () {
        /**
         * Properties of a CryptoGetInfoResponse.
         * @memberof proto
         * @interface ICryptoGetInfoResponse
         * @property {proto.IResponseHeader|null} [header] Standard response from node to client, including the requested fields: cost, or state proof,
         * or both, or neither
         * @property {proto.CryptoGetInfoResponse.IAccountInfo|null} [accountInfo] Info about the account (a state proof can be generated for this)
         */

        /**
         * Constructs a new CryptoGetInfoResponse.
         * @memberof proto
         * @classdesc Response when the client sends the node CryptoGetInfoQuery
         * @implements ICryptoGetInfoResponse
         * @constructor
         * @param {proto.ICryptoGetInfoResponse=} [p] Properties to set
         */
        function CryptoGetInfoResponse(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * Standard response from node to client, including the requested fields: cost, or state proof,
         * or both, or neither
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.CryptoGetInfoResponse
         * @instance
         */
        CryptoGetInfoResponse.prototype.header = null;

        /**
         * Info about the account (a state proof can be generated for this)
         * @member {proto.CryptoGetInfoResponse.IAccountInfo|null|undefined} accountInfo
         * @memberof proto.CryptoGetInfoResponse
         * @instance
         */
        CryptoGetInfoResponse.prototype.accountInfo = null;

        /**
         * Creates a new CryptoGetInfoResponse instance using the specified properties.
         * @function create
         * @memberof proto.CryptoGetInfoResponse
         * @static
         * @param {proto.ICryptoGetInfoResponse=} [properties] Properties to set
         * @returns {proto.CryptoGetInfoResponse} CryptoGetInfoResponse instance
         */
        CryptoGetInfoResponse.create = function create(properties) {
            return new CryptoGetInfoResponse(properties);
        };

        /**
         * Encodes the specified CryptoGetInfoResponse message. Does not implicitly {@link proto.CryptoGetInfoResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.CryptoGetInfoResponse
         * @static
         * @param {proto.ICryptoGetInfoResponse} m CryptoGetInfoResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CryptoGetInfoResponse.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.accountInfo != null && Object.hasOwnProperty.call(m, "accountInfo"))
                $root.proto.CryptoGetInfoResponse.AccountInfo.encode(m.accountInfo, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a CryptoGetInfoResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CryptoGetInfoResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.CryptoGetInfoResponse} CryptoGetInfoResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CryptoGetInfoResponse.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.CryptoGetInfoResponse();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.accountInfo = $root.proto.CryptoGetInfoResponse.AccountInfo.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for CryptoGetInfoResponse
         * @function getTypeUrl
         * @memberof proto.CryptoGetInfoResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CryptoGetInfoResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.CryptoGetInfoResponse";
        };

        CryptoGetInfoResponse.AccountInfo = (function () {
            /**
             * Properties of an AccountInfo.
             * @memberof proto.CryptoGetInfoResponse
             * @interface IAccountInfo
             * @property {proto.IAccountID|null} [accountID] The account ID for which this information applies
             * @property {string|null} [contractAccountID] The Contract Account ID comprising of both the contract instance and the cryptocurrency
             * account owned by the contract instance, in the format used by Solidity
             * @property {boolean|null} [deleted] If true, then this account has been deleted, it will disappear when it expires, and all
             * transactions for it will fail except the transaction to extend its expiration date
             * @property {proto.IAccountID|null} [proxyAccountID] [Deprecated] The Account ID of the account to which this is proxy staked. If proxyAccountID is null,
             * or is an invalid account, or is an account that isn't a node, then this account is
             * automatically proxy staked to a node chosen by the network, but without earning payments.
             * If the proxyAccountID account refuses to accept proxy staking , or if it is not currently
             * running a node, then it will behave as if proxyAccountID was null.
             * @property {Long|null} [proxyReceived] The total number of tinybars proxy staked to this account
             * @property {proto.IKey|null} [key] The key for the account, which must sign in order to transfer out, or to modify the
             * account in any way other than extending its expiration date.
             * @property {Long|null} [balance] The current balance of account in tinybars
             * @property {Long|null} [generateSendRecordThreshold] [Deprecated]. The threshold amount, in tinybars, at which a record is created of any
             * transaction that decreases the balance of this account by more than the threshold
             * @property {Long|null} [generateReceiveRecordThreshold] [Deprecated]. The threshold amount, in tinybars, at which a record is created of any
             * transaction that increases the balance of this account by more than the threshold
             * @property {boolean|null} [receiverSigRequired] If true, no transaction can transfer to this account unless signed by this account's key
             * @property {proto.ITimestamp|null} [expirationTime] The TimeStamp time at which this account is set to expire
             * @property {proto.IDuration|null} [autoRenewPeriod] The duration for expiration time will extend every this many seconds. If there are
             * insufficient funds, then it extends as long as possible. If it is empty when it expires,
             * then it is deleted.
             * @property {Array.<proto.ILiveHash>|null} [liveHashes] All of the livehashes attached to the account (each of which is a hash along with the
             * keys that authorized it and can delete it)
             * @property {Array.<proto.ITokenRelationship>|null} [tokenRelationships] [DEPRECATED] The metadata of the tokens associated to the account. This field was
             * deprecated by <a href="https://hips.hedera.com/hip/hip-367">HIP-367</a>, which allowed
             * an account to be associated to an unlimited number of tokens. This scale makes it more
             * efficient for users to consult mirror nodes to review their token associations.
             * @property {string|null} [memo] The memo associated with the account
             * @property {Long|null} [ownedNfts] The number of NFTs owned by this account
             * @property {number|null} [maxAutomaticTokenAssociations] The maximum number of tokens that an Account can be implicitly associated with.
             * @property {Uint8Array|null} [alias] The alias of this account
             * @property {Uint8Array|null} [ledgerId] The ledger ID the response was returned from; please see <a href="https://github.com/hashgraph/hedera-improvement-proposal/blob/master/HIP/hip-198.md">HIP-198</a> for the network-specific IDs.
             * @property {Long|null} [ethereumNonce] The ethereum transaction nonce associated with this account.
             * @property {proto.IStakingInfo|null} [stakingInfo] Staking metadata for this account.
             */

            /**
             * Constructs a new AccountInfo.
             * @memberof proto.CryptoGetInfoResponse
             * @classdesc Represents an AccountInfo.
             * @implements IAccountInfo
             * @constructor
             * @param {proto.CryptoGetInfoResponse.IAccountInfo=} [p] Properties to set
             */
            function AccountInfo(p) {
                this.liveHashes = [];
                this.tokenRelationships = [];
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
            }

            /**
             * The account ID for which this information applies
             * @member {proto.IAccountID|null|undefined} accountID
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @instance
             */
            AccountInfo.prototype.accountID = null;

            /**
             * The Contract Account ID comprising of both the contract instance and the cryptocurrency
             * account owned by the contract instance, in the format used by Solidity
             * @member {string} contractAccountID
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @instance
             */
            AccountInfo.prototype.contractAccountID = "";

            /**
             * If true, then this account has been deleted, it will disappear when it expires, and all
             * transactions for it will fail except the transaction to extend its expiration date
             * @member {boolean} deleted
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @instance
             */
            AccountInfo.prototype.deleted = false;

            /**
             * [Deprecated] The Account ID of the account to which this is proxy staked. If proxyAccountID is null,
             * or is an invalid account, or is an account that isn't a node, then this account is
             * automatically proxy staked to a node chosen by the network, but without earning payments.
             * If the proxyAccountID account refuses to accept proxy staking , or if it is not currently
             * running a node, then it will behave as if proxyAccountID was null.
             * @member {proto.IAccountID|null|undefined} proxyAccountID
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @instance
             */
            AccountInfo.prototype.proxyAccountID = null;

            /**
             * The total number of tinybars proxy staked to this account
             * @member {Long} proxyReceived
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @instance
             */
            AccountInfo.prototype.proxyReceived = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

            /**
             * The key for the account, which must sign in order to transfer out, or to modify the
             * account in any way other than extending its expiration date.
             * @member {proto.IKey|null|undefined} key
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @instance
             */
            AccountInfo.prototype.key = null;

            /**
             * The current balance of account in tinybars
             * @member {Long} balance
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @instance
             */
            AccountInfo.prototype.balance = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

            /**
             * [Deprecated]. The threshold amount, in tinybars, at which a record is created of any
             * transaction that decreases the balance of this account by more than the threshold
             * @member {Long} generateSendRecordThreshold
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @instance
             */
            AccountInfo.prototype.generateSendRecordThreshold = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

            /**
             * [Deprecated]. The threshold amount, in tinybars, at which a record is created of any
             * transaction that increases the balance of this account by more than the threshold
             * @member {Long} generateReceiveRecordThreshold
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @instance
             */
            AccountInfo.prototype.generateReceiveRecordThreshold = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

            /**
             * If true, no transaction can transfer to this account unless signed by this account's key
             * @member {boolean} receiverSigRequired
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @instance
             */
            AccountInfo.prototype.receiverSigRequired = false;

            /**
             * The TimeStamp time at which this account is set to expire
             * @member {proto.ITimestamp|null|undefined} expirationTime
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @instance
             */
            AccountInfo.prototype.expirationTime = null;

            /**
             * The duration for expiration time will extend every this many seconds. If there are
             * insufficient funds, then it extends as long as possible. If it is empty when it expires,
             * then it is deleted.
             * @member {proto.IDuration|null|undefined} autoRenewPeriod
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @instance
             */
            AccountInfo.prototype.autoRenewPeriod = null;

            /**
             * All of the livehashes attached to the account (each of which is a hash along with the
             * keys that authorized it and can delete it)
             * @member {Array.<proto.ILiveHash>} liveHashes
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @instance
             */
            AccountInfo.prototype.liveHashes = $util.emptyArray;

            /**
             * [DEPRECATED] The metadata of the tokens associated to the account. This field was
             * deprecated by <a href="https://hips.hedera.com/hip/hip-367">HIP-367</a>, which allowed
             * an account to be associated to an unlimited number of tokens. This scale makes it more
             * efficient for users to consult mirror nodes to review their token associations.
             * @member {Array.<proto.ITokenRelationship>} tokenRelationships
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @instance
             */
            AccountInfo.prototype.tokenRelationships = $util.emptyArray;

            /**
             * The memo associated with the account
             * @member {string} memo
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @instance
             */
            AccountInfo.prototype.memo = "";

            /**
             * The number of NFTs owned by this account
             * @member {Long} ownedNfts
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @instance
             */
            AccountInfo.prototype.ownedNfts = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

            /**
             * The maximum number of tokens that an Account can be implicitly associated with.
             * @member {number} maxAutomaticTokenAssociations
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @instance
             */
            AccountInfo.prototype.maxAutomaticTokenAssociations = 0;

            /**
             * The alias of this account
             * @member {Uint8Array} alias
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @instance
             */
            AccountInfo.prototype.alias = $util.newBuffer([]);

            /**
             * The ledger ID the response was returned from; please see <a href="https://github.com/hashgraph/hedera-improvement-proposal/blob/master/HIP/hip-198.md">HIP-198</a> for the network-specific IDs.
             * @member {Uint8Array} ledgerId
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @instance
             */
            AccountInfo.prototype.ledgerId = $util.newBuffer([]);

            /**
             * The ethereum transaction nonce associated with this account.
             * @member {Long} ethereumNonce
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @instance
             */
            AccountInfo.prototype.ethereumNonce = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

            /**
             * Staking metadata for this account.
             * @member {proto.IStakingInfo|null|undefined} stakingInfo
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @instance
             */
            AccountInfo.prototype.stakingInfo = null;

            /**
             * Creates a new AccountInfo instance using the specified properties.
             * @function create
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @static
             * @param {proto.CryptoGetInfoResponse.IAccountInfo=} [properties] Properties to set
             * @returns {proto.CryptoGetInfoResponse.AccountInfo} AccountInfo instance
             */
            AccountInfo.create = function create(properties) {
                return new AccountInfo(properties);
            };

            /**
             * Encodes the specified AccountInfo message. Does not implicitly {@link proto.CryptoGetInfoResponse.AccountInfo.verify|verify} messages.
             * @function encode
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @static
             * @param {proto.CryptoGetInfoResponse.IAccountInfo} m AccountInfo message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AccountInfo.encode = function encode(m, w) {
                if (!w) w = $Writer.create();
                if (m.accountID != null && Object.hasOwnProperty.call(m, "accountID"))
                    $root.proto.AccountID.encode(m.accountID, w.uint32(10).fork()).ldelim();
                if (m.contractAccountID != null && Object.hasOwnProperty.call(m, "contractAccountID"))
                    w.uint32(18).string(m.contractAccountID);
                if (m.deleted != null && Object.hasOwnProperty.call(m, "deleted")) w.uint32(24).bool(m.deleted);
                if (m.proxyAccountID != null && Object.hasOwnProperty.call(m, "proxyAccountID"))
                    $root.proto.AccountID.encode(m.proxyAccountID, w.uint32(34).fork()).ldelim();
                if (m.proxyReceived != null && Object.hasOwnProperty.call(m, "proxyReceived"))
                    w.uint32(48).int64(m.proxyReceived);
                if (m.key != null && Object.hasOwnProperty.call(m, "key"))
                    $root.proto.Key.encode(m.key, w.uint32(58).fork()).ldelim();
                if (m.balance != null && Object.hasOwnProperty.call(m, "balance")) w.uint32(64).uint64(m.balance);
                if (
                    m.generateSendRecordThreshold != null &&
                    Object.hasOwnProperty.call(m, "generateSendRecordThreshold")
                )
                    w.uint32(72).uint64(m.generateSendRecordThreshold);
                if (
                    m.generateReceiveRecordThreshold != null &&
                    Object.hasOwnProperty.call(m, "generateReceiveRecordThreshold")
                )
                    w.uint32(80).uint64(m.generateReceiveRecordThreshold);
                if (m.receiverSigRequired != null && Object.hasOwnProperty.call(m, "receiverSigRequired"))
                    w.uint32(88).bool(m.receiverSigRequired);
                if (m.expirationTime != null && Object.hasOwnProperty.call(m, "expirationTime"))
                    $root.proto.Timestamp.encode(m.expirationTime, w.uint32(98).fork()).ldelim();
                if (m.autoRenewPeriod != null && Object.hasOwnProperty.call(m, "autoRenewPeriod"))
                    $root.proto.Duration.encode(m.autoRenewPeriod, w.uint32(106).fork()).ldelim();
                if (m.liveHashes != null && m.liveHashes.length) {
                    for (var i = 0; i < m.liveHashes.length; ++i)
                        $root.proto.LiveHash.encode(m.liveHashes[i], w.uint32(114).fork()).ldelim();
                }
                if (m.tokenRelationships != null && m.tokenRelationships.length) {
                    for (var i = 0; i < m.tokenRelationships.length; ++i)
                        $root.proto.TokenRelationship.encode(m.tokenRelationships[i], w.uint32(122).fork()).ldelim();
                }
                if (m.memo != null && Object.hasOwnProperty.call(m, "memo")) w.uint32(130).string(m.memo);
                if (m.ownedNfts != null && Object.hasOwnProperty.call(m, "ownedNfts")) w.uint32(136).int64(m.ownedNfts);
                if (
                    m.maxAutomaticTokenAssociations != null &&
                    Object.hasOwnProperty.call(m, "maxAutomaticTokenAssociations")
                )
                    w.uint32(144).int32(m.maxAutomaticTokenAssociations);
                if (m.alias != null && Object.hasOwnProperty.call(m, "alias")) w.uint32(154).bytes(m.alias);
                if (m.ledgerId != null && Object.hasOwnProperty.call(m, "ledgerId")) w.uint32(162).bytes(m.ledgerId);
                if (m.ethereumNonce != null && Object.hasOwnProperty.call(m, "ethereumNonce"))
                    w.uint32(168).int64(m.ethereumNonce);
                if (m.stakingInfo != null && Object.hasOwnProperty.call(m, "stakingInfo"))
                    $root.proto.StakingInfo.encode(m.stakingInfo, w.uint32(178).fork()).ldelim();
                return w;
            };

            /**
             * Decodes an AccountInfo message from the specified reader or buffer.
             * @function decode
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {proto.CryptoGetInfoResponse.AccountInfo} AccountInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AccountInfo.decode = function decode(r, l) {
                if (!(r instanceof $Reader)) r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l,
                    m = new $root.proto.CryptoGetInfoResponse.AccountInfo();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                        case 1: {
                            m.accountID = $root.proto.AccountID.decode(r, r.uint32());
                            break;
                        }
                        case 2: {
                            m.contractAccountID = r.string();
                            break;
                        }
                        case 3: {
                            m.deleted = r.bool();
                            break;
                        }
                        case 4: {
                            m.proxyAccountID = $root.proto.AccountID.decode(r, r.uint32());
                            break;
                        }
                        case 6: {
                            m.proxyReceived = r.int64();
                            break;
                        }
                        case 7: {
                            m.key = $root.proto.Key.decode(r, r.uint32());
                            break;
                        }
                        case 8: {
                            m.balance = r.uint64();
                            break;
                        }
                        case 9: {
                            m.generateSendRecordThreshold = r.uint64();
                            break;
                        }
                        case 10: {
                            m.generateReceiveRecordThreshold = r.uint64();
                            break;
                        }
                        case 11: {
                            m.receiverSigRequired = r.bool();
                            break;
                        }
                        case 12: {
                            m.expirationTime = $root.proto.Timestamp.decode(r, r.uint32());
                            break;
                        }
                        case 13: {
                            m.autoRenewPeriod = $root.proto.Duration.decode(r, r.uint32());
                            break;
                        }
                        case 14: {
                            if (!(m.liveHashes && m.liveHashes.length)) m.liveHashes = [];
                            m.liveHashes.push($root.proto.LiveHash.decode(r, r.uint32()));
                            break;
                        }
                        case 15: {
                            if (!(m.tokenRelationships && m.tokenRelationships.length)) m.tokenRelationships = [];
                            m.tokenRelationships.push($root.proto.TokenRelationship.decode(r, r.uint32()));
                            break;
                        }
                        case 16: {
                            m.memo = r.string();
                            break;
                        }
                        case 17: {
                            m.ownedNfts = r.int64();
                            break;
                        }
                        case 18: {
                            m.maxAutomaticTokenAssociations = r.int32();
                            break;
                        }
                        case 19: {
                            m.alias = r.bytes();
                            break;
                        }
                        case 20: {
                            m.ledgerId = r.bytes();
                            break;
                        }
                        case 21: {
                            m.ethereumNonce = r.int64();
                            break;
                        }
                        case 22: {
                            m.stakingInfo = $root.proto.StakingInfo.decode(r, r.uint32());
                            break;
                        }
                        default:
                            r.skipType(t & 7);
                            break;
                    }
                }
                return m;
            };

            /**
             * Gets the default type url for AccountInfo
             * @function getTypeUrl
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            AccountInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/proto.CryptoGetInfoResponse.AccountInfo";
            };

            return AccountInfo;
        })();

        return CryptoGetInfoResponse;
    })();

    proto.CryptoGetLiveHashQuery = (function () {
        /**
         * Properties of a CryptoGetLiveHashQuery.
         * @memberof proto
         * @interface ICryptoGetLiveHashQuery
         * @property {proto.IQueryHeader|null} [header] Standard info sent from client to node, including the signed payment, and what kind of
         * response is requested (cost, state proof, both, or neither).
         * @property {proto.IAccountID|null} [accountID] The account to which the livehash is associated
         * @property {Uint8Array|null} [hash] The SHA-384 data in the livehash
         */

        /**
         * Constructs a new CryptoGetLiveHashQuery.
         * @memberof proto
         * @classdesc Requests a livehash associated to an account.
         * @implements ICryptoGetLiveHashQuery
         * @constructor
         * @param {proto.ICryptoGetLiveHashQuery=} [p] Properties to set
         */
        function CryptoGetLiveHashQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * Standard info sent from client to node, including the signed payment, and what kind of
         * response is requested (cost, state proof, both, or neither).
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.CryptoGetLiveHashQuery
         * @instance
         */
        CryptoGetLiveHashQuery.prototype.header = null;

        /**
         * The account to which the livehash is associated
         * @member {proto.IAccountID|null|undefined} accountID
         * @memberof proto.CryptoGetLiveHashQuery
         * @instance
         */
        CryptoGetLiveHashQuery.prototype.accountID = null;

        /**
         * The SHA-384 data in the livehash
         * @member {Uint8Array} hash
         * @memberof proto.CryptoGetLiveHashQuery
         * @instance
         */
        CryptoGetLiveHashQuery.prototype.hash = $util.newBuffer([]);

        /**
         * Creates a new CryptoGetLiveHashQuery instance using the specified properties.
         * @function create
         * @memberof proto.CryptoGetLiveHashQuery
         * @static
         * @param {proto.ICryptoGetLiveHashQuery=} [properties] Properties to set
         * @returns {proto.CryptoGetLiveHashQuery} CryptoGetLiveHashQuery instance
         */
        CryptoGetLiveHashQuery.create = function create(properties) {
            return new CryptoGetLiveHashQuery(properties);
        };

        /**
         * Encodes the specified CryptoGetLiveHashQuery message. Does not implicitly {@link proto.CryptoGetLiveHashQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.CryptoGetLiveHashQuery
         * @static
         * @param {proto.ICryptoGetLiveHashQuery} m CryptoGetLiveHashQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CryptoGetLiveHashQuery.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.accountID != null && Object.hasOwnProperty.call(m, "accountID"))
                $root.proto.AccountID.encode(m.accountID, w.uint32(18).fork()).ldelim();
            if (m.hash != null && Object.hasOwnProperty.call(m, "hash")) w.uint32(26).bytes(m.hash);
            return w;
        };

        /**
         * Decodes a CryptoGetLiveHashQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CryptoGetLiveHashQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.CryptoGetLiveHashQuery} CryptoGetLiveHashQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CryptoGetLiveHashQuery.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.CryptoGetLiveHashQuery();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.accountID = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    case 3: {
                        m.hash = r.bytes();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for CryptoGetLiveHashQuery
         * @function getTypeUrl
         * @memberof proto.CryptoGetLiveHashQuery
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CryptoGetLiveHashQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.CryptoGetLiveHashQuery";
        };

        return CryptoGetLiveHashQuery;
    })();

    proto.CryptoGetLiveHashResponse = (function () {
        /**
         * Properties of a CryptoGetLiveHashResponse.
         * @memberof proto
         * @interface ICryptoGetLiveHashResponse
         * @property {proto.IResponseHeader|null} [header] Standard response from node to client, including the requested fields: cost, or state proof,
         * or both, or neither
         * @property {proto.ILiveHash|null} [liveHash] The livehash, if present
         */

        /**
         * Constructs a new CryptoGetLiveHashResponse.
         * @memberof proto
         * @classdesc Returns the full livehash associated to an account, if it is present. Note that the only way to
         * obtain a state proof exhibiting the absence of a livehash from an account is to retrieve a state
         * proof of the entire account with its list of livehashes.
         * @implements ICryptoGetLiveHashResponse
         * @constructor
         * @param {proto.ICryptoGetLiveHashResponse=} [p] Properties to set
         */
        function CryptoGetLiveHashResponse(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * Standard response from node to client, including the requested fields: cost, or state proof,
         * or both, or neither
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.CryptoGetLiveHashResponse
         * @instance
         */
        CryptoGetLiveHashResponse.prototype.header = null;

        /**
         * The livehash, if present
         * @member {proto.ILiveHash|null|undefined} liveHash
         * @memberof proto.CryptoGetLiveHashResponse
         * @instance
         */
        CryptoGetLiveHashResponse.prototype.liveHash = null;

        /**
         * Creates a new CryptoGetLiveHashResponse instance using the specified properties.
         * @function create
         * @memberof proto.CryptoGetLiveHashResponse
         * @static
         * @param {proto.ICryptoGetLiveHashResponse=} [properties] Properties to set
         * @returns {proto.CryptoGetLiveHashResponse} CryptoGetLiveHashResponse instance
         */
        CryptoGetLiveHashResponse.create = function create(properties) {
            return new CryptoGetLiveHashResponse(properties);
        };

        /**
         * Encodes the specified CryptoGetLiveHashResponse message. Does not implicitly {@link proto.CryptoGetLiveHashResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.CryptoGetLiveHashResponse
         * @static
         * @param {proto.ICryptoGetLiveHashResponse} m CryptoGetLiveHashResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CryptoGetLiveHashResponse.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.liveHash != null && Object.hasOwnProperty.call(m, "liveHash"))
                $root.proto.LiveHash.encode(m.liveHash, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a CryptoGetLiveHashResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CryptoGetLiveHashResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.CryptoGetLiveHashResponse} CryptoGetLiveHashResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CryptoGetLiveHashResponse.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.CryptoGetLiveHashResponse();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.liveHash = $root.proto.LiveHash.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for CryptoGetLiveHashResponse
         * @function getTypeUrl
         * @memberof proto.CryptoGetLiveHashResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CryptoGetLiveHashResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.CryptoGetLiveHashResponse";
        };

        return CryptoGetLiveHashResponse;
    })();

    proto.CryptoGetStakersQuery = (function () {
        /**
         * Properties of a CryptoGetStakersQuery.
         * @memberof proto
         * @interface ICryptoGetStakersQuery
         * @property {proto.IQueryHeader|null} [header] Standard info sent from client to node, including the signed payment, and what kind of
         * response is requested (cost, state proof, both, or neither).
         * @property {proto.IAccountID|null} [accountID] The Account ID for which the records should be retrieved
         */

        /**
         * Constructs a new CryptoGetStakersQuery.
         * @memberof proto
         * @classdesc Get all the accounts that are proxy staking to this account. For each of them, give the amount
         * currently staked. This is not yet implemented, but will be in a future version of the API.
         * @implements ICryptoGetStakersQuery
         * @constructor
         * @param {proto.ICryptoGetStakersQuery=} [p] Properties to set
         */
        function CryptoGetStakersQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * Standard info sent from client to node, including the signed payment, and what kind of
         * response is requested (cost, state proof, both, or neither).
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.CryptoGetStakersQuery
         * @instance
         */
        CryptoGetStakersQuery.prototype.header = null;

        /**
         * The Account ID for which the records should be retrieved
         * @member {proto.IAccountID|null|undefined} accountID
         * @memberof proto.CryptoGetStakersQuery
         * @instance
         */
        CryptoGetStakersQuery.prototype.accountID = null;

        /**
         * Creates a new CryptoGetStakersQuery instance using the specified properties.
         * @function create
         * @memberof proto.CryptoGetStakersQuery
         * @static
         * @param {proto.ICryptoGetStakersQuery=} [properties] Properties to set
         * @returns {proto.CryptoGetStakersQuery} CryptoGetStakersQuery instance
         */
        CryptoGetStakersQuery.create = function create(properties) {
            return new CryptoGetStakersQuery(properties);
        };

        /**
         * Encodes the specified CryptoGetStakersQuery message. Does not implicitly {@link proto.CryptoGetStakersQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.CryptoGetStakersQuery
         * @static
         * @param {proto.ICryptoGetStakersQuery} m CryptoGetStakersQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CryptoGetStakersQuery.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.accountID != null && Object.hasOwnProperty.call(m, "accountID"))
                $root.proto.AccountID.encode(m.accountID, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a CryptoGetStakersQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CryptoGetStakersQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.CryptoGetStakersQuery} CryptoGetStakersQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CryptoGetStakersQuery.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.CryptoGetStakersQuery();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.accountID = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for CryptoGetStakersQuery
         * @function getTypeUrl
         * @memberof proto.CryptoGetStakersQuery
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CryptoGetStakersQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.CryptoGetStakersQuery";
        };

        return CryptoGetStakersQuery;
    })();

    proto.ProxyStaker = (function () {
        /**
         * Properties of a ProxyStaker.
         * @memberof proto
         * @interface IProxyStaker
         * @property {proto.IAccountID|null} [accountID] The Account ID that is proxy staking
         * @property {Long|null} [amount] The number of hbars that are currently proxy staked
         */

        /**
         * Constructs a new ProxyStaker.
         * @memberof proto
         * @classdesc information about a single account that is proxy staking
         * @implements IProxyStaker
         * @constructor
         * @param {proto.IProxyStaker=} [p] Properties to set
         */
        function ProxyStaker(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The Account ID that is proxy staking
         * @member {proto.IAccountID|null|undefined} accountID
         * @memberof proto.ProxyStaker
         * @instance
         */
        ProxyStaker.prototype.accountID = null;

        /**
         * The number of hbars that are currently proxy staked
         * @member {Long} amount
         * @memberof proto.ProxyStaker
         * @instance
         */
        ProxyStaker.prototype.amount = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * Creates a new ProxyStaker instance using the specified properties.
         * @function create
         * @memberof proto.ProxyStaker
         * @static
         * @param {proto.IProxyStaker=} [properties] Properties to set
         * @returns {proto.ProxyStaker} ProxyStaker instance
         */
        ProxyStaker.create = function create(properties) {
            return new ProxyStaker(properties);
        };

        /**
         * Encodes the specified ProxyStaker message. Does not implicitly {@link proto.ProxyStaker.verify|verify} messages.
         * @function encode
         * @memberof proto.ProxyStaker
         * @static
         * @param {proto.IProxyStaker} m ProxyStaker message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProxyStaker.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.accountID != null && Object.hasOwnProperty.call(m, "accountID"))
                $root.proto.AccountID.encode(m.accountID, w.uint32(10).fork()).ldelim();
            if (m.amount != null && Object.hasOwnProperty.call(m, "amount")) w.uint32(16).int64(m.amount);
            return w;
        };

        /**
         * Decodes a ProxyStaker message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ProxyStaker
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ProxyStaker} ProxyStaker
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProxyStaker.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.ProxyStaker();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.accountID = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.amount = r.int64();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ProxyStaker
         * @function getTypeUrl
         * @memberof proto.ProxyStaker
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ProxyStaker.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ProxyStaker";
        };

        return ProxyStaker;
    })();

    proto.AllProxyStakers = (function () {
        /**
         * Properties of an AllProxyStakers.
         * @memberof proto
         * @interface IAllProxyStakers
         * @property {proto.IAccountID|null} [accountID] The Account ID that is being proxy staked to
         * @property {Array.<proto.IProxyStaker>|null} [proxyStaker] Each of the proxy staking accounts, and the amount they are proxy staking
         */

        /**
         * Constructs a new AllProxyStakers.
         * @memberof proto
         * @classdesc all of the accounts proxy staking to a given account, and the amounts proxy staked
         * @implements IAllProxyStakers
         * @constructor
         * @param {proto.IAllProxyStakers=} [p] Properties to set
         */
        function AllProxyStakers(p) {
            this.proxyStaker = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The Account ID that is being proxy staked to
         * @member {proto.IAccountID|null|undefined} accountID
         * @memberof proto.AllProxyStakers
         * @instance
         */
        AllProxyStakers.prototype.accountID = null;

        /**
         * Each of the proxy staking accounts, and the amount they are proxy staking
         * @member {Array.<proto.IProxyStaker>} proxyStaker
         * @memberof proto.AllProxyStakers
         * @instance
         */
        AllProxyStakers.prototype.proxyStaker = $util.emptyArray;

        /**
         * Creates a new AllProxyStakers instance using the specified properties.
         * @function create
         * @memberof proto.AllProxyStakers
         * @static
         * @param {proto.IAllProxyStakers=} [properties] Properties to set
         * @returns {proto.AllProxyStakers} AllProxyStakers instance
         */
        AllProxyStakers.create = function create(properties) {
            return new AllProxyStakers(properties);
        };

        /**
         * Encodes the specified AllProxyStakers message. Does not implicitly {@link proto.AllProxyStakers.verify|verify} messages.
         * @function encode
         * @memberof proto.AllProxyStakers
         * @static
         * @param {proto.IAllProxyStakers} m AllProxyStakers message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AllProxyStakers.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.accountID != null && Object.hasOwnProperty.call(m, "accountID"))
                $root.proto.AccountID.encode(m.accountID, w.uint32(10).fork()).ldelim();
            if (m.proxyStaker != null && m.proxyStaker.length) {
                for (var i = 0; i < m.proxyStaker.length; ++i)
                    $root.proto.ProxyStaker.encode(m.proxyStaker[i], w.uint32(18).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes an AllProxyStakers message from the specified reader or buffer.
         * @function decode
         * @memberof proto.AllProxyStakers
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.AllProxyStakers} AllProxyStakers
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AllProxyStakers.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.AllProxyStakers();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.accountID = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        if (!(m.proxyStaker && m.proxyStaker.length)) m.proxyStaker = [];
                        m.proxyStaker.push($root.proto.ProxyStaker.decode(r, r.uint32()));
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for AllProxyStakers
         * @function getTypeUrl
         * @memberof proto.AllProxyStakers
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AllProxyStakers.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.AllProxyStakers";
        };

        return AllProxyStakers;
    })();

    proto.CryptoGetStakersResponse = (function () {
        /**
         * Properties of a CryptoGetStakersResponse.
         * @memberof proto
         * @interface ICryptoGetStakersResponse
         * @property {proto.IResponseHeader|null} [header] Standard response from node to client, including the requested fields: cost, or state proof,
         * or both, or neither
         * @property {proto.IAllProxyStakers|null} [stakers] List of accounts proxy staking to this account, and the amount each is currently proxy
         * staking
         */

        /**
         * Constructs a new CryptoGetStakersResponse.
         * @memberof proto
         * @classdesc Response when the client sends the node CryptoGetStakersQuery
         * @implements ICryptoGetStakersResponse
         * @constructor
         * @param {proto.ICryptoGetStakersResponse=} [p] Properties to set
         */
        function CryptoGetStakersResponse(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * Standard response from node to client, including the requested fields: cost, or state proof,
         * or both, or neither
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.CryptoGetStakersResponse
         * @instance
         */
        CryptoGetStakersResponse.prototype.header = null;

        /**
         * List of accounts proxy staking to this account, and the amount each is currently proxy
         * staking
         * @member {proto.IAllProxyStakers|null|undefined} stakers
         * @memberof proto.CryptoGetStakersResponse
         * @instance
         */
        CryptoGetStakersResponse.prototype.stakers = null;

        /**
         * Creates a new CryptoGetStakersResponse instance using the specified properties.
         * @function create
         * @memberof proto.CryptoGetStakersResponse
         * @static
         * @param {proto.ICryptoGetStakersResponse=} [properties] Properties to set
         * @returns {proto.CryptoGetStakersResponse} CryptoGetStakersResponse instance
         */
        CryptoGetStakersResponse.create = function create(properties) {
            return new CryptoGetStakersResponse(properties);
        };

        /**
         * Encodes the specified CryptoGetStakersResponse message. Does not implicitly {@link proto.CryptoGetStakersResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.CryptoGetStakersResponse
         * @static
         * @param {proto.ICryptoGetStakersResponse} m CryptoGetStakersResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CryptoGetStakersResponse.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.stakers != null && Object.hasOwnProperty.call(m, "stakers"))
                $root.proto.AllProxyStakers.encode(m.stakers, w.uint32(26).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a CryptoGetStakersResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CryptoGetStakersResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.CryptoGetStakersResponse} CryptoGetStakersResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CryptoGetStakersResponse.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.CryptoGetStakersResponse();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                        break;
                    }
                    case 3: {
                        m.stakers = $root.proto.AllProxyStakers.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for CryptoGetStakersResponse
         * @function getTypeUrl
         * @memberof proto.CryptoGetStakersResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CryptoGetStakersResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.CryptoGetStakersResponse";
        };

        return CryptoGetStakersResponse;
    })();

    proto.FileGetContentsQuery = (function () {
        /**
         * Properties of a FileGetContentsQuery.
         * @memberof proto
         * @interface IFileGetContentsQuery
         * @property {proto.IQueryHeader|null} [header] Standard info sent from client to node, including the signed payment, and what kind of
         * response is requested (cost, state proof, both, or neither).
         * @property {proto.IFileID|null} [fileID] The file ID of the file whose contents are requested
         */

        /**
         * Constructs a new FileGetContentsQuery.
         * @memberof proto
         * @classdesc Get the contents of a file. The content field is empty (no bytes) if the file is empty.
         * @implements IFileGetContentsQuery
         * @constructor
         * @param {proto.IFileGetContentsQuery=} [p] Properties to set
         */
        function FileGetContentsQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * Standard info sent from client to node, including the signed payment, and what kind of
         * response is requested (cost, state proof, both, or neither).
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.FileGetContentsQuery
         * @instance
         */
        FileGetContentsQuery.prototype.header = null;

        /**
         * The file ID of the file whose contents are requested
         * @member {proto.IFileID|null|undefined} fileID
         * @memberof proto.FileGetContentsQuery
         * @instance
         */
        FileGetContentsQuery.prototype.fileID = null;

        /**
         * Creates a new FileGetContentsQuery instance using the specified properties.
         * @function create
         * @memberof proto.FileGetContentsQuery
         * @static
         * @param {proto.IFileGetContentsQuery=} [properties] Properties to set
         * @returns {proto.FileGetContentsQuery} FileGetContentsQuery instance
         */
        FileGetContentsQuery.create = function create(properties) {
            return new FileGetContentsQuery(properties);
        };

        /**
         * Encodes the specified FileGetContentsQuery message. Does not implicitly {@link proto.FileGetContentsQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.FileGetContentsQuery
         * @static
         * @param {proto.IFileGetContentsQuery} m FileGetContentsQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FileGetContentsQuery.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.fileID != null && Object.hasOwnProperty.call(m, "fileID"))
                $root.proto.FileID.encode(m.fileID, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a FileGetContentsQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.FileGetContentsQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.FileGetContentsQuery} FileGetContentsQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FileGetContentsQuery.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.FileGetContentsQuery();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.fileID = $root.proto.FileID.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for FileGetContentsQuery
         * @function getTypeUrl
         * @memberof proto.FileGetContentsQuery
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        FileGetContentsQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.FileGetContentsQuery";
        };

        return FileGetContentsQuery;
    })();

    proto.FileGetContentsResponse = (function () {
        /**
         * Properties of a FileGetContentsResponse.
         * @memberof proto
         * @interface IFileGetContentsResponse
         * @property {proto.IResponseHeader|null} [header] Standard response from node to client, including the requested fields: cost, or state proof,
         * or both, or neither
         * @property {proto.FileGetContentsResponse.IFileContents|null} [fileContents] the file ID and contents (a state proof can be generated for this)
         */

        /**
         * Constructs a new FileGetContentsResponse.
         * @memberof proto
         * @classdesc Response when the client sends the node FileGetContentsQuery
         * @implements IFileGetContentsResponse
         * @constructor
         * @param {proto.IFileGetContentsResponse=} [p] Properties to set
         */
        function FileGetContentsResponse(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * Standard response from node to client, including the requested fields: cost, or state proof,
         * or both, or neither
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.FileGetContentsResponse
         * @instance
         */
        FileGetContentsResponse.prototype.header = null;

        /**
         * the file ID and contents (a state proof can be generated for this)
         * @member {proto.FileGetContentsResponse.IFileContents|null|undefined} fileContents
         * @memberof proto.FileGetContentsResponse
         * @instance
         */
        FileGetContentsResponse.prototype.fileContents = null;

        /**
         * Creates a new FileGetContentsResponse instance using the specified properties.
         * @function create
         * @memberof proto.FileGetContentsResponse
         * @static
         * @param {proto.IFileGetContentsResponse=} [properties] Properties to set
         * @returns {proto.FileGetContentsResponse} FileGetContentsResponse instance
         */
        FileGetContentsResponse.create = function create(properties) {
            return new FileGetContentsResponse(properties);
        };

        /**
         * Encodes the specified FileGetContentsResponse message. Does not implicitly {@link proto.FileGetContentsResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.FileGetContentsResponse
         * @static
         * @param {proto.IFileGetContentsResponse} m FileGetContentsResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FileGetContentsResponse.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.fileContents != null && Object.hasOwnProperty.call(m, "fileContents"))
                $root.proto.FileGetContentsResponse.FileContents.encode(m.fileContents, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a FileGetContentsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.FileGetContentsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.FileGetContentsResponse} FileGetContentsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FileGetContentsResponse.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.FileGetContentsResponse();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.fileContents = $root.proto.FileGetContentsResponse.FileContents.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for FileGetContentsResponse
         * @function getTypeUrl
         * @memberof proto.FileGetContentsResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        FileGetContentsResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.FileGetContentsResponse";
        };

        FileGetContentsResponse.FileContents = (function () {
            /**
             * Properties of a FileContents.
             * @memberof proto.FileGetContentsResponse
             * @interface IFileContents
             * @property {proto.IFileID|null} [fileID] The file ID of the file whose contents are being returned
             * @property {Uint8Array|null} [contents] The bytes contained in the file
             */

            /**
             * Constructs a new FileContents.
             * @memberof proto.FileGetContentsResponse
             * @classdesc Represents a FileContents.
             * @implements IFileContents
             * @constructor
             * @param {proto.FileGetContentsResponse.IFileContents=} [p] Properties to set
             */
            function FileContents(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
            }

            /**
             * The file ID of the file whose contents are being returned
             * @member {proto.IFileID|null|undefined} fileID
             * @memberof proto.FileGetContentsResponse.FileContents
             * @instance
             */
            FileContents.prototype.fileID = null;

            /**
             * The bytes contained in the file
             * @member {Uint8Array} contents
             * @memberof proto.FileGetContentsResponse.FileContents
             * @instance
             */
            FileContents.prototype.contents = $util.newBuffer([]);

            /**
             * Creates a new FileContents instance using the specified properties.
             * @function create
             * @memberof proto.FileGetContentsResponse.FileContents
             * @static
             * @param {proto.FileGetContentsResponse.IFileContents=} [properties] Properties to set
             * @returns {proto.FileGetContentsResponse.FileContents} FileContents instance
             */
            FileContents.create = function create(properties) {
                return new FileContents(properties);
            };

            /**
             * Encodes the specified FileContents message. Does not implicitly {@link proto.FileGetContentsResponse.FileContents.verify|verify} messages.
             * @function encode
             * @memberof proto.FileGetContentsResponse.FileContents
             * @static
             * @param {proto.FileGetContentsResponse.IFileContents} m FileContents message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileContents.encode = function encode(m, w) {
                if (!w) w = $Writer.create();
                if (m.fileID != null && Object.hasOwnProperty.call(m, "fileID"))
                    $root.proto.FileID.encode(m.fileID, w.uint32(10).fork()).ldelim();
                if (m.contents != null && Object.hasOwnProperty.call(m, "contents")) w.uint32(18).bytes(m.contents);
                return w;
            };

            /**
             * Decodes a FileContents message from the specified reader or buffer.
             * @function decode
             * @memberof proto.FileGetContentsResponse.FileContents
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {proto.FileGetContentsResponse.FileContents} FileContents
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileContents.decode = function decode(r, l) {
                if (!(r instanceof $Reader)) r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l,
                    m = new $root.proto.FileGetContentsResponse.FileContents();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                        case 1: {
                            m.fileID = $root.proto.FileID.decode(r, r.uint32());
                            break;
                        }
                        case 2: {
                            m.contents = r.bytes();
                            break;
                        }
                        default:
                            r.skipType(t & 7);
                            break;
                    }
                }
                return m;
            };

            /**
             * Gets the default type url for FileContents
             * @function getTypeUrl
             * @memberof proto.FileGetContentsResponse.FileContents
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            FileContents.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/proto.FileGetContentsResponse.FileContents";
            };

            return FileContents;
        })();

        return FileGetContentsResponse;
    })();

    proto.FileGetInfoQuery = (function () {
        /**
         * Properties of a FileGetInfoQuery.
         * @memberof proto
         * @interface IFileGetInfoQuery
         * @property {proto.IQueryHeader|null} [header] Standard info sent from client to node, including the signed payment, and what kind of
         * response is requested (cost, state proof, both, or neither).
         * @property {proto.IFileID|null} [fileID] The file ID of the file for which information is requested
         */

        /**
         * Constructs a new FileGetInfoQuery.
         * @memberof proto
         * @classdesc Get all of the information about a file, except for its contents. When a file expires, it no
         * longer exists, and there will be no info about it, and the fileInfo field will be blank. If a
         * transaction or smart contract deletes the file, but it has not yet expired, then the fileInfo
         * field will be non-empty, the deleted field will be true, its size will be 0, and its contents
         * will be empty.
         * @implements IFileGetInfoQuery
         * @constructor
         * @param {proto.IFileGetInfoQuery=} [p] Properties to set
         */
        function FileGetInfoQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * Standard info sent from client to node, including the signed payment, and what kind of
         * response is requested (cost, state proof, both, or neither).
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.FileGetInfoQuery
         * @instance
         */
        FileGetInfoQuery.prototype.header = null;

        /**
         * The file ID of the file for which information is requested
         * @member {proto.IFileID|null|undefined} fileID
         * @memberof proto.FileGetInfoQuery
         * @instance
         */
        FileGetInfoQuery.prototype.fileID = null;

        /**
         * Creates a new FileGetInfoQuery instance using the specified properties.
         * @function create
         * @memberof proto.FileGetInfoQuery
         * @static
         * @param {proto.IFileGetInfoQuery=} [properties] Properties to set
         * @returns {proto.FileGetInfoQuery} FileGetInfoQuery instance
         */
        FileGetInfoQuery.create = function create(properties) {
            return new FileGetInfoQuery(properties);
        };

        /**
         * Encodes the specified FileGetInfoQuery message. Does not implicitly {@link proto.FileGetInfoQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.FileGetInfoQuery
         * @static
         * @param {proto.IFileGetInfoQuery} m FileGetInfoQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FileGetInfoQuery.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.fileID != null && Object.hasOwnProperty.call(m, "fileID"))
                $root.proto.FileID.encode(m.fileID, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a FileGetInfoQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.FileGetInfoQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.FileGetInfoQuery} FileGetInfoQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FileGetInfoQuery.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.FileGetInfoQuery();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.fileID = $root.proto.FileID.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for FileGetInfoQuery
         * @function getTypeUrl
         * @memberof proto.FileGetInfoQuery
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        FileGetInfoQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.FileGetInfoQuery";
        };

        return FileGetInfoQuery;
    })();

    proto.FileGetInfoResponse = (function () {
        /**
         * Properties of a FileGetInfoResponse.
         * @memberof proto
         * @interface IFileGetInfoResponse
         * @property {proto.IResponseHeader|null} [header] Standard response from node to client, including the requested fields: cost, or state proof,
         * or both, or neither
         * @property {proto.FileGetInfoResponse.IFileInfo|null} [fileInfo] The information about the file
         */

        /**
         * Constructs a new FileGetInfoResponse.
         * @memberof proto
         * @classdesc Response when the client sends the node FileGetInfoQuery
         * @implements IFileGetInfoResponse
         * @constructor
         * @param {proto.IFileGetInfoResponse=} [p] Properties to set
         */
        function FileGetInfoResponse(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * Standard response from node to client, including the requested fields: cost, or state proof,
         * or both, or neither
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.FileGetInfoResponse
         * @instance
         */
        FileGetInfoResponse.prototype.header = null;

        /**
         * The information about the file
         * @member {proto.FileGetInfoResponse.IFileInfo|null|undefined} fileInfo
         * @memberof proto.FileGetInfoResponse
         * @instance
         */
        FileGetInfoResponse.prototype.fileInfo = null;

        /**
         * Creates a new FileGetInfoResponse instance using the specified properties.
         * @function create
         * @memberof proto.FileGetInfoResponse
         * @static
         * @param {proto.IFileGetInfoResponse=} [properties] Properties to set
         * @returns {proto.FileGetInfoResponse} FileGetInfoResponse instance
         */
        FileGetInfoResponse.create = function create(properties) {
            return new FileGetInfoResponse(properties);
        };

        /**
         * Encodes the specified FileGetInfoResponse message. Does not implicitly {@link proto.FileGetInfoResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.FileGetInfoResponse
         * @static
         * @param {proto.IFileGetInfoResponse} m FileGetInfoResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FileGetInfoResponse.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.fileInfo != null && Object.hasOwnProperty.call(m, "fileInfo"))
                $root.proto.FileGetInfoResponse.FileInfo.encode(m.fileInfo, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a FileGetInfoResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.FileGetInfoResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.FileGetInfoResponse} FileGetInfoResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FileGetInfoResponse.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.FileGetInfoResponse();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.fileInfo = $root.proto.FileGetInfoResponse.FileInfo.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for FileGetInfoResponse
         * @function getTypeUrl
         * @memberof proto.FileGetInfoResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        FileGetInfoResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.FileGetInfoResponse";
        };

        FileGetInfoResponse.FileInfo = (function () {
            /**
             * Properties of a FileInfo.
             * @memberof proto.FileGetInfoResponse
             * @interface IFileInfo
             * @property {proto.IFileID|null} [fileID] The file ID of the file for which information is requested
             * @property {Long|null} [size] Number of bytes in contents
             * @property {proto.ITimestamp|null} [expirationTime] The current time at which this account is set to expire
             * @property {boolean|null} [deleted] True if deleted but not yet expired
             * @property {proto.IKeyList|null} [keys] One of these keys must sign in order to modify or delete the file
             * @property {string|null} [memo] The memo associated with the file
             * @property {Uint8Array|null} [ledgerId] The ledger ID the response was returned from; please see <a href="https://github.com/hashgraph/hedera-improvement-proposal/blob/master/HIP/hip-198.md">HIP-198</a> for the network-specific IDs.
             */

            /**
             * Constructs a new FileInfo.
             * @memberof proto.FileGetInfoResponse
             * @classdesc Represents a FileInfo.
             * @implements IFileInfo
             * @constructor
             * @param {proto.FileGetInfoResponse.IFileInfo=} [p] Properties to set
             */
            function FileInfo(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
            }

            /**
             * The file ID of the file for which information is requested
             * @member {proto.IFileID|null|undefined} fileID
             * @memberof proto.FileGetInfoResponse.FileInfo
             * @instance
             */
            FileInfo.prototype.fileID = null;

            /**
             * Number of bytes in contents
             * @member {Long} size
             * @memberof proto.FileGetInfoResponse.FileInfo
             * @instance
             */
            FileInfo.prototype.size = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

            /**
             * The current time at which this account is set to expire
             * @member {proto.ITimestamp|null|undefined} expirationTime
             * @memberof proto.FileGetInfoResponse.FileInfo
             * @instance
             */
            FileInfo.prototype.expirationTime = null;

            /**
             * True if deleted but not yet expired
             * @member {boolean} deleted
             * @memberof proto.FileGetInfoResponse.FileInfo
             * @instance
             */
            FileInfo.prototype.deleted = false;

            /**
             * One of these keys must sign in order to modify or delete the file
             * @member {proto.IKeyList|null|undefined} keys
             * @memberof proto.FileGetInfoResponse.FileInfo
             * @instance
             */
            FileInfo.prototype.keys = null;

            /**
             * The memo associated with the file
             * @member {string} memo
             * @memberof proto.FileGetInfoResponse.FileInfo
             * @instance
             */
            FileInfo.prototype.memo = "";

            /**
             * The ledger ID the response was returned from; please see <a href="https://github.com/hashgraph/hedera-improvement-proposal/blob/master/HIP/hip-198.md">HIP-198</a> for the network-specific IDs.
             * @member {Uint8Array} ledgerId
             * @memberof proto.FileGetInfoResponse.FileInfo
             * @instance
             */
            FileInfo.prototype.ledgerId = $util.newBuffer([]);

            /**
             * Creates a new FileInfo instance using the specified properties.
             * @function create
             * @memberof proto.FileGetInfoResponse.FileInfo
             * @static
             * @param {proto.FileGetInfoResponse.IFileInfo=} [properties] Properties to set
             * @returns {proto.FileGetInfoResponse.FileInfo} FileInfo instance
             */
            FileInfo.create = function create(properties) {
                return new FileInfo(properties);
            };

            /**
             * Encodes the specified FileInfo message. Does not implicitly {@link proto.FileGetInfoResponse.FileInfo.verify|verify} messages.
             * @function encode
             * @memberof proto.FileGetInfoResponse.FileInfo
             * @static
             * @param {proto.FileGetInfoResponse.IFileInfo} m FileInfo message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileInfo.encode = function encode(m, w) {
                if (!w) w = $Writer.create();
                if (m.fileID != null && Object.hasOwnProperty.call(m, "fileID"))
                    $root.proto.FileID.encode(m.fileID, w.uint32(10).fork()).ldelim();
                if (m.size != null && Object.hasOwnProperty.call(m, "size")) w.uint32(16).int64(m.size);
                if (m.expirationTime != null && Object.hasOwnProperty.call(m, "expirationTime"))
                    $root.proto.Timestamp.encode(m.expirationTime, w.uint32(26).fork()).ldelim();
                if (m.deleted != null && Object.hasOwnProperty.call(m, "deleted")) w.uint32(32).bool(m.deleted);
                if (m.keys != null && Object.hasOwnProperty.call(m, "keys"))
                    $root.proto.KeyList.encode(m.keys, w.uint32(42).fork()).ldelim();
                if (m.memo != null && Object.hasOwnProperty.call(m, "memo")) w.uint32(50).string(m.memo);
                if (m.ledgerId != null && Object.hasOwnProperty.call(m, "ledgerId")) w.uint32(58).bytes(m.ledgerId);
                return w;
            };

            /**
             * Decodes a FileInfo message from the specified reader or buffer.
             * @function decode
             * @memberof proto.FileGetInfoResponse.FileInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {proto.FileGetInfoResponse.FileInfo} FileInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileInfo.decode = function decode(r, l) {
                if (!(r instanceof $Reader)) r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l,
                    m = new $root.proto.FileGetInfoResponse.FileInfo();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                        case 1: {
                            m.fileID = $root.proto.FileID.decode(r, r.uint32());
                            break;
                        }
                        case 2: {
                            m.size = r.int64();
                            break;
                        }
                        case 3: {
                            m.expirationTime = $root.proto.Timestamp.decode(r, r.uint32());
                            break;
                        }
                        case 4: {
                            m.deleted = r.bool();
                            break;
                        }
                        case 5: {
                            m.keys = $root.proto.KeyList.decode(r, r.uint32());
                            break;
                        }
                        case 6: {
                            m.memo = r.string();
                            break;
                        }
                        case 7: {
                            m.ledgerId = r.bytes();
                            break;
                        }
                        default:
                            r.skipType(t & 7);
                            break;
                    }
                }
                return m;
            };

            /**
             * Gets the default type url for FileInfo
             * @function getTypeUrl
             * @memberof proto.FileGetInfoResponse.FileInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            FileInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/proto.FileGetInfoResponse.FileInfo";
            };

            return FileInfo;
        })();

        return FileGetInfoResponse;
    })();

    proto.TransactionGetReceiptQuery = (function () {
        /**
         * Properties of a TransactionGetReceiptQuery.
         * @memberof proto
         * @interface ITransactionGetReceiptQuery
         * @property {proto.IQueryHeader|null} [header] Standard info sent from client to node, including the signed payment, and what kind of
         * response is requested (cost, state proof, both, or neither).
         * @property {proto.ITransactionID|null} [transactionID] The ID of the transaction for which the receipt is requested.
         * @property {boolean|null} [includeDuplicates] Whether receipts of processing duplicate transactions should be returned along with the
         * receipt of processing the first consensus transaction with the given id whose status was
         * neither <tt>INVALID_NODE_ACCOUNT</tt> nor <tt>INVALID_PAYER_SIGNATURE</tt>; <b>or</b>, if no
         * such receipt exists, the receipt of processing the first transaction to reach consensus with
         * the given transaction id.
         * @property {boolean|null} [includeChildReceipts] Whether the response should include the receipts of any child transactions spawned by the
         * top-level transaction with the given transactionID.
         */

        /**
         * Constructs a new TransactionGetReceiptQuery.
         * @memberof proto
         * @classdesc Get the receipt of a transaction, given its transaction ID. Once a transaction reaches consensus,
         * then information about whether it succeeded or failed will be available until the end of the
         * receipt period.  Before and after the receipt period, and for a transaction that was never
         * submitted, the receipt is unknown.  This query is free (the payment field is left empty). No
         * State proof is available for this response
         * @implements ITransactionGetReceiptQuery
         * @constructor
         * @param {proto.ITransactionGetReceiptQuery=} [p] Properties to set
         */
        function TransactionGetReceiptQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * Standard info sent from client to node, including the signed payment, and what kind of
         * response is requested (cost, state proof, both, or neither).
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.TransactionGetReceiptQuery
         * @instance
         */
        TransactionGetReceiptQuery.prototype.header = null;

        /**
         * The ID of the transaction for which the receipt is requested.
         * @member {proto.ITransactionID|null|undefined} transactionID
         * @memberof proto.TransactionGetReceiptQuery
         * @instance
         */
        TransactionGetReceiptQuery.prototype.transactionID = null;

        /**
         * Whether receipts of processing duplicate transactions should be returned along with the
         * receipt of processing the first consensus transaction with the given id whose status was
         * neither <tt>INVALID_NODE_ACCOUNT</tt> nor <tt>INVALID_PAYER_SIGNATURE</tt>; <b>or</b>, if no
         * such receipt exists, the receipt of processing the first transaction to reach consensus with
         * the given transaction id.
         * @member {boolean} includeDuplicates
         * @memberof proto.TransactionGetReceiptQuery
         * @instance
         */
        TransactionGetReceiptQuery.prototype.includeDuplicates = false;

        /**
         * Whether the response should include the receipts of any child transactions spawned by the
         * top-level transaction with the given transactionID.
         * @member {boolean} includeChildReceipts
         * @memberof proto.TransactionGetReceiptQuery
         * @instance
         */
        TransactionGetReceiptQuery.prototype.includeChildReceipts = false;

        /**
         * Creates a new TransactionGetReceiptQuery instance using the specified properties.
         * @function create
         * @memberof proto.TransactionGetReceiptQuery
         * @static
         * @param {proto.ITransactionGetReceiptQuery=} [properties] Properties to set
         * @returns {proto.TransactionGetReceiptQuery} TransactionGetReceiptQuery instance
         */
        TransactionGetReceiptQuery.create = function create(properties) {
            return new TransactionGetReceiptQuery(properties);
        };

        /**
         * Encodes the specified TransactionGetReceiptQuery message. Does not implicitly {@link proto.TransactionGetReceiptQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.TransactionGetReceiptQuery
         * @static
         * @param {proto.ITransactionGetReceiptQuery} m TransactionGetReceiptQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionGetReceiptQuery.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.transactionID != null && Object.hasOwnProperty.call(m, "transactionID"))
                $root.proto.TransactionID.encode(m.transactionID, w.uint32(18).fork()).ldelim();
            if (m.includeDuplicates != null && Object.hasOwnProperty.call(m, "includeDuplicates"))
                w.uint32(24).bool(m.includeDuplicates);
            if (m.includeChildReceipts != null && Object.hasOwnProperty.call(m, "includeChildReceipts"))
                w.uint32(32).bool(m.includeChildReceipts);
            return w;
        };

        /**
         * Decodes a TransactionGetReceiptQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TransactionGetReceiptQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TransactionGetReceiptQuery} TransactionGetReceiptQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionGetReceiptQuery.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.TransactionGetReceiptQuery();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.transactionID = $root.proto.TransactionID.decode(r, r.uint32());
                        break;
                    }
                    case 3: {
                        m.includeDuplicates = r.bool();
                        break;
                    }
                    case 4: {
                        m.includeChildReceipts = r.bool();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TransactionGetReceiptQuery
         * @function getTypeUrl
         * @memberof proto.TransactionGetReceiptQuery
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TransactionGetReceiptQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TransactionGetReceiptQuery";
        };

        return TransactionGetReceiptQuery;
    })();

    proto.TransactionGetReceiptResponse = (function () {
        /**
         * Properties of a TransactionGetReceiptResponse.
         * @memberof proto
         * @interface ITransactionGetReceiptResponse
         * @property {proto.IResponseHeader|null} [header] Standard response from node to client, including the requested fields: cost, or state proof,
         * or both, or neither
         * @property {proto.ITransactionReceipt|null} [receipt] Either the receipt of processing the first consensus transaction with the given id whose
         * status was neither <tt>INVALID_NODE_ACCOUNT</tt> nor <tt>INVALID_PAYER_SIGNATURE</tt>;
         * <b>or</b>, if no such receipt exists, the receipt of processing the first transaction to
         * reach consensus with the given transaction id.
         * @property {Array.<proto.ITransactionReceipt>|null} [duplicateTransactionReceipts] The receipts of processing all transactions with the given id, in consensus time order.
         * @property {Array.<proto.ITransactionReceipt>|null} [childTransactionReceipts] The receipts (if any) of all child transactions spawned by the transaction with the
         * given top-level id, in consensus order. Always empty if the top-level status is UNKNOWN.
         */

        /**
         * Constructs a new TransactionGetReceiptResponse.
         * @memberof proto
         * @classdesc Response when the client sends the node TransactionGetReceiptQuery. If it created a new entity
         * (account, file, or smart contract instance) then one of the three ID fields will be filled in
         * with the ID of the new entity. Sometimes a single transaction will create more than one new
         * entity, such as when a new contract instance is created, and this also creates the new account
         * that it owned by that instance. No State proof is available for this response
         * @implements ITransactionGetReceiptResponse
         * @constructor
         * @param {proto.ITransactionGetReceiptResponse=} [p] Properties to set
         */
        function TransactionGetReceiptResponse(p) {
            this.duplicateTransactionReceipts = [];
            this.childTransactionReceipts = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * Standard response from node to client, including the requested fields: cost, or state proof,
         * or both, or neither
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.TransactionGetReceiptResponse
         * @instance
         */
        TransactionGetReceiptResponse.prototype.header = null;

        /**
         * Either the receipt of processing the first consensus transaction with the given id whose
         * status was neither <tt>INVALID_NODE_ACCOUNT</tt> nor <tt>INVALID_PAYER_SIGNATURE</tt>;
         * <b>or</b>, if no such receipt exists, the receipt of processing the first transaction to
         * reach consensus with the given transaction id.
         * @member {proto.ITransactionReceipt|null|undefined} receipt
         * @memberof proto.TransactionGetReceiptResponse
         * @instance
         */
        TransactionGetReceiptResponse.prototype.receipt = null;

        /**
         * The receipts of processing all transactions with the given id, in consensus time order.
         * @member {Array.<proto.ITransactionReceipt>} duplicateTransactionReceipts
         * @memberof proto.TransactionGetReceiptResponse
         * @instance
         */
        TransactionGetReceiptResponse.prototype.duplicateTransactionReceipts = $util.emptyArray;

        /**
         * The receipts (if any) of all child transactions spawned by the transaction with the
         * given top-level id, in consensus order. Always empty if the top-level status is UNKNOWN.
         * @member {Array.<proto.ITransactionReceipt>} childTransactionReceipts
         * @memberof proto.TransactionGetReceiptResponse
         * @instance
         */
        TransactionGetReceiptResponse.prototype.childTransactionReceipts = $util.emptyArray;

        /**
         * Creates a new TransactionGetReceiptResponse instance using the specified properties.
         * @function create
         * @memberof proto.TransactionGetReceiptResponse
         * @static
         * @param {proto.ITransactionGetReceiptResponse=} [properties] Properties to set
         * @returns {proto.TransactionGetReceiptResponse} TransactionGetReceiptResponse instance
         */
        TransactionGetReceiptResponse.create = function create(properties) {
            return new TransactionGetReceiptResponse(properties);
        };

        /**
         * Encodes the specified TransactionGetReceiptResponse message. Does not implicitly {@link proto.TransactionGetReceiptResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.TransactionGetReceiptResponse
         * @static
         * @param {proto.ITransactionGetReceiptResponse} m TransactionGetReceiptResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionGetReceiptResponse.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.receipt != null && Object.hasOwnProperty.call(m, "receipt"))
                $root.proto.TransactionReceipt.encode(m.receipt, w.uint32(18).fork()).ldelim();
            if (m.duplicateTransactionReceipts != null && m.duplicateTransactionReceipts.length) {
                for (var i = 0; i < m.duplicateTransactionReceipts.length; ++i)
                    $root.proto.TransactionReceipt.encode(
                        m.duplicateTransactionReceipts[i],
                        w.uint32(34).fork()
                    ).ldelim();
            }
            if (m.childTransactionReceipts != null && m.childTransactionReceipts.length) {
                for (var i = 0; i < m.childTransactionReceipts.length; ++i)
                    $root.proto.TransactionReceipt.encode(m.childTransactionReceipts[i], w.uint32(42).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a TransactionGetReceiptResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TransactionGetReceiptResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TransactionGetReceiptResponse} TransactionGetReceiptResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionGetReceiptResponse.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.TransactionGetReceiptResponse();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.receipt = $root.proto.TransactionReceipt.decode(r, r.uint32());
                        break;
                    }
                    case 4: {
                        if (!(m.duplicateTransactionReceipts && m.duplicateTransactionReceipts.length))
                            m.duplicateTransactionReceipts = [];
                        m.duplicateTransactionReceipts.push($root.proto.TransactionReceipt.decode(r, r.uint32()));
                        break;
                    }
                    case 5: {
                        if (!(m.childTransactionReceipts && m.childTransactionReceipts.length))
                            m.childTransactionReceipts = [];
                        m.childTransactionReceipts.push($root.proto.TransactionReceipt.decode(r, r.uint32()));
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TransactionGetReceiptResponse
         * @function getTypeUrl
         * @memberof proto.TransactionGetReceiptResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TransactionGetReceiptResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TransactionGetReceiptResponse";
        };

        return TransactionGetReceiptResponse;
    })();

    proto.TransactionGetRecordQuery = (function () {
        /**
         * Properties of a TransactionGetRecordQuery.
         * @memberof proto
         * @interface ITransactionGetRecordQuery
         * @property {proto.IQueryHeader|null} [header] Standard info sent from client to node, including the signed payment, and what kind of
         * response is requested (cost, state proof, both, or neither).
         * @property {proto.ITransactionID|null} [transactionID] The ID of the transaction for which the record is requested.
         * @property {boolean|null} [includeDuplicates] Whether records of processing duplicate transactions should be returned along with the record
         * of processing the first consensus transaction with the given id whose status was neither
         * <tt>INVALID_NODE_ACCOUNT</tt> nor <tt>INVALID_PAYER_SIGNATURE</tt>; <b>or</b>, if no such
         * record exists, the record of processing the first transaction to reach consensus with the
         * given transaction id..
         * @property {boolean|null} [includeChildRecords] Whether the response should include the records of any child transactions spawned by the
         * top-level transaction with the given transactionID.
         */

        /**
         * Constructs a new TransactionGetRecordQuery.
         * @memberof proto
         * @classdesc Get the record for a transaction. If the transaction requested a record, then the record lasts
         * for one hour, and a state proof is available for it. If the transaction created an account, file,
         * or smart contract instance, then the record will contain the ID for what it created. If the
         * transaction called a smart contract function, then the record contains the result of that call.
         * If the transaction was a cryptocurrency transfer, then the record includes the TransferList which
         * gives the details of that transfer. If the transaction didn't return anything that should be in
         * the record, then the results field will be set to nothing.
         * @implements ITransactionGetRecordQuery
         * @constructor
         * @param {proto.ITransactionGetRecordQuery=} [p] Properties to set
         */
        function TransactionGetRecordQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * Standard info sent from client to node, including the signed payment, and what kind of
         * response is requested (cost, state proof, both, or neither).
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.TransactionGetRecordQuery
         * @instance
         */
        TransactionGetRecordQuery.prototype.header = null;

        /**
         * The ID of the transaction for which the record is requested.
         * @member {proto.ITransactionID|null|undefined} transactionID
         * @memberof proto.TransactionGetRecordQuery
         * @instance
         */
        TransactionGetRecordQuery.prototype.transactionID = null;

        /**
         * Whether records of processing duplicate transactions should be returned along with the record
         * of processing the first consensus transaction with the given id whose status was neither
         * <tt>INVALID_NODE_ACCOUNT</tt> nor <tt>INVALID_PAYER_SIGNATURE</tt>; <b>or</b>, if no such
         * record exists, the record of processing the first transaction to reach consensus with the
         * given transaction id..
         * @member {boolean} includeDuplicates
         * @memberof proto.TransactionGetRecordQuery
         * @instance
         */
        TransactionGetRecordQuery.prototype.includeDuplicates = false;

        /**
         * Whether the response should include the records of any child transactions spawned by the
         * top-level transaction with the given transactionID.
         * @member {boolean} includeChildRecords
         * @memberof proto.TransactionGetRecordQuery
         * @instance
         */
        TransactionGetRecordQuery.prototype.includeChildRecords = false;

        /**
         * Creates a new TransactionGetRecordQuery instance using the specified properties.
         * @function create
         * @memberof proto.TransactionGetRecordQuery
         * @static
         * @param {proto.ITransactionGetRecordQuery=} [properties] Properties to set
         * @returns {proto.TransactionGetRecordQuery} TransactionGetRecordQuery instance
         */
        TransactionGetRecordQuery.create = function create(properties) {
            return new TransactionGetRecordQuery(properties);
        };

        /**
         * Encodes the specified TransactionGetRecordQuery message. Does not implicitly {@link proto.TransactionGetRecordQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.TransactionGetRecordQuery
         * @static
         * @param {proto.ITransactionGetRecordQuery} m TransactionGetRecordQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionGetRecordQuery.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.transactionID != null && Object.hasOwnProperty.call(m, "transactionID"))
                $root.proto.TransactionID.encode(m.transactionID, w.uint32(18).fork()).ldelim();
            if (m.includeDuplicates != null && Object.hasOwnProperty.call(m, "includeDuplicates"))
                w.uint32(24).bool(m.includeDuplicates);
            if (m.includeChildRecords != null && Object.hasOwnProperty.call(m, "includeChildRecords"))
                w.uint32(32).bool(m.includeChildRecords);
            return w;
        };

        /**
         * Decodes a TransactionGetRecordQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TransactionGetRecordQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TransactionGetRecordQuery} TransactionGetRecordQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionGetRecordQuery.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.TransactionGetRecordQuery();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.transactionID = $root.proto.TransactionID.decode(r, r.uint32());
                        break;
                    }
                    case 3: {
                        m.includeDuplicates = r.bool();
                        break;
                    }
                    case 4: {
                        m.includeChildRecords = r.bool();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TransactionGetRecordQuery
         * @function getTypeUrl
         * @memberof proto.TransactionGetRecordQuery
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TransactionGetRecordQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TransactionGetRecordQuery";
        };

        return TransactionGetRecordQuery;
    })();

    proto.TransactionGetRecordResponse = (function () {
        /**
         * Properties of a TransactionGetRecordResponse.
         * @memberof proto
         * @interface ITransactionGetRecordResponse
         * @property {proto.IResponseHeader|null} [header] Standard response from node to client, including the requested fields: cost, or state proof,
         * or both, or neither.
         * @property {proto.ITransactionRecord|null} [transactionRecord] Either the record of processing the first consensus transaction with the given id whose
         * status was neither <tt>INVALID_NODE_ACCOUNT</tt> nor <tt>INVALID_PAYER_SIGNATURE</tt>;
         * <b>or</b>, if no such record exists, the record of processing the first transaction to reach
         * consensus with the given transaction id.
         * @property {Array.<proto.ITransactionRecord>|null} [duplicateTransactionRecords] The records of processing all consensus transaction with the same id as the distinguished
         * record above, in chronological order.
         * @property {Array.<proto.ITransactionRecord>|null} [childTransactionRecords] The records of processing all child transaction spawned by the transaction with the given
         * top-level id, in consensus order. Always empty if the top-level status is UNKNOWN.
         */

        /**
         * Constructs a new TransactionGetRecordResponse.
         * @memberof proto
         * @classdesc Response when the client sends the node TransactionGetRecordQuery
         * @implements ITransactionGetRecordResponse
         * @constructor
         * @param {proto.ITransactionGetRecordResponse=} [p] Properties to set
         */
        function TransactionGetRecordResponse(p) {
            this.duplicateTransactionRecords = [];
            this.childTransactionRecords = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * Standard response from node to client, including the requested fields: cost, or state proof,
         * or both, or neither.
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.TransactionGetRecordResponse
         * @instance
         */
        TransactionGetRecordResponse.prototype.header = null;

        /**
         * Either the record of processing the first consensus transaction with the given id whose
         * status was neither <tt>INVALID_NODE_ACCOUNT</tt> nor <tt>INVALID_PAYER_SIGNATURE</tt>;
         * <b>or</b>, if no such record exists, the record of processing the first transaction to reach
         * consensus with the given transaction id.
         * @member {proto.ITransactionRecord|null|undefined} transactionRecord
         * @memberof proto.TransactionGetRecordResponse
         * @instance
         */
        TransactionGetRecordResponse.prototype.transactionRecord = null;

        /**
         * The records of processing all consensus transaction with the same id as the distinguished
         * record above, in chronological order.
         * @member {Array.<proto.ITransactionRecord>} duplicateTransactionRecords
         * @memberof proto.TransactionGetRecordResponse
         * @instance
         */
        TransactionGetRecordResponse.prototype.duplicateTransactionRecords = $util.emptyArray;

        /**
         * The records of processing all child transaction spawned by the transaction with the given
         * top-level id, in consensus order. Always empty if the top-level status is UNKNOWN.
         * @member {Array.<proto.ITransactionRecord>} childTransactionRecords
         * @memberof proto.TransactionGetRecordResponse
         * @instance
         */
        TransactionGetRecordResponse.prototype.childTransactionRecords = $util.emptyArray;

        /**
         * Creates a new TransactionGetRecordResponse instance using the specified properties.
         * @function create
         * @memberof proto.TransactionGetRecordResponse
         * @static
         * @param {proto.ITransactionGetRecordResponse=} [properties] Properties to set
         * @returns {proto.TransactionGetRecordResponse} TransactionGetRecordResponse instance
         */
        TransactionGetRecordResponse.create = function create(properties) {
            return new TransactionGetRecordResponse(properties);
        };

        /**
         * Encodes the specified TransactionGetRecordResponse message. Does not implicitly {@link proto.TransactionGetRecordResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.TransactionGetRecordResponse
         * @static
         * @param {proto.ITransactionGetRecordResponse} m TransactionGetRecordResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionGetRecordResponse.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.transactionRecord != null && Object.hasOwnProperty.call(m, "transactionRecord"))
                $root.proto.TransactionRecord.encode(m.transactionRecord, w.uint32(26).fork()).ldelim();
            if (m.duplicateTransactionRecords != null && m.duplicateTransactionRecords.length) {
                for (var i = 0; i < m.duplicateTransactionRecords.length; ++i)
                    $root.proto.TransactionRecord.encode(
                        m.duplicateTransactionRecords[i],
                        w.uint32(34).fork()
                    ).ldelim();
            }
            if (m.childTransactionRecords != null && m.childTransactionRecords.length) {
                for (var i = 0; i < m.childTransactionRecords.length; ++i)
                    $root.proto.TransactionRecord.encode(m.childTransactionRecords[i], w.uint32(42).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a TransactionGetRecordResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TransactionGetRecordResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TransactionGetRecordResponse} TransactionGetRecordResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionGetRecordResponse.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.TransactionGetRecordResponse();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                        break;
                    }
                    case 3: {
                        m.transactionRecord = $root.proto.TransactionRecord.decode(r, r.uint32());
                        break;
                    }
                    case 4: {
                        if (!(m.duplicateTransactionRecords && m.duplicateTransactionRecords.length))
                            m.duplicateTransactionRecords = [];
                        m.duplicateTransactionRecords.push($root.proto.TransactionRecord.decode(r, r.uint32()));
                        break;
                    }
                    case 5: {
                        if (!(m.childTransactionRecords && m.childTransactionRecords.length))
                            m.childTransactionRecords = [];
                        m.childTransactionRecords.push($root.proto.TransactionRecord.decode(r, r.uint32()));
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TransactionGetRecordResponse
         * @function getTypeUrl
         * @memberof proto.TransactionGetRecordResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TransactionGetRecordResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TransactionGetRecordResponse";
        };

        return TransactionGetRecordResponse;
    })();

    proto.TransactionGetFastRecordQuery = (function () {
        /**
         * Properties of a TransactionGetFastRecordQuery.
         * @memberof proto
         * @interface ITransactionGetFastRecordQuery
         * @property {proto.IQueryHeader|null} [header] Standard info sent from client to node, including the signed payment, and what kind of
         * response is requested (cost, state proof, both, or neither).
         * @property {proto.ITransactionID|null} [transactionID] The ID of the transaction for which the record is requested.
         */

        /**
         * Constructs a new TransactionGetFastRecordQuery.
         * @memberof proto
         * @classdesc Get the tx record of a transaction, given its transaction ID. Once a transaction reaches
         * consensus, then information about whether it succeeded or failed will be available until the end
         * of the receipt period.  Before and after the receipt period, and for a transaction that was never
         * submitted, the receipt is unknown.  This query is free (the payment field is left empty).
         * @implements ITransactionGetFastRecordQuery
         * @constructor
         * @param {proto.ITransactionGetFastRecordQuery=} [p] Properties to set
         */
        function TransactionGetFastRecordQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * Standard info sent from client to node, including the signed payment, and what kind of
         * response is requested (cost, state proof, both, or neither).
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.TransactionGetFastRecordQuery
         * @instance
         */
        TransactionGetFastRecordQuery.prototype.header = null;

        /**
         * The ID of the transaction for which the record is requested.
         * @member {proto.ITransactionID|null|undefined} transactionID
         * @memberof proto.TransactionGetFastRecordQuery
         * @instance
         */
        TransactionGetFastRecordQuery.prototype.transactionID = null;

        /**
         * Creates a new TransactionGetFastRecordQuery instance using the specified properties.
         * @function create
         * @memberof proto.TransactionGetFastRecordQuery
         * @static
         * @param {proto.ITransactionGetFastRecordQuery=} [properties] Properties to set
         * @returns {proto.TransactionGetFastRecordQuery} TransactionGetFastRecordQuery instance
         */
        TransactionGetFastRecordQuery.create = function create(properties) {
            return new TransactionGetFastRecordQuery(properties);
        };

        /**
         * Encodes the specified TransactionGetFastRecordQuery message. Does not implicitly {@link proto.TransactionGetFastRecordQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.TransactionGetFastRecordQuery
         * @static
         * @param {proto.ITransactionGetFastRecordQuery} m TransactionGetFastRecordQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionGetFastRecordQuery.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.transactionID != null && Object.hasOwnProperty.call(m, "transactionID"))
                $root.proto.TransactionID.encode(m.transactionID, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a TransactionGetFastRecordQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TransactionGetFastRecordQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TransactionGetFastRecordQuery} TransactionGetFastRecordQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionGetFastRecordQuery.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.TransactionGetFastRecordQuery();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.transactionID = $root.proto.TransactionID.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TransactionGetFastRecordQuery
         * @function getTypeUrl
         * @memberof proto.TransactionGetFastRecordQuery
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TransactionGetFastRecordQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TransactionGetFastRecordQuery";
        };

        return TransactionGetFastRecordQuery;
    })();

    proto.TransactionGetFastRecordResponse = (function () {
        /**
         * Properties of a TransactionGetFastRecordResponse.
         * @memberof proto
         * @interface ITransactionGetFastRecordResponse
         * @property {proto.IResponseHeader|null} [header] Standard response from node to client, including the requested fields: cost, or state proof,
         * or both, or neither
         * @property {proto.ITransactionRecord|null} [transactionRecord] The requested transaction records
         */

        /**
         * Constructs a new TransactionGetFastRecordResponse.
         * @memberof proto
         * @classdesc Response when the client sends the node TransactionGetFastRecordQuery. If it created a new entity
         * (account, file, or smart contract instance) then one of the three ID fields will be filled in
         * with the ID of the new entity. Sometimes a single transaction will create more than one new
         * entity, such as when a new contract instance is created, and this also creates the new account
         * that it owned by that instance.
         * @implements ITransactionGetFastRecordResponse
         * @constructor
         * @param {proto.ITransactionGetFastRecordResponse=} [p] Properties to set
         */
        function TransactionGetFastRecordResponse(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * Standard response from node to client, including the requested fields: cost, or state proof,
         * or both, or neither
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.TransactionGetFastRecordResponse
         * @instance
         */
        TransactionGetFastRecordResponse.prototype.header = null;

        /**
         * The requested transaction records
         * @member {proto.ITransactionRecord|null|undefined} transactionRecord
         * @memberof proto.TransactionGetFastRecordResponse
         * @instance
         */
        TransactionGetFastRecordResponse.prototype.transactionRecord = null;

        /**
         * Creates a new TransactionGetFastRecordResponse instance using the specified properties.
         * @function create
         * @memberof proto.TransactionGetFastRecordResponse
         * @static
         * @param {proto.ITransactionGetFastRecordResponse=} [properties] Properties to set
         * @returns {proto.TransactionGetFastRecordResponse} TransactionGetFastRecordResponse instance
         */
        TransactionGetFastRecordResponse.create = function create(properties) {
            return new TransactionGetFastRecordResponse(properties);
        };

        /**
         * Encodes the specified TransactionGetFastRecordResponse message. Does not implicitly {@link proto.TransactionGetFastRecordResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.TransactionGetFastRecordResponse
         * @static
         * @param {proto.ITransactionGetFastRecordResponse} m TransactionGetFastRecordResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionGetFastRecordResponse.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.transactionRecord != null && Object.hasOwnProperty.call(m, "transactionRecord"))
                $root.proto.TransactionRecord.encode(m.transactionRecord, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a TransactionGetFastRecordResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TransactionGetFastRecordResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TransactionGetFastRecordResponse} TransactionGetFastRecordResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionGetFastRecordResponse.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.TransactionGetFastRecordResponse();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.transactionRecord = $root.proto.TransactionRecord.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TransactionGetFastRecordResponse
         * @function getTypeUrl
         * @memberof proto.TransactionGetFastRecordResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TransactionGetFastRecordResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TransactionGetFastRecordResponse";
        };

        return TransactionGetFastRecordResponse;
    })();

    proto.NetworkGetVersionInfoQuery = (function () {
        /**
         * Properties of a NetworkGetVersionInfoQuery.
         * @memberof proto
         * @interface INetworkGetVersionInfoQuery
         * @property {proto.IQueryHeader|null} [header] Standard info sent from client to node, including the signed payment, and what kind of
         * response is requested (cost, state proof, both, or neither).
         */

        /**
         * Constructs a new NetworkGetVersionInfoQuery.
         * @memberof proto
         * @classdesc Get the deployed versions of Hedera Services and the HAPI proto in semantic version format
         * @implements INetworkGetVersionInfoQuery
         * @constructor
         * @param {proto.INetworkGetVersionInfoQuery=} [p] Properties to set
         */
        function NetworkGetVersionInfoQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * Standard info sent from client to node, including the signed payment, and what kind of
         * response is requested (cost, state proof, both, or neither).
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.NetworkGetVersionInfoQuery
         * @instance
         */
        NetworkGetVersionInfoQuery.prototype.header = null;

        /**
         * Creates a new NetworkGetVersionInfoQuery instance using the specified properties.
         * @function create
         * @memberof proto.NetworkGetVersionInfoQuery
         * @static
         * @param {proto.INetworkGetVersionInfoQuery=} [properties] Properties to set
         * @returns {proto.NetworkGetVersionInfoQuery} NetworkGetVersionInfoQuery instance
         */
        NetworkGetVersionInfoQuery.create = function create(properties) {
            return new NetworkGetVersionInfoQuery(properties);
        };

        /**
         * Encodes the specified NetworkGetVersionInfoQuery message. Does not implicitly {@link proto.NetworkGetVersionInfoQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.NetworkGetVersionInfoQuery
         * @static
         * @param {proto.INetworkGetVersionInfoQuery} m NetworkGetVersionInfoQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NetworkGetVersionInfoQuery.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a NetworkGetVersionInfoQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.NetworkGetVersionInfoQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.NetworkGetVersionInfoQuery} NetworkGetVersionInfoQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NetworkGetVersionInfoQuery.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.NetworkGetVersionInfoQuery();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for NetworkGetVersionInfoQuery
         * @function getTypeUrl
         * @memberof proto.NetworkGetVersionInfoQuery
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        NetworkGetVersionInfoQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.NetworkGetVersionInfoQuery";
        };

        return NetworkGetVersionInfoQuery;
    })();

    proto.NetworkGetVersionInfoResponse = (function () {
        /**
         * Properties of a NetworkGetVersionInfoResponse.
         * @memberof proto
         * @interface INetworkGetVersionInfoResponse
         * @property {proto.IResponseHeader|null} [header] Standard response from node to client, including the requested fields: cost, or state proof,
         * or both, or neither
         * @property {proto.ISemanticVersion|null} [hapiProtoVersion] The Hedera API (HAPI) protobuf version recognized by the responding node.
         * @property {proto.ISemanticVersion|null} [hederaServicesVersion] The version of the Hedera Services software deployed on the responding node.
         */

        /**
         * Constructs a new NetworkGetVersionInfoResponse.
         * @memberof proto
         * @classdesc Response when the client sends the node NetworkGetVersionInfoQuery
         * @implements INetworkGetVersionInfoResponse
         * @constructor
         * @param {proto.INetworkGetVersionInfoResponse=} [p] Properties to set
         */
        function NetworkGetVersionInfoResponse(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * Standard response from node to client, including the requested fields: cost, or state proof,
         * or both, or neither
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.NetworkGetVersionInfoResponse
         * @instance
         */
        NetworkGetVersionInfoResponse.prototype.header = null;

        /**
         * The Hedera API (HAPI) protobuf version recognized by the responding node.
         * @member {proto.ISemanticVersion|null|undefined} hapiProtoVersion
         * @memberof proto.NetworkGetVersionInfoResponse
         * @instance
         */
        NetworkGetVersionInfoResponse.prototype.hapiProtoVersion = null;

        /**
         * The version of the Hedera Services software deployed on the responding node.
         * @member {proto.ISemanticVersion|null|undefined} hederaServicesVersion
         * @memberof proto.NetworkGetVersionInfoResponse
         * @instance
         */
        NetworkGetVersionInfoResponse.prototype.hederaServicesVersion = null;

        /**
         * Creates a new NetworkGetVersionInfoResponse instance using the specified properties.
         * @function create
         * @memberof proto.NetworkGetVersionInfoResponse
         * @static
         * @param {proto.INetworkGetVersionInfoResponse=} [properties] Properties to set
         * @returns {proto.NetworkGetVersionInfoResponse} NetworkGetVersionInfoResponse instance
         */
        NetworkGetVersionInfoResponse.create = function create(properties) {
            return new NetworkGetVersionInfoResponse(properties);
        };

        /**
         * Encodes the specified NetworkGetVersionInfoResponse message. Does not implicitly {@link proto.NetworkGetVersionInfoResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.NetworkGetVersionInfoResponse
         * @static
         * @param {proto.INetworkGetVersionInfoResponse} m NetworkGetVersionInfoResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NetworkGetVersionInfoResponse.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.hapiProtoVersion != null && Object.hasOwnProperty.call(m, "hapiProtoVersion"))
                $root.proto.SemanticVersion.encode(m.hapiProtoVersion, w.uint32(18).fork()).ldelim();
            if (m.hederaServicesVersion != null && Object.hasOwnProperty.call(m, "hederaServicesVersion"))
                $root.proto.SemanticVersion.encode(m.hederaServicesVersion, w.uint32(26).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a NetworkGetVersionInfoResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.NetworkGetVersionInfoResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.NetworkGetVersionInfoResponse} NetworkGetVersionInfoResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NetworkGetVersionInfoResponse.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.NetworkGetVersionInfoResponse();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.hapiProtoVersion = $root.proto.SemanticVersion.decode(r, r.uint32());
                        break;
                    }
                    case 3: {
                        m.hederaServicesVersion = $root.proto.SemanticVersion.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for NetworkGetVersionInfoResponse
         * @function getTypeUrl
         * @memberof proto.NetworkGetVersionInfoResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        NetworkGetVersionInfoResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.NetworkGetVersionInfoResponse";
        };

        return NetworkGetVersionInfoResponse;
    })();

    proto.NetworkGetExecutionTimeQuery = (function () {
        /**
         * Properties of a NetworkGetExecutionTimeQuery.
         * @memberof proto
         * @interface INetworkGetExecutionTimeQuery
         * @property {proto.IQueryHeader|null} [header] standard info sent from client to node including the signed payment, and what kind of response
         * is requested (cost, state proof, both, or neither).
         * @property {Array.<proto.ITransactionID>|null} [transactionIds] The id(s) of the transactions to get the execution time(s) of
         */

        /**
         * Constructs a new NetworkGetExecutionTimeQuery.
         * @memberof proto
         * @classdesc Gets the time in nanoseconds spent in <tt>handleTransaction</tt> for one or more
         * TransactionIDs (assuming they have reached consensus "recently", since only a limited
         * number of execution times are kept in-memory, depending on the value of the node-local
         * property <tt>stats.executionTimesToTrack</tt>).
         * @implements INetworkGetExecutionTimeQuery
         * @constructor
         * @param {proto.INetworkGetExecutionTimeQuery=} [p] Properties to set
         */
        function NetworkGetExecutionTimeQuery(p) {
            this.transactionIds = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * standard info sent from client to node including the signed payment, and what kind of response
         * is requested (cost, state proof, both, or neither).
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.NetworkGetExecutionTimeQuery
         * @instance
         */
        NetworkGetExecutionTimeQuery.prototype.header = null;

        /**
         * The id(s) of the transactions to get the execution time(s) of
         * @member {Array.<proto.ITransactionID>} transactionIds
         * @memberof proto.NetworkGetExecutionTimeQuery
         * @instance
         */
        NetworkGetExecutionTimeQuery.prototype.transactionIds = $util.emptyArray;

        /**
         * Creates a new NetworkGetExecutionTimeQuery instance using the specified properties.
         * @function create
         * @memberof proto.NetworkGetExecutionTimeQuery
         * @static
         * @param {proto.INetworkGetExecutionTimeQuery=} [properties] Properties to set
         * @returns {proto.NetworkGetExecutionTimeQuery} NetworkGetExecutionTimeQuery instance
         */
        NetworkGetExecutionTimeQuery.create = function create(properties) {
            return new NetworkGetExecutionTimeQuery(properties);
        };

        /**
         * Encodes the specified NetworkGetExecutionTimeQuery message. Does not implicitly {@link proto.NetworkGetExecutionTimeQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.NetworkGetExecutionTimeQuery
         * @static
         * @param {proto.INetworkGetExecutionTimeQuery} m NetworkGetExecutionTimeQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NetworkGetExecutionTimeQuery.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.transactionIds != null && m.transactionIds.length) {
                for (var i = 0; i < m.transactionIds.length; ++i)
                    $root.proto.TransactionID.encode(m.transactionIds[i], w.uint32(18).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a NetworkGetExecutionTimeQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.NetworkGetExecutionTimeQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.NetworkGetExecutionTimeQuery} NetworkGetExecutionTimeQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NetworkGetExecutionTimeQuery.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.NetworkGetExecutionTimeQuery();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        if (!(m.transactionIds && m.transactionIds.length)) m.transactionIds = [];
                        m.transactionIds.push($root.proto.TransactionID.decode(r, r.uint32()));
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for NetworkGetExecutionTimeQuery
         * @function getTypeUrl
         * @memberof proto.NetworkGetExecutionTimeQuery
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        NetworkGetExecutionTimeQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.NetworkGetExecutionTimeQuery";
        };

        return NetworkGetExecutionTimeQuery;
    })();

    proto.NetworkGetExecutionTimeResponse = (function () {
        /**
         * Properties of a NetworkGetExecutionTimeResponse.
         * @memberof proto
         * @interface INetworkGetExecutionTimeResponse
         * @property {proto.IResponseHeader|null} [header] Standard response from node to client, including the requested fields: cost, or state proof,
         * or both, or neither
         * @property {Array.<Long>|null} [executionTimes] The execution time(s) of the requested TransactionIDs, if available
         */

        /**
         * Constructs a new NetworkGetExecutionTimeResponse.
         * @memberof proto
         * @classdesc Response when the client sends the node NetworkGetExecutionTimeQuery; returns
         * INVALID_TRANSACTION_ID if any of the given TransactionIDs do not have available
         * execution times in the answering node.
         * @implements INetworkGetExecutionTimeResponse
         * @constructor
         * @param {proto.INetworkGetExecutionTimeResponse=} [p] Properties to set
         */
        function NetworkGetExecutionTimeResponse(p) {
            this.executionTimes = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * Standard response from node to client, including the requested fields: cost, or state proof,
         * or both, or neither
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.NetworkGetExecutionTimeResponse
         * @instance
         */
        NetworkGetExecutionTimeResponse.prototype.header = null;

        /**
         * The execution time(s) of the requested TransactionIDs, if available
         * @member {Array.<Long>} executionTimes
         * @memberof proto.NetworkGetExecutionTimeResponse
         * @instance
         */
        NetworkGetExecutionTimeResponse.prototype.executionTimes = $util.emptyArray;

        /**
         * Creates a new NetworkGetExecutionTimeResponse instance using the specified properties.
         * @function create
         * @memberof proto.NetworkGetExecutionTimeResponse
         * @static
         * @param {proto.INetworkGetExecutionTimeResponse=} [properties] Properties to set
         * @returns {proto.NetworkGetExecutionTimeResponse} NetworkGetExecutionTimeResponse instance
         */
        NetworkGetExecutionTimeResponse.create = function create(properties) {
            return new NetworkGetExecutionTimeResponse(properties);
        };

        /**
         * Encodes the specified NetworkGetExecutionTimeResponse message. Does not implicitly {@link proto.NetworkGetExecutionTimeResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.NetworkGetExecutionTimeResponse
         * @static
         * @param {proto.INetworkGetExecutionTimeResponse} m NetworkGetExecutionTimeResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NetworkGetExecutionTimeResponse.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.executionTimes != null && m.executionTimes.length) {
                w.uint32(18).fork();
                for (var i = 0; i < m.executionTimes.length; ++i) w.uint64(m.executionTimes[i]);
                w.ldelim();
            }
            return w;
        };

        /**
         * Decodes a NetworkGetExecutionTimeResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.NetworkGetExecutionTimeResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.NetworkGetExecutionTimeResponse} NetworkGetExecutionTimeResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NetworkGetExecutionTimeResponse.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.NetworkGetExecutionTimeResponse();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        if (!(m.executionTimes && m.executionTimes.length)) m.executionTimes = [];
                        if ((t & 7) === 2) {
                            var c2 = r.uint32() + r.pos;
                            while (r.pos < c2) m.executionTimes.push(r.uint64());
                        } else m.executionTimes.push(r.uint64());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for NetworkGetExecutionTimeResponse
         * @function getTypeUrl
         * @memberof proto.NetworkGetExecutionTimeResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        NetworkGetExecutionTimeResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.NetworkGetExecutionTimeResponse";
        };

        return NetworkGetExecutionTimeResponse;
    })();

    proto.TokenGetInfoQuery = (function () {
        /**
         * Properties of a TokenGetInfoQuery.
         * @memberof proto
         * @interface ITokenGetInfoQuery
         * @property {proto.IQueryHeader|null} [header] Standard info sent from client to node, including the signed payment, and what kind of
         * response is requested (cost, state proof, both, or neither)
         * @property {proto.ITokenID|null} [token] The token for which information is requested. If invalid token is provided, INVALID_TOKEN_ID
         * response is returned.
         */

        /**
         * Constructs a new TokenGetInfoQuery.
         * @memberof proto
         * @classdesc Gets information about Token instance
         * @implements ITokenGetInfoQuery
         * @constructor
         * @param {proto.ITokenGetInfoQuery=} [p] Properties to set
         */
        function TokenGetInfoQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * Standard info sent from client to node, including the signed payment, and what kind of
         * response is requested (cost, state proof, both, or neither)
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.TokenGetInfoQuery
         * @instance
         */
        TokenGetInfoQuery.prototype.header = null;

        /**
         * The token for which information is requested. If invalid token is provided, INVALID_TOKEN_ID
         * response is returned.
         * @member {proto.ITokenID|null|undefined} token
         * @memberof proto.TokenGetInfoQuery
         * @instance
         */
        TokenGetInfoQuery.prototype.token = null;

        /**
         * Creates a new TokenGetInfoQuery instance using the specified properties.
         * @function create
         * @memberof proto.TokenGetInfoQuery
         * @static
         * @param {proto.ITokenGetInfoQuery=} [properties] Properties to set
         * @returns {proto.TokenGetInfoQuery} TokenGetInfoQuery instance
         */
        TokenGetInfoQuery.create = function create(properties) {
            return new TokenGetInfoQuery(properties);
        };

        /**
         * Encodes the specified TokenGetInfoQuery message. Does not implicitly {@link proto.TokenGetInfoQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenGetInfoQuery
         * @static
         * @param {proto.ITokenGetInfoQuery} m TokenGetInfoQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenGetInfoQuery.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.token != null && Object.hasOwnProperty.call(m, "token"))
                $root.proto.TokenID.encode(m.token, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a TokenGetInfoQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenGetInfoQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenGetInfoQuery} TokenGetInfoQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenGetInfoQuery.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.TokenGetInfoQuery();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.token = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenGetInfoQuery
         * @function getTypeUrl
         * @memberof proto.TokenGetInfoQuery
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenGetInfoQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenGetInfoQuery";
        };

        return TokenGetInfoQuery;
    })();

    proto.TokenInfo = (function () {
        /**
         * Properties of a TokenInfo.
         * @memberof proto
         * @interface ITokenInfo
         * @property {proto.ITokenID|null} [tokenId] ID of the token instance
         * @property {string|null} [name] The name of the token. It is a string of ASCII only characters
         * @property {string|null} [symbol] The symbol of the token. It is a UTF-8 capitalized alphabetical string
         * @property {number|null} [decimals] The number of decimal places a token is divisible by. Always 0 for tokens of type
         * NON_FUNGIBLE_UNIQUE
         * @property {Long|null} [totalSupply] For tokens of type FUNGIBLE_COMMON - the total supply of tokens that are currently in
         * circulation. For tokens of type NON_FUNGIBLE_UNIQUE - the number of NFTs created of this
         * token instance
         * @property {proto.IAccountID|null} [treasury] The ID of the account which is set as Treasury
         * @property {proto.IKey|null} [adminKey] The key which can perform update/delete operations on the token. If empty, the token can be
         * perceived as immutable (not being able to be updated/deleted)
         * @property {proto.IKey|null} [kycKey] The key which can grant or revoke KYC of an account for the token's transactions. If empty,
         * KYC is not required, and KYC grant or revoke operations are not possible.
         * @property {proto.IKey|null} [freezeKey] The key which can freeze or unfreeze an account for token transactions. If empty, freezing is
         * not possible
         * @property {proto.IKey|null} [wipeKey] The key which can wipe token balance of an account. If empty, wipe is not possible
         * @property {proto.IKey|null} [supplyKey] The key which can change the supply of a token. The key is used to sign Token Mint/Burn
         * operations
         * @property {proto.TokenFreezeStatus|null} [defaultFreezeStatus] The default Freeze status (not applicable, frozen or unfrozen) of Hedera accounts relative to
         * this token. FreezeNotApplicable is returned if Token Freeze Key is empty. Frozen is returned
         * if Token Freeze Key is set and defaultFreeze is set to true. Unfrozen is returned if Token
         * Freeze Key is set and defaultFreeze is set to false
         * @property {proto.TokenKycStatus|null} [defaultKycStatus] The default KYC status (KycNotApplicable or Revoked) of Hedera accounts relative to this
         * token. KycNotApplicable is returned if KYC key is not set, otherwise Revoked
         * @property {boolean|null} [deleted] Specifies whether the token was deleted or not
         * @property {proto.IAccountID|null} [autoRenewAccount] An account which will be automatically charged to renew the token's expiration, at
         * autoRenewPeriod interval
         * @property {proto.IDuration|null} [autoRenewPeriod] The interval at which the auto-renew account will be charged to extend the token's expiry
         * @property {proto.ITimestamp|null} [expiry] The epoch second at which the token will expire
         * @property {string|null} [memo] The memo associated with the token
         * @property {proto.TokenType|null} [tokenType] The token type
         * @property {proto.TokenSupplyType|null} [supplyType] The token supply type
         * @property {Long|null} [maxSupply] For tokens of type FUNGIBLE_COMMON - The Maximum number of fungible tokens that can be in
         * circulation. For tokens of type NON_FUNGIBLE_UNIQUE - the maximum number of NFTs (serial
         * numbers) that can be in circulation
         * @property {proto.IKey|null} [feeScheduleKey] The key which can change the custom fee schedule of the token; if not set, the fee schedule
         * is immutable
         * @property {Array.<proto.ICustomFee>|null} [customFees] The custom fees to be assessed during a CryptoTransfer that transfers units of this token
         * @property {proto.IKey|null} [pauseKey] The Key which can pause and unpause the Token.
         * @property {proto.TokenPauseStatus|null} [pauseStatus] Specifies whether the token is paused or not. PauseNotApplicable is returned if pauseKey is not set.
         * @property {Uint8Array|null} [ledgerId] The ledger ID the response was returned from; please see <a href="https://github.com/hashgraph/hedera-improvement-proposal/blob/master/HIP/hip-198.md">HIP-198</a> for the network-specific IDs.
         */

        /**
         * Constructs a new TokenInfo.
         * @memberof proto
         * @classdesc The metadata about a Token instance
         * @implements ITokenInfo
         * @constructor
         * @param {proto.ITokenInfo=} [p] Properties to set
         */
        function TokenInfo(p) {
            this.customFees = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * ID of the token instance
         * @member {proto.ITokenID|null|undefined} tokenId
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.tokenId = null;

        /**
         * The name of the token. It is a string of ASCII only characters
         * @member {string} name
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.name = "";

        /**
         * The symbol of the token. It is a UTF-8 capitalized alphabetical string
         * @member {string} symbol
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.symbol = "";

        /**
         * The number of decimal places a token is divisible by. Always 0 for tokens of type
         * NON_FUNGIBLE_UNIQUE
         * @member {number} decimals
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.decimals = 0;

        /**
         * For tokens of type FUNGIBLE_COMMON - the total supply of tokens that are currently in
         * circulation. For tokens of type NON_FUNGIBLE_UNIQUE - the number of NFTs created of this
         * token instance
         * @member {Long} totalSupply
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.totalSupply = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * The ID of the account which is set as Treasury
         * @member {proto.IAccountID|null|undefined} treasury
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.treasury = null;

        /**
         * The key which can perform update/delete operations on the token. If empty, the token can be
         * perceived as immutable (not being able to be updated/deleted)
         * @member {proto.IKey|null|undefined} adminKey
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.adminKey = null;

        /**
         * The key which can grant or revoke KYC of an account for the token's transactions. If empty,
         * KYC is not required, and KYC grant or revoke operations are not possible.
         * @member {proto.IKey|null|undefined} kycKey
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.kycKey = null;

        /**
         * The key which can freeze or unfreeze an account for token transactions. If empty, freezing is
         * not possible
         * @member {proto.IKey|null|undefined} freezeKey
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.freezeKey = null;

        /**
         * The key which can wipe token balance of an account. If empty, wipe is not possible
         * @member {proto.IKey|null|undefined} wipeKey
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.wipeKey = null;

        /**
         * The key which can change the supply of a token. The key is used to sign Token Mint/Burn
         * operations
         * @member {proto.IKey|null|undefined} supplyKey
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.supplyKey = null;

        /**
         * The default Freeze status (not applicable, frozen or unfrozen) of Hedera accounts relative to
         * this token. FreezeNotApplicable is returned if Token Freeze Key is empty. Frozen is returned
         * if Token Freeze Key is set and defaultFreeze is set to true. Unfrozen is returned if Token
         * Freeze Key is set and defaultFreeze is set to false
         * @member {proto.TokenFreezeStatus} defaultFreezeStatus
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.defaultFreezeStatus = 0;

        /**
         * The default KYC status (KycNotApplicable or Revoked) of Hedera accounts relative to this
         * token. KycNotApplicable is returned if KYC key is not set, otherwise Revoked
         * @member {proto.TokenKycStatus} defaultKycStatus
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.defaultKycStatus = 0;

        /**
         * Specifies whether the token was deleted or not
         * @member {boolean} deleted
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.deleted = false;

        /**
         * An account which will be automatically charged to renew the token's expiration, at
         * autoRenewPeriod interval
         * @member {proto.IAccountID|null|undefined} autoRenewAccount
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.autoRenewAccount = null;

        /**
         * The interval at which the auto-renew account will be charged to extend the token's expiry
         * @member {proto.IDuration|null|undefined} autoRenewPeriod
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.autoRenewPeriod = null;

        /**
         * The epoch second at which the token will expire
         * @member {proto.ITimestamp|null|undefined} expiry
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.expiry = null;

        /**
         * The memo associated with the token
         * @member {string} memo
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.memo = "";

        /**
         * The token type
         * @member {proto.TokenType} tokenType
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.tokenType = 0;

        /**
         * The token supply type
         * @member {proto.TokenSupplyType} supplyType
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.supplyType = 0;

        /**
         * For tokens of type FUNGIBLE_COMMON - The Maximum number of fungible tokens that can be in
         * circulation. For tokens of type NON_FUNGIBLE_UNIQUE - the maximum number of NFTs (serial
         * numbers) that can be in circulation
         * @member {Long} maxSupply
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.maxSupply = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * The key which can change the custom fee schedule of the token; if not set, the fee schedule
         * is immutable
         * @member {proto.IKey|null|undefined} feeScheduleKey
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.feeScheduleKey = null;

        /**
         * The custom fees to be assessed during a CryptoTransfer that transfers units of this token
         * @member {Array.<proto.ICustomFee>} customFees
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.customFees = $util.emptyArray;

        /**
         * The Key which can pause and unpause the Token.
         * @member {proto.IKey|null|undefined} pauseKey
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.pauseKey = null;

        /**
         * Specifies whether the token is paused or not. PauseNotApplicable is returned if pauseKey is not set.
         * @member {proto.TokenPauseStatus} pauseStatus
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.pauseStatus = 0;

        /**
         * The ledger ID the response was returned from; please see <a href="https://github.com/hashgraph/hedera-improvement-proposal/blob/master/HIP/hip-198.md">HIP-198</a> for the network-specific IDs.
         * @member {Uint8Array} ledgerId
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.ledgerId = $util.newBuffer([]);

        /**
         * Creates a new TokenInfo instance using the specified properties.
         * @function create
         * @memberof proto.TokenInfo
         * @static
         * @param {proto.ITokenInfo=} [properties] Properties to set
         * @returns {proto.TokenInfo} TokenInfo instance
         */
        TokenInfo.create = function create(properties) {
            return new TokenInfo(properties);
        };

        /**
         * Encodes the specified TokenInfo message. Does not implicitly {@link proto.TokenInfo.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenInfo
         * @static
         * @param {proto.ITokenInfo} m TokenInfo message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenInfo.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.tokenId != null && Object.hasOwnProperty.call(m, "tokenId"))
                $root.proto.TokenID.encode(m.tokenId, w.uint32(10).fork()).ldelim();
            if (m.name != null && Object.hasOwnProperty.call(m, "name")) w.uint32(18).string(m.name);
            if (m.symbol != null && Object.hasOwnProperty.call(m, "symbol")) w.uint32(26).string(m.symbol);
            if (m.decimals != null && Object.hasOwnProperty.call(m, "decimals")) w.uint32(32).uint32(m.decimals);
            if (m.totalSupply != null && Object.hasOwnProperty.call(m, "totalSupply"))
                w.uint32(40).uint64(m.totalSupply);
            if (m.treasury != null && Object.hasOwnProperty.call(m, "treasury"))
                $root.proto.AccountID.encode(m.treasury, w.uint32(50).fork()).ldelim();
            if (m.adminKey != null && Object.hasOwnProperty.call(m, "adminKey"))
                $root.proto.Key.encode(m.adminKey, w.uint32(58).fork()).ldelim();
            if (m.kycKey != null && Object.hasOwnProperty.call(m, "kycKey"))
                $root.proto.Key.encode(m.kycKey, w.uint32(66).fork()).ldelim();
            if (m.freezeKey != null && Object.hasOwnProperty.call(m, "freezeKey"))
                $root.proto.Key.encode(m.freezeKey, w.uint32(74).fork()).ldelim();
            if (m.wipeKey != null && Object.hasOwnProperty.call(m, "wipeKey"))
                $root.proto.Key.encode(m.wipeKey, w.uint32(82).fork()).ldelim();
            if (m.supplyKey != null && Object.hasOwnProperty.call(m, "supplyKey"))
                $root.proto.Key.encode(m.supplyKey, w.uint32(90).fork()).ldelim();
            if (m.defaultFreezeStatus != null && Object.hasOwnProperty.call(m, "defaultFreezeStatus"))
                w.uint32(96).int32(m.defaultFreezeStatus);
            if (m.defaultKycStatus != null && Object.hasOwnProperty.call(m, "defaultKycStatus"))
                w.uint32(104).int32(m.defaultKycStatus);
            if (m.deleted != null && Object.hasOwnProperty.call(m, "deleted")) w.uint32(112).bool(m.deleted);
            if (m.autoRenewAccount != null && Object.hasOwnProperty.call(m, "autoRenewAccount"))
                $root.proto.AccountID.encode(m.autoRenewAccount, w.uint32(122).fork()).ldelim();
            if (m.autoRenewPeriod != null && Object.hasOwnProperty.call(m, "autoRenewPeriod"))
                $root.proto.Duration.encode(m.autoRenewPeriod, w.uint32(130).fork()).ldelim();
            if (m.expiry != null && Object.hasOwnProperty.call(m, "expiry"))
                $root.proto.Timestamp.encode(m.expiry, w.uint32(138).fork()).ldelim();
            if (m.memo != null && Object.hasOwnProperty.call(m, "memo")) w.uint32(146).string(m.memo);
            if (m.tokenType != null && Object.hasOwnProperty.call(m, "tokenType")) w.uint32(152).int32(m.tokenType);
            if (m.supplyType != null && Object.hasOwnProperty.call(m, "supplyType")) w.uint32(160).int32(m.supplyType);
            if (m.maxSupply != null && Object.hasOwnProperty.call(m, "maxSupply")) w.uint32(168).int64(m.maxSupply);
            if (m.feeScheduleKey != null && Object.hasOwnProperty.call(m, "feeScheduleKey"))
                $root.proto.Key.encode(m.feeScheduleKey, w.uint32(178).fork()).ldelim();
            if (m.customFees != null && m.customFees.length) {
                for (var i = 0; i < m.customFees.length; ++i)
                    $root.proto.CustomFee.encode(m.customFees[i], w.uint32(186).fork()).ldelim();
            }
            if (m.pauseKey != null && Object.hasOwnProperty.call(m, "pauseKey"))
                $root.proto.Key.encode(m.pauseKey, w.uint32(194).fork()).ldelim();
            if (m.pauseStatus != null && Object.hasOwnProperty.call(m, "pauseStatus"))
                w.uint32(200).int32(m.pauseStatus);
            if (m.ledgerId != null && Object.hasOwnProperty.call(m, "ledgerId")) w.uint32(210).bytes(m.ledgerId);
            return w;
        };

        /**
         * Decodes a TokenInfo message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenInfo} TokenInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenInfo.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.TokenInfo();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.tokenId = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.name = r.string();
                        break;
                    }
                    case 3: {
                        m.symbol = r.string();
                        break;
                    }
                    case 4: {
                        m.decimals = r.uint32();
                        break;
                    }
                    case 5: {
                        m.totalSupply = r.uint64();
                        break;
                    }
                    case 6: {
                        m.treasury = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    case 7: {
                        m.adminKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                    case 8: {
                        m.kycKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                    case 9: {
                        m.freezeKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                    case 10: {
                        m.wipeKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                    case 11: {
                        m.supplyKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                    case 12: {
                        m.defaultFreezeStatus = r.int32();
                        break;
                    }
                    case 13: {
                        m.defaultKycStatus = r.int32();
                        break;
                    }
                    case 14: {
                        m.deleted = r.bool();
                        break;
                    }
                    case 15: {
                        m.autoRenewAccount = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    case 16: {
                        m.autoRenewPeriod = $root.proto.Duration.decode(r, r.uint32());
                        break;
                    }
                    case 17: {
                        m.expiry = $root.proto.Timestamp.decode(r, r.uint32());
                        break;
                    }
                    case 18: {
                        m.memo = r.string();
                        break;
                    }
                    case 19: {
                        m.tokenType = r.int32();
                        break;
                    }
                    case 20: {
                        m.supplyType = r.int32();
                        break;
                    }
                    case 21: {
                        m.maxSupply = r.int64();
                        break;
                    }
                    case 22: {
                        m.feeScheduleKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                    case 23: {
                        if (!(m.customFees && m.customFees.length)) m.customFees = [];
                        m.customFees.push($root.proto.CustomFee.decode(r, r.uint32()));
                        break;
                    }
                    case 24: {
                        m.pauseKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                    case 25: {
                        m.pauseStatus = r.int32();
                        break;
                    }
                    case 26: {
                        m.ledgerId = r.bytes();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenInfo
         * @function getTypeUrl
         * @memberof proto.TokenInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenInfo";
        };

        return TokenInfo;
    })();

    proto.TokenGetInfoResponse = (function () {
        /**
         * Properties of a TokenGetInfoResponse.
         * @memberof proto
         * @interface ITokenGetInfoResponse
         * @property {proto.IResponseHeader|null} [header] Standard response from node to client, including the requested fields: cost, or state proof,
         * or both, or neither
         * @property {proto.ITokenInfo|null} [tokenInfo] The information requested about this token instance
         */

        /**
         * Constructs a new TokenGetInfoResponse.
         * @memberof proto
         * @classdesc Response when the client sends the node TokenGetInfoQuery
         * @implements ITokenGetInfoResponse
         * @constructor
         * @param {proto.ITokenGetInfoResponse=} [p] Properties to set
         */
        function TokenGetInfoResponse(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * Standard response from node to client, including the requested fields: cost, or state proof,
         * or both, or neither
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.TokenGetInfoResponse
         * @instance
         */
        TokenGetInfoResponse.prototype.header = null;

        /**
         * The information requested about this token instance
         * @member {proto.ITokenInfo|null|undefined} tokenInfo
         * @memberof proto.TokenGetInfoResponse
         * @instance
         */
        TokenGetInfoResponse.prototype.tokenInfo = null;

        /**
         * Creates a new TokenGetInfoResponse instance using the specified properties.
         * @function create
         * @memberof proto.TokenGetInfoResponse
         * @static
         * @param {proto.ITokenGetInfoResponse=} [properties] Properties to set
         * @returns {proto.TokenGetInfoResponse} TokenGetInfoResponse instance
         */
        TokenGetInfoResponse.create = function create(properties) {
            return new TokenGetInfoResponse(properties);
        };

        /**
         * Encodes the specified TokenGetInfoResponse message. Does not implicitly {@link proto.TokenGetInfoResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenGetInfoResponse
         * @static
         * @param {proto.ITokenGetInfoResponse} m TokenGetInfoResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenGetInfoResponse.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.tokenInfo != null && Object.hasOwnProperty.call(m, "tokenInfo"))
                $root.proto.TokenInfo.encode(m.tokenInfo, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a TokenGetInfoResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenGetInfoResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenGetInfoResponse} TokenGetInfoResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenGetInfoResponse.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.TokenGetInfoResponse();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.tokenInfo = $root.proto.TokenInfo.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenGetInfoResponse
         * @function getTypeUrl
         * @memberof proto.TokenGetInfoResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenGetInfoResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenGetInfoResponse";
        };

        return TokenGetInfoResponse;
    })();

    proto.ScheduleGetInfoQuery = (function () {
        /**
         * Properties of a ScheduleGetInfoQuery.
         * @memberof proto
         * @interface IScheduleGetInfoQuery
         * @property {proto.IQueryHeader|null} [header] standard info sent from client to node including the signed payment, and what kind of response
         * is requested (cost, state proof, both, or neither).
         * @property {proto.IScheduleID|null} [scheduleID] The id of the schedule to interrogate
         */

        /**
         * Constructs a new ScheduleGetInfoQuery.
         * @memberof proto
         * @classdesc Gets information about a schedule in the network's action queue.
         *
         * Responds with <tt>INVALID_SCHEDULE_ID</tt> if the requested schedule doesn't exist.
         * @implements IScheduleGetInfoQuery
         * @constructor
         * @param {proto.IScheduleGetInfoQuery=} [p] Properties to set
         */
        function ScheduleGetInfoQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * standard info sent from client to node including the signed payment, and what kind of response
         * is requested (cost, state proof, both, or neither).
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.ScheduleGetInfoQuery
         * @instance
         */
        ScheduleGetInfoQuery.prototype.header = null;

        /**
         * The id of the schedule to interrogate
         * @member {proto.IScheduleID|null|undefined} scheduleID
         * @memberof proto.ScheduleGetInfoQuery
         * @instance
         */
        ScheduleGetInfoQuery.prototype.scheduleID = null;

        /**
         * Creates a new ScheduleGetInfoQuery instance using the specified properties.
         * @function create
         * @memberof proto.ScheduleGetInfoQuery
         * @static
         * @param {proto.IScheduleGetInfoQuery=} [properties] Properties to set
         * @returns {proto.ScheduleGetInfoQuery} ScheduleGetInfoQuery instance
         */
        ScheduleGetInfoQuery.create = function create(properties) {
            return new ScheduleGetInfoQuery(properties);
        };

        /**
         * Encodes the specified ScheduleGetInfoQuery message. Does not implicitly {@link proto.ScheduleGetInfoQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.ScheduleGetInfoQuery
         * @static
         * @param {proto.IScheduleGetInfoQuery} m ScheduleGetInfoQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ScheduleGetInfoQuery.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.scheduleID != null && Object.hasOwnProperty.call(m, "scheduleID"))
                $root.proto.ScheduleID.encode(m.scheduleID, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a ScheduleGetInfoQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ScheduleGetInfoQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ScheduleGetInfoQuery} ScheduleGetInfoQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ScheduleGetInfoQuery.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.ScheduleGetInfoQuery();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.scheduleID = $root.proto.ScheduleID.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ScheduleGetInfoQuery
         * @function getTypeUrl
         * @memberof proto.ScheduleGetInfoQuery
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ScheduleGetInfoQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ScheduleGetInfoQuery";
        };

        return ScheduleGetInfoQuery;
    })();

    proto.ScheduleInfo = (function () {
        /**
         * Properties of a ScheduleInfo.
         * @memberof proto
         * @interface IScheduleInfo
         * @property {proto.IScheduleID|null} [scheduleID] The id of the schedule
         * @property {proto.ITimestamp|null} [deletionTime] If the schedule has been deleted, the consensus time when this occurred
         * @property {proto.ITimestamp|null} [executionTime] If the schedule has been executed, the consensus time when this occurred
         * @property {proto.ITimestamp|null} [expirationTime] The time at which the schedule will be evaluated for execution and then expire.
         *
         * Note: Before Long Term Scheduled Transactions are enabled, Scheduled Transactions will _never_ execute at expiration - they
         * will _only_ execute during the initial ScheduleCreate transaction or via ScheduleSign transactions and will _always_
         * expire at expirationTime.
         * @property {proto.ISchedulableTransactionBody|null} [scheduledTransactionBody] The scheduled transaction
         * @property {string|null} [memo] The publicly visible memo of the schedule
         * @property {proto.IKey|null} [adminKey] The key used to delete the schedule from state
         * @property {proto.IKeyList|null} [signers] The Ed25519 keys the network deems to have signed the scheduled transaction
         * @property {proto.IAccountID|null} [creatorAccountID] The id of the account that created the schedule
         * @property {proto.IAccountID|null} [payerAccountID] The id of the account responsible for the service fee of the scheduled transaction
         * @property {proto.ITransactionID|null} [scheduledTransactionID] The transaction id that will be used in the record of the scheduled transaction (if it
         * executes)
         * @property {Uint8Array|null} [ledgerId] The ledger ID the response was returned from; please see <a href="https://github.com/hashgraph/hedera-improvement-proposal/blob/master/HIP/hip-198.md">HIP-198</a> for the network-specific IDs.
         * @property {boolean|null} [waitForExpiry] When set to true, the transaction will be evaluated for execution at expiration_time instead
         * of when all required signatures are received.
         * When set to false, the transaction will execute immediately after sufficient signatures are received
         * to sign the contained transaction. During the initial ScheduleCreate transaction or via ScheduleSign transactions.
         *
         * Note: this field is unused until Long Term Scheduled Transactions are enabled.
         */

        /**
         * Constructs a new ScheduleInfo.
         * @memberof proto
         * @classdesc Information summarizing schedule state
         * @implements IScheduleInfo
         * @constructor
         * @param {proto.IScheduleInfo=} [p] Properties to set
         */
        function ScheduleInfo(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The id of the schedule
         * @member {proto.IScheduleID|null|undefined} scheduleID
         * @memberof proto.ScheduleInfo
         * @instance
         */
        ScheduleInfo.prototype.scheduleID = null;

        /**
         * If the schedule has been deleted, the consensus time when this occurred
         * @member {proto.ITimestamp|null|undefined} deletionTime
         * @memberof proto.ScheduleInfo
         * @instance
         */
        ScheduleInfo.prototype.deletionTime = null;

        /**
         * If the schedule has been executed, the consensus time when this occurred
         * @member {proto.ITimestamp|null|undefined} executionTime
         * @memberof proto.ScheduleInfo
         * @instance
         */
        ScheduleInfo.prototype.executionTime = null;

        /**
         * The time at which the schedule will be evaluated for execution and then expire.
         *
         * Note: Before Long Term Scheduled Transactions are enabled, Scheduled Transactions will _never_ execute at expiration - they
         * will _only_ execute during the initial ScheduleCreate transaction or via ScheduleSign transactions and will _always_
         * expire at expirationTime.
         * @member {proto.ITimestamp|null|undefined} expirationTime
         * @memberof proto.ScheduleInfo
         * @instance
         */
        ScheduleInfo.prototype.expirationTime = null;

        /**
         * The scheduled transaction
         * @member {proto.ISchedulableTransactionBody|null|undefined} scheduledTransactionBody
         * @memberof proto.ScheduleInfo
         * @instance
         */
        ScheduleInfo.prototype.scheduledTransactionBody = null;

        /**
         * The publicly visible memo of the schedule
         * @member {string} memo
         * @memberof proto.ScheduleInfo
         * @instance
         */
        ScheduleInfo.prototype.memo = "";

        /**
         * The key used to delete the schedule from state
         * @member {proto.IKey|null|undefined} adminKey
         * @memberof proto.ScheduleInfo
         * @instance
         */
        ScheduleInfo.prototype.adminKey = null;

        /**
         * The Ed25519 keys the network deems to have signed the scheduled transaction
         * @member {proto.IKeyList|null|undefined} signers
         * @memberof proto.ScheduleInfo
         * @instance
         */
        ScheduleInfo.prototype.signers = null;

        /**
         * The id of the account that created the schedule
         * @member {proto.IAccountID|null|undefined} creatorAccountID
         * @memberof proto.ScheduleInfo
         * @instance
         */
        ScheduleInfo.prototype.creatorAccountID = null;

        /**
         * The id of the account responsible for the service fee of the scheduled transaction
         * @member {proto.IAccountID|null|undefined} payerAccountID
         * @memberof proto.ScheduleInfo
         * @instance
         */
        ScheduleInfo.prototype.payerAccountID = null;

        /**
         * The transaction id that will be used in the record of the scheduled transaction (if it
         * executes)
         * @member {proto.ITransactionID|null|undefined} scheduledTransactionID
         * @memberof proto.ScheduleInfo
         * @instance
         */
        ScheduleInfo.prototype.scheduledTransactionID = null;

        /**
         * The ledger ID the response was returned from; please see <a href="https://github.com/hashgraph/hedera-improvement-proposal/blob/master/HIP/hip-198.md">HIP-198</a> for the network-specific IDs.
         * @member {Uint8Array} ledgerId
         * @memberof proto.ScheduleInfo
         * @instance
         */
        ScheduleInfo.prototype.ledgerId = $util.newBuffer([]);

        /**
         * When set to true, the transaction will be evaluated for execution at expiration_time instead
         * of when all required signatures are received.
         * When set to false, the transaction will execute immediately after sufficient signatures are received
         * to sign the contained transaction. During the initial ScheduleCreate transaction or via ScheduleSign transactions.
         *
         * Note: this field is unused until Long Term Scheduled Transactions are enabled.
         * @member {boolean} waitForExpiry
         * @memberof proto.ScheduleInfo
         * @instance
         */
        ScheduleInfo.prototype.waitForExpiry = false;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * ScheduleInfo data.
         * @member {"deletionTime"|"executionTime"|undefined} data
         * @memberof proto.ScheduleInfo
         * @instance
         */
        Object.defineProperty(ScheduleInfo.prototype, "data", {
            get: $util.oneOfGetter(($oneOfFields = ["deletionTime", "executionTime"])),
            set: $util.oneOfSetter($oneOfFields),
        });

        /**
         * Creates a new ScheduleInfo instance using the specified properties.
         * @function create
         * @memberof proto.ScheduleInfo
         * @static
         * @param {proto.IScheduleInfo=} [properties] Properties to set
         * @returns {proto.ScheduleInfo} ScheduleInfo instance
         */
        ScheduleInfo.create = function create(properties) {
            return new ScheduleInfo(properties);
        };

        /**
         * Encodes the specified ScheduleInfo message. Does not implicitly {@link proto.ScheduleInfo.verify|verify} messages.
         * @function encode
         * @memberof proto.ScheduleInfo
         * @static
         * @param {proto.IScheduleInfo} m ScheduleInfo message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ScheduleInfo.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.scheduleID != null && Object.hasOwnProperty.call(m, "scheduleID"))
                $root.proto.ScheduleID.encode(m.scheduleID, w.uint32(10).fork()).ldelim();
            if (m.deletionTime != null && Object.hasOwnProperty.call(m, "deletionTime"))
                $root.proto.Timestamp.encode(m.deletionTime, w.uint32(18).fork()).ldelim();
            if (m.executionTime != null && Object.hasOwnProperty.call(m, "executionTime"))
                $root.proto.Timestamp.encode(m.executionTime, w.uint32(26).fork()).ldelim();
            if (m.expirationTime != null && Object.hasOwnProperty.call(m, "expirationTime"))
                $root.proto.Timestamp.encode(m.expirationTime, w.uint32(34).fork()).ldelim();
            if (m.scheduledTransactionBody != null && Object.hasOwnProperty.call(m, "scheduledTransactionBody"))
                $root.proto.SchedulableTransactionBody.encode(m.scheduledTransactionBody, w.uint32(42).fork()).ldelim();
            if (m.memo != null && Object.hasOwnProperty.call(m, "memo")) w.uint32(50).string(m.memo);
            if (m.adminKey != null && Object.hasOwnProperty.call(m, "adminKey"))
                $root.proto.Key.encode(m.adminKey, w.uint32(58).fork()).ldelim();
            if (m.signers != null && Object.hasOwnProperty.call(m, "signers"))
                $root.proto.KeyList.encode(m.signers, w.uint32(66).fork()).ldelim();
            if (m.creatorAccountID != null && Object.hasOwnProperty.call(m, "creatorAccountID"))
                $root.proto.AccountID.encode(m.creatorAccountID, w.uint32(74).fork()).ldelim();
            if (m.payerAccountID != null && Object.hasOwnProperty.call(m, "payerAccountID"))
                $root.proto.AccountID.encode(m.payerAccountID, w.uint32(82).fork()).ldelim();
            if (m.scheduledTransactionID != null && Object.hasOwnProperty.call(m, "scheduledTransactionID"))
                $root.proto.TransactionID.encode(m.scheduledTransactionID, w.uint32(90).fork()).ldelim();
            if (m.ledgerId != null && Object.hasOwnProperty.call(m, "ledgerId")) w.uint32(98).bytes(m.ledgerId);
            if (m.waitForExpiry != null && Object.hasOwnProperty.call(m, "waitForExpiry"))
                w.uint32(104).bool(m.waitForExpiry);
            return w;
        };

        /**
         * Decodes a ScheduleInfo message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ScheduleInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ScheduleInfo} ScheduleInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ScheduleInfo.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.ScheduleInfo();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.scheduleID = $root.proto.ScheduleID.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.deletionTime = $root.proto.Timestamp.decode(r, r.uint32());
                        break;
                    }
                    case 3: {
                        m.executionTime = $root.proto.Timestamp.decode(r, r.uint32());
                        break;
                    }
                    case 4: {
                        m.expirationTime = $root.proto.Timestamp.decode(r, r.uint32());
                        break;
                    }
                    case 5: {
                        m.scheduledTransactionBody = $root.proto.SchedulableTransactionBody.decode(r, r.uint32());
                        break;
                    }
                    case 6: {
                        m.memo = r.string();
                        break;
                    }
                    case 7: {
                        m.adminKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    }
                    case 8: {
                        m.signers = $root.proto.KeyList.decode(r, r.uint32());
                        break;
                    }
                    case 9: {
                        m.creatorAccountID = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    case 10: {
                        m.payerAccountID = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    case 11: {
                        m.scheduledTransactionID = $root.proto.TransactionID.decode(r, r.uint32());
                        break;
                    }
                    case 12: {
                        m.ledgerId = r.bytes();
                        break;
                    }
                    case 13: {
                        m.waitForExpiry = r.bool();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ScheduleInfo
         * @function getTypeUrl
         * @memberof proto.ScheduleInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ScheduleInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ScheduleInfo";
        };

        return ScheduleInfo;
    })();

    proto.ScheduleGetInfoResponse = (function () {
        /**
         * Properties of a ScheduleGetInfoResponse.
         * @memberof proto
         * @interface IScheduleGetInfoResponse
         * @property {proto.IResponseHeader|null} [header] Standard response from node to client, including the requested fields: cost, or state proof, or
         * both, or neither
         * @property {proto.IScheduleInfo|null} [scheduleInfo] The information requested about this schedule instance
         */

        /**
         * Constructs a new ScheduleGetInfoResponse.
         * @memberof proto
         * @classdesc Response wrapper for the <tt>ScheduleInfo</tt>
         * @implements IScheduleGetInfoResponse
         * @constructor
         * @param {proto.IScheduleGetInfoResponse=} [p] Properties to set
         */
        function ScheduleGetInfoResponse(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * Standard response from node to client, including the requested fields: cost, or state proof, or
         * both, or neither
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.ScheduleGetInfoResponse
         * @instance
         */
        ScheduleGetInfoResponse.prototype.header = null;

        /**
         * The information requested about this schedule instance
         * @member {proto.IScheduleInfo|null|undefined} scheduleInfo
         * @memberof proto.ScheduleGetInfoResponse
         * @instance
         */
        ScheduleGetInfoResponse.prototype.scheduleInfo = null;

        /**
         * Creates a new ScheduleGetInfoResponse instance using the specified properties.
         * @function create
         * @memberof proto.ScheduleGetInfoResponse
         * @static
         * @param {proto.IScheduleGetInfoResponse=} [properties] Properties to set
         * @returns {proto.ScheduleGetInfoResponse} ScheduleGetInfoResponse instance
         */
        ScheduleGetInfoResponse.create = function create(properties) {
            return new ScheduleGetInfoResponse(properties);
        };

        /**
         * Encodes the specified ScheduleGetInfoResponse message. Does not implicitly {@link proto.ScheduleGetInfoResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ScheduleGetInfoResponse
         * @static
         * @param {proto.IScheduleGetInfoResponse} m ScheduleGetInfoResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ScheduleGetInfoResponse.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.scheduleInfo != null && Object.hasOwnProperty.call(m, "scheduleInfo"))
                $root.proto.ScheduleInfo.encode(m.scheduleInfo, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a ScheduleGetInfoResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ScheduleGetInfoResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ScheduleGetInfoResponse} ScheduleGetInfoResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ScheduleGetInfoResponse.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.ScheduleGetInfoResponse();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.scheduleInfo = $root.proto.ScheduleInfo.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ScheduleGetInfoResponse
         * @function getTypeUrl
         * @memberof proto.ScheduleGetInfoResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ScheduleGetInfoResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ScheduleGetInfoResponse";
        };

        return ScheduleGetInfoResponse;
    })();

    proto.TokenGetAccountNftInfosQuery = (function () {
        /**
         * Properties of a TokenGetAccountNftInfosQuery.
         * @memberof proto
         * @interface ITokenGetAccountNftInfosQuery
         * @property {proto.IQueryHeader|null} [header] Standard info sent from client to node, including the signed payment, and what kind of
         * response is requested (cost, state proof, both, or neither).
         * @property {proto.IAccountID|null} [accountID] The Account for which information is requested
         * @property {Long|null} [start] Specifies the start index (inclusive) of the range of NFTs to query for. Value must be in the
         * range [0; ownedNFTs-1]
         * @property {Long|null} [end] Specifies the end index (exclusive) of the range of NFTs to query for. Value must be in the
         * range (start; ownedNFTs]
         */

        /**
         * Constructs a new TokenGetAccountNftInfosQuery.
         * @memberof proto
         * @classdesc Applicable only to tokens of type NON_FUNGIBLE_UNIQUE. Gets info on NFTs N through M owned by the
         * specified accountId.
         * Example: If Account A owns 5 NFTs (might be of different Token Entity), having start=0 and end=5
         * will return all of the NFTs
         *
         * INVALID_QUERY_RANGE response code will be returned if:
         * 1) Start > End
         * 2) Start and End indices are non-positive
         * 3) Start and End indices are out of boundaries for the retrieved nft list
         * 4) The range between Start and End is bigger than the global dynamic property for maximum query
         * range
         *
         * NOT_SUPPORTED response code will be returned if the queried token is of type FUNGIBLE_COMMON
         *
         * INVALID_ACCOUNT_ID response code will be returned if the queried account does not exist
         *
         * ACCOUNT_DELETED response code will be returned if the queried account has been deleted
         * @implements ITokenGetAccountNftInfosQuery
         * @constructor
         * @param {proto.ITokenGetAccountNftInfosQuery=} [p] Properties to set
         */
        function TokenGetAccountNftInfosQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * Standard info sent from client to node, including the signed payment, and what kind of
         * response is requested (cost, state proof, both, or neither).
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.TokenGetAccountNftInfosQuery
         * @instance
         */
        TokenGetAccountNftInfosQuery.prototype.header = null;

        /**
         * The Account for which information is requested
         * @member {proto.IAccountID|null|undefined} accountID
         * @memberof proto.TokenGetAccountNftInfosQuery
         * @instance
         */
        TokenGetAccountNftInfosQuery.prototype.accountID = null;

        /**
         * Specifies the start index (inclusive) of the range of NFTs to query for. Value must be in the
         * range [0; ownedNFTs-1]
         * @member {Long} start
         * @memberof proto.TokenGetAccountNftInfosQuery
         * @instance
         */
        TokenGetAccountNftInfosQuery.prototype.start = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * Specifies the end index (exclusive) of the range of NFTs to query for. Value must be in the
         * range (start; ownedNFTs]
         * @member {Long} end
         * @memberof proto.TokenGetAccountNftInfosQuery
         * @instance
         */
        TokenGetAccountNftInfosQuery.prototype.end = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * Creates a new TokenGetAccountNftInfosQuery instance using the specified properties.
         * @function create
         * @memberof proto.TokenGetAccountNftInfosQuery
         * @static
         * @param {proto.ITokenGetAccountNftInfosQuery=} [properties] Properties to set
         * @returns {proto.TokenGetAccountNftInfosQuery} TokenGetAccountNftInfosQuery instance
         */
        TokenGetAccountNftInfosQuery.create = function create(properties) {
            return new TokenGetAccountNftInfosQuery(properties);
        };

        /**
         * Encodes the specified TokenGetAccountNftInfosQuery message. Does not implicitly {@link proto.TokenGetAccountNftInfosQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenGetAccountNftInfosQuery
         * @static
         * @param {proto.ITokenGetAccountNftInfosQuery} m TokenGetAccountNftInfosQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenGetAccountNftInfosQuery.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.accountID != null && Object.hasOwnProperty.call(m, "accountID"))
                $root.proto.AccountID.encode(m.accountID, w.uint32(18).fork()).ldelim();
            if (m.start != null && Object.hasOwnProperty.call(m, "start")) w.uint32(24).int64(m.start);
            if (m.end != null && Object.hasOwnProperty.call(m, "end")) w.uint32(32).int64(m.end);
            return w;
        };

        /**
         * Decodes a TokenGetAccountNftInfosQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenGetAccountNftInfosQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenGetAccountNftInfosQuery} TokenGetAccountNftInfosQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenGetAccountNftInfosQuery.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.TokenGetAccountNftInfosQuery();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.accountID = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    case 3: {
                        m.start = r.int64();
                        break;
                    }
                    case 4: {
                        m.end = r.int64();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenGetAccountNftInfosQuery
         * @function getTypeUrl
         * @memberof proto.TokenGetAccountNftInfosQuery
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenGetAccountNftInfosQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenGetAccountNftInfosQuery";
        };

        return TokenGetAccountNftInfosQuery;
    })();

    proto.TokenGetAccountNftInfosResponse = (function () {
        /**
         * Properties of a TokenGetAccountNftInfosResponse.
         * @memberof proto
         * @interface ITokenGetAccountNftInfosResponse
         * @property {proto.IResponseHeader|null} [header] Standard response from node to client, including the requested fields: cost, or state proof,
         * or both, or neither
         * @property {Array.<proto.ITokenNftInfo>|null} [nfts] List of NFTs associated to the account
         */

        /**
         * Constructs a new TokenGetAccountNftInfosResponse.
         * @memberof proto
         * @classdesc UNDOCUMENTED
         * @implements ITokenGetAccountNftInfosResponse
         * @constructor
         * @param {proto.ITokenGetAccountNftInfosResponse=} [p] Properties to set
         */
        function TokenGetAccountNftInfosResponse(p) {
            this.nfts = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * Standard response from node to client, including the requested fields: cost, or state proof,
         * or both, or neither
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.TokenGetAccountNftInfosResponse
         * @instance
         */
        TokenGetAccountNftInfosResponse.prototype.header = null;

        /**
         * List of NFTs associated to the account
         * @member {Array.<proto.ITokenNftInfo>} nfts
         * @memberof proto.TokenGetAccountNftInfosResponse
         * @instance
         */
        TokenGetAccountNftInfosResponse.prototype.nfts = $util.emptyArray;

        /**
         * Creates a new TokenGetAccountNftInfosResponse instance using the specified properties.
         * @function create
         * @memberof proto.TokenGetAccountNftInfosResponse
         * @static
         * @param {proto.ITokenGetAccountNftInfosResponse=} [properties] Properties to set
         * @returns {proto.TokenGetAccountNftInfosResponse} TokenGetAccountNftInfosResponse instance
         */
        TokenGetAccountNftInfosResponse.create = function create(properties) {
            return new TokenGetAccountNftInfosResponse(properties);
        };

        /**
         * Encodes the specified TokenGetAccountNftInfosResponse message. Does not implicitly {@link proto.TokenGetAccountNftInfosResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenGetAccountNftInfosResponse
         * @static
         * @param {proto.ITokenGetAccountNftInfosResponse} m TokenGetAccountNftInfosResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenGetAccountNftInfosResponse.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.nfts != null && m.nfts.length) {
                for (var i = 0; i < m.nfts.length; ++i)
                    $root.proto.TokenNftInfo.encode(m.nfts[i], w.uint32(18).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a TokenGetAccountNftInfosResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenGetAccountNftInfosResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenGetAccountNftInfosResponse} TokenGetAccountNftInfosResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenGetAccountNftInfosResponse.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.TokenGetAccountNftInfosResponse();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        if (!(m.nfts && m.nfts.length)) m.nfts = [];
                        m.nfts.push($root.proto.TokenNftInfo.decode(r, r.uint32()));
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenGetAccountNftInfosResponse
         * @function getTypeUrl
         * @memberof proto.TokenGetAccountNftInfosResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenGetAccountNftInfosResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenGetAccountNftInfosResponse";
        };

        return TokenGetAccountNftInfosResponse;
    })();

    proto.NftID = (function () {
        /**
         * Properties of a NftID.
         * @memberof proto
         * @interface INftID
         * @property {proto.ITokenID|null} [tokenID] The (non-fungible) token of which this NFT is an instance
         * @property {Long|null} [serialNumber] The unique identifier of this instance
         */

        /**
         * Constructs a new NftID.
         * @memberof proto
         * @classdesc Represents an NFT on the Ledger
         * @implements INftID
         * @constructor
         * @param {proto.INftID=} [p] Properties to set
         */
        function NftID(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The (non-fungible) token of which this NFT is an instance
         * @member {proto.ITokenID|null|undefined} tokenID
         * @memberof proto.NftID
         * @instance
         */
        NftID.prototype.tokenID = null;

        /**
         * The unique identifier of this instance
         * @member {Long} serialNumber
         * @memberof proto.NftID
         * @instance
         */
        NftID.prototype.serialNumber = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * Creates a new NftID instance using the specified properties.
         * @function create
         * @memberof proto.NftID
         * @static
         * @param {proto.INftID=} [properties] Properties to set
         * @returns {proto.NftID} NftID instance
         */
        NftID.create = function create(properties) {
            return new NftID(properties);
        };

        /**
         * Encodes the specified NftID message. Does not implicitly {@link proto.NftID.verify|verify} messages.
         * @function encode
         * @memberof proto.NftID
         * @static
         * @param {proto.INftID} m NftID message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NftID.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.tokenID != null && Object.hasOwnProperty.call(m, "tokenID"))
                $root.proto.TokenID.encode(m.tokenID, w.uint32(10).fork()).ldelim();
            if (m.serialNumber != null && Object.hasOwnProperty.call(m, "serialNumber"))
                w.uint32(16).int64(m.serialNumber);
            return w;
        };

        /**
         * Decodes a NftID message from the specified reader or buffer.
         * @function decode
         * @memberof proto.NftID
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.NftID} NftID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NftID.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.NftID();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.tokenID = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.serialNumber = r.int64();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for NftID
         * @function getTypeUrl
         * @memberof proto.NftID
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        NftID.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.NftID";
        };

        return NftID;
    })();

    proto.TokenGetNftInfoQuery = (function () {
        /**
         * Properties of a TokenGetNftInfoQuery.
         * @memberof proto
         * @interface ITokenGetNftInfoQuery
         * @property {proto.IQueryHeader|null} [header] Standard info sent from client to node, including the signed payment, and what kind of
         * response is requested (cost, state proof, both, or neither).
         * @property {proto.INftID|null} [nftID] The ID of the NFT
         */

        /**
         * Constructs a new TokenGetNftInfoQuery.
         * @memberof proto
         * @classdesc Applicable only to tokens of type NON_FUNGIBLE_UNIQUE. Gets info on a NFT for a given TokenID (of
         * type NON_FUNGIBLE_UNIQUE) and serial number
         * @implements ITokenGetNftInfoQuery
         * @constructor
         * @param {proto.ITokenGetNftInfoQuery=} [p] Properties to set
         */
        function TokenGetNftInfoQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * Standard info sent from client to node, including the signed payment, and what kind of
         * response is requested (cost, state proof, both, or neither).
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.TokenGetNftInfoQuery
         * @instance
         */
        TokenGetNftInfoQuery.prototype.header = null;

        /**
         * The ID of the NFT
         * @member {proto.INftID|null|undefined} nftID
         * @memberof proto.TokenGetNftInfoQuery
         * @instance
         */
        TokenGetNftInfoQuery.prototype.nftID = null;

        /**
         * Creates a new TokenGetNftInfoQuery instance using the specified properties.
         * @function create
         * @memberof proto.TokenGetNftInfoQuery
         * @static
         * @param {proto.ITokenGetNftInfoQuery=} [properties] Properties to set
         * @returns {proto.TokenGetNftInfoQuery} TokenGetNftInfoQuery instance
         */
        TokenGetNftInfoQuery.create = function create(properties) {
            return new TokenGetNftInfoQuery(properties);
        };

        /**
         * Encodes the specified TokenGetNftInfoQuery message. Does not implicitly {@link proto.TokenGetNftInfoQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenGetNftInfoQuery
         * @static
         * @param {proto.ITokenGetNftInfoQuery} m TokenGetNftInfoQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenGetNftInfoQuery.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.nftID != null && Object.hasOwnProperty.call(m, "nftID"))
                $root.proto.NftID.encode(m.nftID, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a TokenGetNftInfoQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenGetNftInfoQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenGetNftInfoQuery} TokenGetNftInfoQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenGetNftInfoQuery.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.TokenGetNftInfoQuery();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.nftID = $root.proto.NftID.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenGetNftInfoQuery
         * @function getTypeUrl
         * @memberof proto.TokenGetNftInfoQuery
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenGetNftInfoQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenGetNftInfoQuery";
        };

        return TokenGetNftInfoQuery;
    })();

    proto.TokenNftInfo = (function () {
        /**
         * Properties of a TokenNftInfo.
         * @memberof proto
         * @interface ITokenNftInfo
         * @property {proto.INftID|null} [nftID] The ID of the NFT
         * @property {proto.IAccountID|null} [accountID] The current owner of the NFT
         * @property {proto.ITimestamp|null} [creationTime] The effective consensus timestamp at which the NFT was minted
         * @property {Uint8Array|null} [metadata] Represents the unique metadata of the NFT
         * @property {Uint8Array|null} [ledgerId] The ledger ID the response was returned from; please see <a href="https://github.com/hashgraph/hedera-improvement-proposal/blob/master/HIP/hip-198.md">HIP-198</a> for the network-specific IDs.
         * @property {proto.IAccountID|null} [spenderId] If an allowance is granted for the NFT, its corresponding spender account
         */

        /**
         * Constructs a new TokenNftInfo.
         * @memberof proto
         * @classdesc UNDOCUMENTED
         * @implements ITokenNftInfo
         * @constructor
         * @param {proto.ITokenNftInfo=} [p] Properties to set
         */
        function TokenNftInfo(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The ID of the NFT
         * @member {proto.INftID|null|undefined} nftID
         * @memberof proto.TokenNftInfo
         * @instance
         */
        TokenNftInfo.prototype.nftID = null;

        /**
         * The current owner of the NFT
         * @member {proto.IAccountID|null|undefined} accountID
         * @memberof proto.TokenNftInfo
         * @instance
         */
        TokenNftInfo.prototype.accountID = null;

        /**
         * The effective consensus timestamp at which the NFT was minted
         * @member {proto.ITimestamp|null|undefined} creationTime
         * @memberof proto.TokenNftInfo
         * @instance
         */
        TokenNftInfo.prototype.creationTime = null;

        /**
         * Represents the unique metadata of the NFT
         * @member {Uint8Array} metadata
         * @memberof proto.TokenNftInfo
         * @instance
         */
        TokenNftInfo.prototype.metadata = $util.newBuffer([]);

        /**
         * The ledger ID the response was returned from; please see <a href="https://github.com/hashgraph/hedera-improvement-proposal/blob/master/HIP/hip-198.md">HIP-198</a> for the network-specific IDs.
         * @member {Uint8Array} ledgerId
         * @memberof proto.TokenNftInfo
         * @instance
         */
        TokenNftInfo.prototype.ledgerId = $util.newBuffer([]);

        /**
         * If an allowance is granted for the NFT, its corresponding spender account
         * @member {proto.IAccountID|null|undefined} spenderId
         * @memberof proto.TokenNftInfo
         * @instance
         */
        TokenNftInfo.prototype.spenderId = null;

        /**
         * Creates a new TokenNftInfo instance using the specified properties.
         * @function create
         * @memberof proto.TokenNftInfo
         * @static
         * @param {proto.ITokenNftInfo=} [properties] Properties to set
         * @returns {proto.TokenNftInfo} TokenNftInfo instance
         */
        TokenNftInfo.create = function create(properties) {
            return new TokenNftInfo(properties);
        };

        /**
         * Encodes the specified TokenNftInfo message. Does not implicitly {@link proto.TokenNftInfo.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenNftInfo
         * @static
         * @param {proto.ITokenNftInfo} m TokenNftInfo message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenNftInfo.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.nftID != null && Object.hasOwnProperty.call(m, "nftID"))
                $root.proto.NftID.encode(m.nftID, w.uint32(10).fork()).ldelim();
            if (m.accountID != null && Object.hasOwnProperty.call(m, "accountID"))
                $root.proto.AccountID.encode(m.accountID, w.uint32(18).fork()).ldelim();
            if (m.creationTime != null && Object.hasOwnProperty.call(m, "creationTime"))
                $root.proto.Timestamp.encode(m.creationTime, w.uint32(26).fork()).ldelim();
            if (m.metadata != null && Object.hasOwnProperty.call(m, "metadata")) w.uint32(34).bytes(m.metadata);
            if (m.ledgerId != null && Object.hasOwnProperty.call(m, "ledgerId")) w.uint32(42).bytes(m.ledgerId);
            if (m.spenderId != null && Object.hasOwnProperty.call(m, "spenderId"))
                $root.proto.AccountID.encode(m.spenderId, w.uint32(50).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a TokenNftInfo message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenNftInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenNftInfo} TokenNftInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenNftInfo.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.TokenNftInfo();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.nftID = $root.proto.NftID.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.accountID = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    case 3: {
                        m.creationTime = $root.proto.Timestamp.decode(r, r.uint32());
                        break;
                    }
                    case 4: {
                        m.metadata = r.bytes();
                        break;
                    }
                    case 5: {
                        m.ledgerId = r.bytes();
                        break;
                    }
                    case 6: {
                        m.spenderId = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenNftInfo
         * @function getTypeUrl
         * @memberof proto.TokenNftInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenNftInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenNftInfo";
        };

        return TokenNftInfo;
    })();

    proto.TokenGetNftInfoResponse = (function () {
        /**
         * Properties of a TokenGetNftInfoResponse.
         * @memberof proto
         * @interface ITokenGetNftInfoResponse
         * @property {proto.IResponseHeader|null} [header] Standard response from node to client, including the requested fields: cost, or state proof,
         * or both, or neither
         * @property {proto.ITokenNftInfo|null} [nft] The information about this NFT
         */

        /**
         * Constructs a new TokenGetNftInfoResponse.
         * @memberof proto
         * @classdesc UNDOCUMENTED
         * @implements ITokenGetNftInfoResponse
         * @constructor
         * @param {proto.ITokenGetNftInfoResponse=} [p] Properties to set
         */
        function TokenGetNftInfoResponse(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * Standard response from node to client, including the requested fields: cost, or state proof,
         * or both, or neither
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.TokenGetNftInfoResponse
         * @instance
         */
        TokenGetNftInfoResponse.prototype.header = null;

        /**
         * The information about this NFT
         * @member {proto.ITokenNftInfo|null|undefined} nft
         * @memberof proto.TokenGetNftInfoResponse
         * @instance
         */
        TokenGetNftInfoResponse.prototype.nft = null;

        /**
         * Creates a new TokenGetNftInfoResponse instance using the specified properties.
         * @function create
         * @memberof proto.TokenGetNftInfoResponse
         * @static
         * @param {proto.ITokenGetNftInfoResponse=} [properties] Properties to set
         * @returns {proto.TokenGetNftInfoResponse} TokenGetNftInfoResponse instance
         */
        TokenGetNftInfoResponse.create = function create(properties) {
            return new TokenGetNftInfoResponse(properties);
        };

        /**
         * Encodes the specified TokenGetNftInfoResponse message. Does not implicitly {@link proto.TokenGetNftInfoResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenGetNftInfoResponse
         * @static
         * @param {proto.ITokenGetNftInfoResponse} m TokenGetNftInfoResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenGetNftInfoResponse.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.nft != null && Object.hasOwnProperty.call(m, "nft"))
                $root.proto.TokenNftInfo.encode(m.nft, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a TokenGetNftInfoResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenGetNftInfoResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenGetNftInfoResponse} TokenGetNftInfoResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenGetNftInfoResponse.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.TokenGetNftInfoResponse();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.nft = $root.proto.TokenNftInfo.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenGetNftInfoResponse
         * @function getTypeUrl
         * @memberof proto.TokenGetNftInfoResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenGetNftInfoResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenGetNftInfoResponse";
        };

        return TokenGetNftInfoResponse;
    })();

    proto.TokenGetNftInfosQuery = (function () {
        /**
         * Properties of a TokenGetNftInfosQuery.
         * @memberof proto
         * @interface ITokenGetNftInfosQuery
         * @property {proto.IQueryHeader|null} [header] Standard info sent from client to node, including the signed payment, and what kind of
         * response is requested (cost, state proof, both, or neither).
         * @property {proto.ITokenID|null} [tokenID] The ID of the token for which information is requested
         * @property {Long|null} [start] Specifies the start index (inclusive) of the range of NFTs to query for. Value must be in the
         * range [0; ownedNFTs-1]
         * @property {Long|null} [end] Specifies the end index (exclusive) of the range of NFTs to query for. Value must be in the
         * range (start; ownedNFTs]
         */

        /**
         * Constructs a new TokenGetNftInfosQuery.
         * @memberof proto
         * @classdesc Applicable only to tokens of type NON_FUNGIBLE_UNIQUE. Gets info on NFTs N through M on the list
         * of NFTs associated with a given NON_FUNGIBLE_UNIQUE Token.
         * Example: If there are 10 NFTs issued, having start=0 and end=5 will query for the first 5 NFTs.
         * Querying +all 10 NFTs will require start=0 and end=10
         *
         * INVALID_QUERY_RANGE response code will be returned if:
         * 1) Start > End
         * 2) Start and End indices are non-positive
         * 3) Start and End indices are out of boundaries for the retrieved nft list
         * 4) The range between Start and End is bigger than the global dynamic property for maximum query
         * range
         *
         * NOT_SUPPORTED response code will be returned if the queried token is of type FUNGIBLE_COMMON
         *
         * INVALID_TOKEN_ID response code will be returned if the queried token does not exist
         * @implements ITokenGetNftInfosQuery
         * @constructor
         * @param {proto.ITokenGetNftInfosQuery=} [p] Properties to set
         */
        function TokenGetNftInfosQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * Standard info sent from client to node, including the signed payment, and what kind of
         * response is requested (cost, state proof, both, or neither).
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.TokenGetNftInfosQuery
         * @instance
         */
        TokenGetNftInfosQuery.prototype.header = null;

        /**
         * The ID of the token for which information is requested
         * @member {proto.ITokenID|null|undefined} tokenID
         * @memberof proto.TokenGetNftInfosQuery
         * @instance
         */
        TokenGetNftInfosQuery.prototype.tokenID = null;

        /**
         * Specifies the start index (inclusive) of the range of NFTs to query for. Value must be in the
         * range [0; ownedNFTs-1]
         * @member {Long} start
         * @memberof proto.TokenGetNftInfosQuery
         * @instance
         */
        TokenGetNftInfosQuery.prototype.start = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * Specifies the end index (exclusive) of the range of NFTs to query for. Value must be in the
         * range (start; ownedNFTs]
         * @member {Long} end
         * @memberof proto.TokenGetNftInfosQuery
         * @instance
         */
        TokenGetNftInfosQuery.prototype.end = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * Creates a new TokenGetNftInfosQuery instance using the specified properties.
         * @function create
         * @memberof proto.TokenGetNftInfosQuery
         * @static
         * @param {proto.ITokenGetNftInfosQuery=} [properties] Properties to set
         * @returns {proto.TokenGetNftInfosQuery} TokenGetNftInfosQuery instance
         */
        TokenGetNftInfosQuery.create = function create(properties) {
            return new TokenGetNftInfosQuery(properties);
        };

        /**
         * Encodes the specified TokenGetNftInfosQuery message. Does not implicitly {@link proto.TokenGetNftInfosQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenGetNftInfosQuery
         * @static
         * @param {proto.ITokenGetNftInfosQuery} m TokenGetNftInfosQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenGetNftInfosQuery.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.tokenID != null && Object.hasOwnProperty.call(m, "tokenID"))
                $root.proto.TokenID.encode(m.tokenID, w.uint32(18).fork()).ldelim();
            if (m.start != null && Object.hasOwnProperty.call(m, "start")) w.uint32(24).int64(m.start);
            if (m.end != null && Object.hasOwnProperty.call(m, "end")) w.uint32(32).int64(m.end);
            return w;
        };

        /**
         * Decodes a TokenGetNftInfosQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenGetNftInfosQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenGetNftInfosQuery} TokenGetNftInfosQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenGetNftInfosQuery.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.TokenGetNftInfosQuery();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.tokenID = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                    case 3: {
                        m.start = r.int64();
                        break;
                    }
                    case 4: {
                        m.end = r.int64();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenGetNftInfosQuery
         * @function getTypeUrl
         * @memberof proto.TokenGetNftInfosQuery
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenGetNftInfosQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenGetNftInfosQuery";
        };

        return TokenGetNftInfosQuery;
    })();

    proto.TokenGetNftInfosResponse = (function () {
        /**
         * Properties of a TokenGetNftInfosResponse.
         * @memberof proto
         * @interface ITokenGetNftInfosResponse
         * @property {proto.IResponseHeader|null} [header] Standard response from node to client, including the requested fields: cost, or state proof,
         * or both, or neither
         * @property {proto.ITokenID|null} [tokenID] The Token with type NON_FUNGIBLE that this record is for
         * @property {Array.<proto.ITokenNftInfo>|null} [nfts] List of NFTs associated to the specified token
         */

        /**
         * Constructs a new TokenGetNftInfosResponse.
         * @memberof proto
         * @classdesc Represents a TokenGetNftInfosResponse.
         * @implements ITokenGetNftInfosResponse
         * @constructor
         * @param {proto.ITokenGetNftInfosResponse=} [p] Properties to set
         */
        function TokenGetNftInfosResponse(p) {
            this.nfts = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * Standard response from node to client, including the requested fields: cost, or state proof,
         * or both, or neither
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.TokenGetNftInfosResponse
         * @instance
         */
        TokenGetNftInfosResponse.prototype.header = null;

        /**
         * The Token with type NON_FUNGIBLE that this record is for
         * @member {proto.ITokenID|null|undefined} tokenID
         * @memberof proto.TokenGetNftInfosResponse
         * @instance
         */
        TokenGetNftInfosResponse.prototype.tokenID = null;

        /**
         * List of NFTs associated to the specified token
         * @member {Array.<proto.ITokenNftInfo>} nfts
         * @memberof proto.TokenGetNftInfosResponse
         * @instance
         */
        TokenGetNftInfosResponse.prototype.nfts = $util.emptyArray;

        /**
         * Creates a new TokenGetNftInfosResponse instance using the specified properties.
         * @function create
         * @memberof proto.TokenGetNftInfosResponse
         * @static
         * @param {proto.ITokenGetNftInfosResponse=} [properties] Properties to set
         * @returns {proto.TokenGetNftInfosResponse} TokenGetNftInfosResponse instance
         */
        TokenGetNftInfosResponse.create = function create(properties) {
            return new TokenGetNftInfosResponse(properties);
        };

        /**
         * Encodes the specified TokenGetNftInfosResponse message. Does not implicitly {@link proto.TokenGetNftInfosResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenGetNftInfosResponse
         * @static
         * @param {proto.ITokenGetNftInfosResponse} m TokenGetNftInfosResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenGetNftInfosResponse.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.tokenID != null && Object.hasOwnProperty.call(m, "tokenID"))
                $root.proto.TokenID.encode(m.tokenID, w.uint32(18).fork()).ldelim();
            if (m.nfts != null && m.nfts.length) {
                for (var i = 0; i < m.nfts.length; ++i)
                    $root.proto.TokenNftInfo.encode(m.nfts[i], w.uint32(26).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a TokenGetNftInfosResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenGetNftInfosResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenGetNftInfosResponse} TokenGetNftInfosResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenGetNftInfosResponse.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.TokenGetNftInfosResponse();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.tokenID = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                    case 3: {
                        if (!(m.nfts && m.nfts.length)) m.nfts = [];
                        m.nfts.push($root.proto.TokenNftInfo.decode(r, r.uint32()));
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenGetNftInfosResponse
         * @function getTypeUrl
         * @memberof proto.TokenGetNftInfosResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenGetNftInfosResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenGetNftInfosResponse";
        };

        return TokenGetNftInfosResponse;
    })();

    proto.GetAccountDetailsQuery = (function () {
        /**
         * Properties of a GetAccountDetailsQuery.
         * @memberof proto
         * @interface IGetAccountDetailsQuery
         * @property {proto.IQueryHeader|null} [header] Account details sent from client to node, including the signed payment, and what kind of
         * response is requested (cost, state proof, both, or neither).
         * @property {proto.IAccountID|null} [accountId] The account ID for which information is requested
         */

        /**
         * Constructs a new GetAccountDetailsQuery.
         * @memberof proto
         * @classdesc Gets all the information about an account, including balance and allowances. This does not get the list of
         * account records.
         * @implements IGetAccountDetailsQuery
         * @constructor
         * @param {proto.IGetAccountDetailsQuery=} [p] Properties to set
         */
        function GetAccountDetailsQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * Account details sent from client to node, including the signed payment, and what kind of
         * response is requested (cost, state proof, both, or neither).
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.GetAccountDetailsQuery
         * @instance
         */
        GetAccountDetailsQuery.prototype.header = null;

        /**
         * The account ID for which information is requested
         * @member {proto.IAccountID|null|undefined} accountId
         * @memberof proto.GetAccountDetailsQuery
         * @instance
         */
        GetAccountDetailsQuery.prototype.accountId = null;

        /**
         * Creates a new GetAccountDetailsQuery instance using the specified properties.
         * @function create
         * @memberof proto.GetAccountDetailsQuery
         * @static
         * @param {proto.IGetAccountDetailsQuery=} [properties] Properties to set
         * @returns {proto.GetAccountDetailsQuery} GetAccountDetailsQuery instance
         */
        GetAccountDetailsQuery.create = function create(properties) {
            return new GetAccountDetailsQuery(properties);
        };

        /**
         * Encodes the specified GetAccountDetailsQuery message. Does not implicitly {@link proto.GetAccountDetailsQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.GetAccountDetailsQuery
         * @static
         * @param {proto.IGetAccountDetailsQuery} m GetAccountDetailsQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetAccountDetailsQuery.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.accountId != null && Object.hasOwnProperty.call(m, "accountId"))
                $root.proto.AccountID.encode(m.accountId, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a GetAccountDetailsQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GetAccountDetailsQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.GetAccountDetailsQuery} GetAccountDetailsQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetAccountDetailsQuery.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.GetAccountDetailsQuery();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.accountId = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for GetAccountDetailsQuery
         * @function getTypeUrl
         * @memberof proto.GetAccountDetailsQuery
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetAccountDetailsQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.GetAccountDetailsQuery";
        };

        return GetAccountDetailsQuery;
    })();

    proto.GetAccountDetailsResponse = (function () {
        /**
         * Properties of a GetAccountDetailsResponse.
         * @memberof proto
         * @interface IGetAccountDetailsResponse
         * @property {proto.IResponseHeader|null} [header] Standard response from node to client, including the requested fields: cost, or state proof,
         * or both, or neither
         * @property {proto.GetAccountDetailsResponse.IAccountDetails|null} [accountDetails] Details of the account (a state proof can be generated for this)
         */

        /**
         * Constructs a new GetAccountDetailsResponse.
         * @memberof proto
         * @classdesc Response when the client sends the node GetAccountDetailsQuery
         * @implements IGetAccountDetailsResponse
         * @constructor
         * @param {proto.IGetAccountDetailsResponse=} [p] Properties to set
         */
        function GetAccountDetailsResponse(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * Standard response from node to client, including the requested fields: cost, or state proof,
         * or both, or neither
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.GetAccountDetailsResponse
         * @instance
         */
        GetAccountDetailsResponse.prototype.header = null;

        /**
         * Details of the account (a state proof can be generated for this)
         * @member {proto.GetAccountDetailsResponse.IAccountDetails|null|undefined} accountDetails
         * @memberof proto.GetAccountDetailsResponse
         * @instance
         */
        GetAccountDetailsResponse.prototype.accountDetails = null;

        /**
         * Creates a new GetAccountDetailsResponse instance using the specified properties.
         * @function create
         * @memberof proto.GetAccountDetailsResponse
         * @static
         * @param {proto.IGetAccountDetailsResponse=} [properties] Properties to set
         * @returns {proto.GetAccountDetailsResponse} GetAccountDetailsResponse instance
         */
        GetAccountDetailsResponse.create = function create(properties) {
            return new GetAccountDetailsResponse(properties);
        };

        /**
         * Encodes the specified GetAccountDetailsResponse message. Does not implicitly {@link proto.GetAccountDetailsResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.GetAccountDetailsResponse
         * @static
         * @param {proto.IGetAccountDetailsResponse} m GetAccountDetailsResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetAccountDetailsResponse.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.accountDetails != null && Object.hasOwnProperty.call(m, "accountDetails"))
                $root.proto.GetAccountDetailsResponse.AccountDetails.encode(
                    m.accountDetails,
                    w.uint32(18).fork()
                ).ldelim();
            return w;
        };

        /**
         * Decodes a GetAccountDetailsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GetAccountDetailsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.GetAccountDetailsResponse} GetAccountDetailsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetAccountDetailsResponse.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.GetAccountDetailsResponse();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.accountDetails = $root.proto.GetAccountDetailsResponse.AccountDetails.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for GetAccountDetailsResponse
         * @function getTypeUrl
         * @memberof proto.GetAccountDetailsResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetAccountDetailsResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.GetAccountDetailsResponse";
        };

        GetAccountDetailsResponse.AccountDetails = (function () {
            /**
             * Properties of an AccountDetails.
             * @memberof proto.GetAccountDetailsResponse
             * @interface IAccountDetails
             * @property {proto.IAccountID|null} [accountId] The account ID for which this information applies
             * @property {string|null} [contractAccountId] The Contract Account ID comprising of both the contract instance and the cryptocurrency
             * account owned by the contract instance, in the format used by Solidity
             * @property {boolean|null} [deleted] If true, then this account has been deleted, it will disappear when it expires, and all
             * transactions for it will fail except the transaction to extend its expiration date
             * @property {proto.IAccountID|null} [proxyAccountId] [Deprecated] The Account ID of the account to which this is proxy staked. If proxyAccountID is null,
             * or is an invalid account, or is an account that isn't a node, then this account is
             * automatically proxy staked to a node chosen by the network, but without earning payments.
             * If the proxyAccountID account refuses to accept proxy staking , or if it is not currently
             * running a node, then it will behave as if proxyAccountID was null.
             * @property {Long|null} [proxyReceived] The total number of tinybars proxy staked to this account
             * @property {proto.IKey|null} [key] The key for the account, which must sign in order to transfer out, or to modify the
             * account in any way other than extending its expiration date.
             * @property {Long|null} [balance] The current balance of account in tinybars
             * @property {boolean|null} [receiverSigRequired] If true, no transaction can transfer to this account unless signed by this account's key
             * @property {proto.ITimestamp|null} [expirationTime] The TimeStamp time at which this account is set to expire
             * @property {proto.IDuration|null} [autoRenewPeriod] The duration for expiration time will extend every this many seconds. If there are
             * insufficient funds, then it extends as long as possible. If it is empty when it expires,
             * then it is deleted.
             * @property {Array.<proto.ITokenRelationship>|null} [tokenRelationships] All tokens related to this account
             * @property {string|null} [memo] The memo associated with the account
             * @property {Long|null} [ownedNfts] The number of NFTs owned by this account
             * @property {number|null} [maxAutomaticTokenAssociations] The maximum number of tokens that an Account can be implicitly associated with.
             * @property {Uint8Array|null} [alias] The alias of this account
             * @property {Uint8Array|null} [ledgerId] The ledger ID the response was returned from; please see <a href="https://github.com/hashgraph/hedera-improvement-proposal/blob/master/HIP/hip-198.md">HIP-198</a> for the network-specific IDs.
             * @property {Array.<proto.IGrantedCryptoAllowance>|null} [grantedCryptoAllowances] All of the hbar allowances approved by the account owner.
             * @property {Array.<proto.IGrantedNftAllowance>|null} [grantedNftAllowances] All of the non-fungible token allowances approved by the account owner.
             * @property {Array.<proto.IGrantedTokenAllowance>|null} [grantedTokenAllowances] All of the fungible token allowances approved by the account owner.
             */

            /**
             * Constructs a new AccountDetails.
             * @memberof proto.GetAccountDetailsResponse
             * @classdesc Represents an AccountDetails.
             * @implements IAccountDetails
             * @constructor
             * @param {proto.GetAccountDetailsResponse.IAccountDetails=} [p] Properties to set
             */
            function AccountDetails(p) {
                this.tokenRelationships = [];
                this.grantedCryptoAllowances = [];
                this.grantedNftAllowances = [];
                this.grantedTokenAllowances = [];
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
            }

            /**
             * The account ID for which this information applies
             * @member {proto.IAccountID|null|undefined} accountId
             * @memberof proto.GetAccountDetailsResponse.AccountDetails
             * @instance
             */
            AccountDetails.prototype.accountId = null;

            /**
             * The Contract Account ID comprising of both the contract instance and the cryptocurrency
             * account owned by the contract instance, in the format used by Solidity
             * @member {string} contractAccountId
             * @memberof proto.GetAccountDetailsResponse.AccountDetails
             * @instance
             */
            AccountDetails.prototype.contractAccountId = "";

            /**
             * If true, then this account has been deleted, it will disappear when it expires, and all
             * transactions for it will fail except the transaction to extend its expiration date
             * @member {boolean} deleted
             * @memberof proto.GetAccountDetailsResponse.AccountDetails
             * @instance
             */
            AccountDetails.prototype.deleted = false;

            /**
             * [Deprecated] The Account ID of the account to which this is proxy staked. If proxyAccountID is null,
             * or is an invalid account, or is an account that isn't a node, then this account is
             * automatically proxy staked to a node chosen by the network, but without earning payments.
             * If the proxyAccountID account refuses to accept proxy staking , or if it is not currently
             * running a node, then it will behave as if proxyAccountID was null.
             * @member {proto.IAccountID|null|undefined} proxyAccountId
             * @memberof proto.GetAccountDetailsResponse.AccountDetails
             * @instance
             */
            AccountDetails.prototype.proxyAccountId = null;

            /**
             * The total number of tinybars proxy staked to this account
             * @member {Long} proxyReceived
             * @memberof proto.GetAccountDetailsResponse.AccountDetails
             * @instance
             */
            AccountDetails.prototype.proxyReceived = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

            /**
             * The key for the account, which must sign in order to transfer out, or to modify the
             * account in any way other than extending its expiration date.
             * @member {proto.IKey|null|undefined} key
             * @memberof proto.GetAccountDetailsResponse.AccountDetails
             * @instance
             */
            AccountDetails.prototype.key = null;

            /**
             * The current balance of account in tinybars
             * @member {Long} balance
             * @memberof proto.GetAccountDetailsResponse.AccountDetails
             * @instance
             */
            AccountDetails.prototype.balance = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

            /**
             * If true, no transaction can transfer to this account unless signed by this account's key
             * @member {boolean} receiverSigRequired
             * @memberof proto.GetAccountDetailsResponse.AccountDetails
             * @instance
             */
            AccountDetails.prototype.receiverSigRequired = false;

            /**
             * The TimeStamp time at which this account is set to expire
             * @member {proto.ITimestamp|null|undefined} expirationTime
             * @memberof proto.GetAccountDetailsResponse.AccountDetails
             * @instance
             */
            AccountDetails.prototype.expirationTime = null;

            /**
             * The duration for expiration time will extend every this many seconds. If there are
             * insufficient funds, then it extends as long as possible. If it is empty when it expires,
             * then it is deleted.
             * @member {proto.IDuration|null|undefined} autoRenewPeriod
             * @memberof proto.GetAccountDetailsResponse.AccountDetails
             * @instance
             */
            AccountDetails.prototype.autoRenewPeriod = null;

            /**
             * All tokens related to this account
             * @member {Array.<proto.ITokenRelationship>} tokenRelationships
             * @memberof proto.GetAccountDetailsResponse.AccountDetails
             * @instance
             */
            AccountDetails.prototype.tokenRelationships = $util.emptyArray;

            /**
             * The memo associated with the account
             * @member {string} memo
             * @memberof proto.GetAccountDetailsResponse.AccountDetails
             * @instance
             */
            AccountDetails.prototype.memo = "";

            /**
             * The number of NFTs owned by this account
             * @member {Long} ownedNfts
             * @memberof proto.GetAccountDetailsResponse.AccountDetails
             * @instance
             */
            AccountDetails.prototype.ownedNfts = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

            /**
             * The maximum number of tokens that an Account can be implicitly associated with.
             * @member {number} maxAutomaticTokenAssociations
             * @memberof proto.GetAccountDetailsResponse.AccountDetails
             * @instance
             */
            AccountDetails.prototype.maxAutomaticTokenAssociations = 0;

            /**
             * The alias of this account
             * @member {Uint8Array} alias
             * @memberof proto.GetAccountDetailsResponse.AccountDetails
             * @instance
             */
            AccountDetails.prototype.alias = $util.newBuffer([]);

            /**
             * The ledger ID the response was returned from; please see <a href="https://github.com/hashgraph/hedera-improvement-proposal/blob/master/HIP/hip-198.md">HIP-198</a> for the network-specific IDs.
             * @member {Uint8Array} ledgerId
             * @memberof proto.GetAccountDetailsResponse.AccountDetails
             * @instance
             */
            AccountDetails.prototype.ledgerId = $util.newBuffer([]);

            /**
             * All of the hbar allowances approved by the account owner.
             * @member {Array.<proto.IGrantedCryptoAllowance>} grantedCryptoAllowances
             * @memberof proto.GetAccountDetailsResponse.AccountDetails
             * @instance
             */
            AccountDetails.prototype.grantedCryptoAllowances = $util.emptyArray;

            /**
             * All of the non-fungible token allowances approved by the account owner.
             * @member {Array.<proto.IGrantedNftAllowance>} grantedNftAllowances
             * @memberof proto.GetAccountDetailsResponse.AccountDetails
             * @instance
             */
            AccountDetails.prototype.grantedNftAllowances = $util.emptyArray;

            /**
             * All of the fungible token allowances approved by the account owner.
             * @member {Array.<proto.IGrantedTokenAllowance>} grantedTokenAllowances
             * @memberof proto.GetAccountDetailsResponse.AccountDetails
             * @instance
             */
            AccountDetails.prototype.grantedTokenAllowances = $util.emptyArray;

            /**
             * Creates a new AccountDetails instance using the specified properties.
             * @function create
             * @memberof proto.GetAccountDetailsResponse.AccountDetails
             * @static
             * @param {proto.GetAccountDetailsResponse.IAccountDetails=} [properties] Properties to set
             * @returns {proto.GetAccountDetailsResponse.AccountDetails} AccountDetails instance
             */
            AccountDetails.create = function create(properties) {
                return new AccountDetails(properties);
            };

            /**
             * Encodes the specified AccountDetails message. Does not implicitly {@link proto.GetAccountDetailsResponse.AccountDetails.verify|verify} messages.
             * @function encode
             * @memberof proto.GetAccountDetailsResponse.AccountDetails
             * @static
             * @param {proto.GetAccountDetailsResponse.IAccountDetails} m AccountDetails message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AccountDetails.encode = function encode(m, w) {
                if (!w) w = $Writer.create();
                if (m.accountId != null && Object.hasOwnProperty.call(m, "accountId"))
                    $root.proto.AccountID.encode(m.accountId, w.uint32(10).fork()).ldelim();
                if (m.contractAccountId != null && Object.hasOwnProperty.call(m, "contractAccountId"))
                    w.uint32(18).string(m.contractAccountId);
                if (m.deleted != null && Object.hasOwnProperty.call(m, "deleted")) w.uint32(24).bool(m.deleted);
                if (m.proxyAccountId != null && Object.hasOwnProperty.call(m, "proxyAccountId"))
                    $root.proto.AccountID.encode(m.proxyAccountId, w.uint32(34).fork()).ldelim();
                if (m.proxyReceived != null && Object.hasOwnProperty.call(m, "proxyReceived"))
                    w.uint32(40).int64(m.proxyReceived);
                if (m.key != null && Object.hasOwnProperty.call(m, "key"))
                    $root.proto.Key.encode(m.key, w.uint32(50).fork()).ldelim();
                if (m.balance != null && Object.hasOwnProperty.call(m, "balance")) w.uint32(56).uint64(m.balance);
                if (m.receiverSigRequired != null && Object.hasOwnProperty.call(m, "receiverSigRequired"))
                    w.uint32(64).bool(m.receiverSigRequired);
                if (m.expirationTime != null && Object.hasOwnProperty.call(m, "expirationTime"))
                    $root.proto.Timestamp.encode(m.expirationTime, w.uint32(74).fork()).ldelim();
                if (m.autoRenewPeriod != null && Object.hasOwnProperty.call(m, "autoRenewPeriod"))
                    $root.proto.Duration.encode(m.autoRenewPeriod, w.uint32(82).fork()).ldelim();
                if (m.tokenRelationships != null && m.tokenRelationships.length) {
                    for (var i = 0; i < m.tokenRelationships.length; ++i)
                        $root.proto.TokenRelationship.encode(m.tokenRelationships[i], w.uint32(90).fork()).ldelim();
                }
                if (m.memo != null && Object.hasOwnProperty.call(m, "memo")) w.uint32(98).string(m.memo);
                if (m.ownedNfts != null && Object.hasOwnProperty.call(m, "ownedNfts")) w.uint32(104).int64(m.ownedNfts);
                if (
                    m.maxAutomaticTokenAssociations != null &&
                    Object.hasOwnProperty.call(m, "maxAutomaticTokenAssociations")
                )
                    w.uint32(112).int32(m.maxAutomaticTokenAssociations);
                if (m.alias != null && Object.hasOwnProperty.call(m, "alias")) w.uint32(122).bytes(m.alias);
                if (m.ledgerId != null && Object.hasOwnProperty.call(m, "ledgerId")) w.uint32(130).bytes(m.ledgerId);
                if (m.grantedCryptoAllowances != null && m.grantedCryptoAllowances.length) {
                    for (var i = 0; i < m.grantedCryptoAllowances.length; ++i)
                        $root.proto.GrantedCryptoAllowance.encode(
                            m.grantedCryptoAllowances[i],
                            w.uint32(138).fork()
                        ).ldelim();
                }
                if (m.grantedNftAllowances != null && m.grantedNftAllowances.length) {
                    for (var i = 0; i < m.grantedNftAllowances.length; ++i)
                        $root.proto.GrantedNftAllowance.encode(
                            m.grantedNftAllowances[i],
                            w.uint32(146).fork()
                        ).ldelim();
                }
                if (m.grantedTokenAllowances != null && m.grantedTokenAllowances.length) {
                    for (var i = 0; i < m.grantedTokenAllowances.length; ++i)
                        $root.proto.GrantedTokenAllowance.encode(
                            m.grantedTokenAllowances[i],
                            w.uint32(154).fork()
                        ).ldelim();
                }
                return w;
            };

            /**
             * Decodes an AccountDetails message from the specified reader or buffer.
             * @function decode
             * @memberof proto.GetAccountDetailsResponse.AccountDetails
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {proto.GetAccountDetailsResponse.AccountDetails} AccountDetails
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AccountDetails.decode = function decode(r, l) {
                if (!(r instanceof $Reader)) r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l,
                    m = new $root.proto.GetAccountDetailsResponse.AccountDetails();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                        case 1: {
                            m.accountId = $root.proto.AccountID.decode(r, r.uint32());
                            break;
                        }
                        case 2: {
                            m.contractAccountId = r.string();
                            break;
                        }
                        case 3: {
                            m.deleted = r.bool();
                            break;
                        }
                        case 4: {
                            m.proxyAccountId = $root.proto.AccountID.decode(r, r.uint32());
                            break;
                        }
                        case 5: {
                            m.proxyReceived = r.int64();
                            break;
                        }
                        case 6: {
                            m.key = $root.proto.Key.decode(r, r.uint32());
                            break;
                        }
                        case 7: {
                            m.balance = r.uint64();
                            break;
                        }
                        case 8: {
                            m.receiverSigRequired = r.bool();
                            break;
                        }
                        case 9: {
                            m.expirationTime = $root.proto.Timestamp.decode(r, r.uint32());
                            break;
                        }
                        case 10: {
                            m.autoRenewPeriod = $root.proto.Duration.decode(r, r.uint32());
                            break;
                        }
                        case 11: {
                            if (!(m.tokenRelationships && m.tokenRelationships.length)) m.tokenRelationships = [];
                            m.tokenRelationships.push($root.proto.TokenRelationship.decode(r, r.uint32()));
                            break;
                        }
                        case 12: {
                            m.memo = r.string();
                            break;
                        }
                        case 13: {
                            m.ownedNfts = r.int64();
                            break;
                        }
                        case 14: {
                            m.maxAutomaticTokenAssociations = r.int32();
                            break;
                        }
                        case 15: {
                            m.alias = r.bytes();
                            break;
                        }
                        case 16: {
                            m.ledgerId = r.bytes();
                            break;
                        }
                        case 17: {
                            if (!(m.grantedCryptoAllowances && m.grantedCryptoAllowances.length))
                                m.grantedCryptoAllowances = [];
                            m.grantedCryptoAllowances.push($root.proto.GrantedCryptoAllowance.decode(r, r.uint32()));
                            break;
                        }
                        case 18: {
                            if (!(m.grantedNftAllowances && m.grantedNftAllowances.length)) m.grantedNftAllowances = [];
                            m.grantedNftAllowances.push($root.proto.GrantedNftAllowance.decode(r, r.uint32()));
                            break;
                        }
                        case 19: {
                            if (!(m.grantedTokenAllowances && m.grantedTokenAllowances.length))
                                m.grantedTokenAllowances = [];
                            m.grantedTokenAllowances.push($root.proto.GrantedTokenAllowance.decode(r, r.uint32()));
                            break;
                        }
                        default:
                            r.skipType(t & 7);
                            break;
                    }
                }
                return m;
            };

            /**
             * Gets the default type url for AccountDetails
             * @function getTypeUrl
             * @memberof proto.GetAccountDetailsResponse.AccountDetails
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            AccountDetails.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/proto.GetAccountDetailsResponse.AccountDetails";
            };

            return AccountDetails;
        })();

        return GetAccountDetailsResponse;
    })();

    proto.GrantedCryptoAllowance = (function () {
        /**
         * Properties of a GrantedCryptoAllowance.
         * @memberof proto
         * @interface IGrantedCryptoAllowance
         * @property {proto.IAccountID|null} [spender] The account ID of the spender of the hbar allowance.
         * @property {Long|null} [amount] The amount of the spender's allowance in tinybars.
         */

        /**
         * Constructs a new GrantedCryptoAllowance.
         * @memberof proto
         * @classdesc A granted allowance of hbar transfers for a spender relative to the owner account.
         * @implements IGrantedCryptoAllowance
         * @constructor
         * @param {proto.IGrantedCryptoAllowance=} [p] Properties to set
         */
        function GrantedCryptoAllowance(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The account ID of the spender of the hbar allowance.
         * @member {proto.IAccountID|null|undefined} spender
         * @memberof proto.GrantedCryptoAllowance
         * @instance
         */
        GrantedCryptoAllowance.prototype.spender = null;

        /**
         * The amount of the spender's allowance in tinybars.
         * @member {Long} amount
         * @memberof proto.GrantedCryptoAllowance
         * @instance
         */
        GrantedCryptoAllowance.prototype.amount = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * Creates a new GrantedCryptoAllowance instance using the specified properties.
         * @function create
         * @memberof proto.GrantedCryptoAllowance
         * @static
         * @param {proto.IGrantedCryptoAllowance=} [properties] Properties to set
         * @returns {proto.GrantedCryptoAllowance} GrantedCryptoAllowance instance
         */
        GrantedCryptoAllowance.create = function create(properties) {
            return new GrantedCryptoAllowance(properties);
        };

        /**
         * Encodes the specified GrantedCryptoAllowance message. Does not implicitly {@link proto.GrantedCryptoAllowance.verify|verify} messages.
         * @function encode
         * @memberof proto.GrantedCryptoAllowance
         * @static
         * @param {proto.IGrantedCryptoAllowance} m GrantedCryptoAllowance message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GrantedCryptoAllowance.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.spender != null && Object.hasOwnProperty.call(m, "spender"))
                $root.proto.AccountID.encode(m.spender, w.uint32(10).fork()).ldelim();
            if (m.amount != null && Object.hasOwnProperty.call(m, "amount")) w.uint32(16).int64(m.amount);
            return w;
        };

        /**
         * Decodes a GrantedCryptoAllowance message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GrantedCryptoAllowance
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.GrantedCryptoAllowance} GrantedCryptoAllowance
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GrantedCryptoAllowance.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.GrantedCryptoAllowance();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.spender = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.amount = r.int64();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for GrantedCryptoAllowance
         * @function getTypeUrl
         * @memberof proto.GrantedCryptoAllowance
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GrantedCryptoAllowance.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.GrantedCryptoAllowance";
        };

        return GrantedCryptoAllowance;
    })();

    proto.GrantedNftAllowance = (function () {
        /**
         * Properties of a GrantedNftAllowance.
         * @memberof proto
         * @interface IGrantedNftAllowance
         * @property {proto.ITokenID|null} [tokenId] The token that the allowance pertains to.
         * @property {proto.IAccountID|null} [spender] The account ID of the spender that has been granted access to all NFTs of the owner
         */

        /**
         * Constructs a new GrantedNftAllowance.
         * @memberof proto
         * @classdesc A granted allowance for all the NFTs of a token for a spender relative to the owner account.
         * @implements IGrantedNftAllowance
         * @constructor
         * @param {proto.IGrantedNftAllowance=} [p] Properties to set
         */
        function GrantedNftAllowance(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The token that the allowance pertains to.
         * @member {proto.ITokenID|null|undefined} tokenId
         * @memberof proto.GrantedNftAllowance
         * @instance
         */
        GrantedNftAllowance.prototype.tokenId = null;

        /**
         * The account ID of the spender that has been granted access to all NFTs of the owner
         * @member {proto.IAccountID|null|undefined} spender
         * @memberof proto.GrantedNftAllowance
         * @instance
         */
        GrantedNftAllowance.prototype.spender = null;

        /**
         * Creates a new GrantedNftAllowance instance using the specified properties.
         * @function create
         * @memberof proto.GrantedNftAllowance
         * @static
         * @param {proto.IGrantedNftAllowance=} [properties] Properties to set
         * @returns {proto.GrantedNftAllowance} GrantedNftAllowance instance
         */
        GrantedNftAllowance.create = function create(properties) {
            return new GrantedNftAllowance(properties);
        };

        /**
         * Encodes the specified GrantedNftAllowance message. Does not implicitly {@link proto.GrantedNftAllowance.verify|verify} messages.
         * @function encode
         * @memberof proto.GrantedNftAllowance
         * @static
         * @param {proto.IGrantedNftAllowance} m GrantedNftAllowance message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GrantedNftAllowance.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.tokenId != null && Object.hasOwnProperty.call(m, "tokenId"))
                $root.proto.TokenID.encode(m.tokenId, w.uint32(10).fork()).ldelim();
            if (m.spender != null && Object.hasOwnProperty.call(m, "spender"))
                $root.proto.AccountID.encode(m.spender, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a GrantedNftAllowance message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GrantedNftAllowance
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.GrantedNftAllowance} GrantedNftAllowance
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GrantedNftAllowance.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.GrantedNftAllowance();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.tokenId = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.spender = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for GrantedNftAllowance
         * @function getTypeUrl
         * @memberof proto.GrantedNftAllowance
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GrantedNftAllowance.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.GrantedNftAllowance";
        };

        return GrantedNftAllowance;
    })();

    proto.GrantedTokenAllowance = (function () {
        /**
         * Properties of a GrantedTokenAllowance.
         * @memberof proto
         * @interface IGrantedTokenAllowance
         * @property {proto.ITokenID|null} [tokenId] The token that the allowance pertains to.
         * @property {proto.IAccountID|null} [spender] The account ID of the token allowance spender.
         * @property {Long|null} [amount] The amount of the spender's token allowance.
         */

        /**
         * Constructs a new GrantedTokenAllowance.
         * @memberof proto
         * @classdesc A granted allowance of fungible token transfers for a spender relative to the owner account.
         * @implements IGrantedTokenAllowance
         * @constructor
         * @param {proto.IGrantedTokenAllowance=} [p] Properties to set
         */
        function GrantedTokenAllowance(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The token that the allowance pertains to.
         * @member {proto.ITokenID|null|undefined} tokenId
         * @memberof proto.GrantedTokenAllowance
         * @instance
         */
        GrantedTokenAllowance.prototype.tokenId = null;

        /**
         * The account ID of the token allowance spender.
         * @member {proto.IAccountID|null|undefined} spender
         * @memberof proto.GrantedTokenAllowance
         * @instance
         */
        GrantedTokenAllowance.prototype.spender = null;

        /**
         * The amount of the spender's token allowance.
         * @member {Long} amount
         * @memberof proto.GrantedTokenAllowance
         * @instance
         */
        GrantedTokenAllowance.prototype.amount = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * Creates a new GrantedTokenAllowance instance using the specified properties.
         * @function create
         * @memberof proto.GrantedTokenAllowance
         * @static
         * @param {proto.IGrantedTokenAllowance=} [properties] Properties to set
         * @returns {proto.GrantedTokenAllowance} GrantedTokenAllowance instance
         */
        GrantedTokenAllowance.create = function create(properties) {
            return new GrantedTokenAllowance(properties);
        };

        /**
         * Encodes the specified GrantedTokenAllowance message. Does not implicitly {@link proto.GrantedTokenAllowance.verify|verify} messages.
         * @function encode
         * @memberof proto.GrantedTokenAllowance
         * @static
         * @param {proto.IGrantedTokenAllowance} m GrantedTokenAllowance message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GrantedTokenAllowance.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.tokenId != null && Object.hasOwnProperty.call(m, "tokenId"))
                $root.proto.TokenID.encode(m.tokenId, w.uint32(10).fork()).ldelim();
            if (m.spender != null && Object.hasOwnProperty.call(m, "spender"))
                $root.proto.AccountID.encode(m.spender, w.uint32(18).fork()).ldelim();
            if (m.amount != null && Object.hasOwnProperty.call(m, "amount")) w.uint32(24).int64(m.amount);
            return w;
        };

        /**
         * Decodes a GrantedTokenAllowance message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GrantedTokenAllowance
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.GrantedTokenAllowance} GrantedTokenAllowance
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GrantedTokenAllowance.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.GrantedTokenAllowance();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.tokenId = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.spender = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    case 3: {
                        m.amount = r.int64();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for GrantedTokenAllowance
         * @function getTypeUrl
         * @memberof proto.GrantedTokenAllowance
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GrantedTokenAllowance.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.GrantedTokenAllowance";
        };

        return GrantedTokenAllowance;
    })();

    proto.Response = (function () {
        /**
         * Properties of a Response.
         * @memberof proto
         * @interface IResponse
         * @property {proto.IGetByKeyResponse|null} [getByKey] Get all entities associated with a given key
         * @property {proto.IGetBySolidityIDResponse|null} [getBySolidityID] Get the IDs in the format used in transactions, given the format used in Solidity
         * @property {proto.IContractCallLocalResponse|null} [contractCallLocal] Response to call a function of a smart contract instance
         * @property {proto.IContractGetBytecodeResponse|null} [contractGetBytecodeResponse] Get the runtime code for a smart contract instance
         * @property {proto.IContractGetInfoResponse|null} [contractGetInfo] Get information about a smart contract instance
         * @property {proto.IContractGetRecordsResponse|null} [contractGetRecordsResponse] Get all existing records for a smart contract instance
         * @property {proto.ICryptoGetAccountBalanceResponse|null} [cryptogetAccountBalance] Get the current balance in a cryptocurrency account
         * @property {proto.ICryptoGetAccountRecordsResponse|null} [cryptoGetAccountRecords] Get all the records that currently exist for transactions involving an account
         * @property {proto.ICryptoGetInfoResponse|null} [cryptoGetInfo] Get all information about an account
         * @property {proto.ICryptoGetLiveHashResponse|null} [cryptoGetLiveHash] Contains a livehash associated to an account
         * @property {proto.ICryptoGetStakersResponse|null} [cryptoGetProxyStakers] Get all the accounts that proxy stake to a given account, and how much they proxy stake
         * @property {proto.IFileGetContentsResponse|null} [fileGetContents] Get the contents of a file (the bytes stored in it)
         * @property {proto.IFileGetInfoResponse|null} [fileGetInfo] Get information about a file, such as its expiration date
         * @property {proto.ITransactionGetReceiptResponse|null} [transactionGetReceipt] Get a receipt for a transaction
         * @property {proto.ITransactionGetRecordResponse|null} [transactionGetRecord] Get a record for a transaction
         * @property {proto.ITransactionGetFastRecordResponse|null} [transactionGetFastRecord] Get a record for a transaction (lasts 180 seconds)
         * @property {proto.IConsensusGetTopicInfoResponse|null} [consensusGetTopicInfo] Parameters of and state of a consensus topic..
         * @property {proto.INetworkGetVersionInfoResponse|null} [networkGetVersionInfo] Semantic versions of Hedera Services and HAPI proto
         * @property {proto.ITokenGetInfoResponse|null} [tokenGetInfo] Get all information about a token
         * @property {proto.IScheduleGetInfoResponse|null} [scheduleGetInfo] Get all information about a schedule entity
         * @property {proto.ITokenGetAccountNftInfosResponse|null} [tokenGetAccountNftInfos] A list of the NFTs associated with the account
         * @property {proto.ITokenGetNftInfoResponse|null} [tokenGetNftInfo] All information about an NFT
         * @property {proto.ITokenGetNftInfosResponse|null} [tokenGetNftInfos] A list of the NFTs for the token
         * @property {proto.INetworkGetExecutionTimeResponse|null} [networkGetExecutionTime] Execution times of "sufficiently recent" transactions
         * @property {proto.IGetAccountDetailsResponse|null} [accountDetails] Gets all information about an account including allowances granted by the account
         */

        /**
         * Constructs a new Response.
         * @memberof proto
         * @classdesc A single response, which is returned from the node to the client, after the client sent the node
         * a query. This includes all responses.
         * @implements IResponse
         * @constructor
         * @param {proto.IResponse=} [p] Properties to set
         */
        function Response(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * Get all entities associated with a given key
         * @member {proto.IGetByKeyResponse|null|undefined} getByKey
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.getByKey = null;

        /**
         * Get the IDs in the format used in transactions, given the format used in Solidity
         * @member {proto.IGetBySolidityIDResponse|null|undefined} getBySolidityID
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.getBySolidityID = null;

        /**
         * Response to call a function of a smart contract instance
         * @member {proto.IContractCallLocalResponse|null|undefined} contractCallLocal
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.contractCallLocal = null;

        /**
         * Get the runtime code for a smart contract instance
         * @member {proto.IContractGetBytecodeResponse|null|undefined} contractGetBytecodeResponse
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.contractGetBytecodeResponse = null;

        /**
         * Get information about a smart contract instance
         * @member {proto.IContractGetInfoResponse|null|undefined} contractGetInfo
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.contractGetInfo = null;

        /**
         * Get all existing records for a smart contract instance
         * @member {proto.IContractGetRecordsResponse|null|undefined} contractGetRecordsResponse
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.contractGetRecordsResponse = null;

        /**
         * Get the current balance in a cryptocurrency account
         * @member {proto.ICryptoGetAccountBalanceResponse|null|undefined} cryptogetAccountBalance
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.cryptogetAccountBalance = null;

        /**
         * Get all the records that currently exist for transactions involving an account
         * @member {proto.ICryptoGetAccountRecordsResponse|null|undefined} cryptoGetAccountRecords
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.cryptoGetAccountRecords = null;

        /**
         * Get all information about an account
         * @member {proto.ICryptoGetInfoResponse|null|undefined} cryptoGetInfo
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.cryptoGetInfo = null;

        /**
         * Contains a livehash associated to an account
         * @member {proto.ICryptoGetLiveHashResponse|null|undefined} cryptoGetLiveHash
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.cryptoGetLiveHash = null;

        /**
         * Get all the accounts that proxy stake to a given account, and how much they proxy stake
         * @member {proto.ICryptoGetStakersResponse|null|undefined} cryptoGetProxyStakers
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.cryptoGetProxyStakers = null;

        /**
         * Get the contents of a file (the bytes stored in it)
         * @member {proto.IFileGetContentsResponse|null|undefined} fileGetContents
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.fileGetContents = null;

        /**
         * Get information about a file, such as its expiration date
         * @member {proto.IFileGetInfoResponse|null|undefined} fileGetInfo
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.fileGetInfo = null;

        /**
         * Get a receipt for a transaction
         * @member {proto.ITransactionGetReceiptResponse|null|undefined} transactionGetReceipt
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.transactionGetReceipt = null;

        /**
         * Get a record for a transaction
         * @member {proto.ITransactionGetRecordResponse|null|undefined} transactionGetRecord
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.transactionGetRecord = null;

        /**
         * Get a record for a transaction (lasts 180 seconds)
         * @member {proto.ITransactionGetFastRecordResponse|null|undefined} transactionGetFastRecord
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.transactionGetFastRecord = null;

        /**
         * Parameters of and state of a consensus topic..
         * @member {proto.IConsensusGetTopicInfoResponse|null|undefined} consensusGetTopicInfo
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.consensusGetTopicInfo = null;

        /**
         * Semantic versions of Hedera Services and HAPI proto
         * @member {proto.INetworkGetVersionInfoResponse|null|undefined} networkGetVersionInfo
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.networkGetVersionInfo = null;

        /**
         * Get all information about a token
         * @member {proto.ITokenGetInfoResponse|null|undefined} tokenGetInfo
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.tokenGetInfo = null;

        /**
         * Get all information about a schedule entity
         * @member {proto.IScheduleGetInfoResponse|null|undefined} scheduleGetInfo
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.scheduleGetInfo = null;

        /**
         * A list of the NFTs associated with the account
         * @member {proto.ITokenGetAccountNftInfosResponse|null|undefined} tokenGetAccountNftInfos
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.tokenGetAccountNftInfos = null;

        /**
         * All information about an NFT
         * @member {proto.ITokenGetNftInfoResponse|null|undefined} tokenGetNftInfo
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.tokenGetNftInfo = null;

        /**
         * A list of the NFTs for the token
         * @member {proto.ITokenGetNftInfosResponse|null|undefined} tokenGetNftInfos
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.tokenGetNftInfos = null;

        /**
         * Execution times of "sufficiently recent" transactions
         * @member {proto.INetworkGetExecutionTimeResponse|null|undefined} networkGetExecutionTime
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.networkGetExecutionTime = null;

        /**
         * Gets all information about an account including allowances granted by the account
         * @member {proto.IGetAccountDetailsResponse|null|undefined} accountDetails
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.accountDetails = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * Response response.
         * @member {"getByKey"|"getBySolidityID"|"contractCallLocal"|"contractGetBytecodeResponse"|"contractGetInfo"|"contractGetRecordsResponse"|"cryptogetAccountBalance"|"cryptoGetAccountRecords"|"cryptoGetInfo"|"cryptoGetLiveHash"|"cryptoGetProxyStakers"|"fileGetContents"|"fileGetInfo"|"transactionGetReceipt"|"transactionGetRecord"|"transactionGetFastRecord"|"consensusGetTopicInfo"|"networkGetVersionInfo"|"tokenGetInfo"|"scheduleGetInfo"|"tokenGetAccountNftInfos"|"tokenGetNftInfo"|"tokenGetNftInfos"|"networkGetExecutionTime"|"accountDetails"|undefined} response
         * @memberof proto.Response
         * @instance
         */
        Object.defineProperty(Response.prototype, "response", {
            get: $util.oneOfGetter(
                ($oneOfFields = [
                    "getByKey",
                    "getBySolidityID",
                    "contractCallLocal",
                    "contractGetBytecodeResponse",
                    "contractGetInfo",
                    "contractGetRecordsResponse",
                    "cryptogetAccountBalance",
                    "cryptoGetAccountRecords",
                    "cryptoGetInfo",
                    "cryptoGetLiveHash",
                    "cryptoGetProxyStakers",
                    "fileGetContents",
                    "fileGetInfo",
                    "transactionGetReceipt",
                    "transactionGetRecord",
                    "transactionGetFastRecord",
                    "consensusGetTopicInfo",
                    "networkGetVersionInfo",
                    "tokenGetInfo",
                    "scheduleGetInfo",
                    "tokenGetAccountNftInfos",
                    "tokenGetNftInfo",
                    "tokenGetNftInfos",
                    "networkGetExecutionTime",
                    "accountDetails",
                ])
            ),
            set: $util.oneOfSetter($oneOfFields),
        });

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof proto.Response
         * @static
         * @param {proto.IResponse=} [properties] Properties to set
         * @returns {proto.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link proto.Response.verify|verify} messages.
         * @function encode
         * @memberof proto.Response
         * @static
         * @param {proto.IResponse} m Response message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.getByKey != null && Object.hasOwnProperty.call(m, "getByKey"))
                $root.proto.GetByKeyResponse.encode(m.getByKey, w.uint32(10).fork()).ldelim();
            if (m.getBySolidityID != null && Object.hasOwnProperty.call(m, "getBySolidityID"))
                $root.proto.GetBySolidityIDResponse.encode(m.getBySolidityID, w.uint32(18).fork()).ldelim();
            if (m.contractCallLocal != null && Object.hasOwnProperty.call(m, "contractCallLocal"))
                $root.proto.ContractCallLocalResponse.encode(m.contractCallLocal, w.uint32(26).fork()).ldelim();
            if (m.contractGetInfo != null && Object.hasOwnProperty.call(m, "contractGetInfo"))
                $root.proto.ContractGetInfoResponse.encode(m.contractGetInfo, w.uint32(34).fork()).ldelim();
            if (m.contractGetBytecodeResponse != null && Object.hasOwnProperty.call(m, "contractGetBytecodeResponse"))
                $root.proto.ContractGetBytecodeResponse.encode(
                    m.contractGetBytecodeResponse,
                    w.uint32(42).fork()
                ).ldelim();
            if (m.contractGetRecordsResponse != null && Object.hasOwnProperty.call(m, "contractGetRecordsResponse"))
                $root.proto.ContractGetRecordsResponse.encode(
                    m.contractGetRecordsResponse,
                    w.uint32(50).fork()
                ).ldelim();
            if (m.cryptogetAccountBalance != null && Object.hasOwnProperty.call(m, "cryptogetAccountBalance"))
                $root.proto.CryptoGetAccountBalanceResponse.encode(
                    m.cryptogetAccountBalance,
                    w.uint32(58).fork()
                ).ldelim();
            if (m.cryptoGetAccountRecords != null && Object.hasOwnProperty.call(m, "cryptoGetAccountRecords"))
                $root.proto.CryptoGetAccountRecordsResponse.encode(
                    m.cryptoGetAccountRecords,
                    w.uint32(66).fork()
                ).ldelim();
            if (m.cryptoGetInfo != null && Object.hasOwnProperty.call(m, "cryptoGetInfo"))
                $root.proto.CryptoGetInfoResponse.encode(m.cryptoGetInfo, w.uint32(74).fork()).ldelim();
            if (m.cryptoGetLiveHash != null && Object.hasOwnProperty.call(m, "cryptoGetLiveHash"))
                $root.proto.CryptoGetLiveHashResponse.encode(m.cryptoGetLiveHash, w.uint32(82).fork()).ldelim();
            if (m.cryptoGetProxyStakers != null && Object.hasOwnProperty.call(m, "cryptoGetProxyStakers"))
                $root.proto.CryptoGetStakersResponse.encode(m.cryptoGetProxyStakers, w.uint32(90).fork()).ldelim();
            if (m.fileGetContents != null && Object.hasOwnProperty.call(m, "fileGetContents"))
                $root.proto.FileGetContentsResponse.encode(m.fileGetContents, w.uint32(98).fork()).ldelim();
            if (m.fileGetInfo != null && Object.hasOwnProperty.call(m, "fileGetInfo"))
                $root.proto.FileGetInfoResponse.encode(m.fileGetInfo, w.uint32(106).fork()).ldelim();
            if (m.transactionGetReceipt != null && Object.hasOwnProperty.call(m, "transactionGetReceipt"))
                $root.proto.TransactionGetReceiptResponse.encode(
                    m.transactionGetReceipt,
                    w.uint32(114).fork()
                ).ldelim();
            if (m.transactionGetRecord != null && Object.hasOwnProperty.call(m, "transactionGetRecord"))
                $root.proto.TransactionGetRecordResponse.encode(m.transactionGetRecord, w.uint32(122).fork()).ldelim();
            if (m.transactionGetFastRecord != null && Object.hasOwnProperty.call(m, "transactionGetFastRecord"))
                $root.proto.TransactionGetFastRecordResponse.encode(
                    m.transactionGetFastRecord,
                    w.uint32(130).fork()
                ).ldelim();
            if (m.consensusGetTopicInfo != null && Object.hasOwnProperty.call(m, "consensusGetTopicInfo"))
                $root.proto.ConsensusGetTopicInfoResponse.encode(
                    m.consensusGetTopicInfo,
                    w.uint32(1202).fork()
                ).ldelim();
            if (m.networkGetVersionInfo != null && Object.hasOwnProperty.call(m, "networkGetVersionInfo"))
                $root.proto.NetworkGetVersionInfoResponse.encode(
                    m.networkGetVersionInfo,
                    w.uint32(1210).fork()
                ).ldelim();
            if (m.tokenGetInfo != null && Object.hasOwnProperty.call(m, "tokenGetInfo"))
                $root.proto.TokenGetInfoResponse.encode(m.tokenGetInfo, w.uint32(1218).fork()).ldelim();
            if (m.scheduleGetInfo != null && Object.hasOwnProperty.call(m, "scheduleGetInfo"))
                $root.proto.ScheduleGetInfoResponse.encode(m.scheduleGetInfo, w.uint32(1226).fork()).ldelim();
            if (m.tokenGetAccountNftInfos != null && Object.hasOwnProperty.call(m, "tokenGetAccountNftInfos"))
                $root.proto.TokenGetAccountNftInfosResponse.encode(
                    m.tokenGetAccountNftInfos,
                    w.uint32(1234).fork()
                ).ldelim();
            if (m.tokenGetNftInfo != null && Object.hasOwnProperty.call(m, "tokenGetNftInfo"))
                $root.proto.TokenGetNftInfoResponse.encode(m.tokenGetNftInfo, w.uint32(1242).fork()).ldelim();
            if (m.tokenGetNftInfos != null && Object.hasOwnProperty.call(m, "tokenGetNftInfos"))
                $root.proto.TokenGetNftInfosResponse.encode(m.tokenGetNftInfos, w.uint32(1250).fork()).ldelim();
            if (m.networkGetExecutionTime != null && Object.hasOwnProperty.call(m, "networkGetExecutionTime"))
                $root.proto.NetworkGetExecutionTimeResponse.encode(
                    m.networkGetExecutionTime,
                    w.uint32(1258).fork()
                ).ldelim();
            if (m.accountDetails != null && Object.hasOwnProperty.call(m, "accountDetails"))
                $root.proto.GetAccountDetailsResponse.encode(m.accountDetails, w.uint32(1266).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof proto.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.Response();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.getByKey = $root.proto.GetByKeyResponse.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.getBySolidityID = $root.proto.GetBySolidityIDResponse.decode(r, r.uint32());
                        break;
                    }
                    case 3: {
                        m.contractCallLocal = $root.proto.ContractCallLocalResponse.decode(r, r.uint32());
                        break;
                    }
                    case 5: {
                        m.contractGetBytecodeResponse = $root.proto.ContractGetBytecodeResponse.decode(r, r.uint32());
                        break;
                    }
                    case 4: {
                        m.contractGetInfo = $root.proto.ContractGetInfoResponse.decode(r, r.uint32());
                        break;
                    }
                    case 6: {
                        m.contractGetRecordsResponse = $root.proto.ContractGetRecordsResponse.decode(r, r.uint32());
                        break;
                    }
                    case 7: {
                        m.cryptogetAccountBalance = $root.proto.CryptoGetAccountBalanceResponse.decode(r, r.uint32());
                        break;
                    }
                    case 8: {
                        m.cryptoGetAccountRecords = $root.proto.CryptoGetAccountRecordsResponse.decode(r, r.uint32());
                        break;
                    }
                    case 9: {
                        m.cryptoGetInfo = $root.proto.CryptoGetInfoResponse.decode(r, r.uint32());
                        break;
                    }
                    case 10: {
                        m.cryptoGetLiveHash = $root.proto.CryptoGetLiveHashResponse.decode(r, r.uint32());
                        break;
                    }
                    case 11: {
                        m.cryptoGetProxyStakers = $root.proto.CryptoGetStakersResponse.decode(r, r.uint32());
                        break;
                    }
                    case 12: {
                        m.fileGetContents = $root.proto.FileGetContentsResponse.decode(r, r.uint32());
                        break;
                    }
                    case 13: {
                        m.fileGetInfo = $root.proto.FileGetInfoResponse.decode(r, r.uint32());
                        break;
                    }
                    case 14: {
                        m.transactionGetReceipt = $root.proto.TransactionGetReceiptResponse.decode(r, r.uint32());
                        break;
                    }
                    case 15: {
                        m.transactionGetRecord = $root.proto.TransactionGetRecordResponse.decode(r, r.uint32());
                        break;
                    }
                    case 16: {
                        m.transactionGetFastRecord = $root.proto.TransactionGetFastRecordResponse.decode(r, r.uint32());
                        break;
                    }
                    case 150: {
                        m.consensusGetTopicInfo = $root.proto.ConsensusGetTopicInfoResponse.decode(r, r.uint32());
                        break;
                    }
                    case 151: {
                        m.networkGetVersionInfo = $root.proto.NetworkGetVersionInfoResponse.decode(r, r.uint32());
                        break;
                    }
                    case 152: {
                        m.tokenGetInfo = $root.proto.TokenGetInfoResponse.decode(r, r.uint32());
                        break;
                    }
                    case 153: {
                        m.scheduleGetInfo = $root.proto.ScheduleGetInfoResponse.decode(r, r.uint32());
                        break;
                    }
                    case 154: {
                        m.tokenGetAccountNftInfos = $root.proto.TokenGetAccountNftInfosResponse.decode(r, r.uint32());
                        break;
                    }
                    case 155: {
                        m.tokenGetNftInfo = $root.proto.TokenGetNftInfoResponse.decode(r, r.uint32());
                        break;
                    }
                    case 156: {
                        m.tokenGetNftInfos = $root.proto.TokenGetNftInfosResponse.decode(r, r.uint32());
                        break;
                    }
                    case 157: {
                        m.networkGetExecutionTime = $root.proto.NetworkGetExecutionTimeResponse.decode(r, r.uint32());
                        break;
                    }
                    case 158: {
                        m.accountDetails = $root.proto.GetAccountDetailsResponse.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for Response
         * @function getTypeUrl
         * @memberof proto.Response
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Response.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.Response";
        };

        return Response;
    })();

    proto.CryptoService = (function () {
        /**
         * Constructs a new CryptoService service.
         * @memberof proto
         * @classdesc Transactions and queries for the Crypto Service
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function CryptoService(rpcImpl, requestDelimited, responseDelimited) {
            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (CryptoService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = CryptoService;

        /**
         * Creates new CryptoService service using the specified rpc implementation.
         * @function create
         * @memberof proto.CryptoService
         * @static
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         * @returns {CryptoService} RPC service. Useful where requests and/or responses are streamed.
         */
        CryptoService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
            return new this(rpcImpl, requestDelimited, responseDelimited);
        };

        /**
         * Callback as used by {@link proto.CryptoService#createAccount}.
         * @memberof proto.CryptoService
         * @typedef createAccountCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Creates a new account by submitting the transaction
         * @function createAccount
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.CryptoService.createAccountCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (CryptoService.prototype.createAccount = function createAccount(request, callback) {
                return this.rpcCall(
                    createAccount,
                    $root.proto.Transaction,
                    $root.proto.TransactionResponse,
                    request,
                    callback
                );
            }),
            "name",
            { value: "createAccount" }
        );

        /**
         * Creates a new account by submitting the transaction
         * @function createAccount
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.CryptoService#updateAccount}.
         * @memberof proto.CryptoService
         * @typedef updateAccountCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Updates an account by submitting the transaction
         * @function updateAccount
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.CryptoService.updateAccountCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (CryptoService.prototype.updateAccount = function updateAccount(request, callback) {
                return this.rpcCall(
                    updateAccount,
                    $root.proto.Transaction,
                    $root.proto.TransactionResponse,
                    request,
                    callback
                );
            }),
            "name",
            { value: "updateAccount" }
        );

        /**
         * Updates an account by submitting the transaction
         * @function updateAccount
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.CryptoService#cryptoTransfer}.
         * @memberof proto.CryptoService
         * @typedef cryptoTransferCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Initiates a transfer by submitting the transaction
         * @function cryptoTransfer
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.CryptoService.cryptoTransferCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (CryptoService.prototype.cryptoTransfer = function cryptoTransfer(request, callback) {
                return this.rpcCall(
                    cryptoTransfer,
                    $root.proto.Transaction,
                    $root.proto.TransactionResponse,
                    request,
                    callback
                );
            }),
            "name",
            { value: "cryptoTransfer" }
        );

        /**
         * Initiates a transfer by submitting the transaction
         * @function cryptoTransfer
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.CryptoService#cryptoDelete}.
         * @memberof proto.CryptoService
         * @typedef cryptoDeleteCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Deletes and account by submitting the transaction
         * @function cryptoDelete
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.CryptoService.cryptoDeleteCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (CryptoService.prototype.cryptoDelete = function cryptoDelete(request, callback) {
                return this.rpcCall(
                    cryptoDelete,
                    $root.proto.Transaction,
                    $root.proto.TransactionResponse,
                    request,
                    callback
                );
            }),
            "name",
            { value: "cryptoDelete" }
        );

        /**
         * Deletes and account by submitting the transaction
         * @function cryptoDelete
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.CryptoService#approveAllowances}.
         * @memberof proto.CryptoService
         * @typedef approveAllowancesCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Adds one or more approved allowances for spenders to transfer the paying account's hbar or tokens.
         * @function approveAllowances
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.CryptoService.approveAllowancesCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (CryptoService.prototype.approveAllowances = function approveAllowances(request, callback) {
                return this.rpcCall(
                    approveAllowances,
                    $root.proto.Transaction,
                    $root.proto.TransactionResponse,
                    request,
                    callback
                );
            }),
            "name",
            { value: "approveAllowances" }
        );

        /**
         * Adds one or more approved allowances for spenders to transfer the paying account's hbar or tokens.
         * @function approveAllowances
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.CryptoService#deleteAllowances}.
         * @memberof proto.CryptoService
         * @typedef deleteAllowancesCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Deletes one or more of the specific approved NFT serial numbers on an owner account.
         * @function deleteAllowances
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.CryptoService.deleteAllowancesCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (CryptoService.prototype.deleteAllowances = function deleteAllowances(request, callback) {
                return this.rpcCall(
                    deleteAllowances,
                    $root.proto.Transaction,
                    $root.proto.TransactionResponse,
                    request,
                    callback
                );
            }),
            "name",
            { value: "deleteAllowances" }
        );

        /**
         * Deletes one or more of the specific approved NFT serial numbers on an owner account.
         * @function deleteAllowances
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.CryptoService#addLiveHash}.
         * @memberof proto.CryptoService
         * @typedef addLiveHashCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * (NOT CURRENTLY SUPPORTED) Adds a livehash
         * @function addLiveHash
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.CryptoService.addLiveHashCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (CryptoService.prototype.addLiveHash = function addLiveHash(request, callback) {
                return this.rpcCall(
                    addLiveHash,
                    $root.proto.Transaction,
                    $root.proto.TransactionResponse,
                    request,
                    callback
                );
            }),
            "name",
            { value: "addLiveHash" }
        );

        /**
         * (NOT CURRENTLY SUPPORTED) Adds a livehash
         * @function addLiveHash
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.CryptoService#deleteLiveHash}.
         * @memberof proto.CryptoService
         * @typedef deleteLiveHashCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * (NOT CURRENTLY SUPPORTED) Deletes a livehash
         * @function deleteLiveHash
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.CryptoService.deleteLiveHashCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (CryptoService.prototype.deleteLiveHash = function deleteLiveHash(request, callback) {
                return this.rpcCall(
                    deleteLiveHash,
                    $root.proto.Transaction,
                    $root.proto.TransactionResponse,
                    request,
                    callback
                );
            }),
            "name",
            { value: "deleteLiveHash" }
        );

        /**
         * (NOT CURRENTLY SUPPORTED) Deletes a livehash
         * @function deleteLiveHash
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.CryptoService#getLiveHash}.
         * @memberof proto.CryptoService
         * @typedef getLiveHashCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.Response} [response] Response
         */

        /**
         * (NOT CURRENTLY SUPPORTED) Retrieves a livehash for an account
         * @function getLiveHash
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @param {proto.CryptoService.getLiveHashCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (CryptoService.prototype.getLiveHash = function getLiveHash(request, callback) {
                return this.rpcCall(getLiveHash, $root.proto.Query, $root.proto.Response, request, callback);
            }),
            "name",
            { value: "getLiveHash" }
        );

        /**
         * (NOT CURRENTLY SUPPORTED) Retrieves a livehash for an account
         * @function getLiveHash
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @returns {Promise<proto.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.CryptoService#getAccountRecords}.
         * @memberof proto.CryptoService
         * @typedef getAccountRecordsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.Response} [response] Response
         */

        /**
         * Returns all transactions in the last 180s of consensus time for which the given account was
         * the effective payer <b>and</b> network property <tt>ledger.keepRecordsInState</tt> was
         * <tt>true</tt>.
         * @function getAccountRecords
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @param {proto.CryptoService.getAccountRecordsCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (CryptoService.prototype.getAccountRecords = function getAccountRecords(request, callback) {
                return this.rpcCall(getAccountRecords, $root.proto.Query, $root.proto.Response, request, callback);
            }),
            "name",
            { value: "getAccountRecords" }
        );

        /**
         * Returns all transactions in the last 180s of consensus time for which the given account was
         * the effective payer <b>and</b> network property <tt>ledger.keepRecordsInState</tt> was
         * <tt>true</tt>.
         * @function getAccountRecords
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @returns {Promise<proto.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.CryptoService#cryptoGetBalance}.
         * @memberof proto.CryptoService
         * @typedef cryptoGetBalanceCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.Response} [response] Response
         */

        /**
         * Retrieves the balance of an account
         * @function cryptoGetBalance
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @param {proto.CryptoService.cryptoGetBalanceCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (CryptoService.prototype.cryptoGetBalance = function cryptoGetBalance(request, callback) {
                return this.rpcCall(cryptoGetBalance, $root.proto.Query, $root.proto.Response, request, callback);
            }),
            "name",
            { value: "cryptoGetBalance" }
        );

        /**
         * Retrieves the balance of an account
         * @function cryptoGetBalance
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @returns {Promise<proto.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.CryptoService#getAccountInfo}.
         * @memberof proto.CryptoService
         * @typedef getAccountInfoCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.Response} [response] Response
         */

        /**
         * Retrieves the metadata of an account
         * @function getAccountInfo
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @param {proto.CryptoService.getAccountInfoCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (CryptoService.prototype.getAccountInfo = function getAccountInfo(request, callback) {
                return this.rpcCall(getAccountInfo, $root.proto.Query, $root.proto.Response, request, callback);
            }),
            "name",
            { value: "getAccountInfo" }
        );

        /**
         * Retrieves the metadata of an account
         * @function getAccountInfo
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @returns {Promise<proto.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.CryptoService#getTransactionReceipts}.
         * @memberof proto.CryptoService
         * @typedef getTransactionReceiptsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.Response} [response] Response
         */

        /**
         * Retrieves the latest receipt for a transaction that is either awaiting consensus, or reached
         * consensus in the last 180 seconds
         * @function getTransactionReceipts
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @param {proto.CryptoService.getTransactionReceiptsCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (CryptoService.prototype.getTransactionReceipts = function getTransactionReceipts(request, callback) {
                return this.rpcCall(getTransactionReceipts, $root.proto.Query, $root.proto.Response, request, callback);
            }),
            "name",
            { value: "getTransactionReceipts" }
        );

        /**
         * Retrieves the latest receipt for a transaction that is either awaiting consensus, or reached
         * consensus in the last 180 seconds
         * @function getTransactionReceipts
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @returns {Promise<proto.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.CryptoService#getFastTransactionRecord}.
         * @memberof proto.CryptoService
         * @typedef getFastTransactionRecordCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.Response} [response] Response
         */

        /**
         * (NOT CURRENTLY SUPPORTED) Returns the records of transactions recently funded by an account
         * @function getFastTransactionRecord
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @param {proto.CryptoService.getFastTransactionRecordCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (CryptoService.prototype.getFastTransactionRecord = function getFastTransactionRecord(request, callback) {
                return this.rpcCall(
                    getFastTransactionRecord,
                    $root.proto.Query,
                    $root.proto.Response,
                    request,
                    callback
                );
            }),
            "name",
            { value: "getFastTransactionRecord" }
        );

        /**
         * (NOT CURRENTLY SUPPORTED) Returns the records of transactions recently funded by an account
         * @function getFastTransactionRecord
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @returns {Promise<proto.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.CryptoService#getTxRecordByTxID}.
         * @memberof proto.CryptoService
         * @typedef getTxRecordByTxIDCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.Response} [response] Response
         */

        /**
         * Retrieves the record of a transaction that is either awaiting consensus, or reached consensus
         * in the last 180 seconds
         * @function getTxRecordByTxID
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @param {proto.CryptoService.getTxRecordByTxIDCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (CryptoService.prototype.getTxRecordByTxID = function getTxRecordByTxID(request, callback) {
                return this.rpcCall(getTxRecordByTxID, $root.proto.Query, $root.proto.Response, request, callback);
            }),
            "name",
            { value: "getTxRecordByTxID" }
        );

        /**
         * Retrieves the record of a transaction that is either awaiting consensus, or reached consensus
         * in the last 180 seconds
         * @function getTxRecordByTxID
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @returns {Promise<proto.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.CryptoService#getStakersByAccountID}.
         * @memberof proto.CryptoService
         * @typedef getStakersByAccountIDCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.Response} [response] Response
         */

        /**
         * (NOT CURRENTLY SUPPORTED) Retrieves the stakers for a node by account id
         * @function getStakersByAccountID
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @param {proto.CryptoService.getStakersByAccountIDCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (CryptoService.prototype.getStakersByAccountID = function getStakersByAccountID(request, callback) {
                return this.rpcCall(getStakersByAccountID, $root.proto.Query, $root.proto.Response, request, callback);
            }),
            "name",
            { value: "getStakersByAccountID" }
        );

        /**
         * (NOT CURRENTLY SUPPORTED) Retrieves the stakers for a node by account id
         * @function getStakersByAccountID
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @returns {Promise<proto.Response>} Promise
         * @variation 2
         */

        return CryptoService;
    })();

    proto.FileService = (function () {
        /**
         * Constructs a new FileService service.
         * @memberof proto
         * @classdesc Transactions and queries for the file service.
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function FileService(rpcImpl, requestDelimited, responseDelimited) {
            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (FileService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = FileService;

        /**
         * Creates new FileService service using the specified rpc implementation.
         * @function create
         * @memberof proto.FileService
         * @static
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         * @returns {FileService} RPC service. Useful where requests and/or responses are streamed.
         */
        FileService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
            return new this(rpcImpl, requestDelimited, responseDelimited);
        };

        /**
         * Callback as used by {@link proto.FileService#createFile}.
         * @memberof proto.FileService
         * @typedef createFileCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Creates a file
         * @function createFile
         * @memberof proto.FileService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.FileService.createFileCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (FileService.prototype.createFile = function createFile(request, callback) {
                return this.rpcCall(
                    createFile,
                    $root.proto.Transaction,
                    $root.proto.TransactionResponse,
                    request,
                    callback
                );
            }),
            "name",
            { value: "createFile" }
        );

        /**
         * Creates a file
         * @function createFile
         * @memberof proto.FileService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.FileService#updateFile}.
         * @memberof proto.FileService
         * @typedef updateFileCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Updates a file
         * @function updateFile
         * @memberof proto.FileService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.FileService.updateFileCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (FileService.prototype.updateFile = function updateFile(request, callback) {
                return this.rpcCall(
                    updateFile,
                    $root.proto.Transaction,
                    $root.proto.TransactionResponse,
                    request,
                    callback
                );
            }),
            "name",
            { value: "updateFile" }
        );

        /**
         * Updates a file
         * @function updateFile
         * @memberof proto.FileService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.FileService#deleteFile}.
         * @memberof proto.FileService
         * @typedef deleteFileCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Deletes a file
         * @function deleteFile
         * @memberof proto.FileService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.FileService.deleteFileCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (FileService.prototype.deleteFile = function deleteFile(request, callback) {
                return this.rpcCall(
                    deleteFile,
                    $root.proto.Transaction,
                    $root.proto.TransactionResponse,
                    request,
                    callback
                );
            }),
            "name",
            { value: "deleteFile" }
        );

        /**
         * Deletes a file
         * @function deleteFile
         * @memberof proto.FileService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.FileService#appendContent}.
         * @memberof proto.FileService
         * @typedef appendContentCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Appends to a file
         * @function appendContent
         * @memberof proto.FileService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.FileService.appendContentCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (FileService.prototype.appendContent = function appendContent(request, callback) {
                return this.rpcCall(
                    appendContent,
                    $root.proto.Transaction,
                    $root.proto.TransactionResponse,
                    request,
                    callback
                );
            }),
            "name",
            { value: "appendContent" }
        );

        /**
         * Appends to a file
         * @function appendContent
         * @memberof proto.FileService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.FileService#getFileContent}.
         * @memberof proto.FileService
         * @typedef getFileContentCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.Response} [response] Response
         */

        /**
         * Retrieves the file contents
         * @function getFileContent
         * @memberof proto.FileService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @param {proto.FileService.getFileContentCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (FileService.prototype.getFileContent = function getFileContent(request, callback) {
                return this.rpcCall(getFileContent, $root.proto.Query, $root.proto.Response, request, callback);
            }),
            "name",
            { value: "getFileContent" }
        );

        /**
         * Retrieves the file contents
         * @function getFileContent
         * @memberof proto.FileService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @returns {Promise<proto.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.FileService#getFileInfo}.
         * @memberof proto.FileService
         * @typedef getFileInfoCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.Response} [response] Response
         */

        /**
         * Retrieves the file information
         * @function getFileInfo
         * @memberof proto.FileService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @param {proto.FileService.getFileInfoCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (FileService.prototype.getFileInfo = function getFileInfo(request, callback) {
                return this.rpcCall(getFileInfo, $root.proto.Query, $root.proto.Response, request, callback);
            }),
            "name",
            { value: "getFileInfo" }
        );

        /**
         * Retrieves the file information
         * @function getFileInfo
         * @memberof proto.FileService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @returns {Promise<proto.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.FileService#systemDelete}.
         * @memberof proto.FileService
         * @typedef systemDeleteCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Deletes a file if the submitting account has network admin privileges
         * @function systemDelete
         * @memberof proto.FileService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.FileService.systemDeleteCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (FileService.prototype.systemDelete = function systemDelete(request, callback) {
                return this.rpcCall(
                    systemDelete,
                    $root.proto.Transaction,
                    $root.proto.TransactionResponse,
                    request,
                    callback
                );
            }),
            "name",
            { value: "systemDelete" }
        );

        /**
         * Deletes a file if the submitting account has network admin privileges
         * @function systemDelete
         * @memberof proto.FileService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.FileService#systemUndelete}.
         * @memberof proto.FileService
         * @typedef systemUndeleteCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Undeletes a file if the submitting account has network admin privileges
         * @function systemUndelete
         * @memberof proto.FileService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.FileService.systemUndeleteCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (FileService.prototype.systemUndelete = function systemUndelete(request, callback) {
                return this.rpcCall(
                    systemUndelete,
                    $root.proto.Transaction,
                    $root.proto.TransactionResponse,
                    request,
                    callback
                );
            }),
            "name",
            { value: "systemUndelete" }
        );

        /**
         * Undeletes a file if the submitting account has network admin privileges
         * @function systemUndelete
         * @memberof proto.FileService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        return FileService;
    })();

    proto.FreezeService = (function () {
        /**
         * Constructs a new FreezeService service.
         * @memberof proto
         * @classdesc The request and responses for freeze service.
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function FreezeService(rpcImpl, requestDelimited, responseDelimited) {
            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (FreezeService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = FreezeService;

        /**
         * Creates new FreezeService service using the specified rpc implementation.
         * @function create
         * @memberof proto.FreezeService
         * @static
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         * @returns {FreezeService} RPC service. Useful where requests and/or responses are streamed.
         */
        FreezeService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
            return new this(rpcImpl, requestDelimited, responseDelimited);
        };

        /**
         * Callback as used by {@link proto.FreezeService#freeze}.
         * @memberof proto.FreezeService
         * @typedef freezeCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Freezes the nodes by submitting the transaction. The grpc server returns the
         * TransactionResponse
         * @function freeze
         * @memberof proto.FreezeService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.FreezeService.freezeCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (FreezeService.prototype.freeze = function freeze(request, callback) {
                return this.rpcCall(
                    freeze,
                    $root.proto.Transaction,
                    $root.proto.TransactionResponse,
                    request,
                    callback
                );
            }),
            "name",
            { value: "freeze" }
        );

        /**
         * Freezes the nodes by submitting the transaction. The grpc server returns the
         * TransactionResponse
         * @function freeze
         * @memberof proto.FreezeService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        return FreezeService;
    })();

    proto.NetworkService = (function () {
        /**
         * Constructs a new NetworkService service.
         * @memberof proto
         * @classdesc The requests and responses for different network services.
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function NetworkService(rpcImpl, requestDelimited, responseDelimited) {
            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (NetworkService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = NetworkService;

        /**
         * Creates new NetworkService service using the specified rpc implementation.
         * @function create
         * @memberof proto.NetworkService
         * @static
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         * @returns {NetworkService} RPC service. Useful where requests and/or responses are streamed.
         */
        NetworkService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
            return new this(rpcImpl, requestDelimited, responseDelimited);
        };

        /**
         * Callback as used by {@link proto.NetworkService#getVersionInfo}.
         * @memberof proto.NetworkService
         * @typedef getVersionInfoCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.Response} [response] Response
         */

        /**
         * Retrieves the active versions of Hedera Services and HAPI proto
         * @function getVersionInfo
         * @memberof proto.NetworkService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @param {proto.NetworkService.getVersionInfoCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (NetworkService.prototype.getVersionInfo = function getVersionInfo(request, callback) {
                return this.rpcCall(getVersionInfo, $root.proto.Query, $root.proto.Response, request, callback);
            }),
            "name",
            { value: "getVersionInfo" }
        );

        /**
         * Retrieves the active versions of Hedera Services and HAPI proto
         * @function getVersionInfo
         * @memberof proto.NetworkService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @returns {Promise<proto.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.NetworkService#getExecutionTime}.
         * @memberof proto.NetworkService
         * @typedef getExecutionTimeCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.Response} [response] Response
         */

        /**
         * Retrieves the time in nanoseconds spent in <tt>handleTransaction</tt> for one or more
         * TransactionIDs (assuming they have reached consensus "recently", since only a limited
         * number of execution times are kept in-memory, depending on the value of the node-local
         * property <tt>stats.executionTimesToTrack</tt>).
         * @function getExecutionTime
         * @memberof proto.NetworkService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @param {proto.NetworkService.getExecutionTimeCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (NetworkService.prototype.getExecutionTime = function getExecutionTime(request, callback) {
                return this.rpcCall(getExecutionTime, $root.proto.Query, $root.proto.Response, request, callback);
            }),
            "name",
            { value: "getExecutionTime" }
        );

        /**
         * Retrieves the time in nanoseconds spent in <tt>handleTransaction</tt> for one or more
         * TransactionIDs (assuming they have reached consensus "recently", since only a limited
         * number of execution times are kept in-memory, depending on the value of the node-local
         * property <tt>stats.executionTimesToTrack</tt>).
         * @function getExecutionTime
         * @memberof proto.NetworkService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @returns {Promise<proto.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.NetworkService#uncheckedSubmit}.
         * @memberof proto.NetworkService
         * @typedef uncheckedSubmitCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Submits a "wrapped" transaction to the network, skipping its standard prechecks. (Note that
         * the "wrapper" <tt>UncheckedSubmit</tt> transaction is still subject to normal prechecks,
         * including an authorization requirement that its payer be either the treasury or system admin
         * account.)
         * @function uncheckedSubmit
         * @memberof proto.NetworkService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.NetworkService.uncheckedSubmitCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (NetworkService.prototype.uncheckedSubmit = function uncheckedSubmit(request, callback) {
                return this.rpcCall(
                    uncheckedSubmit,
                    $root.proto.Transaction,
                    $root.proto.TransactionResponse,
                    request,
                    callback
                );
            }),
            "name",
            { value: "uncheckedSubmit" }
        );

        /**
         * Submits a "wrapped" transaction to the network, skipping its standard prechecks. (Note that
         * the "wrapper" <tt>UncheckedSubmit</tt> transaction is still subject to normal prechecks,
         * including an authorization requirement that its payer be either the treasury or system admin
         * account.)
         * @function uncheckedSubmit
         * @memberof proto.NetworkService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.NetworkService#getAccountDetails}.
         * @memberof proto.NetworkService
         * @typedef getAccountDetailsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.Response} [response] Response
         */

        /**
         * Get all the information about an account, including balance and allowances. This does not get the list of
         * account records.
         * @function getAccountDetails
         * @memberof proto.NetworkService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @param {proto.NetworkService.getAccountDetailsCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (NetworkService.prototype.getAccountDetails = function getAccountDetails(request, callback) {
                return this.rpcCall(getAccountDetails, $root.proto.Query, $root.proto.Response, request, callback);
            }),
            "name",
            { value: "getAccountDetails" }
        );

        /**
         * Get all the information about an account, including balance and allowances. This does not get the list of
         * account records.
         * @function getAccountDetails
         * @memberof proto.NetworkService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @returns {Promise<proto.Response>} Promise
         * @variation 2
         */

        return NetworkService;
    })();

    proto.ScheduleService = (function () {
        /**
         * Constructs a new ScheduleService service.
         * @memberof proto
         * @classdesc Transactions and queries for the Schedule Service
         *
         * The Schedule Service allows transactions to be submitted without all the required signatures and
         * allows anyone to provide the required signatures independently after a transaction has already
         * been created. The transactions can be executed immediately when all required signatures are received
         * or at a future date if Long Term Scheduled Transactions are enabled.
         *
         * Execution:
         *
         * Scheduled Transactions are executed in two different modes.
         *
         * 1. If Long Term Scheduled Transactions are enabled and <tt>wait_for_expiry</tt> was set to <tt>true</tt> on the
         * <tt>ScheduleCreate</tt>, then the transaction will be executed at the <tt>expiration_time</tt> specified on the
         * <tt>ScheduleCreate</tt>.
         *
         * 2. Otherwise Scheduled Transactions are executed once all required signatures are collected and witnessed.
         * Every time new signature is provided, a check is performed on the "readiness" of the execution.
         * The Scheduled Transaction will be executed immediately after the transaction that triggered it.
         *
         * NOTICE:
         * A Scheduled Transaction being ready to execute, or even not ready to execute, at the time a <tt>ScheduleCreate</tt> or
         * <tt>ScheduleSign</tt> comes in does not guarantee it will stay that way. Any number of things can happen over time that
         * impact the transaction.
         *
         * For example, account keys can change, accounts can be deleted, and account balances can change.
         *
         * A particularly noteworthy case is if Long Term Scheduled Transactions are enabled and signature requirements for a Scheduled
         * Transaction change such that existing signatures become sufficient to allow the transaction to go through. In this case the transaction
         * will execute at expiration_time unless a ScheduleSign comes in to push it through.
         *
         * Transaction Record:
         *
         * If a Scheduled Transaction is executed immediately following the transaction that provided all required signatures,
         * the timestamp of the Scheduled Transaction will be equal to consensusTimestamp + 1 nano, where
         * consensusTimestamp is the timestamp of the transaction that triggered the execution.
         *
         * The Transaction ID of the Scheduled Transaction will have the scheduled property set to true and
         * inherit the <tt>transactionValidStart</tt> and <tt>accountID</tt> from the <tt>ScheduleCreate</tt> transaction.
         *
         * The <tt>scheduleRef</tt> property of the transaction record will be populated with the <tt>ScheduleID</tt> of the
         * Scheduled Transaction.
         *
         * Post execution:
         *
         * After execution, a Scheduled Transaction will remain in state and can be queried using <tt>GetScheduleInfo</tt> until expiration.
         *
         * Expiry:
         *
         * The expiration time of a schedule is controlled by it's <tt>expiration_time</tt>. If Long Term Scheduled Transactions are disabled,
         * the <tt>expiration_time</tt> is always 30 minutes in the future.
         *
         * Once a given Scheduled Transaction expires, it will be removed from the ledger and any upcoming
         * operation referring the ScheduleID will resolve to INVALID_SCHEDULE_ID.
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function ScheduleService(rpcImpl, requestDelimited, responseDelimited) {
            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (ScheduleService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = ScheduleService;

        /**
         * Creates new ScheduleService service using the specified rpc implementation.
         * @function create
         * @memberof proto.ScheduleService
         * @static
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         * @returns {ScheduleService} RPC service. Useful where requests and/or responses are streamed.
         */
        ScheduleService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
            return new this(rpcImpl, requestDelimited, responseDelimited);
        };

        /**
         * Callback as used by {@link proto.ScheduleService#createSchedule}.
         * @memberof proto.ScheduleService
         * @typedef createScheduleCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Creates a new Schedule by submitting the transaction
         * @function createSchedule
         * @memberof proto.ScheduleService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.ScheduleService.createScheduleCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (ScheduleService.prototype.createSchedule = function createSchedule(request, callback) {
                return this.rpcCall(
                    createSchedule,
                    $root.proto.Transaction,
                    $root.proto.TransactionResponse,
                    request,
                    callback
                );
            }),
            "name",
            { value: "createSchedule" }
        );

        /**
         * Creates a new Schedule by submitting the transaction
         * @function createSchedule
         * @memberof proto.ScheduleService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.ScheduleService#signSchedule}.
         * @memberof proto.ScheduleService
         * @typedef signScheduleCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Signs a new Schedule by submitting the transaction
         * @function signSchedule
         * @memberof proto.ScheduleService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.ScheduleService.signScheduleCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (ScheduleService.prototype.signSchedule = function signSchedule(request, callback) {
                return this.rpcCall(
                    signSchedule,
                    $root.proto.Transaction,
                    $root.proto.TransactionResponse,
                    request,
                    callback
                );
            }),
            "name",
            { value: "signSchedule" }
        );

        /**
         * Signs a new Schedule by submitting the transaction
         * @function signSchedule
         * @memberof proto.ScheduleService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.ScheduleService#deleteSchedule}.
         * @memberof proto.ScheduleService
         * @typedef deleteScheduleCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Deletes a new Schedule by submitting the transaction
         * @function deleteSchedule
         * @memberof proto.ScheduleService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.ScheduleService.deleteScheduleCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (ScheduleService.prototype.deleteSchedule = function deleteSchedule(request, callback) {
                return this.rpcCall(
                    deleteSchedule,
                    $root.proto.Transaction,
                    $root.proto.TransactionResponse,
                    request,
                    callback
                );
            }),
            "name",
            { value: "deleteSchedule" }
        );

        /**
         * Deletes a new Schedule by submitting the transaction
         * @function deleteSchedule
         * @memberof proto.ScheduleService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.ScheduleService#getScheduleInfo}.
         * @memberof proto.ScheduleService
         * @typedef getScheduleInfoCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.Response} [response] Response
         */

        /**
         * Retrieves the metadata of a schedule entity
         * @function getScheduleInfo
         * @memberof proto.ScheduleService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @param {proto.ScheduleService.getScheduleInfoCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (ScheduleService.prototype.getScheduleInfo = function getScheduleInfo(request, callback) {
                return this.rpcCall(getScheduleInfo, $root.proto.Query, $root.proto.Response, request, callback);
            }),
            "name",
            { value: "getScheduleInfo" }
        );

        /**
         * Retrieves the metadata of a schedule entity
         * @function getScheduleInfo
         * @memberof proto.ScheduleService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @returns {Promise<proto.Response>} Promise
         * @variation 2
         */

        return ScheduleService;
    })();

    proto.SmartContractService = (function () {
        /**
         * Constructs a new SmartContractService service.
         * @memberof proto
         * @classdesc Transactions and queries for the file service.
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function SmartContractService(rpcImpl, requestDelimited, responseDelimited) {
            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (SmartContractService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor =
            SmartContractService;

        /**
         * Creates new SmartContractService service using the specified rpc implementation.
         * @function create
         * @memberof proto.SmartContractService
         * @static
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         * @returns {SmartContractService} RPC service. Useful where requests and/or responses are streamed.
         */
        SmartContractService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
            return new this(rpcImpl, requestDelimited, responseDelimited);
        };

        /**
         * Callback as used by {@link proto.SmartContractService#createContract}.
         * @memberof proto.SmartContractService
         * @typedef createContractCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Creates a contract
         * @function createContract
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.SmartContractService.createContractCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (SmartContractService.prototype.createContract = function createContract(request, callback) {
                return this.rpcCall(
                    createContract,
                    $root.proto.Transaction,
                    $root.proto.TransactionResponse,
                    request,
                    callback
                );
            }),
            "name",
            { value: "createContract" }
        );

        /**
         * Creates a contract
         * @function createContract
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.SmartContractService#updateContract}.
         * @memberof proto.SmartContractService
         * @typedef updateContractCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Updates a contract with the content
         * @function updateContract
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.SmartContractService.updateContractCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (SmartContractService.prototype.updateContract = function updateContract(request, callback) {
                return this.rpcCall(
                    updateContract,
                    $root.proto.Transaction,
                    $root.proto.TransactionResponse,
                    request,
                    callback
                );
            }),
            "name",
            { value: "updateContract" }
        );

        /**
         * Updates a contract with the content
         * @function updateContract
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.SmartContractService#contractCallMethod}.
         * @memberof proto.SmartContractService
         * @typedef contractCallMethodCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Calls a contract
         * @function contractCallMethod
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.SmartContractService.contractCallMethodCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (SmartContractService.prototype.contractCallMethod = function contractCallMethod(request, callback) {
                return this.rpcCall(
                    contractCallMethod,
                    $root.proto.Transaction,
                    $root.proto.TransactionResponse,
                    request,
                    callback
                );
            }),
            "name",
            { value: "contractCallMethod" }
        );

        /**
         * Calls a contract
         * @function contractCallMethod
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.SmartContractService#getContractInfo}.
         * @memberof proto.SmartContractService
         * @typedef getContractInfoCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.Response} [response] Response
         */

        /**
         * Retrieves the contract information
         * @function getContractInfo
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @param {proto.SmartContractService.getContractInfoCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (SmartContractService.prototype.getContractInfo = function getContractInfo(request, callback) {
                return this.rpcCall(getContractInfo, $root.proto.Query, $root.proto.Response, request, callback);
            }),
            "name",
            { value: "getContractInfo" }
        );

        /**
         * Retrieves the contract information
         * @function getContractInfo
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @returns {Promise<proto.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.SmartContractService#contractCallLocalMethod}.
         * @memberof proto.SmartContractService
         * @typedef contractCallLocalMethodCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.Response} [response] Response
         */

        /**
         * Calls a smart contract to be run on a single node
         * @function contractCallLocalMethod
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @param {proto.SmartContractService.contractCallLocalMethodCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (SmartContractService.prototype.contractCallLocalMethod = function contractCallLocalMethod(
                request,
                callback
            ) {
                return this.rpcCall(
                    contractCallLocalMethod,
                    $root.proto.Query,
                    $root.proto.Response,
                    request,
                    callback
                );
            }),
            "name",
            { value: "contractCallLocalMethod" }
        );

        /**
         * Calls a smart contract to be run on a single node
         * @function contractCallLocalMethod
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @returns {Promise<proto.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.SmartContractService#contractGetBytecode}.
         * @memberof proto.SmartContractService
         * @typedef ContractGetBytecodeCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.Response} [response] Response
         */

        /**
         * Retrieves the runtime code of a contract
         * @function contractGetBytecode
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @param {proto.SmartContractService.ContractGetBytecodeCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (SmartContractService.prototype.contractGetBytecode = function contractGetBytecode(request, callback) {
                return this.rpcCall(contractGetBytecode, $root.proto.Query, $root.proto.Response, request, callback);
            }),
            "name",
            { value: "ContractGetBytecode" }
        );

        /**
         * Retrieves the runtime code of a contract
         * @function contractGetBytecode
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @returns {Promise<proto.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.SmartContractService#getBySolidityID}.
         * @memberof proto.SmartContractService
         * @typedef getBySolidityIDCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.Response} [response] Response
         */

        /**
         * Retrieves a contract by its Solidity address
         * @function getBySolidityID
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @param {proto.SmartContractService.getBySolidityIDCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (SmartContractService.prototype.getBySolidityID = function getBySolidityID(request, callback) {
                return this.rpcCall(getBySolidityID, $root.proto.Query, $root.proto.Response, request, callback);
            }),
            "name",
            { value: "getBySolidityID" }
        );

        /**
         * Retrieves a contract by its Solidity address
         * @function getBySolidityID
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @returns {Promise<proto.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.SmartContractService#getTxRecordByContractID}.
         * @memberof proto.SmartContractService
         * @typedef getTxRecordByContractIDCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.Response} [response] Response
         */

        /**
         * Always returns an empty record list, as contract accounts are never effective payers for
         * transactions
         * @function getTxRecordByContractID
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @param {proto.SmartContractService.getTxRecordByContractIDCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (SmartContractService.prototype.getTxRecordByContractID = function getTxRecordByContractID(
                request,
                callback
            ) {
                return this.rpcCall(
                    getTxRecordByContractID,
                    $root.proto.Query,
                    $root.proto.Response,
                    request,
                    callback
                );
            }),
            "name",
            { value: "getTxRecordByContractID" }
        );

        /**
         * Always returns an empty record list, as contract accounts are never effective payers for
         * transactions
         * @function getTxRecordByContractID
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @returns {Promise<proto.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.SmartContractService#deleteContract}.
         * @memberof proto.SmartContractService
         * @typedef deleteContractCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Deletes a contract instance and transfers any remaining hbars to a specified receiver
         * @function deleteContract
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.SmartContractService.deleteContractCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (SmartContractService.prototype.deleteContract = function deleteContract(request, callback) {
                return this.rpcCall(
                    deleteContract,
                    $root.proto.Transaction,
                    $root.proto.TransactionResponse,
                    request,
                    callback
                );
            }),
            "name",
            { value: "deleteContract" }
        );

        /**
         * Deletes a contract instance and transfers any remaining hbars to a specified receiver
         * @function deleteContract
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.SmartContractService#systemDelete}.
         * @memberof proto.SmartContractService
         * @typedef systemDeleteCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Deletes a contract if the submitting account has network admin privileges
         * @function systemDelete
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.SmartContractService.systemDeleteCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (SmartContractService.prototype.systemDelete = function systemDelete(request, callback) {
                return this.rpcCall(
                    systemDelete,
                    $root.proto.Transaction,
                    $root.proto.TransactionResponse,
                    request,
                    callback
                );
            }),
            "name",
            { value: "systemDelete" }
        );

        /**
         * Deletes a contract if the submitting account has network admin privileges
         * @function systemDelete
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.SmartContractService#systemUndelete}.
         * @memberof proto.SmartContractService
         * @typedef systemUndeleteCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Undeletes a contract if the submitting account has network admin privileges
         * @function systemUndelete
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.SmartContractService.systemUndeleteCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (SmartContractService.prototype.systemUndelete = function systemUndelete(request, callback) {
                return this.rpcCall(
                    systemUndelete,
                    $root.proto.Transaction,
                    $root.proto.TransactionResponse,
                    request,
                    callback
                );
            }),
            "name",
            { value: "systemUndelete" }
        );

        /**
         * Undeletes a contract if the submitting account has network admin privileges
         * @function systemUndelete
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.SmartContractService#callEthereum}.
         * @memberof proto.SmartContractService
         * @typedef callEthereumCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Ethereum transaction
         * @function callEthereum
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.SmartContractService.callEthereumCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (SmartContractService.prototype.callEthereum = function callEthereum(request, callback) {
                return this.rpcCall(
                    callEthereum,
                    $root.proto.Transaction,
                    $root.proto.TransactionResponse,
                    request,
                    callback
                );
            }),
            "name",
            { value: "callEthereum" }
        );

        /**
         * Ethereum transaction
         * @function callEthereum
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        return SmartContractService;
    })();

    proto.ThrottleGroup = (function () {
        /**
         * Properties of a ThrottleGroup.
         * @memberof proto
         * @interface IThrottleGroup
         * @property {Array.<proto.HederaFunctionality>|null} [operations] The operations to be throttled
         * @property {Long|null} [milliOpsPerSec] The number of total operations per second across the entire network, multiplied by 1000. So, to
         * choose 3 operations per second (which on a network of 30 nodes is a tenth of an operation per
         * second for each node), set milliOpsPerSec = 3000. And to choose 3.6 ops per second, use
         * milliOpsPerSec = 3600. Minimum allowed value is 1, and maximum allowed value is 9223372.
         */

        /**
         * Constructs a new ThrottleGroup.
         * @memberof proto
         * @classdesc A set of operations which should be collectively throttled at a given milli-ops-per-second limit.
         * @implements IThrottleGroup
         * @constructor
         * @param {proto.IThrottleGroup=} [p] Properties to set
         */
        function ThrottleGroup(p) {
            this.operations = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The operations to be throttled
         * @member {Array.<proto.HederaFunctionality>} operations
         * @memberof proto.ThrottleGroup
         * @instance
         */
        ThrottleGroup.prototype.operations = $util.emptyArray;

        /**
         * The number of total operations per second across the entire network, multiplied by 1000. So, to
         * choose 3 operations per second (which on a network of 30 nodes is a tenth of an operation per
         * second for each node), set milliOpsPerSec = 3000. And to choose 3.6 ops per second, use
         * milliOpsPerSec = 3600. Minimum allowed value is 1, and maximum allowed value is 9223372.
         * @member {Long} milliOpsPerSec
         * @memberof proto.ThrottleGroup
         * @instance
         */
        ThrottleGroup.prototype.milliOpsPerSec = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * Creates a new ThrottleGroup instance using the specified properties.
         * @function create
         * @memberof proto.ThrottleGroup
         * @static
         * @param {proto.IThrottleGroup=} [properties] Properties to set
         * @returns {proto.ThrottleGroup} ThrottleGroup instance
         */
        ThrottleGroup.create = function create(properties) {
            return new ThrottleGroup(properties);
        };

        /**
         * Encodes the specified ThrottleGroup message. Does not implicitly {@link proto.ThrottleGroup.verify|verify} messages.
         * @function encode
         * @memberof proto.ThrottleGroup
         * @static
         * @param {proto.IThrottleGroup} m ThrottleGroup message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ThrottleGroup.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.operations != null && m.operations.length) {
                w.uint32(10).fork();
                for (var i = 0; i < m.operations.length; ++i) w.int32(m.operations[i]);
                w.ldelim();
            }
            if (m.milliOpsPerSec != null && Object.hasOwnProperty.call(m, "milliOpsPerSec"))
                w.uint32(16).uint64(m.milliOpsPerSec);
            return w;
        };

        /**
         * Decodes a ThrottleGroup message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ThrottleGroup
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ThrottleGroup} ThrottleGroup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ThrottleGroup.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.ThrottleGroup();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        if (!(m.operations && m.operations.length)) m.operations = [];
                        if ((t & 7) === 2) {
                            var c2 = r.uint32() + r.pos;
                            while (r.pos < c2) m.operations.push(r.int32());
                        } else m.operations.push(r.int32());
                        break;
                    }
                    case 2: {
                        m.milliOpsPerSec = r.uint64();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ThrottleGroup
         * @function getTypeUrl
         * @memberof proto.ThrottleGroup
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ThrottleGroup.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ThrottleGroup";
        };

        return ThrottleGroup;
    })();

    proto.ThrottleBucket = (function () {
        /**
         * Properties of a ThrottleBucket.
         * @memberof proto
         * @interface IThrottleBucket
         * @property {string|null} [name] A name for this bucket (primarily for use in logs)
         * @property {Long|null} [burstPeriodMs] The number of milliseconds required for this bucket to drain completely when full. The product
         * of this number and the least common multiple of the milliOpsPerSec values in this bucket must
         * not exceed 9223372036.
         * @property {Array.<proto.IThrottleGroup>|null} [throttleGroups] The throttle groups competing for this bucket
         */

        /**
         * Constructs a new ThrottleBucket.
         * @memberof proto
         * @classdesc A list of throttle groups that should all compete for the same internal bucket.
         * @implements IThrottleBucket
         * @constructor
         * @param {proto.IThrottleBucket=} [p] Properties to set
         */
        function ThrottleBucket(p) {
            this.throttleGroups = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * A name for this bucket (primarily for use in logs)
         * @member {string} name
         * @memberof proto.ThrottleBucket
         * @instance
         */
        ThrottleBucket.prototype.name = "";

        /**
         * The number of milliseconds required for this bucket to drain completely when full. The product
         * of this number and the least common multiple of the milliOpsPerSec values in this bucket must
         * not exceed 9223372036.
         * @member {Long} burstPeriodMs
         * @memberof proto.ThrottleBucket
         * @instance
         */
        ThrottleBucket.prototype.burstPeriodMs = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * The throttle groups competing for this bucket
         * @member {Array.<proto.IThrottleGroup>} throttleGroups
         * @memberof proto.ThrottleBucket
         * @instance
         */
        ThrottleBucket.prototype.throttleGroups = $util.emptyArray;

        /**
         * Creates a new ThrottleBucket instance using the specified properties.
         * @function create
         * @memberof proto.ThrottleBucket
         * @static
         * @param {proto.IThrottleBucket=} [properties] Properties to set
         * @returns {proto.ThrottleBucket} ThrottleBucket instance
         */
        ThrottleBucket.create = function create(properties) {
            return new ThrottleBucket(properties);
        };

        /**
         * Encodes the specified ThrottleBucket message. Does not implicitly {@link proto.ThrottleBucket.verify|verify} messages.
         * @function encode
         * @memberof proto.ThrottleBucket
         * @static
         * @param {proto.IThrottleBucket} m ThrottleBucket message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ThrottleBucket.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.name != null && Object.hasOwnProperty.call(m, "name")) w.uint32(10).string(m.name);
            if (m.burstPeriodMs != null && Object.hasOwnProperty.call(m, "burstPeriodMs"))
                w.uint32(16).uint64(m.burstPeriodMs);
            if (m.throttleGroups != null && m.throttleGroups.length) {
                for (var i = 0; i < m.throttleGroups.length; ++i)
                    $root.proto.ThrottleGroup.encode(m.throttleGroups[i], w.uint32(26).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a ThrottleBucket message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ThrottleBucket
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ThrottleBucket} ThrottleBucket
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ThrottleBucket.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.ThrottleBucket();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.name = r.string();
                        break;
                    }
                    case 2: {
                        m.burstPeriodMs = r.uint64();
                        break;
                    }
                    case 3: {
                        if (!(m.throttleGroups && m.throttleGroups.length)) m.throttleGroups = [];
                        m.throttleGroups.push($root.proto.ThrottleGroup.decode(r, r.uint32()));
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ThrottleBucket
         * @function getTypeUrl
         * @memberof proto.ThrottleBucket
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ThrottleBucket.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ThrottleBucket";
        };

        return ThrottleBucket;
    })();

    proto.ThrottleDefinitions = (function () {
        /**
         * Properties of a ThrottleDefinitions.
         * @memberof proto
         * @interface IThrottleDefinitions
         * @property {Array.<proto.IThrottleBucket>|null} [throttleBuckets] ThrottleDefinitions throttleBuckets
         */

        /**
         * Constructs a new ThrottleDefinitions.
         * @memberof proto
         * @classdesc A list of throttle buckets which, simultaneously enforced, define the system's throttling policy.
         * <ol>
         * <li> When an operation appears in more than one throttling bucket, all its buckets must have room
         * or it will be throttled.</li>
         * <li>An operation assigned to no buckets is always throttled.</li>
         * </ol>
         * @implements IThrottleDefinitions
         * @constructor
         * @param {proto.IThrottleDefinitions=} [p] Properties to set
         */
        function ThrottleDefinitions(p) {
            this.throttleBuckets = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * ThrottleDefinitions throttleBuckets.
         * @member {Array.<proto.IThrottleBucket>} throttleBuckets
         * @memberof proto.ThrottleDefinitions
         * @instance
         */
        ThrottleDefinitions.prototype.throttleBuckets = $util.emptyArray;

        /**
         * Creates a new ThrottleDefinitions instance using the specified properties.
         * @function create
         * @memberof proto.ThrottleDefinitions
         * @static
         * @param {proto.IThrottleDefinitions=} [properties] Properties to set
         * @returns {proto.ThrottleDefinitions} ThrottleDefinitions instance
         */
        ThrottleDefinitions.create = function create(properties) {
            return new ThrottleDefinitions(properties);
        };

        /**
         * Encodes the specified ThrottleDefinitions message. Does not implicitly {@link proto.ThrottleDefinitions.verify|verify} messages.
         * @function encode
         * @memberof proto.ThrottleDefinitions
         * @static
         * @param {proto.IThrottleDefinitions} m ThrottleDefinitions message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ThrottleDefinitions.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.throttleBuckets != null && m.throttleBuckets.length) {
                for (var i = 0; i < m.throttleBuckets.length; ++i)
                    $root.proto.ThrottleBucket.encode(m.throttleBuckets[i], w.uint32(10).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a ThrottleDefinitions message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ThrottleDefinitions
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ThrottleDefinitions} ThrottleDefinitions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ThrottleDefinitions.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.ThrottleDefinitions();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        if (!(m.throttleBuckets && m.throttleBuckets.length)) m.throttleBuckets = [];
                        m.throttleBuckets.push($root.proto.ThrottleBucket.decode(r, r.uint32()));
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ThrottleDefinitions
         * @function getTypeUrl
         * @memberof proto.ThrottleDefinitions
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ThrottleDefinitions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ThrottleDefinitions";
        };

        return ThrottleDefinitions;
    })();

    proto.TokenService = (function () {
        /**
         * Constructs a new TokenService service.
         * @memberof proto
         * @classdesc Transactions and queries for the Token Service
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function TokenService(rpcImpl, requestDelimited, responseDelimited) {
            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (TokenService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = TokenService;

        /**
         * Creates new TokenService service using the specified rpc implementation.
         * @function create
         * @memberof proto.TokenService
         * @static
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         * @returns {TokenService} RPC service. Useful where requests and/or responses are streamed.
         */
        TokenService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
            return new this(rpcImpl, requestDelimited, responseDelimited);
        };

        /**
         * Callback as used by {@link proto.TokenService#createToken}.
         * @memberof proto.TokenService
         * @typedef createTokenCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Creates a new Token by submitting the transaction
         * @function createToken
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.TokenService.createTokenCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (TokenService.prototype.createToken = function createToken(request, callback) {
                return this.rpcCall(
                    createToken,
                    $root.proto.Transaction,
                    $root.proto.TransactionResponse,
                    request,
                    callback
                );
            }),
            "name",
            { value: "createToken" }
        );

        /**
         * Creates a new Token by submitting the transaction
         * @function createToken
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.TokenService#updateToken}.
         * @memberof proto.TokenService
         * @typedef updateTokenCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Updates the account by submitting the transaction
         * @function updateToken
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.TokenService.updateTokenCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (TokenService.prototype.updateToken = function updateToken(request, callback) {
                return this.rpcCall(
                    updateToken,
                    $root.proto.Transaction,
                    $root.proto.TransactionResponse,
                    request,
                    callback
                );
            }),
            "name",
            { value: "updateToken" }
        );

        /**
         * Updates the account by submitting the transaction
         * @function updateToken
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.TokenService#mintToken}.
         * @memberof proto.TokenService
         * @typedef mintTokenCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Mints an amount of the token to the defined treasury account
         * @function mintToken
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.TokenService.mintTokenCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (TokenService.prototype.mintToken = function mintToken(request, callback) {
                return this.rpcCall(
                    mintToken,
                    $root.proto.Transaction,
                    $root.proto.TransactionResponse,
                    request,
                    callback
                );
            }),
            "name",
            { value: "mintToken" }
        );

        /**
         * Mints an amount of the token to the defined treasury account
         * @function mintToken
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.TokenService#burnToken}.
         * @memberof proto.TokenService
         * @typedef burnTokenCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Burns an amount of the token from the defined treasury account
         * @function burnToken
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.TokenService.burnTokenCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (TokenService.prototype.burnToken = function burnToken(request, callback) {
                return this.rpcCall(
                    burnToken,
                    $root.proto.Transaction,
                    $root.proto.TransactionResponse,
                    request,
                    callback
                );
            }),
            "name",
            { value: "burnToken" }
        );

        /**
         * Burns an amount of the token from the defined treasury account
         * @function burnToken
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.TokenService#deleteToken}.
         * @memberof proto.TokenService
         * @typedef deleteTokenCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Deletes a Token
         * @function deleteToken
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.TokenService.deleteTokenCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (TokenService.prototype.deleteToken = function deleteToken(request, callback) {
                return this.rpcCall(
                    deleteToken,
                    $root.proto.Transaction,
                    $root.proto.TransactionResponse,
                    request,
                    callback
                );
            }),
            "name",
            { value: "deleteToken" }
        );

        /**
         * Deletes a Token
         * @function deleteToken
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.TokenService#wipeTokenAccount}.
         * @memberof proto.TokenService
         * @typedef wipeTokenAccountCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Wipes the provided amount of tokens from the specified Account ID
         * @function wipeTokenAccount
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.TokenService.wipeTokenAccountCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (TokenService.prototype.wipeTokenAccount = function wipeTokenAccount(request, callback) {
                return this.rpcCall(
                    wipeTokenAccount,
                    $root.proto.Transaction,
                    $root.proto.TransactionResponse,
                    request,
                    callback
                );
            }),
            "name",
            { value: "wipeTokenAccount" }
        );

        /**
         * Wipes the provided amount of tokens from the specified Account ID
         * @function wipeTokenAccount
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.TokenService#freezeTokenAccount}.
         * @memberof proto.TokenService
         * @typedef freezeTokenAccountCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Freezes the transfer of tokens to or from the specified Account ID
         * @function freezeTokenAccount
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.TokenService.freezeTokenAccountCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (TokenService.prototype.freezeTokenAccount = function freezeTokenAccount(request, callback) {
                return this.rpcCall(
                    freezeTokenAccount,
                    $root.proto.Transaction,
                    $root.proto.TransactionResponse,
                    request,
                    callback
                );
            }),
            "name",
            { value: "freezeTokenAccount" }
        );

        /**
         * Freezes the transfer of tokens to or from the specified Account ID
         * @function freezeTokenAccount
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.TokenService#unfreezeTokenAccount}.
         * @memberof proto.TokenService
         * @typedef unfreezeTokenAccountCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Unfreezes the transfer of tokens to or from the specified Account ID
         * @function unfreezeTokenAccount
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.TokenService.unfreezeTokenAccountCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (TokenService.prototype.unfreezeTokenAccount = function unfreezeTokenAccount(request, callback) {
                return this.rpcCall(
                    unfreezeTokenAccount,
                    $root.proto.Transaction,
                    $root.proto.TransactionResponse,
                    request,
                    callback
                );
            }),
            "name",
            { value: "unfreezeTokenAccount" }
        );

        /**
         * Unfreezes the transfer of tokens to or from the specified Account ID
         * @function unfreezeTokenAccount
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.TokenService#grantKycToTokenAccount}.
         * @memberof proto.TokenService
         * @typedef grantKycToTokenAccountCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Flags the provided Account ID as having gone through KYC
         * @function grantKycToTokenAccount
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.TokenService.grantKycToTokenAccountCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (TokenService.prototype.grantKycToTokenAccount = function grantKycToTokenAccount(request, callback) {
                return this.rpcCall(
                    grantKycToTokenAccount,
                    $root.proto.Transaction,
                    $root.proto.TransactionResponse,
                    request,
                    callback
                );
            }),
            "name",
            { value: "grantKycToTokenAccount" }
        );

        /**
         * Flags the provided Account ID as having gone through KYC
         * @function grantKycToTokenAccount
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.TokenService#revokeKycFromTokenAccount}.
         * @memberof proto.TokenService
         * @typedef revokeKycFromTokenAccountCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Removes the KYC flag of the provided Account ID
         * @function revokeKycFromTokenAccount
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.TokenService.revokeKycFromTokenAccountCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (TokenService.prototype.revokeKycFromTokenAccount = function revokeKycFromTokenAccount(request, callback) {
                return this.rpcCall(
                    revokeKycFromTokenAccount,
                    $root.proto.Transaction,
                    $root.proto.TransactionResponse,
                    request,
                    callback
                );
            }),
            "name",
            { value: "revokeKycFromTokenAccount" }
        );

        /**
         * Removes the KYC flag of the provided Account ID
         * @function revokeKycFromTokenAccount
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.TokenService#associateTokens}.
         * @memberof proto.TokenService
         * @typedef associateTokensCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Associates tokens to an account
         * @function associateTokens
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.TokenService.associateTokensCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (TokenService.prototype.associateTokens = function associateTokens(request, callback) {
                return this.rpcCall(
                    associateTokens,
                    $root.proto.Transaction,
                    $root.proto.TransactionResponse,
                    request,
                    callback
                );
            }),
            "name",
            { value: "associateTokens" }
        );

        /**
         * Associates tokens to an account
         * @function associateTokens
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.TokenService#dissociateTokens}.
         * @memberof proto.TokenService
         * @typedef dissociateTokensCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Dissociates tokens from an account
         * @function dissociateTokens
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.TokenService.dissociateTokensCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (TokenService.prototype.dissociateTokens = function dissociateTokens(request, callback) {
                return this.rpcCall(
                    dissociateTokens,
                    $root.proto.Transaction,
                    $root.proto.TransactionResponse,
                    request,
                    callback
                );
            }),
            "name",
            { value: "dissociateTokens" }
        );

        /**
         * Dissociates tokens from an account
         * @function dissociateTokens
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.TokenService#updateTokenFeeSchedule}.
         * @memberof proto.TokenService
         * @typedef updateTokenFeeScheduleCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Updates the custom fee schedule on a token
         * @function updateTokenFeeSchedule
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.TokenService.updateTokenFeeScheduleCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (TokenService.prototype.updateTokenFeeSchedule = function updateTokenFeeSchedule(request, callback) {
                return this.rpcCall(
                    updateTokenFeeSchedule,
                    $root.proto.Transaction,
                    $root.proto.TransactionResponse,
                    request,
                    callback
                );
            }),
            "name",
            { value: "updateTokenFeeSchedule" }
        );

        /**
         * Updates the custom fee schedule on a token
         * @function updateTokenFeeSchedule
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.TokenService#getTokenInfo}.
         * @memberof proto.TokenService
         * @typedef getTokenInfoCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.Response} [response] Response
         */

        /**
         * Retrieves the metadata of a token
         * @function getTokenInfo
         * @memberof proto.TokenService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @param {proto.TokenService.getTokenInfoCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (TokenService.prototype.getTokenInfo = function getTokenInfo(request, callback) {
                return this.rpcCall(getTokenInfo, $root.proto.Query, $root.proto.Response, request, callback);
            }),
            "name",
            { value: "getTokenInfo" }
        );

        /**
         * Retrieves the metadata of a token
         * @function getTokenInfo
         * @memberof proto.TokenService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @returns {Promise<proto.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.TokenService#getAccountNftInfos}.
         * @memberof proto.TokenService
         * @typedef getAccountNftInfosCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.Response} [response] Response
         */

        /**
         * (DEPRECATED) Gets info on NFTs N through M on the list of NFTs associated with a given account
         * @function getAccountNftInfos
         * @memberof proto.TokenService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @param {proto.TokenService.getAccountNftInfosCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (TokenService.prototype.getAccountNftInfos = function getAccountNftInfos(request, callback) {
                return this.rpcCall(getAccountNftInfos, $root.proto.Query, $root.proto.Response, request, callback);
            }),
            "name",
            { value: "getAccountNftInfos" }
        );

        /**
         * (DEPRECATED) Gets info on NFTs N through M on the list of NFTs associated with a given account
         * @function getAccountNftInfos
         * @memberof proto.TokenService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @returns {Promise<proto.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.TokenService#getTokenNftInfo}.
         * @memberof proto.TokenService
         * @typedef getTokenNftInfoCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.Response} [response] Response
         */

        /**
         * Retrieves the metadata of an NFT by TokenID and serial number
         * @function getTokenNftInfo
         * @memberof proto.TokenService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @param {proto.TokenService.getTokenNftInfoCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (TokenService.prototype.getTokenNftInfo = function getTokenNftInfo(request, callback) {
                return this.rpcCall(getTokenNftInfo, $root.proto.Query, $root.proto.Response, request, callback);
            }),
            "name",
            { value: "getTokenNftInfo" }
        );

        /**
         * Retrieves the metadata of an NFT by TokenID and serial number
         * @function getTokenNftInfo
         * @memberof proto.TokenService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @returns {Promise<proto.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.TokenService#getTokenNftInfos}.
         * @memberof proto.TokenService
         * @typedef getTokenNftInfosCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.Response} [response] Response
         */

        /**
         * (DEPRECATED) Gets info on NFTs N through M on the list of NFTs associated with a given Token of type NON_FUNGIBLE
         * @function getTokenNftInfos
         * @memberof proto.TokenService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @param {proto.TokenService.getTokenNftInfosCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (TokenService.prototype.getTokenNftInfos = function getTokenNftInfos(request, callback) {
                return this.rpcCall(getTokenNftInfos, $root.proto.Query, $root.proto.Response, request, callback);
            }),
            "name",
            { value: "getTokenNftInfos" }
        );

        /**
         * (DEPRECATED) Gets info on NFTs N through M on the list of NFTs associated with a given Token of type NON_FUNGIBLE
         * @function getTokenNftInfos
         * @memberof proto.TokenService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @returns {Promise<proto.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.TokenService#pauseToken}.
         * @memberof proto.TokenService
         * @typedef pauseTokenCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Calls pauseToken.
         * @function pauseToken
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.TokenService.pauseTokenCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (TokenService.prototype.pauseToken = function pauseToken(request, callback) {
                return this.rpcCall(
                    pauseToken,
                    $root.proto.Transaction,
                    $root.proto.TransactionResponse,
                    request,
                    callback
                );
            }),
            "name",
            { value: "pauseToken" }
        );

        /**
         * Calls pauseToken.
         * @function pauseToken
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.TokenService#unpauseToken}.
         * @memberof proto.TokenService
         * @typedef unpauseTokenCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Calls unpauseToken.
         * @function unpauseToken
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.TokenService.unpauseTokenCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (TokenService.prototype.unpauseToken = function unpauseToken(request, callback) {
                return this.rpcCall(
                    unpauseToken,
                    $root.proto.Transaction,
                    $root.proto.TransactionResponse,
                    request,
                    callback
                );
            }),
            "name",
            { value: "unpauseToken" }
        );

        /**
         * Calls unpauseToken.
         * @function unpauseToken
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        return TokenService;
    })();

    proto.SignedTransaction = (function () {
        /**
         * Properties of a SignedTransaction.
         * @memberof proto
         * @interface ISignedTransaction
         * @property {Uint8Array|null} [bodyBytes] TransactionBody serialized into bytes, which needs to be signed
         * @property {proto.ISignatureMap|null} [sigMap] The signatures on the body with the new format, to authorize the transaction
         */

        /**
         * Constructs a new SignedTransaction.
         * @memberof proto
         * @classdesc Represents a SignedTransaction.
         * @implements ISignedTransaction
         * @constructor
         * @param {proto.ISignedTransaction=} [p] Properties to set
         */
        function SignedTransaction(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * TransactionBody serialized into bytes, which needs to be signed
         * @member {Uint8Array} bodyBytes
         * @memberof proto.SignedTransaction
         * @instance
         */
        SignedTransaction.prototype.bodyBytes = $util.newBuffer([]);

        /**
         * The signatures on the body with the new format, to authorize the transaction
         * @member {proto.ISignatureMap|null|undefined} sigMap
         * @memberof proto.SignedTransaction
         * @instance
         */
        SignedTransaction.prototype.sigMap = null;

        /**
         * Creates a new SignedTransaction instance using the specified properties.
         * @function create
         * @memberof proto.SignedTransaction
         * @static
         * @param {proto.ISignedTransaction=} [properties] Properties to set
         * @returns {proto.SignedTransaction} SignedTransaction instance
         */
        SignedTransaction.create = function create(properties) {
            return new SignedTransaction(properties);
        };

        /**
         * Encodes the specified SignedTransaction message. Does not implicitly {@link proto.SignedTransaction.verify|verify} messages.
         * @function encode
         * @memberof proto.SignedTransaction
         * @static
         * @param {proto.ISignedTransaction} m SignedTransaction message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignedTransaction.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.bodyBytes != null && Object.hasOwnProperty.call(m, "bodyBytes")) w.uint32(10).bytes(m.bodyBytes);
            if (m.sigMap != null && Object.hasOwnProperty.call(m, "sigMap"))
                $root.proto.SignatureMap.encode(m.sigMap, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a SignedTransaction message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SignedTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.SignedTransaction} SignedTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignedTransaction.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.SignedTransaction();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.bodyBytes = r.bytes();
                        break;
                    }
                    case 2: {
                        m.sigMap = $root.proto.SignatureMap.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for SignedTransaction
         * @function getTypeUrl
         * @memberof proto.SignedTransaction
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SignedTransaction.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.SignedTransaction";
        };

        return SignedTransaction;
    })();

    proto.UtilService = (function () {
        /**
         * Constructs a new UtilService service.
         * @memberof proto
         * @classdesc The requests and responses for different utility services.
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function UtilService(rpcImpl, requestDelimited, responseDelimited) {
            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (UtilService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = UtilService;

        /**
         * Creates new UtilService service using the specified rpc implementation.
         * @function create
         * @memberof proto.UtilService
         * @static
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         * @returns {UtilService} RPC service. Useful where requests and/or responses are streamed.
         */
        UtilService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
            return new this(rpcImpl, requestDelimited, responseDelimited);
        };

        /**
         * Callback as used by {@link proto.UtilService#prng}.
         * @memberof proto.UtilService
         * @typedef prngCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Generates a pseudorandom number.
         * @function prng
         * @memberof proto.UtilService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.UtilService.prngCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
            (UtilService.prototype.prng = function prng(request, callback) {
                return this.rpcCall(prng, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
            }),
            "name",
            { value: "prng" }
        );

        /**
         * Generates a pseudorandom number.
         * @function prng
         * @memberof proto.UtilService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        return UtilService;
    })();

    proto.TokenUnitBalance = (function () {
        /**
         * Properties of a TokenUnitBalance.
         * @memberof proto
         * @interface ITokenUnitBalance
         * @property {proto.ITokenID|null} [tokenId] A unique token id
         * @property {Long|null} [balance] Number of transferable units of the identified token. For token of type FUNGIBLE_COMMON -
         * balance in the smallest denomination. For token of type NON_FUNGIBLE_UNIQUE - the number of
         * NFTs held by the account
         */

        /**
         * Constructs a new TokenUnitBalance.
         * @memberof proto
         * @classdesc Represents a TokenUnitBalance.
         * @implements ITokenUnitBalance
         * @constructor
         * @param {proto.ITokenUnitBalance=} [p] Properties to set
         */
        function TokenUnitBalance(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * A unique token id
         * @member {proto.ITokenID|null|undefined} tokenId
         * @memberof proto.TokenUnitBalance
         * @instance
         */
        TokenUnitBalance.prototype.tokenId = null;

        /**
         * Number of transferable units of the identified token. For token of type FUNGIBLE_COMMON -
         * balance in the smallest denomination. For token of type NON_FUNGIBLE_UNIQUE - the number of
         * NFTs held by the account
         * @member {Long} balance
         * @memberof proto.TokenUnitBalance
         * @instance
         */
        TokenUnitBalance.prototype.balance = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * Creates a new TokenUnitBalance instance using the specified properties.
         * @function create
         * @memberof proto.TokenUnitBalance
         * @static
         * @param {proto.ITokenUnitBalance=} [properties] Properties to set
         * @returns {proto.TokenUnitBalance} TokenUnitBalance instance
         */
        TokenUnitBalance.create = function create(properties) {
            return new TokenUnitBalance(properties);
        };

        /**
         * Encodes the specified TokenUnitBalance message. Does not implicitly {@link proto.TokenUnitBalance.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenUnitBalance
         * @static
         * @param {proto.ITokenUnitBalance} m TokenUnitBalance message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenUnitBalance.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.tokenId != null && Object.hasOwnProperty.call(m, "tokenId"))
                $root.proto.TokenID.encode(m.tokenId, w.uint32(10).fork()).ldelim();
            if (m.balance != null && Object.hasOwnProperty.call(m, "balance")) w.uint32(16).uint64(m.balance);
            return w;
        };

        /**
         * Decodes a TokenUnitBalance message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenUnitBalance
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenUnitBalance} TokenUnitBalance
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenUnitBalance.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.TokenUnitBalance();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.tokenId = $root.proto.TokenID.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.balance = r.uint64();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TokenUnitBalance
         * @function getTypeUrl
         * @memberof proto.TokenUnitBalance
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TokenUnitBalance.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TokenUnitBalance";
        };

        return TokenUnitBalance;
    })();

    proto.SingleAccountBalances = (function () {
        /**
         * Properties of a SingleAccountBalances.
         * @memberof proto
         * @interface ISingleAccountBalances
         * @property {proto.IAccountID|null} [accountID] The account
         * @property {Long|null} [hbarBalance] The account's hbar balance
         * @property {Array.<proto.ITokenUnitBalance>|null} [tokenUnitBalances] The list of the account's token balances
         */

        /**
         * Constructs a new SingleAccountBalances.
         * @memberof proto
         * @classdesc Includes all currency balances (both hbar and token) of a single account in the ledger.
         * @implements ISingleAccountBalances
         * @constructor
         * @param {proto.ISingleAccountBalances=} [p] Properties to set
         */
        function SingleAccountBalances(p) {
            this.tokenUnitBalances = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The account
         * @member {proto.IAccountID|null|undefined} accountID
         * @memberof proto.SingleAccountBalances
         * @instance
         */
        SingleAccountBalances.prototype.accountID = null;

        /**
         * The account's hbar balance
         * @member {Long} hbarBalance
         * @memberof proto.SingleAccountBalances
         * @instance
         */
        SingleAccountBalances.prototype.hbarBalance = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * The list of the account's token balances
         * @member {Array.<proto.ITokenUnitBalance>} tokenUnitBalances
         * @memberof proto.SingleAccountBalances
         * @instance
         */
        SingleAccountBalances.prototype.tokenUnitBalances = $util.emptyArray;

        /**
         * Creates a new SingleAccountBalances instance using the specified properties.
         * @function create
         * @memberof proto.SingleAccountBalances
         * @static
         * @param {proto.ISingleAccountBalances=} [properties] Properties to set
         * @returns {proto.SingleAccountBalances} SingleAccountBalances instance
         */
        SingleAccountBalances.create = function create(properties) {
            return new SingleAccountBalances(properties);
        };

        /**
         * Encodes the specified SingleAccountBalances message. Does not implicitly {@link proto.SingleAccountBalances.verify|verify} messages.
         * @function encode
         * @memberof proto.SingleAccountBalances
         * @static
         * @param {proto.ISingleAccountBalances} m SingleAccountBalances message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SingleAccountBalances.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.accountID != null && Object.hasOwnProperty.call(m, "accountID"))
                $root.proto.AccountID.encode(m.accountID, w.uint32(10).fork()).ldelim();
            if (m.hbarBalance != null && Object.hasOwnProperty.call(m, "hbarBalance"))
                w.uint32(16).uint64(m.hbarBalance);
            if (m.tokenUnitBalances != null && m.tokenUnitBalances.length) {
                for (var i = 0; i < m.tokenUnitBalances.length; ++i)
                    $root.proto.TokenUnitBalance.encode(m.tokenUnitBalances[i], w.uint32(26).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a SingleAccountBalances message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SingleAccountBalances
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.SingleAccountBalances} SingleAccountBalances
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SingleAccountBalances.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.SingleAccountBalances();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.accountID = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.hbarBalance = r.uint64();
                        break;
                    }
                    case 3: {
                        if (!(m.tokenUnitBalances && m.tokenUnitBalances.length)) m.tokenUnitBalances = [];
                        m.tokenUnitBalances.push($root.proto.TokenUnitBalance.decode(r, r.uint32()));
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for SingleAccountBalances
         * @function getTypeUrl
         * @memberof proto.SingleAccountBalances
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SingleAccountBalances.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.SingleAccountBalances";
        };

        return SingleAccountBalances;
    })();

    proto.AllAccountBalances = (function () {
        /**
         * Properties of an AllAccountBalances.
         * @memberof proto
         * @interface IAllAccountBalances
         * @property {proto.ITimestamp|null} [consensusTimestamp] An instant in consensus time
         * @property {Array.<proto.ISingleAccountBalances>|null} [allAccounts] The list of account balances for all accounts, after handling all transactions with consensus
         * timestamp up to and including the above instant
         */

        /**
         * Constructs a new AllAccountBalances.
         * @memberof proto
         * @classdesc Includes all currency balances (both hbar and token) of all accounts in the ledger.
         * @implements IAllAccountBalances
         * @constructor
         * @param {proto.IAllAccountBalances=} [p] Properties to set
         */
        function AllAccountBalances(p) {
            this.allAccounts = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * An instant in consensus time
         * @member {proto.ITimestamp|null|undefined} consensusTimestamp
         * @memberof proto.AllAccountBalances
         * @instance
         */
        AllAccountBalances.prototype.consensusTimestamp = null;

        /**
         * The list of account balances for all accounts, after handling all transactions with consensus
         * timestamp up to and including the above instant
         * @member {Array.<proto.ISingleAccountBalances>} allAccounts
         * @memberof proto.AllAccountBalances
         * @instance
         */
        AllAccountBalances.prototype.allAccounts = $util.emptyArray;

        /**
         * Creates a new AllAccountBalances instance using the specified properties.
         * @function create
         * @memberof proto.AllAccountBalances
         * @static
         * @param {proto.IAllAccountBalances=} [properties] Properties to set
         * @returns {proto.AllAccountBalances} AllAccountBalances instance
         */
        AllAccountBalances.create = function create(properties) {
            return new AllAccountBalances(properties);
        };

        /**
         * Encodes the specified AllAccountBalances message. Does not implicitly {@link proto.AllAccountBalances.verify|verify} messages.
         * @function encode
         * @memberof proto.AllAccountBalances
         * @static
         * @param {proto.IAllAccountBalances} m AllAccountBalances message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AllAccountBalances.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.consensusTimestamp != null && Object.hasOwnProperty.call(m, "consensusTimestamp"))
                $root.proto.Timestamp.encode(m.consensusTimestamp, w.uint32(10).fork()).ldelim();
            if (m.allAccounts != null && m.allAccounts.length) {
                for (var i = 0; i < m.allAccounts.length; ++i)
                    $root.proto.SingleAccountBalances.encode(m.allAccounts[i], w.uint32(18).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes an AllAccountBalances message from the specified reader or buffer.
         * @function decode
         * @memberof proto.AllAccountBalances
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.AllAccountBalances} AllAccountBalances
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AllAccountBalances.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.AllAccountBalances();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.consensusTimestamp = $root.proto.Timestamp.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        if (!(m.allAccounts && m.allAccounts.length)) m.allAccounts = [];
                        m.allAccounts.push($root.proto.SingleAccountBalances.decode(r, r.uint32()));
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for AllAccountBalances
         * @function getTypeUrl
         * @memberof proto.AllAccountBalances
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AllAccountBalances.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.AllAccountBalances";
        };

        return AllAccountBalances;
    })();

    proto.ContractActions = (function () {
        /**
         * Properties of a ContractActions.
         * @memberof proto
         * @interface IContractActions
         * @property {Array.<proto.IContractAction>|null} [contractActions] ContractActions contractActions
         */

        /**
         * Constructs a new ContractActions.
         * @memberof proto
         * @classdesc Represents a ContractActions.
         * @implements IContractActions
         * @constructor
         * @param {proto.IContractActions=} [p] Properties to set
         */
        function ContractActions(p) {
            this.contractActions = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * ContractActions contractActions.
         * @member {Array.<proto.IContractAction>} contractActions
         * @memberof proto.ContractActions
         * @instance
         */
        ContractActions.prototype.contractActions = $util.emptyArray;

        /**
         * Creates a new ContractActions instance using the specified properties.
         * @function create
         * @memberof proto.ContractActions
         * @static
         * @param {proto.IContractActions=} [properties] Properties to set
         * @returns {proto.ContractActions} ContractActions instance
         */
        ContractActions.create = function create(properties) {
            return new ContractActions(properties);
        };

        /**
         * Encodes the specified ContractActions message. Does not implicitly {@link proto.ContractActions.verify|verify} messages.
         * @function encode
         * @memberof proto.ContractActions
         * @static
         * @param {proto.IContractActions} m ContractActions message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractActions.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.contractActions != null && m.contractActions.length) {
                for (var i = 0; i < m.contractActions.length; ++i)
                    $root.proto.ContractAction.encode(m.contractActions[i], w.uint32(10).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a ContractActions message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ContractActions
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ContractActions} ContractActions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractActions.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.ContractActions();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        if (!(m.contractActions && m.contractActions.length)) m.contractActions = [];
                        m.contractActions.push($root.proto.ContractAction.decode(r, r.uint32()));
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ContractActions
         * @function getTypeUrl
         * @memberof proto.ContractActions
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ContractActions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ContractActions";
        };

        return ContractActions;
    })();

    /**
     * The type of action described by the action proto.
     * @name proto.ContractActionType
     * @enum {number}
     * @property {number} NO_ACTION=0 default non-value.
     * @property {number} CALL=1 Most CALL, CALLCODE, DELEGATECALL, and STATICCALL, and first action of ContractCall/ContractCallLocal to deployed
     * contracts. This does not include calls to system or precompiled contracts.
     * @property {number} CREATE=2 CREATE value
     * @property {number} PRECOMPILE=3 like Call, but to precompiled contracts (0x1 to 0x9 as of Berlin)
     * @property {number} SYSTEM=4 Call, but to system contract like HTS or ERC20 facades over Token accounts
     */
    proto.ContractActionType = (function () {
        const valuesById = {},
            values = Object.create(valuesById);
        values[(valuesById[0] = "NO_ACTION")] = 0;
        values[(valuesById[1] = "CALL")] = 1;
        values[(valuesById[2] = "CREATE")] = 2;
        values[(valuesById[3] = "PRECOMPILE")] = 3;
        values[(valuesById[4] = "SYSTEM")] = 4;
        return values;
    })();

    /**
     * The specific operation type of a call. The OP prefix has been added to avoid name collisions for
     * the CALL and CREATE operation types since both ContractActionType and CallOperationType enums are
     * used in ContractAction
     * @name proto.CallOperationType
     * @enum {number}
     * @property {number} OP_UNKNOWN=0 default operation type is UNKNOWN
     * @property {number} OP_CALL=1 CALL operation type.
     * @property {number} OP_CALLCODE=2 CALLCODE operation type
     * @property {number} OP_DELEGATECALL=3 DELEGATECALL operation type
     * @property {number} OP_STATICCALL=4 STATICCALL operation type
     * @property {number} OP_CREATE=5 CREATE operation type
     * @property {number} OP_CREATE2=6 CREATE2 operation type
     */
    proto.CallOperationType = (function () {
        const valuesById = {},
            values = Object.create(valuesById);
        values[(valuesById[0] = "OP_UNKNOWN")] = 0;
        values[(valuesById[1] = "OP_CALL")] = 1;
        values[(valuesById[2] = "OP_CALLCODE")] = 2;
        values[(valuesById[3] = "OP_DELEGATECALL")] = 3;
        values[(valuesById[4] = "OP_STATICCALL")] = 4;
        values[(valuesById[5] = "OP_CREATE")] = 5;
        values[(valuesById[6] = "OP_CREATE2")] = 6;
        return values;
    })();

    proto.ContractAction = (function () {
        /**
         * Properties of a ContractAction.
         * @memberof proto
         * @interface IContractAction
         * @property {proto.ContractActionType|null} [callType] The type of this action.
         * @property {proto.IAccountID|null} [callingAccount] If the caller was a regular account, the AccountID.
         * @property {proto.IContractID|null} [callingContract] If the caller was a smart contract account, the ContractID.
         * @property {Long|null} [gas] The upper limit of gas this action can spend.
         * @property {Uint8Array|null} [input] Bytes passed in as input data to this action.
         * @property {proto.IAccountID|null} [recipientAccount] The AccountID of the recipient if the recipient is an account. Only HBars will be transferred, no other side
         * effects should be expected.
         * @property {proto.IContractID|null} [recipientContract] The ContractID of the recipient if the recipient is a smart contract.
         * @property {Uint8Array|null} [targetedAddress] The bytes of the targeted by the action address.
         * Only set on failed executions. If set, denotes that the address did not
         * correspond to any account or contract at the time of finalization of
         * this action.
         * An example would be a failed lazy create as per HIP-583.
         * @property {Long|null} [value] The value (in tinybars) that is associated with this action.
         * @property {Long|null} [gasUsed] The actual gas spent by this action.
         * @property {Uint8Array|null} [output] If successful, the output bytes of the action.
         * @property {Uint8Array|null} [revertReason] The contract itself caused the transaction to fail via the `REVERT` operation
         * @property {Uint8Array|null} [error] The transaction itself failed without an explicit `REVERT`
         * @property {number|null} [callDepth] The nesting depth of this call. The original action is at depth=0.
         * @property {proto.CallOperationType|null} [callOperationType] The call operation type
         */

        /**
         * Constructs a new ContractAction.
         * @memberof proto
         * @classdesc A finer grained action with a function result. Sometimes called "internal transactions." The function call itself
         * will be the first action in a list, followed by sub-action in the order they were executed.
         * @implements IContractAction
         * @constructor
         * @param {proto.IContractAction=} [p] Properties to set
         */
        function ContractAction(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The type of this action.
         * @member {proto.ContractActionType} callType
         * @memberof proto.ContractAction
         * @instance
         */
        ContractAction.prototype.callType = 0;

        /**
         * If the caller was a regular account, the AccountID.
         * @member {proto.IAccountID|null|undefined} callingAccount
         * @memberof proto.ContractAction
         * @instance
         */
        ContractAction.prototype.callingAccount = null;

        /**
         * If the caller was a smart contract account, the ContractID.
         * @member {proto.IContractID|null|undefined} callingContract
         * @memberof proto.ContractAction
         * @instance
         */
        ContractAction.prototype.callingContract = null;

        /**
         * The upper limit of gas this action can spend.
         * @member {Long} gas
         * @memberof proto.ContractAction
         * @instance
         */
        ContractAction.prototype.gas = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * Bytes passed in as input data to this action.
         * @member {Uint8Array} input
         * @memberof proto.ContractAction
         * @instance
         */
        ContractAction.prototype.input = $util.newBuffer([]);

        /**
         * The AccountID of the recipient if the recipient is an account. Only HBars will be transferred, no other side
         * effects should be expected.
         * @member {proto.IAccountID|null|undefined} recipientAccount
         * @memberof proto.ContractAction
         * @instance
         */
        ContractAction.prototype.recipientAccount = null;

        /**
         * The ContractID of the recipient if the recipient is a smart contract.
         * @member {proto.IContractID|null|undefined} recipientContract
         * @memberof proto.ContractAction
         * @instance
         */
        ContractAction.prototype.recipientContract = null;

        /**
         * The bytes of the targeted by the action address.
         * Only set on failed executions. If set, denotes that the address did not
         * correspond to any account or contract at the time of finalization of
         * this action.
         * An example would be a failed lazy create as per HIP-583.
         * @member {Uint8Array|null|undefined} targetedAddress
         * @memberof proto.ContractAction
         * @instance
         */
        ContractAction.prototype.targetedAddress = null;

        /**
         * The value (in tinybars) that is associated with this action.
         * @member {Long} value
         * @memberof proto.ContractAction
         * @instance
         */
        ContractAction.prototype.value = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * The actual gas spent by this action.
         * @member {Long} gasUsed
         * @memberof proto.ContractAction
         * @instance
         */
        ContractAction.prototype.gasUsed = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * If successful, the output bytes of the action.
         * @member {Uint8Array|null|undefined} output
         * @memberof proto.ContractAction
         * @instance
         */
        ContractAction.prototype.output = null;

        /**
         * The contract itself caused the transaction to fail via the `REVERT` operation
         * @member {Uint8Array|null|undefined} revertReason
         * @memberof proto.ContractAction
         * @instance
         */
        ContractAction.prototype.revertReason = null;

        /**
         * The transaction itself failed without an explicit `REVERT`
         * @member {Uint8Array|null|undefined} error
         * @memberof proto.ContractAction
         * @instance
         */
        ContractAction.prototype.error = null;

        /**
         * The nesting depth of this call. The original action is at depth=0.
         * @member {number} callDepth
         * @memberof proto.ContractAction
         * @instance
         */
        ContractAction.prototype.callDepth = 0;

        /**
         * The call operation type
         * @member {proto.CallOperationType} callOperationType
         * @memberof proto.ContractAction
         * @instance
         */
        ContractAction.prototype.callOperationType = 0;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * Only the first action can come from an account, the rest will come from contracts.  Because of DELEGATECALL
         * and CALLCODE the caller of actions whose parent is an account may also be an account.
         * @member {"callingAccount"|"callingContract"|undefined} caller
         * @memberof proto.ContractAction
         * @instance
         */
        Object.defineProperty(ContractAction.prototype, "caller", {
            get: $util.oneOfGetter(($oneOfFields = ["callingAccount", "callingContract"])),
            set: $util.oneOfSetter($oneOfFields),
        });

        /**
         * Who this action is directed to.
         * @member {"recipientAccount"|"recipientContract"|"targetedAddress"|undefined} recipient
         * @memberof proto.ContractAction
         * @instance
         */
        Object.defineProperty(ContractAction.prototype, "recipient", {
            get: $util.oneOfGetter(($oneOfFields = ["recipientAccount", "recipientContract", "targetedAddress"])),
            set: $util.oneOfSetter($oneOfFields),
        });

        /**
         * The result data of the action.
         * @member {"output"|"revertReason"|"error"|undefined} resultData
         * @memberof proto.ContractAction
         * @instance
         */
        Object.defineProperty(ContractAction.prototype, "resultData", {
            get: $util.oneOfGetter(($oneOfFields = ["output", "revertReason", "error"])),
            set: $util.oneOfSetter($oneOfFields),
        });

        /**
         * Creates a new ContractAction instance using the specified properties.
         * @function create
         * @memberof proto.ContractAction
         * @static
         * @param {proto.IContractAction=} [properties] Properties to set
         * @returns {proto.ContractAction} ContractAction instance
         */
        ContractAction.create = function create(properties) {
            return new ContractAction(properties);
        };

        /**
         * Encodes the specified ContractAction message. Does not implicitly {@link proto.ContractAction.verify|verify} messages.
         * @function encode
         * @memberof proto.ContractAction
         * @static
         * @param {proto.IContractAction} m ContractAction message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractAction.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.callType != null && Object.hasOwnProperty.call(m, "callType")) w.uint32(8).int32(m.callType);
            if (m.callingAccount != null && Object.hasOwnProperty.call(m, "callingAccount"))
                $root.proto.AccountID.encode(m.callingAccount, w.uint32(18).fork()).ldelim();
            if (m.callingContract != null && Object.hasOwnProperty.call(m, "callingContract"))
                $root.proto.ContractID.encode(m.callingContract, w.uint32(26).fork()).ldelim();
            if (m.gas != null && Object.hasOwnProperty.call(m, "gas")) w.uint32(32).int64(m.gas);
            if (m.input != null && Object.hasOwnProperty.call(m, "input")) w.uint32(42).bytes(m.input);
            if (m.recipientAccount != null && Object.hasOwnProperty.call(m, "recipientAccount"))
                $root.proto.AccountID.encode(m.recipientAccount, w.uint32(50).fork()).ldelim();
            if (m.recipientContract != null && Object.hasOwnProperty.call(m, "recipientContract"))
                $root.proto.ContractID.encode(m.recipientContract, w.uint32(58).fork()).ldelim();
            if (m.targetedAddress != null && Object.hasOwnProperty.call(m, "targetedAddress"))
                w.uint32(66).bytes(m.targetedAddress);
            if (m.value != null && Object.hasOwnProperty.call(m, "value")) w.uint32(72).int64(m.value);
            if (m.gasUsed != null && Object.hasOwnProperty.call(m, "gasUsed")) w.uint32(80).int64(m.gasUsed);
            if (m.output != null && Object.hasOwnProperty.call(m, "output")) w.uint32(90).bytes(m.output);
            if (m.revertReason != null && Object.hasOwnProperty.call(m, "revertReason"))
                w.uint32(98).bytes(m.revertReason);
            if (m.error != null && Object.hasOwnProperty.call(m, "error")) w.uint32(106).bytes(m.error);
            if (m.callDepth != null && Object.hasOwnProperty.call(m, "callDepth")) w.uint32(112).int32(m.callDepth);
            if (m.callOperationType != null && Object.hasOwnProperty.call(m, "callOperationType"))
                w.uint32(120).int32(m.callOperationType);
            return w;
        };

        /**
         * Decodes a ContractAction message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ContractAction
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ContractAction} ContractAction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractAction.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.ContractAction();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.callType = r.int32();
                        break;
                    }
                    case 2: {
                        m.callingAccount = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    case 3: {
                        m.callingContract = $root.proto.ContractID.decode(r, r.uint32());
                        break;
                    }
                    case 4: {
                        m.gas = r.int64();
                        break;
                    }
                    case 5: {
                        m.input = r.bytes();
                        break;
                    }
                    case 6: {
                        m.recipientAccount = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    }
                    case 7: {
                        m.recipientContract = $root.proto.ContractID.decode(r, r.uint32());
                        break;
                    }
                    case 8: {
                        m.targetedAddress = r.bytes();
                        break;
                    }
                    case 9: {
                        m.value = r.int64();
                        break;
                    }
                    case 10: {
                        m.gasUsed = r.int64();
                        break;
                    }
                    case 11: {
                        m.output = r.bytes();
                        break;
                    }
                    case 12: {
                        m.revertReason = r.bytes();
                        break;
                    }
                    case 13: {
                        m.error = r.bytes();
                        break;
                    }
                    case 14: {
                        m.callDepth = r.int32();
                        break;
                    }
                    case 15: {
                        m.callOperationType = r.int32();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ContractAction
         * @function getTypeUrl
         * @memberof proto.ContractAction
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ContractAction.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ContractAction";
        };

        return ContractAction;
    })();

    proto.ContractBytecode = (function () {
        /**
         * Properties of a ContractBytecode.
         * @memberof proto
         * @interface IContractBytecode
         * @property {proto.IContractID|null} [contractId] The contract to which the bytecodes apply to
         * @property {Uint8Array|null} [initcode] Contract bytecode during deployment
         * @property {Uint8Array|null} [runtimeBytecode] Contract bytecode after deployment
         */

        /**
         * Constructs a new ContractBytecode.
         * @memberof proto
         * @classdesc Represents a ContractBytecode.
         * @implements IContractBytecode
         * @constructor
         * @param {proto.IContractBytecode=} [p] Properties to set
         */
        function ContractBytecode(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The contract to which the bytecodes apply to
         * @member {proto.IContractID|null|undefined} contractId
         * @memberof proto.ContractBytecode
         * @instance
         */
        ContractBytecode.prototype.contractId = null;

        /**
         * Contract bytecode during deployment
         * @member {Uint8Array} initcode
         * @memberof proto.ContractBytecode
         * @instance
         */
        ContractBytecode.prototype.initcode = $util.newBuffer([]);

        /**
         * Contract bytecode after deployment
         * @member {Uint8Array} runtimeBytecode
         * @memberof proto.ContractBytecode
         * @instance
         */
        ContractBytecode.prototype.runtimeBytecode = $util.newBuffer([]);

        /**
         * Creates a new ContractBytecode instance using the specified properties.
         * @function create
         * @memberof proto.ContractBytecode
         * @static
         * @param {proto.IContractBytecode=} [properties] Properties to set
         * @returns {proto.ContractBytecode} ContractBytecode instance
         */
        ContractBytecode.create = function create(properties) {
            return new ContractBytecode(properties);
        };

        /**
         * Encodes the specified ContractBytecode message. Does not implicitly {@link proto.ContractBytecode.verify|verify} messages.
         * @function encode
         * @memberof proto.ContractBytecode
         * @static
         * @param {proto.IContractBytecode} m ContractBytecode message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractBytecode.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.contractId != null && Object.hasOwnProperty.call(m, "contractId"))
                $root.proto.ContractID.encode(m.contractId, w.uint32(10).fork()).ldelim();
            if (m.initcode != null && Object.hasOwnProperty.call(m, "initcode")) w.uint32(18).bytes(m.initcode);
            if (m.runtimeBytecode != null && Object.hasOwnProperty.call(m, "runtimeBytecode"))
                w.uint32(26).bytes(m.runtimeBytecode);
            return w;
        };

        /**
         * Decodes a ContractBytecode message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ContractBytecode
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ContractBytecode} ContractBytecode
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractBytecode.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.ContractBytecode();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.contractId = $root.proto.ContractID.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.initcode = r.bytes();
                        break;
                    }
                    case 3: {
                        m.runtimeBytecode = r.bytes();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ContractBytecode
         * @function getTypeUrl
         * @memberof proto.ContractBytecode
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ContractBytecode.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ContractBytecode";
        };

        return ContractBytecode;
    })();

    proto.ContractStateChanges = (function () {
        /**
         * Properties of a ContractStateChanges.
         * @memberof proto
         * @interface IContractStateChanges
         * @property {Array.<proto.IContractStateChange>|null} [contractStateChanges] ContractStateChanges contractStateChanges
         */

        /**
         * Constructs a new ContractStateChanges.
         * @memberof proto
         * @classdesc Represents a ContractStateChanges.
         * @implements IContractStateChanges
         * @constructor
         * @param {proto.IContractStateChanges=} [p] Properties to set
         */
        function ContractStateChanges(p) {
            this.contractStateChanges = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * ContractStateChanges contractStateChanges.
         * @member {Array.<proto.IContractStateChange>} contractStateChanges
         * @memberof proto.ContractStateChanges
         * @instance
         */
        ContractStateChanges.prototype.contractStateChanges = $util.emptyArray;

        /**
         * Creates a new ContractStateChanges instance using the specified properties.
         * @function create
         * @memberof proto.ContractStateChanges
         * @static
         * @param {proto.IContractStateChanges=} [properties] Properties to set
         * @returns {proto.ContractStateChanges} ContractStateChanges instance
         */
        ContractStateChanges.create = function create(properties) {
            return new ContractStateChanges(properties);
        };

        /**
         * Encodes the specified ContractStateChanges message. Does not implicitly {@link proto.ContractStateChanges.verify|verify} messages.
         * @function encode
         * @memberof proto.ContractStateChanges
         * @static
         * @param {proto.IContractStateChanges} m ContractStateChanges message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractStateChanges.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.contractStateChanges != null && m.contractStateChanges.length) {
                for (var i = 0; i < m.contractStateChanges.length; ++i)
                    $root.proto.ContractStateChange.encode(m.contractStateChanges[i], w.uint32(10).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a ContractStateChanges message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ContractStateChanges
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ContractStateChanges} ContractStateChanges
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractStateChanges.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.ContractStateChanges();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        if (!(m.contractStateChanges && m.contractStateChanges.length)) m.contractStateChanges = [];
                        m.contractStateChanges.push($root.proto.ContractStateChange.decode(r, r.uint32()));
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ContractStateChanges
         * @function getTypeUrl
         * @memberof proto.ContractStateChanges
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ContractStateChanges.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ContractStateChanges";
        };

        return ContractStateChanges;
    })();

    proto.ContractStateChange = (function () {
        /**
         * Properties of a ContractStateChange.
         * @memberof proto
         * @interface IContractStateChange
         * @property {proto.IContractID|null} [contractId] The contract to which the storage changes apply to
         * @property {Array.<proto.IStorageChange>|null} [storageChanges] The list of storage changes.
         */

        /**
         * Constructs a new ContractStateChange.
         * @memberof proto
         * @classdesc The storage changes to a smart contract's storage as a side effect of the function call.
         * @implements IContractStateChange
         * @constructor
         * @param {proto.IContractStateChange=} [p] Properties to set
         */
        function ContractStateChange(p) {
            this.storageChanges = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The contract to which the storage changes apply to
         * @member {proto.IContractID|null|undefined} contractId
         * @memberof proto.ContractStateChange
         * @instance
         */
        ContractStateChange.prototype.contractId = null;

        /**
         * The list of storage changes.
         * @member {Array.<proto.IStorageChange>} storageChanges
         * @memberof proto.ContractStateChange
         * @instance
         */
        ContractStateChange.prototype.storageChanges = $util.emptyArray;

        /**
         * Creates a new ContractStateChange instance using the specified properties.
         * @function create
         * @memberof proto.ContractStateChange
         * @static
         * @param {proto.IContractStateChange=} [properties] Properties to set
         * @returns {proto.ContractStateChange} ContractStateChange instance
         */
        ContractStateChange.create = function create(properties) {
            return new ContractStateChange(properties);
        };

        /**
         * Encodes the specified ContractStateChange message. Does not implicitly {@link proto.ContractStateChange.verify|verify} messages.
         * @function encode
         * @memberof proto.ContractStateChange
         * @static
         * @param {proto.IContractStateChange} m ContractStateChange message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractStateChange.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.contractId != null && Object.hasOwnProperty.call(m, "contractId"))
                $root.proto.ContractID.encode(m.contractId, w.uint32(10).fork()).ldelim();
            if (m.storageChanges != null && m.storageChanges.length) {
                for (var i = 0; i < m.storageChanges.length; ++i)
                    $root.proto.StorageChange.encode(m.storageChanges[i], w.uint32(18).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a ContractStateChange message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ContractStateChange
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ContractStateChange} ContractStateChange
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractStateChange.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.ContractStateChange();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.contractId = $root.proto.ContractID.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        if (!(m.storageChanges && m.storageChanges.length)) m.storageChanges = [];
                        m.storageChanges.push($root.proto.StorageChange.decode(r, r.uint32()));
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for ContractStateChange
         * @function getTypeUrl
         * @memberof proto.ContractStateChange
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ContractStateChange.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ContractStateChange";
        };

        return ContractStateChange;
    })();

    proto.StorageChange = (function () {
        /**
         * Properties of a StorageChange.
         * @memberof proto
         * @interface IStorageChange
         * @property {Uint8Array|null} [slot] The storage slot changed.  Up to 32 bytes, big-endian, zero bytes left trimmed.
         * @property {Uint8Array|null} [valueRead] The value read from the storage slot.  Up to 32 bytes, big-endian, zero bytes left trimmed.
         *
         * Because of the way SSTORE operations are charged the slot is always read before being written to.
         * @property {google.protobuf.IBytesValue|null} [valueWritten] The new value written to the slot.  Up to 32 bytes, big-endian, zero bytes left trimmed.
         *
         * If a value of zero is written the valueWritten will be present but the inner value will be absent.
         *
         * If a value was read and not written this value will not be present.
         */

        /**
         * Constructs a new StorageChange.
         * @memberof proto
         * @classdesc A storage slot change description.
         * @implements IStorageChange
         * @constructor
         * @param {proto.IStorageChange=} [p] Properties to set
         */
        function StorageChange(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The storage slot changed.  Up to 32 bytes, big-endian, zero bytes left trimmed.
         * @member {Uint8Array} slot
         * @memberof proto.StorageChange
         * @instance
         */
        StorageChange.prototype.slot = $util.newBuffer([]);

        /**
         * The value read from the storage slot.  Up to 32 bytes, big-endian, zero bytes left trimmed.
         *
         * Because of the way SSTORE operations are charged the slot is always read before being written to.
         * @member {Uint8Array} valueRead
         * @memberof proto.StorageChange
         * @instance
         */
        StorageChange.prototype.valueRead = $util.newBuffer([]);

        /**
         * The new value written to the slot.  Up to 32 bytes, big-endian, zero bytes left trimmed.
         *
         * If a value of zero is written the valueWritten will be present but the inner value will be absent.
         *
         * If a value was read and not written this value will not be present.
         * @member {google.protobuf.IBytesValue|null|undefined} valueWritten
         * @memberof proto.StorageChange
         * @instance
         */
        StorageChange.prototype.valueWritten = null;

        /**
         * Creates a new StorageChange instance using the specified properties.
         * @function create
         * @memberof proto.StorageChange
         * @static
         * @param {proto.IStorageChange=} [properties] Properties to set
         * @returns {proto.StorageChange} StorageChange instance
         */
        StorageChange.create = function create(properties) {
            return new StorageChange(properties);
        };

        /**
         * Encodes the specified StorageChange message. Does not implicitly {@link proto.StorageChange.verify|verify} messages.
         * @function encode
         * @memberof proto.StorageChange
         * @static
         * @param {proto.IStorageChange} m StorageChange message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StorageChange.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.slot != null && Object.hasOwnProperty.call(m, "slot")) w.uint32(10).bytes(m.slot);
            if (m.valueRead != null && Object.hasOwnProperty.call(m, "valueRead")) w.uint32(18).bytes(m.valueRead);
            if (m.valueWritten != null && Object.hasOwnProperty.call(m, "valueWritten"))
                $root.google.protobuf.BytesValue.encode(m.valueWritten, w.uint32(26).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a StorageChange message from the specified reader or buffer.
         * @function decode
         * @memberof proto.StorageChange
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.StorageChange} StorageChange
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StorageChange.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.StorageChange();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.slot = r.bytes();
                        break;
                    }
                    case 2: {
                        m.valueRead = r.bytes();
                        break;
                    }
                    case 3: {
                        m.valueWritten = $root.google.protobuf.BytesValue.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for StorageChange
         * @function getTypeUrl
         * @memberof proto.StorageChange
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        StorageChange.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.StorageChange";
        };

        return StorageChange;
    })();

    /**
     * List of hash algorithms
     * @name proto.HashAlgorithm
     * @enum {number}
     * @property {number} HASH_ALGORITHM_UNKNOWN=0 HASH_ALGORITHM_UNKNOWN value
     * @property {number} SHA_384=1 SHA_384 value
     */
    proto.HashAlgorithm = (function () {
        const valuesById = {},
            values = Object.create(valuesById);
        values[(valuesById[0] = "HASH_ALGORITHM_UNKNOWN")] = 0;
        values[(valuesById[1] = "SHA_384")] = 1;
        return values;
    })();

    proto.HashObject = (function () {
        /**
         * Properties of a HashObject.
         * @memberof proto
         * @interface IHashObject
         * @property {proto.HashAlgorithm|null} [algorithm] Specifies the hashing algorithm
         * @property {number|null} [length] Hash length
         * @property {Uint8Array|null} [hash] Specifies the result of the hashing operation in bytes
         */

        /**
         * Constructs a new HashObject.
         * @memberof proto
         * @classdesc Encapsulates an object hash so that additional hash algorithms
         * can be added in the future without requiring a breaking change.
         * @implements IHashObject
         * @constructor
         * @param {proto.IHashObject=} [p] Properties to set
         */
        function HashObject(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * Specifies the hashing algorithm
         * @member {proto.HashAlgorithm} algorithm
         * @memberof proto.HashObject
         * @instance
         */
        HashObject.prototype.algorithm = 0;

        /**
         * Hash length
         * @member {number} length
         * @memberof proto.HashObject
         * @instance
         */
        HashObject.prototype.length = 0;

        /**
         * Specifies the result of the hashing operation in bytes
         * @member {Uint8Array} hash
         * @memberof proto.HashObject
         * @instance
         */
        HashObject.prototype.hash = $util.newBuffer([]);

        /**
         * Creates a new HashObject instance using the specified properties.
         * @function create
         * @memberof proto.HashObject
         * @static
         * @param {proto.IHashObject=} [properties] Properties to set
         * @returns {proto.HashObject} HashObject instance
         */
        HashObject.create = function create(properties) {
            return new HashObject(properties);
        };

        /**
         * Encodes the specified HashObject message. Does not implicitly {@link proto.HashObject.verify|verify} messages.
         * @function encode
         * @memberof proto.HashObject
         * @static
         * @param {proto.IHashObject} m HashObject message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HashObject.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.algorithm != null && Object.hasOwnProperty.call(m, "algorithm")) w.uint32(8).int32(m.algorithm);
            if (m.length != null && Object.hasOwnProperty.call(m, "length")) w.uint32(16).int32(m.length);
            if (m.hash != null && Object.hasOwnProperty.call(m, "hash")) w.uint32(26).bytes(m.hash);
            return w;
        };

        /**
         * Decodes a HashObject message from the specified reader or buffer.
         * @function decode
         * @memberof proto.HashObject
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.HashObject} HashObject
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HashObject.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.HashObject();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.algorithm = r.int32();
                        break;
                    }
                    case 2: {
                        m.length = r.int32();
                        break;
                    }
                    case 3: {
                        m.hash = r.bytes();
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for HashObject
         * @function getTypeUrl
         * @memberof proto.HashObject
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        HashObject.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.HashObject";
        };

        return HashObject;
    })();

    proto.RecordStreamFile = (function () {
        /**
         * Properties of a RecordStreamFile.
         * @memberof proto
         * @interface IRecordStreamFile
         * @property {proto.ISemanticVersion|null} [hapiProtoVersion] Version of HAPI that was used to serialize the file.
         * @property {proto.IHashObject|null} [startObjectRunningHash] Running Hash of all RecordStreamItems before writing this file.
         * @property {Array.<proto.IRecordStreamItem>|null} [recordStreamItems] List of all the record stream items from that period.
         * @property {proto.IHashObject|null} [endObjectRunningHash] Running Hash of all RecordStreamItems before closing this file.
         * @property {Long|null} [blockNumber] The block number associated with this period.
         * @property {Array.<proto.ISidecarMetadata>|null} [sidecars] List of the hashes of all the sidecar record files created for the same period.
         * Allows multiple sidecar files to be linked to this RecordStreamFile.
         */

        /**
         * Constructs a new RecordStreamFile.
         * @memberof proto
         * @classdesc RecordStreamFile is used to serialize all RecordStreamItems that are part of the
         * same period into record stream files.
         * This structure represents a block in Hedera (HIP-415).
         * @implements IRecordStreamFile
         * @constructor
         * @param {proto.IRecordStreamFile=} [p] Properties to set
         */
        function RecordStreamFile(p) {
            this.recordStreamItems = [];
            this.sidecars = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * Version of HAPI that was used to serialize the file.
         * @member {proto.ISemanticVersion|null|undefined} hapiProtoVersion
         * @memberof proto.RecordStreamFile
         * @instance
         */
        RecordStreamFile.prototype.hapiProtoVersion = null;

        /**
         * Running Hash of all RecordStreamItems before writing this file.
         * @member {proto.IHashObject|null|undefined} startObjectRunningHash
         * @memberof proto.RecordStreamFile
         * @instance
         */
        RecordStreamFile.prototype.startObjectRunningHash = null;

        /**
         * List of all the record stream items from that period.
         * @member {Array.<proto.IRecordStreamItem>} recordStreamItems
         * @memberof proto.RecordStreamFile
         * @instance
         */
        RecordStreamFile.prototype.recordStreamItems = $util.emptyArray;

        /**
         * Running Hash of all RecordStreamItems before closing this file.
         * @member {proto.IHashObject|null|undefined} endObjectRunningHash
         * @memberof proto.RecordStreamFile
         * @instance
         */
        RecordStreamFile.prototype.endObjectRunningHash = null;

        /**
         * The block number associated with this period.
         * @member {Long} blockNumber
         * @memberof proto.RecordStreamFile
         * @instance
         */
        RecordStreamFile.prototype.blockNumber = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * List of the hashes of all the sidecar record files created for the same period.
         * Allows multiple sidecar files to be linked to this RecordStreamFile.
         * @member {Array.<proto.ISidecarMetadata>} sidecars
         * @memberof proto.RecordStreamFile
         * @instance
         */
        RecordStreamFile.prototype.sidecars = $util.emptyArray;

        /**
         * Creates a new RecordStreamFile instance using the specified properties.
         * @function create
         * @memberof proto.RecordStreamFile
         * @static
         * @param {proto.IRecordStreamFile=} [properties] Properties to set
         * @returns {proto.RecordStreamFile} RecordStreamFile instance
         */
        RecordStreamFile.create = function create(properties) {
            return new RecordStreamFile(properties);
        };

        /**
         * Encodes the specified RecordStreamFile message. Does not implicitly {@link proto.RecordStreamFile.verify|verify} messages.
         * @function encode
         * @memberof proto.RecordStreamFile
         * @static
         * @param {proto.IRecordStreamFile} m RecordStreamFile message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RecordStreamFile.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.hapiProtoVersion != null && Object.hasOwnProperty.call(m, "hapiProtoVersion"))
                $root.proto.SemanticVersion.encode(m.hapiProtoVersion, w.uint32(10).fork()).ldelim();
            if (m.startObjectRunningHash != null && Object.hasOwnProperty.call(m, "startObjectRunningHash"))
                $root.proto.HashObject.encode(m.startObjectRunningHash, w.uint32(18).fork()).ldelim();
            if (m.recordStreamItems != null && m.recordStreamItems.length) {
                for (var i = 0; i < m.recordStreamItems.length; ++i)
                    $root.proto.RecordStreamItem.encode(m.recordStreamItems[i], w.uint32(26).fork()).ldelim();
            }
            if (m.endObjectRunningHash != null && Object.hasOwnProperty.call(m, "endObjectRunningHash"))
                $root.proto.HashObject.encode(m.endObjectRunningHash, w.uint32(34).fork()).ldelim();
            if (m.blockNumber != null && Object.hasOwnProperty.call(m, "blockNumber"))
                w.uint32(40).int64(m.blockNumber);
            if (m.sidecars != null && m.sidecars.length) {
                for (var i = 0; i < m.sidecars.length; ++i)
                    $root.proto.SidecarMetadata.encode(m.sidecars[i], w.uint32(50).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a RecordStreamFile message from the specified reader or buffer.
         * @function decode
         * @memberof proto.RecordStreamFile
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.RecordStreamFile} RecordStreamFile
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RecordStreamFile.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.RecordStreamFile();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.hapiProtoVersion = $root.proto.SemanticVersion.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.startObjectRunningHash = $root.proto.HashObject.decode(r, r.uint32());
                        break;
                    }
                    case 3: {
                        if (!(m.recordStreamItems && m.recordStreamItems.length)) m.recordStreamItems = [];
                        m.recordStreamItems.push($root.proto.RecordStreamItem.decode(r, r.uint32()));
                        break;
                    }
                    case 4: {
                        m.endObjectRunningHash = $root.proto.HashObject.decode(r, r.uint32());
                        break;
                    }
                    case 5: {
                        m.blockNumber = r.int64();
                        break;
                    }
                    case 6: {
                        if (!(m.sidecars && m.sidecars.length)) m.sidecars = [];
                        m.sidecars.push($root.proto.SidecarMetadata.decode(r, r.uint32()));
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for RecordStreamFile
         * @function getTypeUrl
         * @memberof proto.RecordStreamFile
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        RecordStreamFile.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.RecordStreamFile";
        };

        return RecordStreamFile;
    })();

    proto.RecordStreamItem = (function () {
        /**
         * Properties of a RecordStreamItem.
         * @memberof proto
         * @interface IRecordStreamItem
         * @property {proto.ITransaction|null} [transaction] RecordStreamItem transaction
         * @property {proto.ITransactionRecord|null} [record] RecordStreamItem record
         */

        /**
         * Constructs a new RecordStreamItem.
         * @memberof proto
         * @classdesc A RecordStreamItem consists of a Transaction and a TransactionRecord,
         * which are already defined protobuf messages.
         * @implements IRecordStreamItem
         * @constructor
         * @param {proto.IRecordStreamItem=} [p] Properties to set
         */
        function RecordStreamItem(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * RecordStreamItem transaction.
         * @member {proto.ITransaction|null|undefined} transaction
         * @memberof proto.RecordStreamItem
         * @instance
         */
        RecordStreamItem.prototype.transaction = null;

        /**
         * RecordStreamItem record.
         * @member {proto.ITransactionRecord|null|undefined} record
         * @memberof proto.RecordStreamItem
         * @instance
         */
        RecordStreamItem.prototype.record = null;

        /**
         * Creates a new RecordStreamItem instance using the specified properties.
         * @function create
         * @memberof proto.RecordStreamItem
         * @static
         * @param {proto.IRecordStreamItem=} [properties] Properties to set
         * @returns {proto.RecordStreamItem} RecordStreamItem instance
         */
        RecordStreamItem.create = function create(properties) {
            return new RecordStreamItem(properties);
        };

        /**
         * Encodes the specified RecordStreamItem message. Does not implicitly {@link proto.RecordStreamItem.verify|verify} messages.
         * @function encode
         * @memberof proto.RecordStreamItem
         * @static
         * @param {proto.IRecordStreamItem} m RecordStreamItem message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RecordStreamItem.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.transaction != null && Object.hasOwnProperty.call(m, "transaction"))
                $root.proto.Transaction.encode(m.transaction, w.uint32(10).fork()).ldelim();
            if (m.record != null && Object.hasOwnProperty.call(m, "record"))
                $root.proto.TransactionRecord.encode(m.record, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a RecordStreamItem message from the specified reader or buffer.
         * @function decode
         * @memberof proto.RecordStreamItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.RecordStreamItem} RecordStreamItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RecordStreamItem.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.RecordStreamItem();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.transaction = $root.proto.Transaction.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.record = $root.proto.TransactionRecord.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for RecordStreamItem
         * @function getTypeUrl
         * @memberof proto.RecordStreamItem
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        RecordStreamItem.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.RecordStreamItem";
        };

        return RecordStreamItem;
    })();

    proto.SidecarMetadata = (function () {
        /**
         * Properties of a SidecarMetadata.
         * @memberof proto
         * @interface ISidecarMetadata
         * @property {proto.IHashObject|null} [hash] The hash of the entire file.
         * @property {number|null} [id] The id of the sidecar record file
         * @property {Array.<proto.SidecarType>|null} [types] The types of sidecar records that will be included in the file.
         */

        /**
         * Constructs a new SidecarMetadata.
         * @memberof proto
         * @classdesc Information about a single sidecar file.
         * @implements ISidecarMetadata
         * @constructor
         * @param {proto.ISidecarMetadata=} [p] Properties to set
         */
        function SidecarMetadata(p) {
            this.types = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The hash of the entire file.
         * @member {proto.IHashObject|null|undefined} hash
         * @memberof proto.SidecarMetadata
         * @instance
         */
        SidecarMetadata.prototype.hash = null;

        /**
         * The id of the sidecar record file
         * @member {number} id
         * @memberof proto.SidecarMetadata
         * @instance
         */
        SidecarMetadata.prototype.id = 0;

        /**
         * The types of sidecar records that will be included in the file.
         * @member {Array.<proto.SidecarType>} types
         * @memberof proto.SidecarMetadata
         * @instance
         */
        SidecarMetadata.prototype.types = $util.emptyArray;

        /**
         * Creates a new SidecarMetadata instance using the specified properties.
         * @function create
         * @memberof proto.SidecarMetadata
         * @static
         * @param {proto.ISidecarMetadata=} [properties] Properties to set
         * @returns {proto.SidecarMetadata} SidecarMetadata instance
         */
        SidecarMetadata.create = function create(properties) {
            return new SidecarMetadata(properties);
        };

        /**
         * Encodes the specified SidecarMetadata message. Does not implicitly {@link proto.SidecarMetadata.verify|verify} messages.
         * @function encode
         * @memberof proto.SidecarMetadata
         * @static
         * @param {proto.ISidecarMetadata} m SidecarMetadata message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SidecarMetadata.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.hash != null && Object.hasOwnProperty.call(m, "hash"))
                $root.proto.HashObject.encode(m.hash, w.uint32(10).fork()).ldelim();
            if (m.id != null && Object.hasOwnProperty.call(m, "id")) w.uint32(16).int32(m.id);
            if (m.types != null && m.types.length) {
                w.uint32(26).fork();
                for (var i = 0; i < m.types.length; ++i) w.int32(m.types[i]);
                w.ldelim();
            }
            return w;
        };

        /**
         * Decodes a SidecarMetadata message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SidecarMetadata
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.SidecarMetadata} SidecarMetadata
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SidecarMetadata.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.SidecarMetadata();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.hash = $root.proto.HashObject.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.id = r.int32();
                        break;
                    }
                    case 3: {
                        if (!(m.types && m.types.length)) m.types = [];
                        if ((t & 7) === 2) {
                            var c2 = r.uint32() + r.pos;
                            while (r.pos < c2) m.types.push(r.int32());
                        } else m.types.push(r.int32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for SidecarMetadata
         * @function getTypeUrl
         * @memberof proto.SidecarMetadata
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SidecarMetadata.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.SidecarMetadata";
        };

        return SidecarMetadata;
    })();

    /**
     * The type of sidecar records contained in the sidecar record file
     * @name proto.SidecarType
     * @enum {number}
     * @property {number} SIDECAR_TYPE_UNKNOWN=0 SIDECAR_TYPE_UNKNOWN value
     * @property {number} CONTRACT_STATE_CHANGE=1 CONTRACT_STATE_CHANGE value
     * @property {number} CONTRACT_ACTION=2 CONTRACT_ACTION value
     * @property {number} CONTRACT_BYTECODE=3 CONTRACT_BYTECODE value
     */
    proto.SidecarType = (function () {
        const valuesById = {},
            values = Object.create(valuesById);
        values[(valuesById[0] = "SIDECAR_TYPE_UNKNOWN")] = 0;
        values[(valuesById[1] = "CONTRACT_STATE_CHANGE")] = 1;
        values[(valuesById[2] = "CONTRACT_ACTION")] = 2;
        values[(valuesById[3] = "CONTRACT_BYTECODE")] = 3;
        return values;
    })();

    proto.SidecarFile = (function () {
        /**
         * Properties of a SidecarFile.
         * @memberof proto
         * @interface ISidecarFile
         * @property {Array.<proto.ITransactionSidecarRecord>|null} [sidecarRecords] List of sidecar records
         */

        /**
         * Constructs a new SidecarFile.
         * @memberof proto
         * @classdesc A SidecarFile contains a list of TransactionSidecarRecords that are all created
         * in the same period and related to the same RecordStreamFile.
         * @implements ISidecarFile
         * @constructor
         * @param {proto.ISidecarFile=} [p] Properties to set
         */
        function SidecarFile(p) {
            this.sidecarRecords = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * List of sidecar records
         * @member {Array.<proto.ITransactionSidecarRecord>} sidecarRecords
         * @memberof proto.SidecarFile
         * @instance
         */
        SidecarFile.prototype.sidecarRecords = $util.emptyArray;

        /**
         * Creates a new SidecarFile instance using the specified properties.
         * @function create
         * @memberof proto.SidecarFile
         * @static
         * @param {proto.ISidecarFile=} [properties] Properties to set
         * @returns {proto.SidecarFile} SidecarFile instance
         */
        SidecarFile.create = function create(properties) {
            return new SidecarFile(properties);
        };

        /**
         * Encodes the specified SidecarFile message. Does not implicitly {@link proto.SidecarFile.verify|verify} messages.
         * @function encode
         * @memberof proto.SidecarFile
         * @static
         * @param {proto.ISidecarFile} m SidecarFile message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SidecarFile.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.sidecarRecords != null && m.sidecarRecords.length) {
                for (var i = 0; i < m.sidecarRecords.length; ++i)
                    $root.proto.TransactionSidecarRecord.encode(m.sidecarRecords[i], w.uint32(10).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a SidecarFile message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SidecarFile
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.SidecarFile} SidecarFile
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SidecarFile.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.SidecarFile();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        if (!(m.sidecarRecords && m.sidecarRecords.length)) m.sidecarRecords = [];
                        m.sidecarRecords.push($root.proto.TransactionSidecarRecord.decode(r, r.uint32()));
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for SidecarFile
         * @function getTypeUrl
         * @memberof proto.SidecarFile
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SidecarFile.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.SidecarFile";
        };

        return SidecarFile;
    })();

    proto.TransactionSidecarRecord = (function () {
        /**
         * Properties of a TransactionSidecarRecord.
         * @memberof proto
         * @interface ITransactionSidecarRecord
         * @property {proto.ITimestamp|null} [consensusTimestamp] Consensus timestamp will be the same as the consensus timestamp of the
         * transaction the side car is related to. This offers a convenient
         * way to match record to sidecar.
         * @property {boolean|null} [migration] Whether sidecar is from migration.
         * @property {proto.IContractStateChanges|null} [stateChanges] TransactionSidecarRecord stateChanges
         * @property {proto.IContractActions|null} [actions] TransactionSidecarRecord actions
         * @property {proto.IContractBytecode|null} [bytecode] TransactionSidecarRecord bytecode
         */

        /**
         * Constructs a new TransactionSidecarRecord.
         * @memberof proto
         * @classdesc TransactionSidecarRecord is used to create sidecar records complementing
         * TransactionRecord and storing additional information about a transaction's execution.
         * @implements ITransactionSidecarRecord
         * @constructor
         * @param {proto.ITransactionSidecarRecord=} [p] Properties to set
         */
        function TransactionSidecarRecord(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * Consensus timestamp will be the same as the consensus timestamp of the
         * transaction the side car is related to. This offers a convenient
         * way to match record to sidecar.
         * @member {proto.ITimestamp|null|undefined} consensusTimestamp
         * @memberof proto.TransactionSidecarRecord
         * @instance
         */
        TransactionSidecarRecord.prototype.consensusTimestamp = null;

        /**
         * Whether sidecar is from migration.
         * @member {boolean} migration
         * @memberof proto.TransactionSidecarRecord
         * @instance
         */
        TransactionSidecarRecord.prototype.migration = false;

        /**
         * TransactionSidecarRecord stateChanges.
         * @member {proto.IContractStateChanges|null|undefined} stateChanges
         * @memberof proto.TransactionSidecarRecord
         * @instance
         */
        TransactionSidecarRecord.prototype.stateChanges = null;

        /**
         * TransactionSidecarRecord actions.
         * @member {proto.IContractActions|null|undefined} actions
         * @memberof proto.TransactionSidecarRecord
         * @instance
         */
        TransactionSidecarRecord.prototype.actions = null;

        /**
         * TransactionSidecarRecord bytecode.
         * @member {proto.IContractBytecode|null|undefined} bytecode
         * @memberof proto.TransactionSidecarRecord
         * @instance
         */
        TransactionSidecarRecord.prototype.bytecode = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * TransactionSidecarRecord sidecarRecords.
         * @member {"stateChanges"|"actions"|"bytecode"|undefined} sidecarRecords
         * @memberof proto.TransactionSidecarRecord
         * @instance
         */
        Object.defineProperty(TransactionSidecarRecord.prototype, "sidecarRecords", {
            get: $util.oneOfGetter(($oneOfFields = ["stateChanges", "actions", "bytecode"])),
            set: $util.oneOfSetter($oneOfFields),
        });

        /**
         * Creates a new TransactionSidecarRecord instance using the specified properties.
         * @function create
         * @memberof proto.TransactionSidecarRecord
         * @static
         * @param {proto.ITransactionSidecarRecord=} [properties] Properties to set
         * @returns {proto.TransactionSidecarRecord} TransactionSidecarRecord instance
         */
        TransactionSidecarRecord.create = function create(properties) {
            return new TransactionSidecarRecord(properties);
        };

        /**
         * Encodes the specified TransactionSidecarRecord message. Does not implicitly {@link proto.TransactionSidecarRecord.verify|verify} messages.
         * @function encode
         * @memberof proto.TransactionSidecarRecord
         * @static
         * @param {proto.ITransactionSidecarRecord} m TransactionSidecarRecord message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionSidecarRecord.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.consensusTimestamp != null && Object.hasOwnProperty.call(m, "consensusTimestamp"))
                $root.proto.Timestamp.encode(m.consensusTimestamp, w.uint32(10).fork()).ldelim();
            if (m.migration != null && Object.hasOwnProperty.call(m, "migration")) w.uint32(16).bool(m.migration);
            if (m.stateChanges != null && Object.hasOwnProperty.call(m, "stateChanges"))
                $root.proto.ContractStateChanges.encode(m.stateChanges, w.uint32(26).fork()).ldelim();
            if (m.actions != null && Object.hasOwnProperty.call(m, "actions"))
                $root.proto.ContractActions.encode(m.actions, w.uint32(34).fork()).ldelim();
            if (m.bytecode != null && Object.hasOwnProperty.call(m, "bytecode"))
                $root.proto.ContractBytecode.encode(m.bytecode, w.uint32(42).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a TransactionSidecarRecord message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TransactionSidecarRecord
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TransactionSidecarRecord} TransactionSidecarRecord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionSidecarRecord.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.TransactionSidecarRecord();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.consensusTimestamp = $root.proto.Timestamp.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.migration = r.bool();
                        break;
                    }
                    case 3: {
                        m.stateChanges = $root.proto.ContractStateChanges.decode(r, r.uint32());
                        break;
                    }
                    case 4: {
                        m.actions = $root.proto.ContractActions.decode(r, r.uint32());
                        break;
                    }
                    case 5: {
                        m.bytecode = $root.proto.ContractBytecode.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for TransactionSidecarRecord
         * @function getTypeUrl
         * @memberof proto.TransactionSidecarRecord
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TransactionSidecarRecord.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TransactionSidecarRecord";
        };

        return TransactionSidecarRecord;
    })();

    proto.SignatureFile = (function () {
        /**
         * Properties of a SignatureFile.
         * @memberof proto
         * @interface ISignatureFile
         * @property {proto.ISignatureObject|null} [fileSignature] Signature for the file
         * @property {proto.ISignatureObject|null} [metadataSignature] Metadata signature
         */

        /**
         * Constructs a new SignatureFile.
         * @memberof proto
         * @classdesc The record signature file which is created for each record stream file
         * that signs the hash of the entire corresponding stream file.
         * @implements ISignatureFile
         * @constructor
         * @param {proto.ISignatureFile=} [p] Properties to set
         */
        function SignatureFile(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * Signature for the file
         * @member {proto.ISignatureObject|null|undefined} fileSignature
         * @memberof proto.SignatureFile
         * @instance
         */
        SignatureFile.prototype.fileSignature = null;

        /**
         * Metadata signature
         * @member {proto.ISignatureObject|null|undefined} metadataSignature
         * @memberof proto.SignatureFile
         * @instance
         */
        SignatureFile.prototype.metadataSignature = null;

        /**
         * Creates a new SignatureFile instance using the specified properties.
         * @function create
         * @memberof proto.SignatureFile
         * @static
         * @param {proto.ISignatureFile=} [properties] Properties to set
         * @returns {proto.SignatureFile} SignatureFile instance
         */
        SignatureFile.create = function create(properties) {
            return new SignatureFile(properties);
        };

        /**
         * Encodes the specified SignatureFile message. Does not implicitly {@link proto.SignatureFile.verify|verify} messages.
         * @function encode
         * @memberof proto.SignatureFile
         * @static
         * @param {proto.ISignatureFile} m SignatureFile message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignatureFile.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.fileSignature != null && Object.hasOwnProperty.call(m, "fileSignature"))
                $root.proto.SignatureObject.encode(m.fileSignature, w.uint32(10).fork()).ldelim();
            if (m.metadataSignature != null && Object.hasOwnProperty.call(m, "metadataSignature"))
                $root.proto.SignatureObject.encode(m.metadataSignature, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a SignatureFile message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SignatureFile
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.SignatureFile} SignatureFile
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignatureFile.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.SignatureFile();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.fileSignature = $root.proto.SignatureObject.decode(r, r.uint32());
                        break;
                    }
                    case 2: {
                        m.metadataSignature = $root.proto.SignatureObject.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for SignatureFile
         * @function getTypeUrl
         * @memberof proto.SignatureFile
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SignatureFile.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.SignatureFile";
        };

        return SignatureFile;
    })();

    proto.SignatureObject = (function () {
        /**
         * Properties of a SignatureObject.
         * @memberof proto
         * @interface ISignatureObject
         * @property {proto.SignatureType|null} [type] The signature type
         * @property {number|null} [length] Signature length
         * @property {number|null} [checksum] Signature checksum
         * @property {Uint8Array|null} [signature] Signature bytes
         * @property {proto.IHashObject|null} [hashObject] The hash that is signed by this signature
         */

        /**
         * Constructs a new SignatureObject.
         * @memberof proto
         * @classdesc A Signature defined by its type, length, checksum and signature bytes and the hash that is signed
         * @implements ISignatureObject
         * @constructor
         * @param {proto.ISignatureObject=} [p] Properties to set
         */
        function SignatureObject(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }

        /**
         * The signature type
         * @member {proto.SignatureType} type
         * @memberof proto.SignatureObject
         * @instance
         */
        SignatureObject.prototype.type = 0;

        /**
         * Signature length
         * @member {number} length
         * @memberof proto.SignatureObject
         * @instance
         */
        SignatureObject.prototype.length = 0;

        /**
         * Signature checksum
         * @member {number} checksum
         * @memberof proto.SignatureObject
         * @instance
         */
        SignatureObject.prototype.checksum = 0;

        /**
         * Signature bytes
         * @member {Uint8Array} signature
         * @memberof proto.SignatureObject
         * @instance
         */
        SignatureObject.prototype.signature = $util.newBuffer([]);

        /**
         * The hash that is signed by this signature
         * @member {proto.IHashObject|null|undefined} hashObject
         * @memberof proto.SignatureObject
         * @instance
         */
        SignatureObject.prototype.hashObject = null;

        /**
         * Creates a new SignatureObject instance using the specified properties.
         * @function create
         * @memberof proto.SignatureObject
         * @static
         * @param {proto.ISignatureObject=} [properties] Properties to set
         * @returns {proto.SignatureObject} SignatureObject instance
         */
        SignatureObject.create = function create(properties) {
            return new SignatureObject(properties);
        };

        /**
         * Encodes the specified SignatureObject message. Does not implicitly {@link proto.SignatureObject.verify|verify} messages.
         * @function encode
         * @memberof proto.SignatureObject
         * @static
         * @param {proto.ISignatureObject} m SignatureObject message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignatureObject.encode = function encode(m, w) {
            if (!w) w = $Writer.create();
            if (m.type != null && Object.hasOwnProperty.call(m, "type")) w.uint32(8).int32(m.type);
            if (m.length != null && Object.hasOwnProperty.call(m, "length")) w.uint32(16).int32(m.length);
            if (m.checksum != null && Object.hasOwnProperty.call(m, "checksum")) w.uint32(24).int32(m.checksum);
            if (m.signature != null && Object.hasOwnProperty.call(m, "signature")) w.uint32(34).bytes(m.signature);
            if (m.hashObject != null && Object.hasOwnProperty.call(m, "hashObject"))
                $root.proto.HashObject.encode(m.hashObject, w.uint32(42).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a SignatureObject message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SignatureObject
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.SignatureObject} SignatureObject
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignatureObject.decode = function decode(r, l) {
            if (!(r instanceof $Reader)) r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l,
                m = new $root.proto.SignatureObject();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                    case 1: {
                        m.type = r.int32();
                        break;
                    }
                    case 2: {
                        m.length = r.int32();
                        break;
                    }
                    case 3: {
                        m.checksum = r.int32();
                        break;
                    }
                    case 4: {
                        m.signature = r.bytes();
                        break;
                    }
                    case 5: {
                        m.hashObject = $root.proto.HashObject.decode(r, r.uint32());
                        break;
                    }
                    default:
                        r.skipType(t & 7);
                        break;
                }
            }
            return m;
        };

        /**
         * Gets the default type url for SignatureObject
         * @function getTypeUrl
         * @memberof proto.SignatureObject
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SignatureObject.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.SignatureObject";
        };

        return SignatureObject;
    })();

    /**
     * The signature type
     * @name proto.SignatureType
     * @enum {number}
     * @property {number} SIGNATURE_TYPE_UNKNOWN=0 SIGNATURE_TYPE_UNKNOWN value
     * @property {number} SHA_384_WITH_RSA=1 SHA_384_WITH_RSA value
     */
    proto.SignatureType = (function () {
        const valuesById = {},
            values = Object.create(valuesById);
        values[(valuesById[0] = "SIGNATURE_TYPE_UNKNOWN")] = 0;
        values[(valuesById[1] = "SHA_384_WITH_RSA")] = 1;
        return values;
    })();

    return proto;
})());

export const google = ($root.google = (() => {
    /**
     * Namespace google.
     * @exports google
     * @namespace
     */
    const google = {};

    google.protobuf = (function () {
        /**
         * Namespace protobuf.
         * @memberof google
         * @namespace
         */
        const protobuf = {};

        protobuf.DoubleValue = (function () {
            /**
             * Properties of a DoubleValue.
             * @memberof google.protobuf
             * @interface IDoubleValue
             * @property {number|null} [value] DoubleValue value
             */

            /**
             * Constructs a new DoubleValue.
             * @memberof google.protobuf
             * @classdesc Represents a DoubleValue.
             * @implements IDoubleValue
             * @constructor
             * @param {google.protobuf.IDoubleValue=} [p] Properties to set
             */
            function DoubleValue(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
            }

            /**
             * DoubleValue value.
             * @member {number} value
             * @memberof google.protobuf.DoubleValue
             * @instance
             */
            DoubleValue.prototype.value = 0;

            /**
             * Creates a new DoubleValue instance using the specified properties.
             * @function create
             * @memberof google.protobuf.DoubleValue
             * @static
             * @param {google.protobuf.IDoubleValue=} [properties] Properties to set
             * @returns {google.protobuf.DoubleValue} DoubleValue instance
             */
            DoubleValue.create = function create(properties) {
                return new DoubleValue(properties);
            };

            /**
             * Encodes the specified DoubleValue message. Does not implicitly {@link google.protobuf.DoubleValue.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.DoubleValue
             * @static
             * @param {google.protobuf.IDoubleValue} m DoubleValue message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DoubleValue.encode = function encode(m, w) {
                if (!w) w = $Writer.create();
                if (m.value != null && Object.hasOwnProperty.call(m, "value")) w.uint32(9).double(m.value);
                return w;
            };

            /**
             * Decodes a DoubleValue message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.DoubleValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {google.protobuf.DoubleValue} DoubleValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DoubleValue.decode = function decode(r, l) {
                if (!(r instanceof $Reader)) r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l,
                    m = new $root.google.protobuf.DoubleValue();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                        case 1: {
                            m.value = r.double();
                            break;
                        }
                        default:
                            r.skipType(t & 7);
                            break;
                    }
                }
                return m;
            };

            /**
             * Gets the default type url for DoubleValue
             * @function getTypeUrl
             * @memberof google.protobuf.DoubleValue
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DoubleValue.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.DoubleValue";
            };

            return DoubleValue;
        })();

        protobuf.FloatValue = (function () {
            /**
             * Properties of a FloatValue.
             * @memberof google.protobuf
             * @interface IFloatValue
             * @property {number|null} [value] FloatValue value
             */

            /**
             * Constructs a new FloatValue.
             * @memberof google.protobuf
             * @classdesc Represents a FloatValue.
             * @implements IFloatValue
             * @constructor
             * @param {google.protobuf.IFloatValue=} [p] Properties to set
             */
            function FloatValue(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
            }

            /**
             * FloatValue value.
             * @member {number} value
             * @memberof google.protobuf.FloatValue
             * @instance
             */
            FloatValue.prototype.value = 0;

            /**
             * Creates a new FloatValue instance using the specified properties.
             * @function create
             * @memberof google.protobuf.FloatValue
             * @static
             * @param {google.protobuf.IFloatValue=} [properties] Properties to set
             * @returns {google.protobuf.FloatValue} FloatValue instance
             */
            FloatValue.create = function create(properties) {
                return new FloatValue(properties);
            };

            /**
             * Encodes the specified FloatValue message. Does not implicitly {@link google.protobuf.FloatValue.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FloatValue
             * @static
             * @param {google.protobuf.IFloatValue} m FloatValue message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FloatValue.encode = function encode(m, w) {
                if (!w) w = $Writer.create();
                if (m.value != null && Object.hasOwnProperty.call(m, "value")) w.uint32(13).float(m.value);
                return w;
            };

            /**
             * Decodes a FloatValue message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FloatValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {google.protobuf.FloatValue} FloatValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FloatValue.decode = function decode(r, l) {
                if (!(r instanceof $Reader)) r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l,
                    m = new $root.google.protobuf.FloatValue();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                        case 1: {
                            m.value = r.float();
                            break;
                        }
                        default:
                            r.skipType(t & 7);
                            break;
                    }
                }
                return m;
            };

            /**
             * Gets the default type url for FloatValue
             * @function getTypeUrl
             * @memberof google.protobuf.FloatValue
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            FloatValue.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.FloatValue";
            };

            return FloatValue;
        })();

        protobuf.Int64Value = (function () {
            /**
             * Properties of an Int64Value.
             * @memberof google.protobuf
             * @interface IInt64Value
             * @property {Long|null} [value] Int64Value value
             */

            /**
             * Constructs a new Int64Value.
             * @memberof google.protobuf
             * @classdesc Represents an Int64Value.
             * @implements IInt64Value
             * @constructor
             * @param {google.protobuf.IInt64Value=} [p] Properties to set
             */
            function Int64Value(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
            }

            /**
             * Int64Value value.
             * @member {Long} value
             * @memberof google.protobuf.Int64Value
             * @instance
             */
            Int64Value.prototype.value = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

            /**
             * Creates a new Int64Value instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Int64Value
             * @static
             * @param {google.protobuf.IInt64Value=} [properties] Properties to set
             * @returns {google.protobuf.Int64Value} Int64Value instance
             */
            Int64Value.create = function create(properties) {
                return new Int64Value(properties);
            };

            /**
             * Encodes the specified Int64Value message. Does not implicitly {@link google.protobuf.Int64Value.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Int64Value
             * @static
             * @param {google.protobuf.IInt64Value} m Int64Value message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Int64Value.encode = function encode(m, w) {
                if (!w) w = $Writer.create();
                if (m.value != null && Object.hasOwnProperty.call(m, "value")) w.uint32(8).int64(m.value);
                return w;
            };

            /**
             * Decodes an Int64Value message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Int64Value
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {google.protobuf.Int64Value} Int64Value
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Int64Value.decode = function decode(r, l) {
                if (!(r instanceof $Reader)) r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l,
                    m = new $root.google.protobuf.Int64Value();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                        case 1: {
                            m.value = r.int64();
                            break;
                        }
                        default:
                            r.skipType(t & 7);
                            break;
                    }
                }
                return m;
            };

            /**
             * Gets the default type url for Int64Value
             * @function getTypeUrl
             * @memberof google.protobuf.Int64Value
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Int64Value.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.Int64Value";
            };

            return Int64Value;
        })();

        protobuf.UInt64Value = (function () {
            /**
             * Properties of a UInt64Value.
             * @memberof google.protobuf
             * @interface IUInt64Value
             * @property {Long|null} [value] UInt64Value value
             */

            /**
             * Constructs a new UInt64Value.
             * @memberof google.protobuf
             * @classdesc Represents a UInt64Value.
             * @implements IUInt64Value
             * @constructor
             * @param {google.protobuf.IUInt64Value=} [p] Properties to set
             */
            function UInt64Value(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
            }

            /**
             * UInt64Value value.
             * @member {Long} value
             * @memberof google.protobuf.UInt64Value
             * @instance
             */
            UInt64Value.prototype.value = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

            /**
             * Creates a new UInt64Value instance using the specified properties.
             * @function create
             * @memberof google.protobuf.UInt64Value
             * @static
             * @param {google.protobuf.IUInt64Value=} [properties] Properties to set
             * @returns {google.protobuf.UInt64Value} UInt64Value instance
             */
            UInt64Value.create = function create(properties) {
                return new UInt64Value(properties);
            };

            /**
             * Encodes the specified UInt64Value message. Does not implicitly {@link google.protobuf.UInt64Value.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.UInt64Value
             * @static
             * @param {google.protobuf.IUInt64Value} m UInt64Value message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UInt64Value.encode = function encode(m, w) {
                if (!w) w = $Writer.create();
                if (m.value != null && Object.hasOwnProperty.call(m, "value")) w.uint32(8).uint64(m.value);
                return w;
            };

            /**
             * Decodes a UInt64Value message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.UInt64Value
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {google.protobuf.UInt64Value} UInt64Value
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UInt64Value.decode = function decode(r, l) {
                if (!(r instanceof $Reader)) r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l,
                    m = new $root.google.protobuf.UInt64Value();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                        case 1: {
                            m.value = r.uint64();
                            break;
                        }
                        default:
                            r.skipType(t & 7);
                            break;
                    }
                }
                return m;
            };

            /**
             * Gets the default type url for UInt64Value
             * @function getTypeUrl
             * @memberof google.protobuf.UInt64Value
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            UInt64Value.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.UInt64Value";
            };

            return UInt64Value;
        })();

        protobuf.Int32Value = (function () {
            /**
             * Properties of an Int32Value.
             * @memberof google.protobuf
             * @interface IInt32Value
             * @property {number|null} [value] Int32Value value
             */

            /**
             * Constructs a new Int32Value.
             * @memberof google.protobuf
             * @classdesc Represents an Int32Value.
             * @implements IInt32Value
             * @constructor
             * @param {google.protobuf.IInt32Value=} [p] Properties to set
             */
            function Int32Value(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
            }

            /**
             * Int32Value value.
             * @member {number} value
             * @memberof google.protobuf.Int32Value
             * @instance
             */
            Int32Value.prototype.value = 0;

            /**
             * Creates a new Int32Value instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Int32Value
             * @static
             * @param {google.protobuf.IInt32Value=} [properties] Properties to set
             * @returns {google.protobuf.Int32Value} Int32Value instance
             */
            Int32Value.create = function create(properties) {
                return new Int32Value(properties);
            };

            /**
             * Encodes the specified Int32Value message. Does not implicitly {@link google.protobuf.Int32Value.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Int32Value
             * @static
             * @param {google.protobuf.IInt32Value} m Int32Value message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Int32Value.encode = function encode(m, w) {
                if (!w) w = $Writer.create();
                if (m.value != null && Object.hasOwnProperty.call(m, "value")) w.uint32(8).int32(m.value);
                return w;
            };

            /**
             * Decodes an Int32Value message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Int32Value
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {google.protobuf.Int32Value} Int32Value
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Int32Value.decode = function decode(r, l) {
                if (!(r instanceof $Reader)) r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l,
                    m = new $root.google.protobuf.Int32Value();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                        case 1: {
                            m.value = r.int32();
                            break;
                        }
                        default:
                            r.skipType(t & 7);
                            break;
                    }
                }
                return m;
            };

            /**
             * Gets the default type url for Int32Value
             * @function getTypeUrl
             * @memberof google.protobuf.Int32Value
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Int32Value.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.Int32Value";
            };

            return Int32Value;
        })();

        protobuf.UInt32Value = (function () {
            /**
             * Properties of a UInt32Value.
             * @memberof google.protobuf
             * @interface IUInt32Value
             * @property {number|null} [value] UInt32Value value
             */

            /**
             * Constructs a new UInt32Value.
             * @memberof google.protobuf
             * @classdesc Represents a UInt32Value.
             * @implements IUInt32Value
             * @constructor
             * @param {google.protobuf.IUInt32Value=} [p] Properties to set
             */
            function UInt32Value(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
            }

            /**
             * UInt32Value value.
             * @member {number} value
             * @memberof google.protobuf.UInt32Value
             * @instance
             */
            UInt32Value.prototype.value = 0;

            /**
             * Creates a new UInt32Value instance using the specified properties.
             * @function create
             * @memberof google.protobuf.UInt32Value
             * @static
             * @param {google.protobuf.IUInt32Value=} [properties] Properties to set
             * @returns {google.protobuf.UInt32Value} UInt32Value instance
             */
            UInt32Value.create = function create(properties) {
                return new UInt32Value(properties);
            };

            /**
             * Encodes the specified UInt32Value message. Does not implicitly {@link google.protobuf.UInt32Value.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.UInt32Value
             * @static
             * @param {google.protobuf.IUInt32Value} m UInt32Value message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UInt32Value.encode = function encode(m, w) {
                if (!w) w = $Writer.create();
                if (m.value != null && Object.hasOwnProperty.call(m, "value")) w.uint32(8).uint32(m.value);
                return w;
            };

            /**
             * Decodes a UInt32Value message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.UInt32Value
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {google.protobuf.UInt32Value} UInt32Value
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UInt32Value.decode = function decode(r, l) {
                if (!(r instanceof $Reader)) r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l,
                    m = new $root.google.protobuf.UInt32Value();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                        case 1: {
                            m.value = r.uint32();
                            break;
                        }
                        default:
                            r.skipType(t & 7);
                            break;
                    }
                }
                return m;
            };

            /**
             * Gets the default type url for UInt32Value
             * @function getTypeUrl
             * @memberof google.protobuf.UInt32Value
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            UInt32Value.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.UInt32Value";
            };

            return UInt32Value;
        })();

        protobuf.BoolValue = (function () {
            /**
             * Properties of a BoolValue.
             * @memberof google.protobuf
             * @interface IBoolValue
             * @property {boolean|null} [value] BoolValue value
             */

            /**
             * Constructs a new BoolValue.
             * @memberof google.protobuf
             * @classdesc Represents a BoolValue.
             * @implements IBoolValue
             * @constructor
             * @param {google.protobuf.IBoolValue=} [p] Properties to set
             */
            function BoolValue(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
            }

            /**
             * BoolValue value.
             * @member {boolean} value
             * @memberof google.protobuf.BoolValue
             * @instance
             */
            BoolValue.prototype.value = false;

            /**
             * Creates a new BoolValue instance using the specified properties.
             * @function create
             * @memberof google.protobuf.BoolValue
             * @static
             * @param {google.protobuf.IBoolValue=} [properties] Properties to set
             * @returns {google.protobuf.BoolValue} BoolValue instance
             */
            BoolValue.create = function create(properties) {
                return new BoolValue(properties);
            };

            /**
             * Encodes the specified BoolValue message. Does not implicitly {@link google.protobuf.BoolValue.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.BoolValue
             * @static
             * @param {google.protobuf.IBoolValue} m BoolValue message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BoolValue.encode = function encode(m, w) {
                if (!w) w = $Writer.create();
                if (m.value != null && Object.hasOwnProperty.call(m, "value")) w.uint32(8).bool(m.value);
                return w;
            };

            /**
             * Decodes a BoolValue message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.BoolValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {google.protobuf.BoolValue} BoolValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BoolValue.decode = function decode(r, l) {
                if (!(r instanceof $Reader)) r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l,
                    m = new $root.google.protobuf.BoolValue();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                        case 1: {
                            m.value = r.bool();
                            break;
                        }
                        default:
                            r.skipType(t & 7);
                            break;
                    }
                }
                return m;
            };

            /**
             * Gets the default type url for BoolValue
             * @function getTypeUrl
             * @memberof google.protobuf.BoolValue
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            BoolValue.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.BoolValue";
            };

            return BoolValue;
        })();

        protobuf.StringValue = (function () {
            /**
             * Properties of a StringValue.
             * @memberof google.protobuf
             * @interface IStringValue
             * @property {string|null} [value] StringValue value
             */

            /**
             * Constructs a new StringValue.
             * @memberof google.protobuf
             * @classdesc Represents a StringValue.
             * @implements IStringValue
             * @constructor
             * @param {google.protobuf.IStringValue=} [p] Properties to set
             */
            function StringValue(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
            }

            /**
             * StringValue value.
             * @member {string} value
             * @memberof google.protobuf.StringValue
             * @instance
             */
            StringValue.prototype.value = "";

            /**
             * Creates a new StringValue instance using the specified properties.
             * @function create
             * @memberof google.protobuf.StringValue
             * @static
             * @param {google.protobuf.IStringValue=} [properties] Properties to set
             * @returns {google.protobuf.StringValue} StringValue instance
             */
            StringValue.create = function create(properties) {
                return new StringValue(properties);
            };

            /**
             * Encodes the specified StringValue message. Does not implicitly {@link google.protobuf.StringValue.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.StringValue
             * @static
             * @param {google.protobuf.IStringValue} m StringValue message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StringValue.encode = function encode(m, w) {
                if (!w) w = $Writer.create();
                if (m.value != null && Object.hasOwnProperty.call(m, "value")) w.uint32(10).string(m.value);
                return w;
            };

            /**
             * Decodes a StringValue message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.StringValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {google.protobuf.StringValue} StringValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StringValue.decode = function decode(r, l) {
                if (!(r instanceof $Reader)) r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l,
                    m = new $root.google.protobuf.StringValue();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                        case 1: {
                            m.value = r.string();
                            break;
                        }
                        default:
                            r.skipType(t & 7);
                            break;
                    }
                }
                return m;
            };

            /**
             * Gets the default type url for StringValue
             * @function getTypeUrl
             * @memberof google.protobuf.StringValue
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            StringValue.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.StringValue";
            };

            return StringValue;
        })();

        protobuf.BytesValue = (function () {
            /**
             * Properties of a BytesValue.
             * @memberof google.protobuf
             * @interface IBytesValue
             * @property {Uint8Array|null} [value] BytesValue value
             */

            /**
             * Constructs a new BytesValue.
             * @memberof google.protobuf
             * @classdesc Represents a BytesValue.
             * @implements IBytesValue
             * @constructor
             * @param {google.protobuf.IBytesValue=} [p] Properties to set
             */
            function BytesValue(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
            }

            /**
             * BytesValue value.
             * @member {Uint8Array} value
             * @memberof google.protobuf.BytesValue
             * @instance
             */
            BytesValue.prototype.value = $util.newBuffer([]);

            /**
             * Creates a new BytesValue instance using the specified properties.
             * @function create
             * @memberof google.protobuf.BytesValue
             * @static
             * @param {google.protobuf.IBytesValue=} [properties] Properties to set
             * @returns {google.protobuf.BytesValue} BytesValue instance
             */
            BytesValue.create = function create(properties) {
                return new BytesValue(properties);
            };

            /**
             * Encodes the specified BytesValue message. Does not implicitly {@link google.protobuf.BytesValue.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.BytesValue
             * @static
             * @param {google.protobuf.IBytesValue} m BytesValue message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BytesValue.encode = function encode(m, w) {
                if (!w) w = $Writer.create();
                if (m.value != null && Object.hasOwnProperty.call(m, "value")) w.uint32(10).bytes(m.value);
                return w;
            };

            /**
             * Decodes a BytesValue message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.BytesValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {google.protobuf.BytesValue} BytesValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BytesValue.decode = function decode(r, l) {
                if (!(r instanceof $Reader)) r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l,
                    m = new $root.google.protobuf.BytesValue();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                        case 1: {
                            m.value = r.bytes();
                            break;
                        }
                        default:
                            r.skipType(t & 7);
                            break;
                    }
                }
                return m;
            };

            /**
             * Gets the default type url for BytesValue
             * @function getTypeUrl
             * @memberof google.protobuf.BytesValue
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            BytesValue.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.BytesValue";
            };

            return BytesValue;
        })();

        return protobuf;
    })();

    return google;
})());

export { $root as default };

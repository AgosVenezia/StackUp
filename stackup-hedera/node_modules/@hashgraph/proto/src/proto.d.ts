import * as $protobuf from "protobufjs";
import Long = require("long");
export = hashgraph;

declare namespace hashgraph {


    /** Namespace com. */
    namespace com {

        /** Namespace hedera. */
        namespace hedera {

            /** Namespace mirror. */
            namespace mirror {

                /** Namespace api. */
                namespace api {

                    /** Namespace hashgraph.proto. */
                    namespace proto {

                        /** Properties of a ConsensusTopicQuery. */
                        interface IConsensusTopicQuery {

                            /** A required topic ID to retrieve messages for. */
                            topicID?: (hashgraph.proto.ITopicID|null);

                            /**
                             * Include messages which reached consensus on or after this time. Defaults to current time if
                             * not set.
                             */
                            consensusStartTime?: (hashgraph.proto.ITimestamp|null);

                            /**
                             * Include messages which reached consensus before this time. If not set it will receive
                             * indefinitely.
                             */
                            consensusEndTime?: (hashgraph.proto.ITimestamp|null);

                            /**
                             * The maximum number of messages to receive before stopping. If not set or set to zero it will
                             * return messages indefinitely.
                             */
                            limit?: (Long|null);
                        }

                        /** Represents a ConsensusTopicQuery. */
                        class ConsensusTopicQuery implements IConsensusTopicQuery {

                            /**
                             * Constructs a new ConsensusTopicQuery.
                             * @param [p] Properties to set
                             */
                            constructor(p?: com.hedera.mirror.api.proto.IConsensusTopicQuery);

                            /** A required topic ID to retrieve messages for. */
                            public topicID?: (hashgraph.proto.ITopicID|null);

                            /**
                             * Include messages which reached consensus on or after this time. Defaults to current time if
                             * not set.
                             */
                            public consensusStartTime?: (hashgraph.proto.ITimestamp|null);

                            /**
                             * Include messages which reached consensus before this time. If not set it will receive
                             * indefinitely.
                             */
                            public consensusEndTime?: (hashgraph.proto.ITimestamp|null);

                            /**
                             * The maximum number of messages to receive before stopping. If not set or set to zero it will
                             * return messages indefinitely.
                             */
                            public limit: Long;

                            /**
                             * Creates a new ConsensusTopicQuery instance using the specified properties.
                             * @param [properties] Properties to set
                             * @returns ConsensusTopicQuery instance
                             */
                            public static create(properties?: com.hedera.mirror.api.proto.IConsensusTopicQuery): com.hedera.mirror.api.proto.ConsensusTopicQuery;

                            /**
                             * Encodes the specified ConsensusTopicQuery message. Does not implicitly {@link com.hedera.mirror.api.proto.ConsensusTopicQuery.verify|verify} messages.
                             * @param m ConsensusTopicQuery message or plain object to encode
                             * @param [w] Writer to encode to
                             * @returns Writer
                             */
                            public static encode(m: com.hedera.mirror.api.proto.IConsensusTopicQuery, w?: $protobuf.Writer): $protobuf.Writer;

                            /**
                             * Decodes a ConsensusTopicQuery message from the specified reader or buffer.
                             * @param r Reader or buffer to decode from
                             * @param [l] Message length if known beforehand
                             * @returns ConsensusTopicQuery
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): com.hedera.mirror.api.proto.ConsensusTopicQuery;

                            /**
                             * Gets the default type url for ConsensusTopicQuery
                             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns The default type url
                             */
                            public static getTypeUrl(typeUrlPrefix?: string): string;
                        }

                        /** Properties of a ConsensusTopicResponse. */
                        interface IConsensusTopicResponse {

                            /** The time at which the transaction reached consensus */
                            consensusTimestamp?: (hashgraph.proto.ITimestamp|null);

                            /**
                             * The message body originally in the ConsensusSubmitMessageTransactionBody. Message size will
                             * be less than 6KiB.
                             */
                            message?: (Uint8Array|null);

                            /** The running hash (SHA384) of every message. */
                            runningHash?: (Uint8Array|null);

                            /** Starts at 1 for first submitted message. Incremented on each submitted message. */
                            sequenceNumber?: (Long|null);

                            /** Version of the SHA-384 digest used to update the running hash. */
                            runningHashVersion?: (Long|null);

                            /** Optional information of the current chunk in a fragmented message. */
                            chunkInfo?: (hashgraph.proto.IConsensusMessageChunkInfo|null);
                        }

                        /** Represents a ConsensusTopicResponse. */
                        class ConsensusTopicResponse implements IConsensusTopicResponse {

                            /**
                             * Constructs a new ConsensusTopicResponse.
                             * @param [p] Properties to set
                             */
                            constructor(p?: com.hedera.mirror.api.proto.IConsensusTopicResponse);

                            /** The time at which the transaction reached consensus */
                            public consensusTimestamp?: (hashgraph.proto.ITimestamp|null);

                            /**
                             * The message body originally in the ConsensusSubmitMessageTransactionBody. Message size will
                             * be less than 6KiB.
                             */
                            public message: Uint8Array;

                            /** The running hash (SHA384) of every message. */
                            public runningHash: Uint8Array;

                            /** Starts at 1 for first submitted message. Incremented on each submitted message. */
                            public sequenceNumber: Long;

                            /** Version of the SHA-384 digest used to update the running hash. */
                            public runningHashVersion: Long;

                            /** Optional information of the current chunk in a fragmented message. */
                            public chunkInfo?: (hashgraph.proto.IConsensusMessageChunkInfo|null);

                            /**
                             * Creates a new ConsensusTopicResponse instance using the specified properties.
                             * @param [properties] Properties to set
                             * @returns ConsensusTopicResponse instance
                             */
                            public static create(properties?: com.hedera.mirror.api.proto.IConsensusTopicResponse): com.hedera.mirror.api.proto.ConsensusTopicResponse;

                            /**
                             * Encodes the specified ConsensusTopicResponse message. Does not implicitly {@link com.hedera.mirror.api.proto.ConsensusTopicResponse.verify|verify} messages.
                             * @param m ConsensusTopicResponse message or plain object to encode
                             * @param [w] Writer to encode to
                             * @returns Writer
                             */
                            public static encode(m: com.hedera.mirror.api.proto.IConsensusTopicResponse, w?: $protobuf.Writer): $protobuf.Writer;

                            /**
                             * Decodes a ConsensusTopicResponse message from the specified reader or buffer.
                             * @param r Reader or buffer to decode from
                             * @param [l] Message length if known beforehand
                             * @returns ConsensusTopicResponse
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): com.hedera.mirror.api.proto.ConsensusTopicResponse;

                            /**
                             * Gets the default type url for ConsensusTopicResponse
                             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns The default type url
                             */
                            public static getTypeUrl(typeUrlPrefix?: string): string;
                        }

                        /**
                         * The Mirror Service provides the ability to query a stream of Hedera Consensus Service (HCS)
                         * messages for an HCS Topic via a specific (possibly open-ended) time range.
                         */
                        class ConsensusService extends $protobuf.rpc.Service {

                            /**
                             * Constructs a new ConsensusService service.
                             * @param rpcImpl RPC implementation
                             * @param [requestDelimited=false] Whether requests are length-delimited
                             * @param [responseDelimited=false] Whether responses are length-delimited
                             */
                            constructor(rpcImpl: $protobuf.RPCImpl, requestDelimited?: boolean, responseDelimited?: boolean);

                            /**
                             * Creates new ConsensusService service using the specified rpc implementation.
                             * @param rpcImpl RPC implementation
                             * @param [requestDelimited=false] Whether requests are length-delimited
                             * @param [responseDelimited=false] Whether responses are length-delimited
                             * @returns RPC service. Useful where requests and/or responses are streamed.
                             */
                            public static create(rpcImpl: $protobuf.RPCImpl, requestDelimited?: boolean, responseDelimited?: boolean): ConsensusService;

                            /**
                             * Calls subscribeTopic.
                             * @param request ConsensusTopicQuery message or plain object
                             * @param callback Node-style callback called with the error, if any, and ConsensusTopicResponse
                             */
                            public subscribeTopic(request: com.hedera.mirror.api.proto.IConsensusTopicQuery, callback: com.hedera.mirror.api.proto.ConsensusService.subscribeTopicCallback): void;

                            /**
                             * Calls subscribeTopic.
                             * @param request ConsensusTopicQuery message or plain object
                             * @returns Promise
                             */
                            public subscribeTopic(request: com.hedera.mirror.api.proto.IConsensusTopicQuery): Promise<com.hedera.mirror.api.proto.ConsensusTopicResponse>;
                        }

                        namespace ConsensusService {

                            /**
                             * Callback as used by {@link com.hedera.mirror.api.proto.ConsensusService#subscribeTopic}.
                             * @param error Error, if any
                             * @param [response] ConsensusTopicResponse
                             */
                            type subscribeTopicCallback = (error: (Error|null), response?: com.hedera.mirror.api.proto.ConsensusTopicResponse) => void;
                        }

                        /** Properties of an AddressBookQuery. */
                        interface IAddressBookQuery {

                            /** The ID of the address book file on the network. Can be either 0.0.101 or 0.0.102. */
                            fileId?: (hashgraph.proto.IFileID|null);

                            /** The maximum number of node addresses to receive before stopping. If not set or set to zero it will return all node addresses in the database. */
                            limit?: (number|null);
                        }

                        /** Request object to query an address book for its list of nodes */
                        class AddressBookQuery implements IAddressBookQuery {

                            /**
                             * Constructs a new AddressBookQuery.
                             * @param [p] Properties to set
                             */
                            constructor(p?: com.hedera.mirror.api.proto.IAddressBookQuery);

                            /** The ID of the address book file on the network. Can be either 0.0.101 or 0.0.102. */
                            public fileId?: (hashgraph.proto.IFileID|null);

                            /** The maximum number of node addresses to receive before stopping. If not set or set to zero it will return all node addresses in the database. */
                            public limit: number;

                            /**
                             * Creates a new AddressBookQuery instance using the specified properties.
                             * @param [properties] Properties to set
                             * @returns AddressBookQuery instance
                             */
                            public static create(properties?: com.hedera.mirror.api.proto.IAddressBookQuery): com.hedera.mirror.api.proto.AddressBookQuery;

                            /**
                             * Encodes the specified AddressBookQuery message. Does not implicitly {@link com.hedera.mirror.api.proto.AddressBookQuery.verify|verify} messages.
                             * @param m AddressBookQuery message or plain object to encode
                             * @param [w] Writer to encode to
                             * @returns Writer
                             */
                            public static encode(m: com.hedera.mirror.api.proto.IAddressBookQuery, w?: $protobuf.Writer): $protobuf.Writer;

                            /**
                             * Decodes an AddressBookQuery message from the specified reader or buffer.
                             * @param r Reader or buffer to decode from
                             * @param [l] Message length if known beforehand
                             * @returns AddressBookQuery
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): com.hedera.mirror.api.proto.AddressBookQuery;

                            /**
                             * Gets the default type url for AddressBookQuery
                             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns The default type url
                             */
                            public static getTypeUrl(typeUrlPrefix?: string): string;
                        }

                        /** Provides cross network APIs like address book queries */
                        class NetworkService extends $protobuf.rpc.Service {

                            /**
                             * Constructs a new NetworkService service.
                             * @param rpcImpl RPC implementation
                             * @param [requestDelimited=false] Whether requests are length-delimited
                             * @param [responseDelimited=false] Whether responses are length-delimited
                             */
                            constructor(rpcImpl: $protobuf.RPCImpl, requestDelimited?: boolean, responseDelimited?: boolean);

                            /**
                             * Creates new NetworkService service using the specified rpc implementation.
                             * @param rpcImpl RPC implementation
                             * @param [requestDelimited=false] Whether requests are length-delimited
                             * @param [responseDelimited=false] Whether responses are length-delimited
                             * @returns RPC service. Useful where requests and/or responses are streamed.
                             */
                            public static create(rpcImpl: $protobuf.RPCImpl, requestDelimited?: boolean, responseDelimited?: boolean): NetworkService;

                            /**
                             * Calls getNodes.
                             * @param request AddressBookQuery message or plain object
                             * @param callback Node-style callback called with the error, if any, and NodeAddress
                             */
                            public getNodes(request: com.hedera.mirror.api.proto.IAddressBookQuery, callback: com.hedera.mirror.api.proto.NetworkService.getNodesCallback): void;

                            /**
                             * Calls getNodes.
                             * @param request AddressBookQuery message or plain object
                             * @returns Promise
                             */
                            public getNodes(request: com.hedera.mirror.api.proto.IAddressBookQuery): Promise<hashgraph.proto.NodeAddress>;
                        }

                        namespace NetworkService {

                            /**
                             * Callback as used by {@link com.hedera.mirror.api.proto.NetworkService#getNodes}.
                             * @param error Error, if any
                             * @param [response] NodeAddress
                             */
                            type getNodesCallback = (error: (Error|null), response?: hashgraph.proto.NodeAddress) => void;
                        }
                    }
                }
            }
        }
    }

    /** Namespace hashgraph.proto. */
    namespace proto {

        /** Properties of a TransactionList. */
        interface ITransactionList {

            /** TransactionList transactionList */
            transactionList?: (hashgraph.proto.ITransaction[]|null);
        }

        /**
         * A simple protobuf wrapper to store a list of transactions. This is used by
         * `Transaction.[from|to]Bytes()` in the SDKs. The reason the SDK needs a list of transactions is
         * because it holds onto a transaction per node. So if a transaction is to be submitted to nodes 3
         * and 4 the SDK Transaction type would contain a list of 2 protobuf transactions, one for node 3
         * and one for node 4.
         */
        class TransactionList implements ITransactionList {

            /**
             * Constructs a new TransactionList.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITransactionList);

            /** TransactionList transactionList. */
            public transactionList: hashgraph.proto.ITransaction[];

            /**
             * Creates a new TransactionList instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TransactionList instance
             */
            public static create(properties?: hashgraph.proto.ITransactionList): hashgraph.proto.TransactionList;

            /**
             * Encodes the specified TransactionList message. Does not implicitly {@link hashgraph.proto.TransactionList.verify|verify} messages.
             * @param m TransactionList message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITransactionList, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TransactionList message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TransactionList
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TransactionList;

            /**
             * Gets the default type url for TransactionList
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ShardID. */
        interface IShardID {

            /** the shard number (nonnegative) */
            shardNum?: (Long|null);
        }

        /**
         * Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative
         * realm number (that number might be reused in other shards). And each account, file, and smart
         * contract instance within a given realm has a nonnegative number (which might be reused in other
         * realms).  Every account, file, and smart contract instance is within exactly one realm. So a
         * FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.
         * Each realm maintains a single counter for assigning numbers,  so if there is a file with ID
         * 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.
         *
         * Everything is partitioned into realms so that each Solidity smart contract can  access everything
         * in just a single realm, locking all those entities while it's  running, but other smart contracts
         * could potentially run in other realms in  parallel. So realms allow Solidity to be parallelized
         * somewhat, even though the  language itself assumes everything is serial.
         */
        class ShardID implements IShardID {

            /**
             * Constructs a new ShardID.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IShardID);

            /** the shard number (nonnegative) */
            public shardNum: Long;

            /**
             * Creates a new ShardID instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ShardID instance
             */
            public static create(properties?: hashgraph.proto.IShardID): hashgraph.proto.ShardID;

            /**
             * Encodes the specified ShardID message. Does not implicitly {@link hashgraph.proto.ShardID.verify|verify} messages.
             * @param m ShardID message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IShardID, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ShardID message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ShardID
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ShardID;

            /**
             * Gets the default type url for ShardID
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a RealmID. */
        interface IRealmID {

            /** The shard number (nonnegative) */
            shardNum?: (Long|null);

            /** The realm number (nonnegative) */
            realmNum?: (Long|null);
        }

        /**
         * The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and
         * contract instance belongs to exactly one realm.
         */
        class RealmID implements IRealmID {

            /**
             * Constructs a new RealmID.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IRealmID);

            /** The shard number (nonnegative) */
            public shardNum: Long;

            /** The realm number (nonnegative) */
            public realmNum: Long;

            /**
             * Creates a new RealmID instance using the specified properties.
             * @param [properties] Properties to set
             * @returns RealmID instance
             */
            public static create(properties?: hashgraph.proto.IRealmID): hashgraph.proto.RealmID;

            /**
             * Encodes the specified RealmID message. Does not implicitly {@link hashgraph.proto.RealmID.verify|verify} messages.
             * @param m RealmID message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IRealmID, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a RealmID message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns RealmID
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.RealmID;

            /**
             * Gets the default type url for RealmID
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of an AccountID. */
        interface IAccountID {

            /** The shard number (nonnegative) */
            shardNum?: (Long|null);

            /** The realm number (nonnegative) */
            realmNum?: (Long|null);

            /** A non-negative account number unique within its realm */
            accountNum?: (Long|null);

            /**
             * The public key bytes to be used as the account's alias. The public key bytes are the result of serializing
             * a protobuf Key message for any primitive key type. Currently only primitive key bytes are supported as an alias
             * (ThresholdKey, KeyList, ContractID, and delegatable_contract_id are not supported)
             *
             * May also be the ethereum account 20-byte EVM address to be used initially in place of the public key bytes. This EVM
             * address may be either the encoded form of the shard.realm.num or the keccak-256 hash of a ECDSA_SECP256K1 primitive key.
             *
             * At most one account can ever have a given alias and it is used for account creation if it
             * was automatically created using a crypto transfer. It will be null if an account is created normally.
             * It is immutable once it is set for an account.
             *
             * If a transaction auto-creates the account, any further transfers to that alias will simply be deposited
             * in that account, without creating anything, and with no creation fee being charged.
             *
             * If a transaction lazily-creates this account, a subsequent transaction will be required containing the public key bytes
             * that map to the EVM address bytes. The provided public key bytes will then serve as the final alias bytes.
             */
            alias?: (Uint8Array|null);
        }

        /** The ID for an a cryptocurrency account */
        class AccountID implements IAccountID {

            /**
             * Constructs a new AccountID.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IAccountID);

            /** The shard number (nonnegative) */
            public shardNum: Long;

            /** The realm number (nonnegative) */
            public realmNum: Long;

            /** A non-negative account number unique within its realm */
            public accountNum?: (Long|null);

            /**
             * The public key bytes to be used as the account's alias. The public key bytes are the result of serializing
             * a protobuf Key message for any primitive key type. Currently only primitive key bytes are supported as an alias
             * (ThresholdKey, KeyList, ContractID, and delegatable_contract_id are not supported)
             *
             * May also be the ethereum account 20-byte EVM address to be used initially in place of the public key bytes. This EVM
             * address may be either the encoded form of the shard.realm.num or the keccak-256 hash of a ECDSA_SECP256K1 primitive key.
             *
             * At most one account can ever have a given alias and it is used for account creation if it
             * was automatically created using a crypto transfer. It will be null if an account is created normally.
             * It is immutable once it is set for an account.
             *
             * If a transaction auto-creates the account, any further transfers to that alias will simply be deposited
             * in that account, without creating anything, and with no creation fee being charged.
             *
             * If a transaction lazily-creates this account, a subsequent transaction will be required containing the public key bytes
             * that map to the EVM address bytes. The provided public key bytes will then serve as the final alias bytes.
             */
            public alias?: (Uint8Array|null);

            /**
             * The account number unique within its realm which can be a non-negative integer, an alias public key or an EVM address.
             * For any AccountID fields in the query response, transaction record or transaction receipt only accountNum will
             * be populated.
             */
            public account?: ("accountNum"|"alias");

            /**
             * Creates a new AccountID instance using the specified properties.
             * @param [properties] Properties to set
             * @returns AccountID instance
             */
            public static create(properties?: hashgraph.proto.IAccountID): hashgraph.proto.AccountID;

            /**
             * Encodes the specified AccountID message. Does not implicitly {@link hashgraph.proto.AccountID.verify|verify} messages.
             * @param m AccountID message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IAccountID, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an AccountID message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns AccountID
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.AccountID;

            /**
             * Gets the default type url for AccountID
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a FileID. */
        interface IFileID {

            /** The shard number (nonnegative) */
            shardNum?: (Long|null);

            /** The realm number (nonnegative) */
            realmNum?: (Long|null);

            /** A nonnegative File number unique within its realm */
            fileNum?: (Long|null);
        }

        /** The ID for a file */
        class FileID implements IFileID {

            /**
             * Constructs a new FileID.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IFileID);

            /** The shard number (nonnegative) */
            public shardNum: Long;

            /** The realm number (nonnegative) */
            public realmNum: Long;

            /** A nonnegative File number unique within its realm */
            public fileNum: Long;

            /**
             * Creates a new FileID instance using the specified properties.
             * @param [properties] Properties to set
             * @returns FileID instance
             */
            public static create(properties?: hashgraph.proto.IFileID): hashgraph.proto.FileID;

            /**
             * Encodes the specified FileID message. Does not implicitly {@link hashgraph.proto.FileID.verify|verify} messages.
             * @param m FileID message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IFileID, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a FileID message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns FileID
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.FileID;

            /**
             * Gets the default type url for FileID
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ContractID. */
        interface IContractID {

            /** The shard number (nonnegative) */
            shardNum?: (Long|null);

            /** The realm number (nonnegative) */
            realmNum?: (Long|null);

            /** A nonnegative number unique within a given shard and realm */
            contractNum?: (Long|null);

            /**
             * The 20-byte EVM address of the contract to call.
             *
             * Every contract has an EVM address determined by its <tt>shard.realm.num</tt> id.
             * This address is as follows:
             * <ol>
             * <li>The first 4 bytes are the big-endian representation of the shard.</li>
             * <li>The next 8 bytes are the big-endian representation of the realm.</li>
             * <li>The final 8 bytes are the big-endian representation of the number.</li>
             * </ol>
             *
             * Contracts created via CREATE2 have an <b>additional, primary address</b> that is
             * derived from the <a href="https://eips.ethereum.org/EIPS/eip-1014">EIP-1014</a>
             * specification, and does not have a simple relation to a <tt>shard.realm.num</tt> id.
             *
             * (Please do note that CREATE2 contracts can also be referenced by the three-part
             * EVM address described above.)
             */
            evmAddress?: (Uint8Array|null);
        }

        /** The ID for a smart contract instance */
        class ContractID implements IContractID {

            /**
             * Constructs a new ContractID.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IContractID);

            /** The shard number (nonnegative) */
            public shardNum: Long;

            /** The realm number (nonnegative) */
            public realmNum: Long;

            /** A nonnegative number unique within a given shard and realm */
            public contractNum?: (Long|null);

            /**
             * The 20-byte EVM address of the contract to call.
             *
             * Every contract has an EVM address determined by its <tt>shard.realm.num</tt> id.
             * This address is as follows:
             * <ol>
             * <li>The first 4 bytes are the big-endian representation of the shard.</li>
             * <li>The next 8 bytes are the big-endian representation of the realm.</li>
             * <li>The final 8 bytes are the big-endian representation of the number.</li>
             * </ol>
             *
             * Contracts created via CREATE2 have an <b>additional, primary address</b> that is
             * derived from the <a href="https://eips.ethereum.org/EIPS/eip-1014">EIP-1014</a>
             * specification, and does not have a simple relation to a <tt>shard.realm.num</tt> id.
             *
             * (Please do note that CREATE2 contracts can also be referenced by the three-part
             * EVM address described above.)
             */
            public evmAddress?: (Uint8Array|null);

            /** ContractID contract. */
            public contract?: ("contractNum"|"evmAddress");

            /**
             * Creates a new ContractID instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ContractID instance
             */
            public static create(properties?: hashgraph.proto.IContractID): hashgraph.proto.ContractID;

            /**
             * Encodes the specified ContractID message. Does not implicitly {@link hashgraph.proto.ContractID.verify|verify} messages.
             * @param m ContractID message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IContractID, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ContractID message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ContractID
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ContractID;

            /**
             * Gets the default type url for ContractID
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TransactionID. */
        interface ITransactionID {

            /** The transaction is invalid if consensusTimestamp < transactionID.transactionStartValid */
            transactionValidStart?: (hashgraph.proto.ITimestamp|null);

            /** The Account ID that paid for this transaction */
            accountID?: (hashgraph.proto.IAccountID|null);

            /** Whether the Transaction is of type Scheduled or no */
            scheduled?: (boolean|null);

            /**
             * The identifier for an internal transaction that was spawned as part
             * of handling a user transaction. (These internal transactions share the
             * transactionValidStart and accountID of the user transaction, so a
             * nonce is necessary to give them a unique TransactionID.)
             *
             * An example is when a "parent" ContractCreate or ContractCall transaction
             * calls one or more HTS precompiled contracts; each of the "child"
             * transactions spawned for a precompile has a id with a different nonce.
             */
            nonce?: (number|null);
        }

        /**
         * The ID for a transaction. This is used for retrieving receipts and records for a transaction, for
         * appending to a file right after creating it, for instantiating a smart contract with bytecode in
         * a file just created, and internally by the network for detecting when duplicate transactions are
         * submitted. A user might get a transaction processed faster by submitting it to N nodes, each with
         * a different node account, but all with the same TransactionID. Then, the transaction will take
         * effect when the first of all those nodes submits the transaction and it reaches consensus. The
         * other transactions will not take effect. So this could make the transaction take effect faster,
         * if any given node might be slow. However, the full transaction fee is charged for each
         * transaction, so the total fee is N times as much if the transaction is sent to N nodes.
         *
         * Applicable to Scheduled Transactions:
         * - The ID of a Scheduled Transaction has transactionValidStart and accountIDs inherited from the
         * ScheduleCreate transaction that created it. That is to say that they are equal
         * - The scheduled property is true for Scheduled Transactions
         * - transactionValidStart, accountID and scheduled properties should be omitted
         */
        class TransactionID implements ITransactionID {

            /**
             * Constructs a new TransactionID.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITransactionID);

            /** The transaction is invalid if consensusTimestamp < transactionID.transactionStartValid */
            public transactionValidStart?: (hashgraph.proto.ITimestamp|null);

            /** The Account ID that paid for this transaction */
            public accountID?: (hashgraph.proto.IAccountID|null);

            /** Whether the Transaction is of type Scheduled or no */
            public scheduled: boolean;

            /**
             * The identifier for an internal transaction that was spawned as part
             * of handling a user transaction. (These internal transactions share the
             * transactionValidStart and accountID of the user transaction, so a
             * nonce is necessary to give them a unique TransactionID.)
             *
             * An example is when a "parent" ContractCreate or ContractCall transaction
             * calls one or more HTS precompiled contracts; each of the "child"
             * transactions spawned for a precompile has a id with a different nonce.
             */
            public nonce: number;

            /**
             * Creates a new TransactionID instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TransactionID instance
             */
            public static create(properties?: hashgraph.proto.ITransactionID): hashgraph.proto.TransactionID;

            /**
             * Encodes the specified TransactionID message. Does not implicitly {@link hashgraph.proto.TransactionID.verify|verify} messages.
             * @param m TransactionID message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITransactionID, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TransactionID message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TransactionID
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TransactionID;

            /**
             * Gets the default type url for TransactionID
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of an AccountAmount. */
        interface IAccountAmount {

            /** The Account ID that sends/receives cryptocurrency or tokens */
            accountID?: (hashgraph.proto.IAccountID|null);

            /**
             * The amount of tinybars (for Crypto transfers) or in the lowest
             * denomination (for Token transfers) that the account sends(negative) or
             * receives(positive)
             */
            amount?: (Long|null);

            /**
             * If true then the transfer is expected to be an approved allowance and the
             * accountID is expected to be the owner. The default is false (omitted).
             */
            isApproval?: (boolean|null);
        }

        /** An account, and the amount that it sends or receives during a cryptocurrency or token transfer. */
        class AccountAmount implements IAccountAmount {

            /**
             * Constructs a new AccountAmount.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IAccountAmount);

            /** The Account ID that sends/receives cryptocurrency or tokens */
            public accountID?: (hashgraph.proto.IAccountID|null);

            /**
             * The amount of tinybars (for Crypto transfers) or in the lowest
             * denomination (for Token transfers) that the account sends(negative) or
             * receives(positive)
             */
            public amount: Long;

            /**
             * If true then the transfer is expected to be an approved allowance and the
             * accountID is expected to be the owner. The default is false (omitted).
             */
            public isApproval: boolean;

            /**
             * Creates a new AccountAmount instance using the specified properties.
             * @param [properties] Properties to set
             * @returns AccountAmount instance
             */
            public static create(properties?: hashgraph.proto.IAccountAmount): hashgraph.proto.AccountAmount;

            /**
             * Encodes the specified AccountAmount message. Does not implicitly {@link hashgraph.proto.AccountAmount.verify|verify} messages.
             * @param m AccountAmount message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IAccountAmount, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an AccountAmount message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns AccountAmount
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.AccountAmount;

            /**
             * Gets the default type url for AccountAmount
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TransferList. */
        interface ITransferList {

            /**
             * Multiple list of AccountAmount pairs, each of which has an account and
             * an amount to transfer into it (positive) or out of it (negative)
             */
            accountAmounts?: (hashgraph.proto.IAccountAmount[]|null);
        }

        /** A list of accounts and amounts to transfer out of each account (negative) or into it (positive). */
        class TransferList implements ITransferList {

            /**
             * Constructs a new TransferList.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITransferList);

            /**
             * Multiple list of AccountAmount pairs, each of which has an account and
             * an amount to transfer into it (positive) or out of it (negative)
             */
            public accountAmounts: hashgraph.proto.IAccountAmount[];

            /**
             * Creates a new TransferList instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TransferList instance
             */
            public static create(properties?: hashgraph.proto.ITransferList): hashgraph.proto.TransferList;

            /**
             * Encodes the specified TransferList message. Does not implicitly {@link hashgraph.proto.TransferList.verify|verify} messages.
             * @param m TransferList message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITransferList, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TransferList message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TransferList
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TransferList;

            /**
             * Gets the default type url for TransferList
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a NftTransfer. */
        interface INftTransfer {

            /** The accountID of the sender */
            senderAccountID?: (hashgraph.proto.IAccountID|null);

            /** The accountID of the receiver */
            receiverAccountID?: (hashgraph.proto.IAccountID|null);

            /** The serial number of the NFT */
            serialNumber?: (Long|null);

            /**
             * If true then the transfer is expected to be an approved allowance and the
             * senderAccountID is expected to be the owner. The default is false (omitted).
             */
            isApproval?: (boolean|null);
        }

        /**
         * A sender account, a receiver account, and the serial number of an NFT of a Token with
         * NON_FUNGIBLE_UNIQUE type. When minting NFTs the sender will be the default AccountID instance
         * (0.0.0) and when burning NFTs, the receiver will be the default AccountID instance.
         */
        class NftTransfer implements INftTransfer {

            /**
             * Constructs a new NftTransfer.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.INftTransfer);

            /** The accountID of the sender */
            public senderAccountID?: (hashgraph.proto.IAccountID|null);

            /** The accountID of the receiver */
            public receiverAccountID?: (hashgraph.proto.IAccountID|null);

            /** The serial number of the NFT */
            public serialNumber: Long;

            /**
             * If true then the transfer is expected to be an approved allowance and the
             * senderAccountID is expected to be the owner. The default is false (omitted).
             */
            public isApproval: boolean;

            /**
             * Creates a new NftTransfer instance using the specified properties.
             * @param [properties] Properties to set
             * @returns NftTransfer instance
             */
            public static create(properties?: hashgraph.proto.INftTransfer): hashgraph.proto.NftTransfer;

            /**
             * Encodes the specified NftTransfer message. Does not implicitly {@link hashgraph.proto.NftTransfer.verify|verify} messages.
             * @param m NftTransfer message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.INftTransfer, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a NftTransfer message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns NftTransfer
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.NftTransfer;

            /**
             * Gets the default type url for NftTransfer
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenTransferList. */
        interface ITokenTransferList {

            /** The ID of the token */
            token?: (hashgraph.proto.ITokenID|null);

            /**
             * Applicable to tokens of type FUNGIBLE_COMMON. Multiple list of AccountAmounts, each of which
             * has an account and amount
             */
            transfers?: (hashgraph.proto.IAccountAmount[]|null);

            /**
             * Applicable to tokens of type NON_FUNGIBLE_UNIQUE. Multiple list of NftTransfers, each of
             * which has a sender and receiver account, including the serial number of the NFT
             */
            nftTransfers?: (hashgraph.proto.INftTransfer[]|null);

            /**
             * If present, the number of decimals this fungible token type is expected to have. The transfer
             * will fail with UNEXPECTED_TOKEN_DECIMALS if the actual decimals differ.
             */
            expectedDecimals?: (google.protobuf.IUInt32Value|null);
        }

        /**
         * A list of token IDs and amounts representing the transferred out (negative) or into (positive)
         * amounts, represented in the lowest denomination of the token
         */
        class TokenTransferList implements ITokenTransferList {

            /**
             * Constructs a new TokenTransferList.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenTransferList);

            /** The ID of the token */
            public token?: (hashgraph.proto.ITokenID|null);

            /**
             * Applicable to tokens of type FUNGIBLE_COMMON. Multiple list of AccountAmounts, each of which
             * has an account and amount
             */
            public transfers: hashgraph.proto.IAccountAmount[];

            /**
             * Applicable to tokens of type NON_FUNGIBLE_UNIQUE. Multiple list of NftTransfers, each of
             * which has a sender and receiver account, including the serial number of the NFT
             */
            public nftTransfers: hashgraph.proto.INftTransfer[];

            /**
             * If present, the number of decimals this fungible token type is expected to have. The transfer
             * will fail with UNEXPECTED_TOKEN_DECIMALS if the actual decimals differ.
             */
            public expectedDecimals?: (google.protobuf.IUInt32Value|null);

            /**
             * Creates a new TokenTransferList instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenTransferList instance
             */
            public static create(properties?: hashgraph.proto.ITokenTransferList): hashgraph.proto.TokenTransferList;

            /**
             * Encodes the specified TokenTransferList message. Does not implicitly {@link hashgraph.proto.TokenTransferList.verify|verify} messages.
             * @param m TokenTransferList message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenTransferList, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenTransferList message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenTransferList
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenTransferList;

            /**
             * Gets the default type url for TokenTransferList
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a Fraction. */
        interface IFraction {

            /** The rational's numerator */
            numerator?: (Long|null);

            /** The rational's denominator; a zero value will result in FRACTION_DIVIDES_BY_ZERO */
            denominator?: (Long|null);
        }

        /** A rational number, used to set the amount of a value transfer to collect as a custom fee */
        class Fraction implements IFraction {

            /**
             * Constructs a new Fraction.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IFraction);

            /** The rational's numerator */
            public numerator: Long;

            /** The rational's denominator; a zero value will result in FRACTION_DIVIDES_BY_ZERO */
            public denominator: Long;

            /**
             * Creates a new Fraction instance using the specified properties.
             * @param [properties] Properties to set
             * @returns Fraction instance
             */
            public static create(properties?: hashgraph.proto.IFraction): hashgraph.proto.Fraction;

            /**
             * Encodes the specified Fraction message. Does not implicitly {@link hashgraph.proto.Fraction.verify|verify} messages.
             * @param m Fraction message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IFraction, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a Fraction message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns Fraction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.Fraction;

            /**
             * Gets the default type url for Fraction
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TopicID. */
        interface ITopicID {

            /** The shard number (nonnegative) */
            shardNum?: (Long|null);

            /** The realm number (nonnegative) */
            realmNum?: (Long|null);

            /** Unique topic identifier within a realm (nonnegative). */
            topicNum?: (Long|null);
        }

        /** Unique identifier for a topic (used by the consensus service) */
        class TopicID implements ITopicID {

            /**
             * Constructs a new TopicID.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITopicID);

            /** The shard number (nonnegative) */
            public shardNum: Long;

            /** The realm number (nonnegative) */
            public realmNum: Long;

            /** Unique topic identifier within a realm (nonnegative). */
            public topicNum: Long;

            /**
             * Creates a new TopicID instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TopicID instance
             */
            public static create(properties?: hashgraph.proto.ITopicID): hashgraph.proto.TopicID;

            /**
             * Encodes the specified TopicID message. Does not implicitly {@link hashgraph.proto.TopicID.verify|verify} messages.
             * @param m TopicID message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITopicID, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TopicID message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TopicID
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TopicID;

            /**
             * Gets the default type url for TopicID
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenID. */
        interface ITokenID {

            /** A nonnegative shard number */
            shardNum?: (Long|null);

            /** A nonnegative realm number */
            realmNum?: (Long|null);

            /** A nonnegative token number */
            tokenNum?: (Long|null);
        }

        /** Unique identifier for a token */
        class TokenID implements ITokenID {

            /**
             * Constructs a new TokenID.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenID);

            /** A nonnegative shard number */
            public shardNum: Long;

            /** A nonnegative realm number */
            public realmNum: Long;

            /** A nonnegative token number */
            public tokenNum: Long;

            /**
             * Creates a new TokenID instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenID instance
             */
            public static create(properties?: hashgraph.proto.ITokenID): hashgraph.proto.TokenID;

            /**
             * Encodes the specified TokenID message. Does not implicitly {@link hashgraph.proto.TokenID.verify|verify} messages.
             * @param m TokenID message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenID, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenID message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenID
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenID;

            /**
             * Gets the default type url for TokenID
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ScheduleID. */
        interface IScheduleID {

            /** A nonnegative shard number */
            shardNum?: (Long|null);

            /** A nonnegative realm number */
            realmNum?: (Long|null);

            /** A nonnegative schedule number */
            scheduleNum?: (Long|null);
        }

        /** Unique identifier for a Schedule */
        class ScheduleID implements IScheduleID {

            /**
             * Constructs a new ScheduleID.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IScheduleID);

            /** A nonnegative shard number */
            public shardNum: Long;

            /** A nonnegative realm number */
            public realmNum: Long;

            /** A nonnegative schedule number */
            public scheduleNum: Long;

            /**
             * Creates a new ScheduleID instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ScheduleID instance
             */
            public static create(properties?: hashgraph.proto.IScheduleID): hashgraph.proto.ScheduleID;

            /**
             * Encodes the specified ScheduleID message. Does not implicitly {@link hashgraph.proto.ScheduleID.verify|verify} messages.
             * @param m ScheduleID message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IScheduleID, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ScheduleID message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ScheduleID
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ScheduleID;

            /**
             * Gets the default type url for ScheduleID
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /**
         * Possible Token Types (IWA Compatibility).
         * Apart from fungible and non-fungible, Tokens can have either a common or unique representation.
         * This distinction might seem subtle, but it is important when considering how tokens can be traced
         * and if they can have isolated and unique properties.
         */
        enum TokenType {
            FUNGIBLE_COMMON = 0,
            NON_FUNGIBLE_UNIQUE = 1
        }

        /**
         * Allows a set of resource prices to be scoped to a certain type of a HAPI operation.
         *
         * For example, the resource prices for a TokenMint operation are different between minting fungible
         * and non-fungible tokens. This enum allows us to "mark" a set of prices as applying to one or the
         * other.
         *
         * Similarly, the resource prices for a basic TokenCreate without a custom fee schedule yield a
         * total price of $1. The resource prices for a TokenCreate with a custom fee schedule are different
         * and yield a total base price of $2.
         */
        enum SubType {
            DEFAULT = 0,
            TOKEN_FUNGIBLE_COMMON = 1,
            TOKEN_NON_FUNGIBLE_UNIQUE = 2,
            TOKEN_FUNGIBLE_COMMON_WITH_CUSTOM_FEES = 3,
            TOKEN_NON_FUNGIBLE_UNIQUE_WITH_CUSTOM_FEES = 4,
            SCHEDULE_CREATE_CONTRACT_CALL = 5
        }

        /**
         * Possible Token Supply Types (IWA Compatibility).
         * Indicates how many tokens can have during its lifetime.
         */
        enum TokenSupplyType {
            INFINITE = 0,
            FINITE = 1
        }

        /**
         * Possible Freeze statuses returned on TokenGetInfoQuery or CryptoGetInfoResponse in
         * TokenRelationship
         */
        enum TokenFreezeStatus {
            FreezeNotApplicable = 0,
            Frozen = 1,
            Unfrozen = 2
        }

        /** Possible KYC statuses returned on TokenGetInfoQuery or CryptoGetInfoResponse in TokenRelationship */
        enum TokenKycStatus {
            KycNotApplicable = 0,
            Granted = 1,
            Revoked = 2
        }

        /** Possible Pause statuses returned on TokenGetInfoQuery */
        enum TokenPauseStatus {
            PauseNotApplicable = 0,
            Paused = 1,
            Unpaused = 2
        }

        /** Properties of a Key. */
        interface IKey {

            /** smart contract instance that is authorized as if it had signed with a key */
            contractID?: (hashgraph.proto.IContractID|null);

            /** Ed25519 public key bytes */
            ed25519?: (Uint8Array|null);

            /** (NOT SUPPORTED) RSA-3072 public key bytes */
            RSA_3072?: (Uint8Array|null);

            /** (NOT SUPPORTED) ECDSA with the p-384 curve public key bytes */
            ECDSA_384?: (Uint8Array|null);

            /**
             * a threshold N followed by a list of M keys, any N of which are required to form a valid
             * signature
             */
            thresholdKey?: (hashgraph.proto.IThresholdKey|null);

            /** A list of Keys of the Key type. */
            keyList?: (hashgraph.proto.IKeyList|null);

            /** Compressed ECDSA(secp256k1) public key bytes */
            ECDSASecp256k1?: (Uint8Array|null);

            /**
             * A smart contract that, if the recipient of the active message frame, should be treated
             * as having signed. (Note this does not mean the <i>code being executed in the frame</i>
             * will belong to the given contract, since it could be running another contract's code via
             * <tt>delegatecall</tt>. So setting this key is a more permissive version of setting the
             * contractID key, which also requires the code in the active message frame belong to the
             * the contract with the given id.)
             */
            delegatableContractId?: (hashgraph.proto.IContractID|null);
        }

        /**
         * A Key can be a public key from either the Ed25519 or ECDSA(secp256k1) signature schemes, where
         * in the ECDSA(secp256k1) case we require the 33-byte compressed form of the public key. We call
         * these public keys <b>primitive keys</b>.
         *
         * If an account has primitive key associated to it, then the corresponding private key must sign
         * any transaction to transfer cryptocurrency out of it.
         *
         * A Key can also be the ID of a smart contract instance, which is then authorized to perform any
         * precompiled contract action that requires this key to sign.
         *
         * Note that when a Key is a smart contract ID, it <i>doesn't</i> mean the contract with that ID
         * will actually create a cryptographic signature. It only means that when the contract calls a
         * precompiled contract, the resulting "child transaction" will be authorized to perform any action
         * controlled by the Key.
         *
         * A Key can be a "threshold key", which means a list of M keys, any N of which must sign in order
         * for the threshold signature to be considered valid. The keys within a threshold signature may
         * themselves be threshold signatures, to allow complex signature requirements.
         *
         * A Key can be a "key list" where all keys in the list must sign unless specified otherwise in the
         * documentation for a specific transaction type (e.g.  FileDeleteTransactionBody).  Their use is
         * dependent on context. For example, a Hedera file is created with a list of keys, where all of
         * them must sign a transaction to create or modify the file, but only one of them is needed to sign
         * a transaction to delete the file. So it's a single list that sometimes acts as a 1-of-M threshold
         * key, and sometimes acts as an M-of-M threshold key.  A key list is always an M-of-M, unless
         * specified otherwise in documentation. A key list can have nested key lists or threshold keys.
         * Nested key lists are always M-of-M. A key list can have repeated primitive public keys, but all
         * repeated keys are only required to sign once.
         *
         * A Key can contain a ThresholdKey or KeyList, which in turn contain a Key, so this mutual
         * recursion would allow nesting arbitrarily deep. A ThresholdKey which contains a list of primitive
         * keys has 3 levels: ThresholdKey -> KeyList -> Key. A KeyList which contains several primitive
         * keys has 2 levels: KeyList -> Key. A Key with 2 levels of nested ThresholdKeys has 7 levels:
         * Key -> ThresholdKey -> KeyList -> Key -> ThresholdKey -> KeyList -> Key.
         *
         * Each Key should not have more than 46 levels, which implies 15 levels of nested ThresholdKeys.
         */
        class Key implements IKey {

            /**
             * Constructs a new Key.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IKey);

            /** smart contract instance that is authorized as if it had signed with a key */
            public contractID?: (hashgraph.proto.IContractID|null);

            /** Ed25519 public key bytes */
            public ed25519?: (Uint8Array|null);

            /** (NOT SUPPORTED) RSA-3072 public key bytes */
            public RSA_3072?: (Uint8Array|null);

            /** (NOT SUPPORTED) ECDSA with the p-384 curve public key bytes */
            public ECDSA_384?: (Uint8Array|null);

            /**
             * a threshold N followed by a list of M keys, any N of which are required to form a valid
             * signature
             */
            public thresholdKey?: (hashgraph.proto.IThresholdKey|null);

            /** A list of Keys of the Key type. */
            public keyList?: (hashgraph.proto.IKeyList|null);

            /** Compressed ECDSA(secp256k1) public key bytes */
            public ECDSASecp256k1?: (Uint8Array|null);

            /**
             * A smart contract that, if the recipient of the active message frame, should be treated
             * as having signed. (Note this does not mean the <i>code being executed in the frame</i>
             * will belong to the given contract, since it could be running another contract's code via
             * <tt>delegatecall</tt>. So setting this key is a more permissive version of setting the
             * contractID key, which also requires the code in the active message frame belong to the
             * the contract with the given id.)
             */
            public delegatableContractId?: (hashgraph.proto.IContractID|null);

            /** Key key. */
            public key?: ("contractID"|"ed25519"|"RSA_3072"|"ECDSA_384"|"thresholdKey"|"keyList"|"ECDSASecp256k1"|"delegatableContractId");

            /**
             * Creates a new Key instance using the specified properties.
             * @param [properties] Properties to set
             * @returns Key instance
             */
            public static create(properties?: hashgraph.proto.IKey): hashgraph.proto.Key;

            /**
             * Encodes the specified Key message. Does not implicitly {@link hashgraph.proto.Key.verify|verify} messages.
             * @param m Key message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IKey, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a Key message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns Key
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.Key;

            /**
             * Gets the default type url for Key
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ThresholdKey. */
        interface IThresholdKey {

            /** A valid signature set must have at least this many signatures */
            threshold?: (number|null);

            /** List of all the keys that can sign */
            keys?: (hashgraph.proto.IKeyList|null);
        }

        /**
         * A set of public keys that are used together to form a threshold signature.  If the threshold is N
         * and there are M keys, then this is an N of M threshold signature. If an account is associated
         * with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list
         * of M signatures, where at most M-N of them are blank, and the other at least N of them are valid
         * signatures corresponding to at least N of the public keys listed here.
         */
        class ThresholdKey implements IThresholdKey {

            /**
             * Constructs a new ThresholdKey.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IThresholdKey);

            /** A valid signature set must have at least this many signatures */
            public threshold: number;

            /** List of all the keys that can sign */
            public keys?: (hashgraph.proto.IKeyList|null);

            /**
             * Creates a new ThresholdKey instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ThresholdKey instance
             */
            public static create(properties?: hashgraph.proto.IThresholdKey): hashgraph.proto.ThresholdKey;

            /**
             * Encodes the specified ThresholdKey message. Does not implicitly {@link hashgraph.proto.ThresholdKey.verify|verify} messages.
             * @param m ThresholdKey message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IThresholdKey, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ThresholdKey message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ThresholdKey
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ThresholdKey;

            /**
             * Gets the default type url for ThresholdKey
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a KeyList. */
        interface IKeyList {

            /** list of keys */
            keys?: (hashgraph.proto.IKey[]|null);
        }

        /**
         * A list of keys that requires all keys (M-of-M) to sign unless otherwise specified in
         * documentation. A KeyList may contain repeated keys, but all repeated keys are only required to
         * sign once.
         */
        class KeyList implements IKeyList {

            /**
             * Constructs a new KeyList.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IKeyList);

            /** list of keys */
            public keys: hashgraph.proto.IKey[];

            /**
             * Creates a new KeyList instance using the specified properties.
             * @param [properties] Properties to set
             * @returns KeyList instance
             */
            public static create(properties?: hashgraph.proto.IKeyList): hashgraph.proto.KeyList;

            /**
             * Encodes the specified KeyList message. Does not implicitly {@link hashgraph.proto.KeyList.verify|verify} messages.
             * @param m KeyList message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IKeyList, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a KeyList message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns KeyList
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.KeyList;

            /**
             * Gets the default type url for KeyList
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a Signature. */
        interface ISignature {

            /** smart contract virtual signature (always length zero) */
            contract?: (Uint8Array|null);

            /** ed25519 signature bytes */
            ed25519?: (Uint8Array|null);

            /** RSA-3072 signature bytes */
            RSA_3072?: (Uint8Array|null);

            /** ECDSA p-384 signature bytes */
            ECDSA_384?: (Uint8Array|null);

            /**
             * A list of signatures for a single N-of-M threshold Key. This must be a list of exactly M
             * signatures, at least N of which are non-null.
             */
            thresholdSignature?: (hashgraph.proto.IThresholdSignature|null);

            /** A list of M signatures, each corresponding to a Key in a KeyList of the same length. */
            signatureList?: (hashgraph.proto.ISignatureList|null);
        }

        /**
         * This message is <b>DEPRECATED</b> and <b>UNUSABLE</b> with network nodes. It is retained
         * here only for historical reasons.
         *
         * Please use the SignaturePair and SignatureMap messages.
         */
        class Signature implements ISignature {

            /**
             * Constructs a new Signature.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ISignature);

            /** smart contract virtual signature (always length zero) */
            public contract?: (Uint8Array|null);

            /** ed25519 signature bytes */
            public ed25519?: (Uint8Array|null);

            /** RSA-3072 signature bytes */
            public RSA_3072?: (Uint8Array|null);

            /** ECDSA p-384 signature bytes */
            public ECDSA_384?: (Uint8Array|null);

            /**
             * A list of signatures for a single N-of-M threshold Key. This must be a list of exactly M
             * signatures, at least N of which are non-null.
             */
            public thresholdSignature?: (hashgraph.proto.IThresholdSignature|null);

            /** A list of M signatures, each corresponding to a Key in a KeyList of the same length. */
            public signatureList?: (hashgraph.proto.ISignatureList|null);

            /** Signature signature. */
            public signature?: ("contract"|"ed25519"|"RSA_3072"|"ECDSA_384"|"thresholdSignature"|"signatureList");

            /**
             * Creates a new Signature instance using the specified properties.
             * @param [properties] Properties to set
             * @returns Signature instance
             */
            public static create(properties?: hashgraph.proto.ISignature): hashgraph.proto.Signature;

            /**
             * Encodes the specified Signature message. Does not implicitly {@link hashgraph.proto.Signature.verify|verify} messages.
             * @param m Signature message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ISignature, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a Signature message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns Signature
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.Signature;

            /**
             * Gets the default type url for Signature
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ThresholdSignature. */
        interface IThresholdSignature {

            /**
             * for an N-of-M threshold key, this is a list of M signatures, at least N of which must be
             * non-null
             */
            sigs?: (hashgraph.proto.ISignatureList|null);
        }

        /**
         * This message is <b>DEPRECATED</b> and <b>UNUSABLE</b> with network nodes. It is retained
         * here only for historical reasons.
         *
         * Please use the SignaturePair and SignatureMap messages.
         */
        class ThresholdSignature implements IThresholdSignature {

            /**
             * Constructs a new ThresholdSignature.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IThresholdSignature);

            /**
             * for an N-of-M threshold key, this is a list of M signatures, at least N of which must be
             * non-null
             */
            public sigs?: (hashgraph.proto.ISignatureList|null);

            /**
             * Creates a new ThresholdSignature instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ThresholdSignature instance
             */
            public static create(properties?: hashgraph.proto.IThresholdSignature): hashgraph.proto.ThresholdSignature;

            /**
             * Encodes the specified ThresholdSignature message. Does not implicitly {@link hashgraph.proto.ThresholdSignature.verify|verify} messages.
             * @param m ThresholdSignature message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IThresholdSignature, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ThresholdSignature message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ThresholdSignature
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ThresholdSignature;

            /**
             * Gets the default type url for ThresholdSignature
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a SignatureList. */
        interface ISignatureList {

            /** each signature corresponds to a Key in the KeyList */
            sigs?: (hashgraph.proto.ISignature[]|null);
        }

        /**
         * This message is <b>DEPRECATED</b> and <b>UNUSABLE</b> with network nodes. It is retained
         * here only for historical reasons.
         *
         * Please use the SignaturePair and SignatureMap messages.
         */
        class SignatureList implements ISignatureList {

            /**
             * Constructs a new SignatureList.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ISignatureList);

            /** each signature corresponds to a Key in the KeyList */
            public sigs: hashgraph.proto.ISignature[];

            /**
             * Creates a new SignatureList instance using the specified properties.
             * @param [properties] Properties to set
             * @returns SignatureList instance
             */
            public static create(properties?: hashgraph.proto.ISignatureList): hashgraph.proto.SignatureList;

            /**
             * Encodes the specified SignatureList message. Does not implicitly {@link hashgraph.proto.SignatureList.verify|verify} messages.
             * @param m SignatureList message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ISignatureList, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a SignatureList message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns SignatureList
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.SignatureList;

            /**
             * Gets the default type url for SignatureList
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a SignaturePair. */
        interface ISignaturePair {

            /** First few bytes of the public key */
            pubKeyPrefix?: (Uint8Array|null);

            /** smart contract virtual signature (always length zero) */
            contract?: (Uint8Array|null);

            /** ed25519 signature */
            ed25519?: (Uint8Array|null);

            /** RSA-3072 signature */
            RSA_3072?: (Uint8Array|null);

            /** ECDSA p-384 signature */
            ECDSA_384?: (Uint8Array|null);

            /** ECDSA(secp256k1) signature */
            ECDSASecp256k1?: (Uint8Array|null);
        }

        /**
         * The client may use any number of bytes from zero to the whole length of the public key for
         * pubKeyPrefix. If zero bytes are used, then it must be that only one primitive key is required
         * to sign the linked transaction; it will surely resolve to <tt>INVALID_SIGNATURE</tt> otherwise.
         *
         * <b>IMPORTANT:</b> In the special case that a signature is being provided for a key used to
         * authorize a precompiled contract, the <tt>pubKeyPrefix</tt> must contain the <b>entire public
         * key</b>! That is, if the key is a Ed25519 key, the <tt>pubKeyPrefix</tt> should be 32 bytes
         * long. If the key is a ECDSA(secp256k1) key, the <tt>pubKeyPrefix</tt> should be 33 bytes long,
         * since we require the compressed form of the public key.
         *
         * Only Ed25519 and ECDSA(secp256k1) keys and hence signatures are currently supported.
         */
        class SignaturePair implements ISignaturePair {

            /**
             * Constructs a new SignaturePair.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ISignaturePair);

            /** First few bytes of the public key */
            public pubKeyPrefix: Uint8Array;

            /** smart contract virtual signature (always length zero) */
            public contract?: (Uint8Array|null);

            /** ed25519 signature */
            public ed25519?: (Uint8Array|null);

            /** RSA-3072 signature */
            public RSA_3072?: (Uint8Array|null);

            /** ECDSA p-384 signature */
            public ECDSA_384?: (Uint8Array|null);

            /** ECDSA(secp256k1) signature */
            public ECDSASecp256k1?: (Uint8Array|null);

            /** SignaturePair signature. */
            public signature?: ("contract"|"ed25519"|"RSA_3072"|"ECDSA_384"|"ECDSASecp256k1");

            /**
             * Creates a new SignaturePair instance using the specified properties.
             * @param [properties] Properties to set
             * @returns SignaturePair instance
             */
            public static create(properties?: hashgraph.proto.ISignaturePair): hashgraph.proto.SignaturePair;

            /**
             * Encodes the specified SignaturePair message. Does not implicitly {@link hashgraph.proto.SignaturePair.verify|verify} messages.
             * @param m SignaturePair message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ISignaturePair, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a SignaturePair message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns SignaturePair
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.SignaturePair;

            /**
             * Gets the default type url for SignaturePair
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a SignatureMap. */
        interface ISignatureMap {

            /** Each signature pair corresponds to a unique Key required to sign the transaction. */
            sigPair?: (hashgraph.proto.ISignaturePair[]|null);
        }

        /**
         * A set of signatures corresponding to every unique public key used to sign a given transaction. If
         * one public key matches more than one prefixes on the signature map, the transaction containing
         * the map will fail immediately with the response code KEY_PREFIX_MISMATCH.
         */
        class SignatureMap implements ISignatureMap {

            /**
             * Constructs a new SignatureMap.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ISignatureMap);

            /** Each signature pair corresponds to a unique Key required to sign the transaction. */
            public sigPair: hashgraph.proto.ISignaturePair[];

            /**
             * Creates a new SignatureMap instance using the specified properties.
             * @param [properties] Properties to set
             * @returns SignatureMap instance
             */
            public static create(properties?: hashgraph.proto.ISignatureMap): hashgraph.proto.SignatureMap;

            /**
             * Encodes the specified SignatureMap message. Does not implicitly {@link hashgraph.proto.SignatureMap.verify|verify} messages.
             * @param m SignatureMap message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ISignatureMap, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a SignatureMap message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns SignatureMap
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.SignatureMap;

            /**
             * Gets the default type url for SignatureMap
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** The transactions and queries supported by Hedera Hashgraph. */
        enum HederaFunctionality {
            NONE = 0,
            CryptoTransfer = 1,
            CryptoUpdate = 2,
            CryptoDelete = 3,
            CryptoAddLiveHash = 4,
            CryptoDeleteLiveHash = 5,
            ContractCall = 6,
            ContractCreate = 7,
            ContractUpdate = 8,
            FileCreate = 9,
            FileAppend = 10,
            FileUpdate = 11,
            FileDelete = 12,
            CryptoGetAccountBalance = 13,
            CryptoGetAccountRecords = 14,
            CryptoGetInfo = 15,
            ContractCallLocal = 16,
            ContractGetInfo = 17,
            ContractGetBytecode = 18,
            GetBySolidityID = 19,
            GetByKey = 20,
            CryptoGetLiveHash = 21,
            CryptoGetStakers = 22,
            FileGetContents = 23,
            FileGetInfo = 24,
            TransactionGetRecord = 25,
            ContractGetRecords = 26,
            CryptoCreate = 27,
            SystemDelete = 28,
            SystemUndelete = 29,
            ContractDelete = 30,
            Freeze = 31,
            CreateTransactionRecord = 32,
            CryptoAccountAutoRenew = 33,
            ContractAutoRenew = 34,
            GetVersionInfo = 35,
            TransactionGetReceipt = 36,
            ConsensusCreateTopic = 50,
            ConsensusUpdateTopic = 51,
            ConsensusDeleteTopic = 52,
            ConsensusGetTopicInfo = 53,
            ConsensusSubmitMessage = 54,
            UncheckedSubmit = 55,
            TokenCreate = 56,
            TokenGetInfo = 58,
            TokenFreezeAccount = 59,
            TokenUnfreezeAccount = 60,
            TokenGrantKycToAccount = 61,
            TokenRevokeKycFromAccount = 62,
            TokenDelete = 63,
            TokenUpdate = 64,
            TokenMint = 65,
            TokenBurn = 66,
            TokenAccountWipe = 67,
            TokenAssociateToAccount = 68,
            TokenDissociateFromAccount = 69,
            ScheduleCreate = 70,
            ScheduleDelete = 71,
            ScheduleSign = 72,
            ScheduleGetInfo = 73,
            TokenGetAccountNftInfos = 74,
            TokenGetNftInfo = 75,
            TokenGetNftInfos = 76,
            TokenFeeScheduleUpdate = 77,
            NetworkGetExecutionTime = 78,
            TokenPause = 79,
            TokenUnpause = 80,
            CryptoApproveAllowance = 81,
            CryptoDeleteAllowance = 82,
            GetAccountDetails = 83,
            EthereumTransaction = 84,
            NodeStakeUpdate = 85,
            UtilPrng = 86
        }

        /** Properties of a FeeComponents. */
        interface IFeeComponents {

            /** A minimum, the calculated fee must be greater than this value */
            min?: (Long|null);

            /** A maximum, the calculated fee must be less than this value */
            max?: (Long|null);

            /** A constant contribution to the fee */
            constant?: (Long|null);

            /** The price of bandwidth consumed by a transaction, measured in bytes */
            bpt?: (Long|null);

            /** The price per signature verification for a transaction */
            vpt?: (Long|null);

            /** The price of RAM consumed by a transaction, measured in byte-hours */
            rbh?: (Long|null);

            /** The price of storage consumed by a transaction, measured in byte-hours */
            sbh?: (Long|null);

            /** The price of computation for a smart contract transaction, measured in gas */
            gas?: (Long|null);

            /** The price per hbar transferred for a transfer */
            tv?: (Long|null);

            /** The price of bandwidth for data retrieved from memory for a response, measured in bytes */
            bpr?: (Long|null);

            /** The price of bandwidth for data retrieved from disk for a response, measured in bytes */
            sbpr?: (Long|null);
        }

        /**
         * A set of prices the nodes use in determining transaction and query fees, and constants involved
         * in fee calculations.  Nodes multiply the amount of resources consumed by a transaction or query
         * by the corresponding price to calculate the appropriate fee. Units are one-thousandth of a
         * tinyCent.
         */
        class FeeComponents implements IFeeComponents {

            /**
             * Constructs a new FeeComponents.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IFeeComponents);

            /** A minimum, the calculated fee must be greater than this value */
            public min: Long;

            /** A maximum, the calculated fee must be less than this value */
            public max: Long;

            /** A constant contribution to the fee */
            public constant: Long;

            /** The price of bandwidth consumed by a transaction, measured in bytes */
            public bpt: Long;

            /** The price per signature verification for a transaction */
            public vpt: Long;

            /** The price of RAM consumed by a transaction, measured in byte-hours */
            public rbh: Long;

            /** The price of storage consumed by a transaction, measured in byte-hours */
            public sbh: Long;

            /** The price of computation for a smart contract transaction, measured in gas */
            public gas: Long;

            /** The price per hbar transferred for a transfer */
            public tv: Long;

            /** The price of bandwidth for data retrieved from memory for a response, measured in bytes */
            public bpr: Long;

            /** The price of bandwidth for data retrieved from disk for a response, measured in bytes */
            public sbpr: Long;

            /**
             * Creates a new FeeComponents instance using the specified properties.
             * @param [properties] Properties to set
             * @returns FeeComponents instance
             */
            public static create(properties?: hashgraph.proto.IFeeComponents): hashgraph.proto.FeeComponents;

            /**
             * Encodes the specified FeeComponents message. Does not implicitly {@link hashgraph.proto.FeeComponents.verify|verify} messages.
             * @param m FeeComponents message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IFeeComponents, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a FeeComponents message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns FeeComponents
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.FeeComponents;

            /**
             * Gets the default type url for FeeComponents
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TransactionFeeSchedule. */
        interface ITransactionFeeSchedule {

            /** A particular transaction or query */
            hederaFunctionality?: (hashgraph.proto.HederaFunctionality|null);

            /** Resource price coefficients */
            feeData?: (hashgraph.proto.IFeeData|null);

            /** Resource price coefficients. Supports subtype price definition. */
            fees?: (hashgraph.proto.IFeeData[]|null);
        }

        /** The fees for a specific transaction or query based on the fee data. */
        class TransactionFeeSchedule implements ITransactionFeeSchedule {

            /**
             * Constructs a new TransactionFeeSchedule.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITransactionFeeSchedule);

            /** A particular transaction or query */
            public hederaFunctionality: hashgraph.proto.HederaFunctionality;

            /** Resource price coefficients */
            public feeData?: (hashgraph.proto.IFeeData|null);

            /** Resource price coefficients. Supports subtype price definition. */
            public fees: hashgraph.proto.IFeeData[];

            /**
             * Creates a new TransactionFeeSchedule instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TransactionFeeSchedule instance
             */
            public static create(properties?: hashgraph.proto.ITransactionFeeSchedule): hashgraph.proto.TransactionFeeSchedule;

            /**
             * Encodes the specified TransactionFeeSchedule message. Does not implicitly {@link hashgraph.proto.TransactionFeeSchedule.verify|verify} messages.
             * @param m TransactionFeeSchedule message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITransactionFeeSchedule, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TransactionFeeSchedule message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TransactionFeeSchedule
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TransactionFeeSchedule;

            /**
             * Gets the default type url for TransactionFeeSchedule
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a FeeData. */
        interface IFeeData {

            /** Fee paid to the submitting node */
            nodedata?: (hashgraph.proto.IFeeComponents|null);

            /** Fee paid to the network for processing a transaction into consensus */
            networkdata?: (hashgraph.proto.IFeeComponents|null);

            /**
             * Fee paid to the network for providing the service associated with the
             * transaction; for instance, storing a file
             */
            servicedata?: (hashgraph.proto.IFeeComponents|null);

            /**
             * SubType distinguishing between different types of FeeData, correlating
             * to the same HederaFunctionality
             */
            subType?: (hashgraph.proto.SubType|null);
        }

        /**
         * The total fee charged for a transaction. It is composed of three components – a node fee that
         * compensates the specific node that submitted the transaction, a network fee that compensates the
         * network for assigning the transaction a consensus timestamp, and a service fee that compensates
         * the network for the ongoing maintenance of the consequences of the transaction.
         */
        class FeeData implements IFeeData {

            /**
             * Constructs a new FeeData.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IFeeData);

            /** Fee paid to the submitting node */
            public nodedata?: (hashgraph.proto.IFeeComponents|null);

            /** Fee paid to the network for processing a transaction into consensus */
            public networkdata?: (hashgraph.proto.IFeeComponents|null);

            /**
             * Fee paid to the network for providing the service associated with the
             * transaction; for instance, storing a file
             */
            public servicedata?: (hashgraph.proto.IFeeComponents|null);

            /**
             * SubType distinguishing between different types of FeeData, correlating
             * to the same HederaFunctionality
             */
            public subType: hashgraph.proto.SubType;

            /**
             * Creates a new FeeData instance using the specified properties.
             * @param [properties] Properties to set
             * @returns FeeData instance
             */
            public static create(properties?: hashgraph.proto.IFeeData): hashgraph.proto.FeeData;

            /**
             * Encodes the specified FeeData message. Does not implicitly {@link hashgraph.proto.FeeData.verify|verify} messages.
             * @param m FeeData message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IFeeData, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a FeeData message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns FeeData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.FeeData;

            /**
             * Gets the default type url for FeeData
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a FeeSchedule. */
        interface IFeeSchedule {

            /** List of price coefficients for network resources */
            transactionFeeSchedule?: (hashgraph.proto.ITransactionFeeSchedule[]|null);

            /** FeeSchedule expiry time */
            expiryTime?: (hashgraph.proto.ITimestampSeconds|null);
        }

        /**
         * A list of resource prices fee for different transactions and queries and the time period at which
         * this fee schedule will expire. Nodes use the prices to determine the fees for all transactions
         * based on how much of those resources each transaction uses.
         */
        class FeeSchedule implements IFeeSchedule {

            /**
             * Constructs a new FeeSchedule.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IFeeSchedule);

            /** List of price coefficients for network resources */
            public transactionFeeSchedule: hashgraph.proto.ITransactionFeeSchedule[];

            /** FeeSchedule expiry time */
            public expiryTime?: (hashgraph.proto.ITimestampSeconds|null);

            /**
             * Creates a new FeeSchedule instance using the specified properties.
             * @param [properties] Properties to set
             * @returns FeeSchedule instance
             */
            public static create(properties?: hashgraph.proto.IFeeSchedule): hashgraph.proto.FeeSchedule;

            /**
             * Encodes the specified FeeSchedule message. Does not implicitly {@link hashgraph.proto.FeeSchedule.verify|verify} messages.
             * @param m FeeSchedule message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IFeeSchedule, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a FeeSchedule message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns FeeSchedule
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.FeeSchedule;

            /**
             * Gets the default type url for FeeSchedule
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a CurrentAndNextFeeSchedule. */
        interface ICurrentAndNextFeeSchedule {

            /** Contains current Fee Schedule */
            currentFeeSchedule?: (hashgraph.proto.IFeeSchedule|null);

            /** Contains next Fee Schedule */
            nextFeeSchedule?: (hashgraph.proto.IFeeSchedule|null);
        }

        /** This contains two Fee Schedules with expiry timestamp. */
        class CurrentAndNextFeeSchedule implements ICurrentAndNextFeeSchedule {

            /**
             * Constructs a new CurrentAndNextFeeSchedule.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ICurrentAndNextFeeSchedule);

            /** Contains current Fee Schedule */
            public currentFeeSchedule?: (hashgraph.proto.IFeeSchedule|null);

            /** Contains next Fee Schedule */
            public nextFeeSchedule?: (hashgraph.proto.IFeeSchedule|null);

            /**
             * Creates a new CurrentAndNextFeeSchedule instance using the specified properties.
             * @param [properties] Properties to set
             * @returns CurrentAndNextFeeSchedule instance
             */
            public static create(properties?: hashgraph.proto.ICurrentAndNextFeeSchedule): hashgraph.proto.CurrentAndNextFeeSchedule;

            /**
             * Encodes the specified CurrentAndNextFeeSchedule message. Does not implicitly {@link hashgraph.proto.CurrentAndNextFeeSchedule.verify|verify} messages.
             * @param m CurrentAndNextFeeSchedule message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ICurrentAndNextFeeSchedule, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a CurrentAndNextFeeSchedule message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns CurrentAndNextFeeSchedule
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.CurrentAndNextFeeSchedule;

            /**
             * Gets the default type url for CurrentAndNextFeeSchedule
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ServiceEndpoint. */
        interface IServiceEndpoint {

            /**
             * The 32-bit IPv4 address of the node encoded in left to right order (e.g.  127.0.0.1 has 127
             * as its first byte)
             */
            ipAddressV4?: (Uint8Array|null);

            /** The port of the node */
            port?: (number|null);
        }

        /**
         * Contains the IP address and the port representing a service endpoint of a Node in a network. Used
         * to reach the Hedera API and submit transactions to the network.
         */
        class ServiceEndpoint implements IServiceEndpoint {

            /**
             * Constructs a new ServiceEndpoint.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IServiceEndpoint);

            /**
             * The 32-bit IPv4 address of the node encoded in left to right order (e.g.  127.0.0.1 has 127
             * as its first byte)
             */
            public ipAddressV4: Uint8Array;

            /** The port of the node */
            public port: number;

            /**
             * Creates a new ServiceEndpoint instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ServiceEndpoint instance
             */
            public static create(properties?: hashgraph.proto.IServiceEndpoint): hashgraph.proto.ServiceEndpoint;

            /**
             * Encodes the specified ServiceEndpoint message. Does not implicitly {@link hashgraph.proto.ServiceEndpoint.verify|verify} messages.
             * @param m ServiceEndpoint message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IServiceEndpoint, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ServiceEndpoint message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ServiceEndpoint
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ServiceEndpoint;

            /**
             * Gets the default type url for ServiceEndpoint
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a NodeAddress. */
        interface INodeAddress {

            /**
             * The IP address of the Node with separator & octets encoded in UTF-8.  Usage is deprecated,
             * ServiceEndpoint is preferred to retrieve a node's list of IP addresses and ports
             */
            ipAddress?: (Uint8Array|null);

            /**
             * The port number of the grpc server for the node.  Usage is deprecated, ServiceEndpoint is
             * preferred to retrieve a node's list of IP addresses and ports
             */
            portno?: (number|null);

            /** Usage is deprecated, nodeAccountId is preferred to retrieve a node's account ID */
            memo?: (Uint8Array|null);

            /**
             * The node's X509 RSA public key used to sign stream files (e.g., record stream
             * files). Precisely, this field is a string of hexadecimal characters which,
             * translated to binary, are the public key's DER encoding.
             */
            RSA_PubKey?: (string|null);

            /** # A non-sequential identifier for the node */
            nodeId?: (Long|null);

            /** # The account to be paid for queries and transactions sent to this node */
            nodeAccountId?: (hashgraph.proto.IAccountID|null);

            /**
             * # Hash of the node's TLS certificate. Precisely, this field is a string of
             * hexadecimal characters which, translated to binary, are the SHA-384 hash of
             * the UTF-8 NFKD encoding of the node's TLS cert in PEM format. Its value can be
             * used to verify the node's certificate it presents during TLS negotiations.
             */
            nodeCertHash?: (Uint8Array|null);

            /** # A node's service IP addresses and ports */
            serviceEndpoint?: (hashgraph.proto.IServiceEndpoint[]|null);

            /** A description of the node, with UTF-8 encoding up to 100 bytes */
            description?: (string|null);

            /** [Deprecated] The amount of tinybars staked to the node */
            stake?: (Long|null);
        }

        /**
         * The data about a node, including its service endpoints and the Hedera account to be paid for
         * services provided by the node (that is, queries answered and transactions submitted.)
         *
         * If the <tt>serviceEndpoint</tt> list is not set, or empty, then the endpoint given by the
         * (deprecated) <tt>ipAddress</tt> and <tt>portno</tt> fields should be used.
         *
         * All fields are populated in the 0.0.102 address book file while only fields that start with # are
         * populated in the 0.0.101 address book file.
         */
        class NodeAddress implements INodeAddress {

            /**
             * Constructs a new NodeAddress.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.INodeAddress);

            /**
             * The IP address of the Node with separator & octets encoded in UTF-8.  Usage is deprecated,
             * ServiceEndpoint is preferred to retrieve a node's list of IP addresses and ports
             */
            public ipAddress: Uint8Array;

            /**
             * The port number of the grpc server for the node.  Usage is deprecated, ServiceEndpoint is
             * preferred to retrieve a node's list of IP addresses and ports
             */
            public portno: number;

            /** Usage is deprecated, nodeAccountId is preferred to retrieve a node's account ID */
            public memo: Uint8Array;

            /**
             * The node's X509 RSA public key used to sign stream files (e.g., record stream
             * files). Precisely, this field is a string of hexadecimal characters which,
             * translated to binary, are the public key's DER encoding.
             */
            public RSA_PubKey: string;

            /** # A non-sequential identifier for the node */
            public nodeId: Long;

            /** # The account to be paid for queries and transactions sent to this node */
            public nodeAccountId?: (hashgraph.proto.IAccountID|null);

            /**
             * # Hash of the node's TLS certificate. Precisely, this field is a string of
             * hexadecimal characters which, translated to binary, are the SHA-384 hash of
             * the UTF-8 NFKD encoding of the node's TLS cert in PEM format. Its value can be
             * used to verify the node's certificate it presents during TLS negotiations.
             */
            public nodeCertHash: Uint8Array;

            /** # A node's service IP addresses and ports */
            public serviceEndpoint: hashgraph.proto.IServiceEndpoint[];

            /** A description of the node, with UTF-8 encoding up to 100 bytes */
            public description: string;

            /** [Deprecated] The amount of tinybars staked to the node */
            public stake: Long;

            /**
             * Creates a new NodeAddress instance using the specified properties.
             * @param [properties] Properties to set
             * @returns NodeAddress instance
             */
            public static create(properties?: hashgraph.proto.INodeAddress): hashgraph.proto.NodeAddress;

            /**
             * Encodes the specified NodeAddress message. Does not implicitly {@link hashgraph.proto.NodeAddress.verify|verify} messages.
             * @param m NodeAddress message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.INodeAddress, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a NodeAddress message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns NodeAddress
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.NodeAddress;

            /**
             * Gets the default type url for NodeAddress
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a NodeAddressBook. */
        interface INodeAddressBook {

            /** Metadata of all nodes in the network */
            nodeAddress?: (hashgraph.proto.INodeAddress[]|null);
        }

        /**
         * A list of nodes and their metadata that contains all details of the nodes for the network.  Used
         * to parse the contents of system files <tt>0.0.101</tt> and <tt>0.0.102</tt>.
         */
        class NodeAddressBook implements INodeAddressBook {

            /**
             * Constructs a new NodeAddressBook.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.INodeAddressBook);

            /** Metadata of all nodes in the network */
            public nodeAddress: hashgraph.proto.INodeAddress[];

            /**
             * Creates a new NodeAddressBook instance using the specified properties.
             * @param [properties] Properties to set
             * @returns NodeAddressBook instance
             */
            public static create(properties?: hashgraph.proto.INodeAddressBook): hashgraph.proto.NodeAddressBook;

            /**
             * Encodes the specified NodeAddressBook message. Does not implicitly {@link hashgraph.proto.NodeAddressBook.verify|verify} messages.
             * @param m NodeAddressBook message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.INodeAddressBook, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a NodeAddressBook message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns NodeAddressBook
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.NodeAddressBook;

            /**
             * Gets the default type url for NodeAddressBook
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a SemanticVersion. */
        interface ISemanticVersion {

            /** Increases with incompatible API changes */
            major?: (number|null);

            /** Increases with backwards-compatible new functionality */
            minor?: (number|null);

            /** Increases with backwards-compatible bug fixes */
            patch?: (number|null);

            /**
             * A pre-release version MAY be denoted by appending a hyphen and a series of dot separated
             * identifiers (https://semver.org/#spec-item-9); so given a semver 0.14.0-alpha.1+21AF26D3,
             * this field would contain 'alpha.1'
             */
            pre?: (string|null);

            /**
             * Build metadata MAY be denoted by appending a plus sign and a series of dot separated
             * identifiers immediately following the patch or pre-release version
             * (https://semver.org/#spec-item-10); so given a semver 0.14.0-alpha.1+21AF26D3, this field
             * would contain '21AF26D3'
             */
            build?: (string|null);
        }

        /**
         * Hedera follows semantic versioning (https://semver.org/) for both the HAPI protobufs and the
         * Services software.  This type allows the <tt>getVersionInfo</tt> query in the
         * <tt>NetworkService</tt> to return the deployed versions of both protobufs and software on the
         * node answering the query.
         */
        class SemanticVersion implements ISemanticVersion {

            /**
             * Constructs a new SemanticVersion.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ISemanticVersion);

            /** Increases with incompatible API changes */
            public major: number;

            /** Increases with backwards-compatible new functionality */
            public minor: number;

            /** Increases with backwards-compatible bug fixes */
            public patch: number;

            /**
             * A pre-release version MAY be denoted by appending a hyphen and a series of dot separated
             * identifiers (https://semver.org/#spec-item-9); so given a semver 0.14.0-alpha.1+21AF26D3,
             * this field would contain 'alpha.1'
             */
            public pre: string;

            /**
             * Build metadata MAY be denoted by appending a plus sign and a series of dot separated
             * identifiers immediately following the patch or pre-release version
             * (https://semver.org/#spec-item-10); so given a semver 0.14.0-alpha.1+21AF26D3, this field
             * would contain '21AF26D3'
             */
            public build: string;

            /**
             * Creates a new SemanticVersion instance using the specified properties.
             * @param [properties] Properties to set
             * @returns SemanticVersion instance
             */
            public static create(properties?: hashgraph.proto.ISemanticVersion): hashgraph.proto.SemanticVersion;

            /**
             * Encodes the specified SemanticVersion message. Does not implicitly {@link hashgraph.proto.SemanticVersion.verify|verify} messages.
             * @param m SemanticVersion message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ISemanticVersion, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a SemanticVersion message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns SemanticVersion
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.SemanticVersion;

            /**
             * Gets the default type url for SemanticVersion
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a Setting. */
        interface ISetting {

            /** name of the property */
            name?: (string|null);

            /** value of the property */
            value?: (string|null);

            /** any data associated with property */
            data?: (Uint8Array|null);
        }

        /** UNDOCUMENTED */
        class Setting implements ISetting {

            /**
             * Constructs a new Setting.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ISetting);

            /** name of the property */
            public name: string;

            /** value of the property */
            public value: string;

            /** any data associated with property */
            public data: Uint8Array;

            /**
             * Creates a new Setting instance using the specified properties.
             * @param [properties] Properties to set
             * @returns Setting instance
             */
            public static create(properties?: hashgraph.proto.ISetting): hashgraph.proto.Setting;

            /**
             * Encodes the specified Setting message. Does not implicitly {@link hashgraph.proto.Setting.verify|verify} messages.
             * @param m Setting message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ISetting, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a Setting message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns Setting
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.Setting;

            /**
             * Gets the default type url for Setting
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ServicesConfigurationList. */
        interface IServicesConfigurationList {

            /** list of name value pairs of the application properties */
            nameValue?: (hashgraph.proto.ISetting[]|null);
        }

        /** UNDOCUMENTED */
        class ServicesConfigurationList implements IServicesConfigurationList {

            /**
             * Constructs a new ServicesConfigurationList.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IServicesConfigurationList);

            /** list of name value pairs of the application properties */
            public nameValue: hashgraph.proto.ISetting[];

            /**
             * Creates a new ServicesConfigurationList instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ServicesConfigurationList instance
             */
            public static create(properties?: hashgraph.proto.IServicesConfigurationList): hashgraph.proto.ServicesConfigurationList;

            /**
             * Encodes the specified ServicesConfigurationList message. Does not implicitly {@link hashgraph.proto.ServicesConfigurationList.verify|verify} messages.
             * @param m ServicesConfigurationList message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IServicesConfigurationList, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ServicesConfigurationList message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ServicesConfigurationList
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ServicesConfigurationList;

            /**
             * Gets the default type url for ServicesConfigurationList
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenRelationship. */
        interface ITokenRelationship {

            /** The ID of the token */
            tokenId?: (hashgraph.proto.ITokenID|null);

            /** The Symbol of the token */
            symbol?: (string|null);

            /**
             * For token of type FUNGIBLE_COMMON - the balance that the Account holds in the smallest
             * denomination. For token of type NON_FUNGIBLE_UNIQUE - the number of NFTs held by the account
             */
            balance?: (Long|null);

            /**
             * The KYC status of the account (KycNotApplicable, Granted or Revoked). If the token does not
             * have KYC key, KycNotApplicable is returned
             */
            kycStatus?: (hashgraph.proto.TokenKycStatus|null);

            /**
             * The Freeze status of the account (FreezeNotApplicable, Frozen or Unfrozen). If the token does
             * not have Freeze key, FreezeNotApplicable is returned
             */
            freezeStatus?: (hashgraph.proto.TokenFreezeStatus|null);

            /** Tokens divide into <tt>10<sup>decimals</sup></tt> pieces */
            decimals?: (number|null);

            /**
             * Specifies if the relationship is created implicitly. False : explicitly associated, True :
             * implicitly associated.
             */
            automaticAssociation?: (boolean|null);
        }

        /** Token's information related to the given Account */
        class TokenRelationship implements ITokenRelationship {

            /**
             * Constructs a new TokenRelationship.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenRelationship);

            /** The ID of the token */
            public tokenId?: (hashgraph.proto.ITokenID|null);

            /** The Symbol of the token */
            public symbol: string;

            /**
             * For token of type FUNGIBLE_COMMON - the balance that the Account holds in the smallest
             * denomination. For token of type NON_FUNGIBLE_UNIQUE - the number of NFTs held by the account
             */
            public balance: Long;

            /**
             * The KYC status of the account (KycNotApplicable, Granted or Revoked). If the token does not
             * have KYC key, KycNotApplicable is returned
             */
            public kycStatus: hashgraph.proto.TokenKycStatus;

            /**
             * The Freeze status of the account (FreezeNotApplicable, Frozen or Unfrozen). If the token does
             * not have Freeze key, FreezeNotApplicable is returned
             */
            public freezeStatus: hashgraph.proto.TokenFreezeStatus;

            /** Tokens divide into <tt>10<sup>decimals</sup></tt> pieces */
            public decimals: number;

            /**
             * Specifies if the relationship is created implicitly. False : explicitly associated, True :
             * implicitly associated.
             */
            public automaticAssociation: boolean;

            /**
             * Creates a new TokenRelationship instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenRelationship instance
             */
            public static create(properties?: hashgraph.proto.ITokenRelationship): hashgraph.proto.TokenRelationship;

            /**
             * Encodes the specified TokenRelationship message. Does not implicitly {@link hashgraph.proto.TokenRelationship.verify|verify} messages.
             * @param m TokenRelationship message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenRelationship, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenRelationship message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenRelationship
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenRelationship;

            /**
             * Gets the default type url for TokenRelationship
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenBalance. */
        interface ITokenBalance {

            /** A unique token id */
            tokenId?: (hashgraph.proto.ITokenID|null);

            /**
             * Number of transferable units of the identified token. For token of type FUNGIBLE_COMMON -
             * balance in the smallest denomination. For token of type NON_FUNGIBLE_UNIQUE - the number of
             * NFTs held by the account
             */
            balance?: (Long|null);

            /** Tokens divide into <tt>10<sup>decimals</sup></tt> pieces */
            decimals?: (number|null);
        }

        /**
         * A number of <i>transferable units</i> of a certain token.
         *
         * The transferable unit of a token is its smallest denomination, as given by the token's
         * <tt>decimals</tt> property---each minted token contains <tt>10<sup>decimals</sup></tt>
         * transferable units. For example, we could think of the cent as the transferable unit of the US
         * dollar (<tt>decimals=2</tt>); and the tinybar as the transferable unit of hbar
         * (<tt>decimals=8</tt>).
         *
         * Transferable units are not directly comparable across different tokens.
         */
        class TokenBalance implements ITokenBalance {

            /**
             * Constructs a new TokenBalance.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenBalance);

            /** A unique token id */
            public tokenId?: (hashgraph.proto.ITokenID|null);

            /**
             * Number of transferable units of the identified token. For token of type FUNGIBLE_COMMON -
             * balance in the smallest denomination. For token of type NON_FUNGIBLE_UNIQUE - the number of
             * NFTs held by the account
             */
            public balance: Long;

            /** Tokens divide into <tt>10<sup>decimals</sup></tt> pieces */
            public decimals: number;

            /**
             * Creates a new TokenBalance instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenBalance instance
             */
            public static create(properties?: hashgraph.proto.ITokenBalance): hashgraph.proto.TokenBalance;

            /**
             * Encodes the specified TokenBalance message. Does not implicitly {@link hashgraph.proto.TokenBalance.verify|verify} messages.
             * @param m TokenBalance message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenBalance, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenBalance message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenBalance
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenBalance;

            /**
             * Gets the default type url for TokenBalance
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenBalances. */
        interface ITokenBalances {

            /** TokenBalances tokenBalances */
            tokenBalances?: (hashgraph.proto.ITokenBalance[]|null);
        }

        /** A sequence of token balances */
        class TokenBalances implements ITokenBalances {

            /**
             * Constructs a new TokenBalances.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenBalances);

            /** TokenBalances tokenBalances. */
            public tokenBalances: hashgraph.proto.ITokenBalance[];

            /**
             * Creates a new TokenBalances instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenBalances instance
             */
            public static create(properties?: hashgraph.proto.ITokenBalances): hashgraph.proto.TokenBalances;

            /**
             * Encodes the specified TokenBalances message. Does not implicitly {@link hashgraph.proto.TokenBalances.verify|verify} messages.
             * @param m TokenBalances message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenBalances, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenBalances message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenBalances
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenBalances;

            /**
             * Gets the default type url for TokenBalances
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenAssociation. */
        interface ITokenAssociation {

            /** TokenAssociation tokenId */
            tokenId?: (hashgraph.proto.ITokenID|null);

            /** TokenAssociation accountId */
            accountId?: (hashgraph.proto.IAccountID|null);
        }

        /** Represents a TokenAssociation. */
        class TokenAssociation implements ITokenAssociation {

            /**
             * Constructs a new TokenAssociation.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenAssociation);

            /** TokenAssociation tokenId. */
            public tokenId?: (hashgraph.proto.ITokenID|null);

            /** TokenAssociation accountId. */
            public accountId?: (hashgraph.proto.IAccountID|null);

            /**
             * Creates a new TokenAssociation instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenAssociation instance
             */
            public static create(properties?: hashgraph.proto.ITokenAssociation): hashgraph.proto.TokenAssociation;

            /**
             * Encodes the specified TokenAssociation message. Does not implicitly {@link hashgraph.proto.TokenAssociation.verify|verify} messages.
             * @param m TokenAssociation message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenAssociation, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenAssociation message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenAssociation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenAssociation;

            /**
             * Gets the default type url for TokenAssociation
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a StakingInfo. */
        interface IStakingInfo {

            /** If true, this account or contract declined to receive a staking reward. */
            declineReward?: (boolean|null);

            /**
             * The staking period during which either the staking settings for this account or contract changed (such as starting
             * staking or changing staked_node_id) or the most recent reward was earned, whichever is later. If this account or contract
             * is not currently staked to a node, then this field is not set.
             */
            stakePeriodStart?: (hashgraph.proto.ITimestamp|null);

            /** The amount in tinybars that will be received in the next reward situation. */
            pendingReward?: (Long|null);

            /** The total of balance of all accounts staked to this account or contract. */
            stakedToMe?: (Long|null);

            /** The account to which this account or contract is staking. */
            stakedAccountId?: (hashgraph.proto.IAccountID|null);

            /** The ID of the node this account or contract is staked to. */
            stakedNodeId?: (Long|null);
        }

        /** Staking metadata for an account or a contract returned in CryptoGetInfo or ContractGetInfo queries */
        class StakingInfo implements IStakingInfo {

            /**
             * Constructs a new StakingInfo.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IStakingInfo);

            /** If true, this account or contract declined to receive a staking reward. */
            public declineReward: boolean;

            /**
             * The staking period during which either the staking settings for this account or contract changed (such as starting
             * staking or changing staked_node_id) or the most recent reward was earned, whichever is later. If this account or contract
             * is not currently staked to a node, then this field is not set.
             */
            public stakePeriodStart?: (hashgraph.proto.ITimestamp|null);

            /** The amount in tinybars that will be received in the next reward situation. */
            public pendingReward: Long;

            /** The total of balance of all accounts staked to this account or contract. */
            public stakedToMe: Long;

            /** The account to which this account or contract is staking. */
            public stakedAccountId?: (hashgraph.proto.IAccountID|null);

            /** The ID of the node this account or contract is staked to. */
            public stakedNodeId?: (Long|null);

            /** ID of the account or node to which this account or contract is staking. */
            public stakedId?: ("stakedAccountId"|"stakedNodeId");

            /**
             * Creates a new StakingInfo instance using the specified properties.
             * @param [properties] Properties to set
             * @returns StakingInfo instance
             */
            public static create(properties?: hashgraph.proto.IStakingInfo): hashgraph.proto.StakingInfo;

            /**
             * Encodes the specified StakingInfo message. Does not implicitly {@link hashgraph.proto.StakingInfo.verify|verify} messages.
             * @param m StakingInfo message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IStakingInfo, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a StakingInfo message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns StakingInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.StakingInfo;

            /**
             * Gets the default type url for StakingInfo
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a Timestamp. */
        interface ITimestamp {

            /** Number of complete seconds since the start of the epoch */
            seconds?: (Long|null);

            /** Number of nanoseconds since the start of the last second */
            nanos?: (number|null);
        }

        /**
         * An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the
         * comments in https://github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto)
         */
        class Timestamp implements ITimestamp {

            /**
             * Constructs a new Timestamp.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITimestamp);

            /** Number of complete seconds since the start of the epoch */
            public seconds: Long;

            /** Number of nanoseconds since the start of the last second */
            public nanos: number;

            /**
             * Creates a new Timestamp instance using the specified properties.
             * @param [properties] Properties to set
             * @returns Timestamp instance
             */
            public static create(properties?: hashgraph.proto.ITimestamp): hashgraph.proto.Timestamp;

            /**
             * Encodes the specified Timestamp message. Does not implicitly {@link hashgraph.proto.Timestamp.verify|verify} messages.
             * @param m Timestamp message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITimestamp, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a Timestamp message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns Timestamp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.Timestamp;

            /**
             * Gets the default type url for Timestamp
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TimestampSeconds. */
        interface ITimestampSeconds {

            /** Number of complete seconds since the start of the epoch */
            seconds?: (Long|null);
        }

        /** An exact date and time,  with a resolution of one second (no nanoseconds). */
        class TimestampSeconds implements ITimestampSeconds {

            /**
             * Constructs a new TimestampSeconds.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITimestampSeconds);

            /** Number of complete seconds since the start of the epoch */
            public seconds: Long;

            /**
             * Creates a new TimestampSeconds instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TimestampSeconds instance
             */
            public static create(properties?: hashgraph.proto.ITimestampSeconds): hashgraph.proto.TimestampSeconds;

            /**
             * Encodes the specified TimestampSeconds message. Does not implicitly {@link hashgraph.proto.TimestampSeconds.verify|verify} messages.
             * @param m TimestampSeconds message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITimestampSeconds, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TimestampSeconds message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TimestampSeconds
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TimestampSeconds;

            /**
             * Gets the default type url for TimestampSeconds
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ConsensusCreateTopicTransactionBody. */
        interface IConsensusCreateTopicTransactionBody {

            /** Short publicly visible memo about the topic. No guarantee of uniqueness. */
            memo?: (string|null);

            /**
             * Access control for updateTopic/deleteTopic.
             * Anyone can increase the topic's expirationTime via ConsensusService.updateTopic(), regardless of the adminKey.
             * If no adminKey is specified, updateTopic may only be used to extend the topic's expirationTime, and deleteTopic
             * is disallowed.
             */
            adminKey?: (hashgraph.proto.IKey|null);

            /**
             * Access control for submitMessage.
             * If unspecified, no access control is performed on ConsensusService.submitMessage (all submissions are allowed).
             */
            submitKey?: (hashgraph.proto.IKey|null);

            /**
             * The initial lifetime of the topic and the amount of time to attempt to extend the topic's lifetime by
             * automatically at the topic's expirationTime, if the autoRenewAccount is configured (once autoRenew functionality
             * is supported by HAPI).
             * Limited to MIN_AUTORENEW_PERIOD and MAX_AUTORENEW_PERIOD value by server-side configuration.
             * Required.
             */
            autoRenewPeriod?: (hashgraph.proto.IDuration|null);

            /**
             * Optional account to be used at the topic's expirationTime to extend the life of the topic (once autoRenew
             * functionality is supported by HAPI).
             * The topic lifetime will be extended up to a maximum of the autoRenewPeriod or however long the topic
             * can be extended using all funds on the account (whichever is the smaller duration/amount and if any extension
             * is possible with the account's funds).
             * If specified, there must be an adminKey and the autoRenewAccount must sign this transaction.
             */
            autoRenewAccount?: (hashgraph.proto.IAccountID|null);
        }

        /** See [ConsensusService.createTopic()](#hashgraph.proto.ConsensusService) */
        class ConsensusCreateTopicTransactionBody implements IConsensusCreateTopicTransactionBody {

            /**
             * Constructs a new ConsensusCreateTopicTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IConsensusCreateTopicTransactionBody);

            /** Short publicly visible memo about the topic. No guarantee of uniqueness. */
            public memo: string;

            /**
             * Access control for updateTopic/deleteTopic.
             * Anyone can increase the topic's expirationTime via ConsensusService.updateTopic(), regardless of the adminKey.
             * If no adminKey is specified, updateTopic may only be used to extend the topic's expirationTime, and deleteTopic
             * is disallowed.
             */
            public adminKey?: (hashgraph.proto.IKey|null);

            /**
             * Access control for submitMessage.
             * If unspecified, no access control is performed on ConsensusService.submitMessage (all submissions are allowed).
             */
            public submitKey?: (hashgraph.proto.IKey|null);

            /**
             * The initial lifetime of the topic and the amount of time to attempt to extend the topic's lifetime by
             * automatically at the topic's expirationTime, if the autoRenewAccount is configured (once autoRenew functionality
             * is supported by HAPI).
             * Limited to MIN_AUTORENEW_PERIOD and MAX_AUTORENEW_PERIOD value by server-side configuration.
             * Required.
             */
            public autoRenewPeriod?: (hashgraph.proto.IDuration|null);

            /**
             * Optional account to be used at the topic's expirationTime to extend the life of the topic (once autoRenew
             * functionality is supported by HAPI).
             * The topic lifetime will be extended up to a maximum of the autoRenewPeriod or however long the topic
             * can be extended using all funds on the account (whichever is the smaller duration/amount and if any extension
             * is possible with the account's funds).
             * If specified, there must be an adminKey and the autoRenewAccount must sign this transaction.
             */
            public autoRenewAccount?: (hashgraph.proto.IAccountID|null);

            /**
             * Creates a new ConsensusCreateTopicTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ConsensusCreateTopicTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.IConsensusCreateTopicTransactionBody): hashgraph.proto.ConsensusCreateTopicTransactionBody;

            /**
             * Encodes the specified ConsensusCreateTopicTransactionBody message. Does not implicitly {@link hashgraph.proto.ConsensusCreateTopicTransactionBody.verify|verify} messages.
             * @param m ConsensusCreateTopicTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IConsensusCreateTopicTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ConsensusCreateTopicTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ConsensusCreateTopicTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ConsensusCreateTopicTransactionBody;

            /**
             * Gets the default type url for ConsensusCreateTopicTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a Duration. */
        interface IDuration {

            /** The number of seconds */
            seconds?: (Long|null);
        }

        /** A length of time in seconds. */
        class Duration implements IDuration {

            /**
             * Constructs a new Duration.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IDuration);

            /** The number of seconds */
            public seconds: Long;

            /**
             * Creates a new Duration instance using the specified properties.
             * @param [properties] Properties to set
             * @returns Duration instance
             */
            public static create(properties?: hashgraph.proto.IDuration): hashgraph.proto.Duration;

            /**
             * Encodes the specified Duration message. Does not implicitly {@link hashgraph.proto.Duration.verify|verify} messages.
             * @param m Duration message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IDuration, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a Duration message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns Duration
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.Duration;

            /**
             * Gets the default type url for Duration
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ConsensusDeleteTopicTransactionBody. */
        interface IConsensusDeleteTopicTransactionBody {

            /** Topic identifier */
            topicID?: (hashgraph.proto.ITopicID|null);
        }

        /** See [ConsensusService.deleteTopic()](#hashgraph.proto.ConsensusService) */
        class ConsensusDeleteTopicTransactionBody implements IConsensusDeleteTopicTransactionBody {

            /**
             * Constructs a new ConsensusDeleteTopicTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IConsensusDeleteTopicTransactionBody);

            /** Topic identifier */
            public topicID?: (hashgraph.proto.ITopicID|null);

            /**
             * Creates a new ConsensusDeleteTopicTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ConsensusDeleteTopicTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.IConsensusDeleteTopicTransactionBody): hashgraph.proto.ConsensusDeleteTopicTransactionBody;

            /**
             * Encodes the specified ConsensusDeleteTopicTransactionBody message. Does not implicitly {@link hashgraph.proto.ConsensusDeleteTopicTransactionBody.verify|verify} messages.
             * @param m ConsensusDeleteTopicTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IConsensusDeleteTopicTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ConsensusDeleteTopicTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ConsensusDeleteTopicTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ConsensusDeleteTopicTransactionBody;

            /**
             * Gets the default type url for ConsensusDeleteTopicTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ConsensusGetTopicInfoQuery. */
        interface IConsensusGetTopicInfoQuery {

            /**
             * Standard info sent from client to node, including the signed payment, and what kind of response is requested
             * (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IQueryHeader|null);

            /** The Topic for which information is being requested */
            topicID?: (hashgraph.proto.ITopicID|null);
        }

        /** See [ConsensusService.getTopicInfo()](#hashgraph.proto.ConsensusService) */
        class ConsensusGetTopicInfoQuery implements IConsensusGetTopicInfoQuery {

            /**
             * Constructs a new ConsensusGetTopicInfoQuery.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IConsensusGetTopicInfoQuery);

            /**
             * Standard info sent from client to node, including the signed payment, and what kind of response is requested
             * (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IQueryHeader|null);

            /** The Topic for which information is being requested */
            public topicID?: (hashgraph.proto.ITopicID|null);

            /**
             * Creates a new ConsensusGetTopicInfoQuery instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ConsensusGetTopicInfoQuery instance
             */
            public static create(properties?: hashgraph.proto.IConsensusGetTopicInfoQuery): hashgraph.proto.ConsensusGetTopicInfoQuery;

            /**
             * Encodes the specified ConsensusGetTopicInfoQuery message. Does not implicitly {@link hashgraph.proto.ConsensusGetTopicInfoQuery.verify|verify} messages.
             * @param m ConsensusGetTopicInfoQuery message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IConsensusGetTopicInfoQuery, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ConsensusGetTopicInfoQuery message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ConsensusGetTopicInfoQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ConsensusGetTopicInfoQuery;

            /**
             * Gets the default type url for ConsensusGetTopicInfoQuery
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ConsensusGetTopicInfoResponse. */
        interface IConsensusGetTopicInfoResponse {

            /** Standard response from node to client, including the requested fields: cost, or state proof, or both, or neither. */
            header?: (hashgraph.proto.IResponseHeader|null);

            /** Topic identifier. */
            topicID?: (hashgraph.proto.ITopicID|null);

            /** Current state of the topic */
            topicInfo?: (hashgraph.proto.IConsensusTopicInfo|null);
        }

        /** Retrieve the parameters of and state of a consensus topic. */
        class ConsensusGetTopicInfoResponse implements IConsensusGetTopicInfoResponse {

            /**
             * Constructs a new ConsensusGetTopicInfoResponse.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IConsensusGetTopicInfoResponse);

            /** Standard response from node to client, including the requested fields: cost, or state proof, or both, or neither. */
            public header?: (hashgraph.proto.IResponseHeader|null);

            /** Topic identifier. */
            public topicID?: (hashgraph.proto.ITopicID|null);

            /** Current state of the topic */
            public topicInfo?: (hashgraph.proto.IConsensusTopicInfo|null);

            /**
             * Creates a new ConsensusGetTopicInfoResponse instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ConsensusGetTopicInfoResponse instance
             */
            public static create(properties?: hashgraph.proto.IConsensusGetTopicInfoResponse): hashgraph.proto.ConsensusGetTopicInfoResponse;

            /**
             * Encodes the specified ConsensusGetTopicInfoResponse message. Does not implicitly {@link hashgraph.proto.ConsensusGetTopicInfoResponse.verify|verify} messages.
             * @param m ConsensusGetTopicInfoResponse message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IConsensusGetTopicInfoResponse, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ConsensusGetTopicInfoResponse message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ConsensusGetTopicInfoResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ConsensusGetTopicInfoResponse;

            /**
             * Gets the default type url for ConsensusGetTopicInfoResponse
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /**
         * The client uses the ResponseType to indicate that it desires the node send just the answer, or
         * both the answer and a state proof. It can also ask for just the cost and not the answer itself
         * (allowing it to tailor the payment transaction accordingly). If the payment in the query fails
         * the precheck, then the response may have some fields blank. The state proof is only available for
         * some types of information. It is available for a Record, but not a receipt. It is available for
         * the information in each kind of *GetInfo request.
         */
        enum ResponseType {
            ANSWER_ONLY = 0,
            ANSWER_STATE_PROOF = 1,
            COST_ANSWER = 2,
            COST_ANSWER_STATE_PROOF = 3
        }

        /** Properties of a QueryHeader. */
        interface IQueryHeader {

            /** A signed CryptoTransferTransaction to pay the node a fee for handling this query */
            payment?: (hashgraph.proto.ITransaction|null);

            /** The requested response, asking for cost, state proof, both, or neither */
            responseType?: (hashgraph.proto.ResponseType|null);
        }

        /**
         * Each query from the client to the node will contain the QueryHeader, which gives the requested
         * response type, and includes a payment transaction that will compensate the node for responding to
         * the query. The payment can be blank if the query is free.
         */
        class QueryHeader implements IQueryHeader {

            /**
             * Constructs a new QueryHeader.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IQueryHeader);

            /** A signed CryptoTransferTransaction to pay the node a fee for handling this query */
            public payment?: (hashgraph.proto.ITransaction|null);

            /** The requested response, asking for cost, state proof, both, or neither */
            public responseType: hashgraph.proto.ResponseType;

            /**
             * Creates a new QueryHeader instance using the specified properties.
             * @param [properties] Properties to set
             * @returns QueryHeader instance
             */
            public static create(properties?: hashgraph.proto.IQueryHeader): hashgraph.proto.QueryHeader;

            /**
             * Encodes the specified QueryHeader message. Does not implicitly {@link hashgraph.proto.QueryHeader.verify|verify} messages.
             * @param m QueryHeader message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IQueryHeader, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a QueryHeader message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns QueryHeader
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.QueryHeader;

            /**
             * Gets the default type url for QueryHeader
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a Transaction. */
        interface ITransaction {

            /** the body of the transaction, which needs to be signed */
            body?: (hashgraph.proto.ITransactionBody|null);

            /**
             * The signatures on the body, to authorize the transaction; deprecated and to be succeeded by
             * SignatureMap field
             */
            sigs?: (hashgraph.proto.ISignatureList|null);

            /** The signatures on the body with the new format, to authorize the transaction */
            sigMap?: (hashgraph.proto.ISignatureMap|null);

            /** TransactionBody serialized into bytes, which needs to be signed */
            bodyBytes?: (Uint8Array|null);

            /** SignedTransaction serialized into bytes */
            signedTransactionBytes?: (Uint8Array|null);
        }

        /**
         * A single signed transaction, including all its signatures. The SignatureList will have a
         * Signature for each Key in the transaction, either explicit or implicit, in the order that they
         * appear in the transaction. For example, a CryptoTransfer will first have a Signature
         * corresponding to the Key for the paying account, followed by a Signature corresponding to the Key
         * for each account that is sending or receiving cryptocurrency in the transfer. Each Transaction
         * should not have more than 50 levels.
         * The SignatureList field is deprecated and succeeded by SignatureMap.
         */
        class Transaction implements ITransaction {

            /**
             * Constructs a new Transaction.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITransaction);

            /** the body of the transaction, which needs to be signed */
            public body?: (hashgraph.proto.ITransactionBody|null);

            /**
             * The signatures on the body, to authorize the transaction; deprecated and to be succeeded by
             * SignatureMap field
             */
            public sigs?: (hashgraph.proto.ISignatureList|null);

            /** The signatures on the body with the new format, to authorize the transaction */
            public sigMap?: (hashgraph.proto.ISignatureMap|null);

            /** TransactionBody serialized into bytes, which needs to be signed */
            public bodyBytes: Uint8Array;

            /** SignedTransaction serialized into bytes */
            public signedTransactionBytes: Uint8Array;

            /**
             * Creates a new Transaction instance using the specified properties.
             * @param [properties] Properties to set
             * @returns Transaction instance
             */
            public static create(properties?: hashgraph.proto.ITransaction): hashgraph.proto.Transaction;

            /**
             * Encodes the specified Transaction message. Does not implicitly {@link hashgraph.proto.Transaction.verify|verify} messages.
             * @param m Transaction message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITransaction, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a Transaction message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns Transaction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.Transaction;

            /**
             * Gets the default type url for Transaction
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TransactionBody. */
        interface ITransactionBody {

            /**
             * The ID for this transaction, which includes the payer's account (the account paying the
             * transaction fee). If two transactions have the same transactionID, they won't both have an
             * effect
             */
            transactionID?: (hashgraph.proto.ITransactionID|null);

            /** The account of the node that submits the client's transaction to the network */
            nodeAccountID?: (hashgraph.proto.IAccountID|null);

            /** The maximum transaction fee the client is willing to pay */
            transactionFee?: (Long|null);

            /**
             * The transaction is invalid if consensusTimestamp > transactionID.transactionValidStart +
             * transactionValidDuration
             */
            transactionValidDuration?: (hashgraph.proto.IDuration|null);

            /**
             * Should a record of this transaction be generated? (A receipt is always generated, but the
             * record is optional)
             */
            generateRecord?: (boolean|null);

            /** Any notes or descriptions that should be put into the record (max length 100) */
            memo?: (string|null);

            /** Calls a function of a contract instance */
            contractCall?: (hashgraph.proto.IContractCallTransactionBody|null);

            /** Creates a contract instance */
            contractCreateInstance?: (hashgraph.proto.IContractCreateTransactionBody|null);

            /** Updates a contract */
            contractUpdateInstance?: (hashgraph.proto.IContractUpdateTransactionBody|null);

            /** Delete contract and transfer remaining balance into specified account */
            contractDeleteInstance?: (hashgraph.proto.IContractDeleteTransactionBody|null);

            /** An Ethereum encoded transaction. */
            ethereumTransaction?: (hashgraph.proto.IEthereumTransactionBody|null);

            /** Attach a new livehash to an account */
            cryptoAddLiveHash?: (hashgraph.proto.ICryptoAddLiveHashTransactionBody|null);

            /** Adds one or more approved allowances for spenders to transfer the paying account's hbar or tokens. */
            cryptoApproveAllowance?: (hashgraph.proto.ICryptoApproveAllowanceTransactionBody|null);

            /** Deletes one or more of the specific approved NFT serial numbers on an owner account. */
            cryptoDeleteAllowance?: (hashgraph.proto.ICryptoDeleteAllowanceTransactionBody|null);

            /** Create a new cryptocurrency account */
            cryptoCreateAccount?: (hashgraph.proto.ICryptoCreateTransactionBody|null);

            /** Delete a cryptocurrency account (mark as deleted, and transfer hbars out) */
            cryptoDelete?: (hashgraph.proto.ICryptoDeleteTransactionBody|null);

            /** Remove a livehash from an account */
            cryptoDeleteLiveHash?: (hashgraph.proto.ICryptoDeleteLiveHashTransactionBody|null);

            /** Transfer amount between accounts */
            cryptoTransfer?: (hashgraph.proto.ICryptoTransferTransactionBody|null);

            /** Modify information such as the expiration date for an account */
            cryptoUpdateAccount?: (hashgraph.proto.ICryptoUpdateTransactionBody|null);

            /** Add bytes to the end of the contents of a file */
            fileAppend?: (hashgraph.proto.IFileAppendTransactionBody|null);

            /** Create a new file */
            fileCreate?: (hashgraph.proto.IFileCreateTransactionBody|null);

            /** Delete a file (remove contents and mark as deleted until it expires) */
            fileDelete?: (hashgraph.proto.IFileDeleteTransactionBody|null);

            /** Modify information such as the expiration date for a file */
            fileUpdate?: (hashgraph.proto.IFileUpdateTransactionBody|null);

            /** Hedera administrative deletion of a file or smart contract */
            systemDelete?: (hashgraph.proto.ISystemDeleteTransactionBody|null);

            /** To undelete an entity deleted by SystemDelete */
            systemUndelete?: (hashgraph.proto.ISystemUndeleteTransactionBody|null);

            /** Freeze the nodes */
            freeze?: (hashgraph.proto.IFreezeTransactionBody|null);

            /** Creates a topic */
            consensusCreateTopic?: (hashgraph.proto.IConsensusCreateTopicTransactionBody|null);

            /** Updates a topic */
            consensusUpdateTopic?: (hashgraph.proto.IConsensusUpdateTopicTransactionBody|null);

            /** Deletes a topic */
            consensusDeleteTopic?: (hashgraph.proto.IConsensusDeleteTopicTransactionBody|null);

            /** Submits message to a topic */
            consensusSubmitMessage?: (hashgraph.proto.IConsensusSubmitMessageTransactionBody|null);

            /** UNDOCUMENTED */
            uncheckedSubmit?: (hashgraph.proto.IUncheckedSubmitBody|null);

            /** Creates a token instance */
            tokenCreation?: (hashgraph.proto.ITokenCreateTransactionBody|null);

            /** Freezes account not to be able to transact with a token */
            tokenFreeze?: (hashgraph.proto.ITokenFreezeAccountTransactionBody|null);

            /** Unfreezes account for a token */
            tokenUnfreeze?: (hashgraph.proto.ITokenUnfreezeAccountTransactionBody|null);

            /** Grants KYC to an account for a token */
            tokenGrantKyc?: (hashgraph.proto.ITokenGrantKycTransactionBody|null);

            /** Revokes KYC of an account for a token */
            tokenRevokeKyc?: (hashgraph.proto.ITokenRevokeKycTransactionBody|null);

            /** Deletes a token instance */
            tokenDeletion?: (hashgraph.proto.ITokenDeleteTransactionBody|null);

            /** Updates a token instance */
            tokenUpdate?: (hashgraph.proto.ITokenUpdateTransactionBody|null);

            /** Mints new tokens to a token's treasury account */
            tokenMint?: (hashgraph.proto.ITokenMintTransactionBody|null);

            /** Burns tokens from a token's treasury account */
            tokenBurn?: (hashgraph.proto.ITokenBurnTransactionBody|null);

            /** Wipes amount of tokens from an account */
            tokenWipe?: (hashgraph.proto.ITokenWipeAccountTransactionBody|null);

            /** Associate tokens to an account */
            tokenAssociate?: (hashgraph.proto.ITokenAssociateTransactionBody|null);

            /** Dissociate tokens from an account */
            tokenDissociate?: (hashgraph.proto.ITokenDissociateTransactionBody|null);

            /** Updates a token's custom fee schedule */
            tokenFeeScheduleUpdate?: (hashgraph.proto.ITokenFeeScheduleUpdateTransactionBody|null);

            /** Pauses the Token */
            tokenPause?: (hashgraph.proto.ITokenPauseTransactionBody|null);

            /** Unpauses the Token */
            tokenUnpause?: (hashgraph.proto.ITokenUnpauseTransactionBody|null);

            /** Creates a schedule in the network's action queue */
            scheduleCreate?: (hashgraph.proto.IScheduleCreateTransactionBody|null);

            /** Deletes a schedule from the network's action queue */
            scheduleDelete?: (hashgraph.proto.IScheduleDeleteTransactionBody|null);

            /** Adds one or more Ed25519 keys to the affirmed signers of a scheduled transaction */
            scheduleSign?: (hashgraph.proto.IScheduleSignTransactionBody|null);

            /** Updates the staking info at the end of staking period to indicate new staking period has started. */
            nodeStakeUpdate?: (hashgraph.proto.INodeStakeUpdateTransactionBody|null);

            /** Generates a pseudorandom number. */
            utilPrng?: (hashgraph.proto.IUtilPrngTransactionBody|null);
        }

        /** A single transaction. All transaction types are possible here. */
        class TransactionBody implements ITransactionBody {

            /**
             * Constructs a new TransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITransactionBody);

            /**
             * The ID for this transaction, which includes the payer's account (the account paying the
             * transaction fee). If two transactions have the same transactionID, they won't both have an
             * effect
             */
            public transactionID?: (hashgraph.proto.ITransactionID|null);

            /** The account of the node that submits the client's transaction to the network */
            public nodeAccountID?: (hashgraph.proto.IAccountID|null);

            /** The maximum transaction fee the client is willing to pay */
            public transactionFee: Long;

            /**
             * The transaction is invalid if consensusTimestamp > transactionID.transactionValidStart +
             * transactionValidDuration
             */
            public transactionValidDuration?: (hashgraph.proto.IDuration|null);

            /**
             * Should a record of this transaction be generated? (A receipt is always generated, but the
             * record is optional)
             */
            public generateRecord: boolean;

            /** Any notes or descriptions that should be put into the record (max length 100) */
            public memo: string;

            /** Calls a function of a contract instance */
            public contractCall?: (hashgraph.proto.IContractCallTransactionBody|null);

            /** Creates a contract instance */
            public contractCreateInstance?: (hashgraph.proto.IContractCreateTransactionBody|null);

            /** Updates a contract */
            public contractUpdateInstance?: (hashgraph.proto.IContractUpdateTransactionBody|null);

            /** Delete contract and transfer remaining balance into specified account */
            public contractDeleteInstance?: (hashgraph.proto.IContractDeleteTransactionBody|null);

            /** An Ethereum encoded transaction. */
            public ethereumTransaction?: (hashgraph.proto.IEthereumTransactionBody|null);

            /** Attach a new livehash to an account */
            public cryptoAddLiveHash?: (hashgraph.proto.ICryptoAddLiveHashTransactionBody|null);

            /** Adds one or more approved allowances for spenders to transfer the paying account's hbar or tokens. */
            public cryptoApproveAllowance?: (hashgraph.proto.ICryptoApproveAllowanceTransactionBody|null);

            /** Deletes one or more of the specific approved NFT serial numbers on an owner account. */
            public cryptoDeleteAllowance?: (hashgraph.proto.ICryptoDeleteAllowanceTransactionBody|null);

            /** Create a new cryptocurrency account */
            public cryptoCreateAccount?: (hashgraph.proto.ICryptoCreateTransactionBody|null);

            /** Delete a cryptocurrency account (mark as deleted, and transfer hbars out) */
            public cryptoDelete?: (hashgraph.proto.ICryptoDeleteTransactionBody|null);

            /** Remove a livehash from an account */
            public cryptoDeleteLiveHash?: (hashgraph.proto.ICryptoDeleteLiveHashTransactionBody|null);

            /** Transfer amount between accounts */
            public cryptoTransfer?: (hashgraph.proto.ICryptoTransferTransactionBody|null);

            /** Modify information such as the expiration date for an account */
            public cryptoUpdateAccount?: (hashgraph.proto.ICryptoUpdateTransactionBody|null);

            /** Add bytes to the end of the contents of a file */
            public fileAppend?: (hashgraph.proto.IFileAppendTransactionBody|null);

            /** Create a new file */
            public fileCreate?: (hashgraph.proto.IFileCreateTransactionBody|null);

            /** Delete a file (remove contents and mark as deleted until it expires) */
            public fileDelete?: (hashgraph.proto.IFileDeleteTransactionBody|null);

            /** Modify information such as the expiration date for a file */
            public fileUpdate?: (hashgraph.proto.IFileUpdateTransactionBody|null);

            /** Hedera administrative deletion of a file or smart contract */
            public systemDelete?: (hashgraph.proto.ISystemDeleteTransactionBody|null);

            /** To undelete an entity deleted by SystemDelete */
            public systemUndelete?: (hashgraph.proto.ISystemUndeleteTransactionBody|null);

            /** Freeze the nodes */
            public freeze?: (hashgraph.proto.IFreezeTransactionBody|null);

            /** Creates a topic */
            public consensusCreateTopic?: (hashgraph.proto.IConsensusCreateTopicTransactionBody|null);

            /** Updates a topic */
            public consensusUpdateTopic?: (hashgraph.proto.IConsensusUpdateTopicTransactionBody|null);

            /** Deletes a topic */
            public consensusDeleteTopic?: (hashgraph.proto.IConsensusDeleteTopicTransactionBody|null);

            /** Submits message to a topic */
            public consensusSubmitMessage?: (hashgraph.proto.IConsensusSubmitMessageTransactionBody|null);

            /** UNDOCUMENTED */
            public uncheckedSubmit?: (hashgraph.proto.IUncheckedSubmitBody|null);

            /** Creates a token instance */
            public tokenCreation?: (hashgraph.proto.ITokenCreateTransactionBody|null);

            /** Freezes account not to be able to transact with a token */
            public tokenFreeze?: (hashgraph.proto.ITokenFreezeAccountTransactionBody|null);

            /** Unfreezes account for a token */
            public tokenUnfreeze?: (hashgraph.proto.ITokenUnfreezeAccountTransactionBody|null);

            /** Grants KYC to an account for a token */
            public tokenGrantKyc?: (hashgraph.proto.ITokenGrantKycTransactionBody|null);

            /** Revokes KYC of an account for a token */
            public tokenRevokeKyc?: (hashgraph.proto.ITokenRevokeKycTransactionBody|null);

            /** Deletes a token instance */
            public tokenDeletion?: (hashgraph.proto.ITokenDeleteTransactionBody|null);

            /** Updates a token instance */
            public tokenUpdate?: (hashgraph.proto.ITokenUpdateTransactionBody|null);

            /** Mints new tokens to a token's treasury account */
            public tokenMint?: (hashgraph.proto.ITokenMintTransactionBody|null);

            /** Burns tokens from a token's treasury account */
            public tokenBurn?: (hashgraph.proto.ITokenBurnTransactionBody|null);

            /** Wipes amount of tokens from an account */
            public tokenWipe?: (hashgraph.proto.ITokenWipeAccountTransactionBody|null);

            /** Associate tokens to an account */
            public tokenAssociate?: (hashgraph.proto.ITokenAssociateTransactionBody|null);

            /** Dissociate tokens from an account */
            public tokenDissociate?: (hashgraph.proto.ITokenDissociateTransactionBody|null);

            /** Updates a token's custom fee schedule */
            public tokenFeeScheduleUpdate?: (hashgraph.proto.ITokenFeeScheduleUpdateTransactionBody|null);

            /** Pauses the Token */
            public tokenPause?: (hashgraph.proto.ITokenPauseTransactionBody|null);

            /** Unpauses the Token */
            public tokenUnpause?: (hashgraph.proto.ITokenUnpauseTransactionBody|null);

            /** Creates a schedule in the network's action queue */
            public scheduleCreate?: (hashgraph.proto.IScheduleCreateTransactionBody|null);

            /** Deletes a schedule from the network's action queue */
            public scheduleDelete?: (hashgraph.proto.IScheduleDeleteTransactionBody|null);

            /** Adds one or more Ed25519 keys to the affirmed signers of a scheduled transaction */
            public scheduleSign?: (hashgraph.proto.IScheduleSignTransactionBody|null);

            /** Updates the staking info at the end of staking period to indicate new staking period has started. */
            public nodeStakeUpdate?: (hashgraph.proto.INodeStakeUpdateTransactionBody|null);

            /** Generates a pseudorandom number. */
            public utilPrng?: (hashgraph.proto.IUtilPrngTransactionBody|null);

            /** The choices here are arranged by service in roughly lexicographical order. The field ordinals are non-sequential, and a result of the historical order of implementation. */
            public data?: ("contractCall"|"contractCreateInstance"|"contractUpdateInstance"|"contractDeleteInstance"|"ethereumTransaction"|"cryptoAddLiveHash"|"cryptoApproveAllowance"|"cryptoDeleteAllowance"|"cryptoCreateAccount"|"cryptoDelete"|"cryptoDeleteLiveHash"|"cryptoTransfer"|"cryptoUpdateAccount"|"fileAppend"|"fileCreate"|"fileDelete"|"fileUpdate"|"systemDelete"|"systemUndelete"|"freeze"|"consensusCreateTopic"|"consensusUpdateTopic"|"consensusDeleteTopic"|"consensusSubmitMessage"|"uncheckedSubmit"|"tokenCreation"|"tokenFreeze"|"tokenUnfreeze"|"tokenGrantKyc"|"tokenRevokeKyc"|"tokenDeletion"|"tokenUpdate"|"tokenMint"|"tokenBurn"|"tokenWipe"|"tokenAssociate"|"tokenDissociate"|"tokenFeeScheduleUpdate"|"tokenPause"|"tokenUnpause"|"scheduleCreate"|"scheduleDelete"|"scheduleSign"|"nodeStakeUpdate"|"utilPrng");

            /**
             * Creates a new TransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TransactionBody instance
             */
            public static create(properties?: hashgraph.proto.ITransactionBody): hashgraph.proto.TransactionBody;

            /**
             * Encodes the specified TransactionBody message. Does not implicitly {@link hashgraph.proto.TransactionBody.verify|verify} messages.
             * @param m TransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TransactionBody;

            /**
             * Gets the default type url for TransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a SystemDeleteTransactionBody. */
        interface ISystemDeleteTransactionBody {

            /** The file ID of the file to delete, in the format used in transactions */
            fileID?: (hashgraph.proto.IFileID|null);

            /** The contract ID instance to delete, in the format used in transactions */
            contractID?: (hashgraph.proto.IContractID|null);

            /** The timestamp in seconds at which the "deleted" file should truly be permanently deleted */
            expirationTime?: (hashgraph.proto.ITimestampSeconds|null);
        }

        /**
         * Delete a file or smart contract - can only be done with a Hedera administrative multisignature.
         * When it is deleted, it immediately disappears from the system as seen by the user, but is still
         * stored internally until the expiration time, at which time it is truly and permanently deleted.
         * Until that time, it can be undeleted by the Hedera administrative multisignature. When a smart
         * contract is deleted, the cryptocurrency account within it continues to exist, and is not affected
         * by the expiration time here.
         */
        class SystemDeleteTransactionBody implements ISystemDeleteTransactionBody {

            /**
             * Constructs a new SystemDeleteTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ISystemDeleteTransactionBody);

            /** The file ID of the file to delete, in the format used in transactions */
            public fileID?: (hashgraph.proto.IFileID|null);

            /** The contract ID instance to delete, in the format used in transactions */
            public contractID?: (hashgraph.proto.IContractID|null);

            /** The timestamp in seconds at which the "deleted" file should truly be permanently deleted */
            public expirationTime?: (hashgraph.proto.ITimestampSeconds|null);

            /** SystemDeleteTransactionBody id. */
            public id?: ("fileID"|"contractID");

            /**
             * Creates a new SystemDeleteTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns SystemDeleteTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.ISystemDeleteTransactionBody): hashgraph.proto.SystemDeleteTransactionBody;

            /**
             * Encodes the specified SystemDeleteTransactionBody message. Does not implicitly {@link hashgraph.proto.SystemDeleteTransactionBody.verify|verify} messages.
             * @param m SystemDeleteTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ISystemDeleteTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a SystemDeleteTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns SystemDeleteTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.SystemDeleteTransactionBody;

            /**
             * Gets the default type url for SystemDeleteTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a SystemUndeleteTransactionBody. */
        interface ISystemUndeleteTransactionBody {

            /** The file ID to undelete, in the format used in transactions */
            fileID?: (hashgraph.proto.IFileID|null);

            /** The contract ID instance to undelete, in the format used in transactions */
            contractID?: (hashgraph.proto.IContractID|null);
        }

        /**
         * Undelete a file or smart contract that was deleted by SystemDelete; requires a Hedera
         * administrative multisignature.
         */
        class SystemUndeleteTransactionBody implements ISystemUndeleteTransactionBody {

            /**
             * Constructs a new SystemUndeleteTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ISystemUndeleteTransactionBody);

            /** The file ID to undelete, in the format used in transactions */
            public fileID?: (hashgraph.proto.IFileID|null);

            /** The contract ID instance to undelete, in the format used in transactions */
            public contractID?: (hashgraph.proto.IContractID|null);

            /** SystemUndeleteTransactionBody id. */
            public id?: ("fileID"|"contractID");

            /**
             * Creates a new SystemUndeleteTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns SystemUndeleteTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.ISystemUndeleteTransactionBody): hashgraph.proto.SystemUndeleteTransactionBody;

            /**
             * Encodes the specified SystemUndeleteTransactionBody message. Does not implicitly {@link hashgraph.proto.SystemUndeleteTransactionBody.verify|verify} messages.
             * @param m SystemUndeleteTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ISystemUndeleteTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a SystemUndeleteTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns SystemUndeleteTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.SystemUndeleteTransactionBody;

            /**
             * Gets the default type url for SystemUndeleteTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a FreezeTransactionBody. */
        interface IFreezeTransactionBody {

            /**
             * !! DEPRECATED and REJECTED by nodes
             * The start hour (in UTC time), a value between 0 and 23
             */
            startHour?: (number|null);

            /**
             * !! DEPRECATED and REJECTED by nodes
             * The start minute (in UTC time), a value between 0 and 59
             */
            startMin?: (number|null);

            /**
             * !! DEPRECATED and REJECTED by nodes
             * The end hour (in UTC time), a value between 0 and 23
             */
            endHour?: (number|null);

            /**
             * !! DEPRECATED and REJECTED by nodes
             * The end minute (in UTC time), a value between 0 and 59
             */
            endMin?: (number|null);

            /**
             * If set, the file whose contents should be used for a network software update during the
             * maintenance window.
             */
            updateFile?: (hashgraph.proto.IFileID|null);

            /** If set, the expected hash of the contents of the update file (used to verify the update). */
            fileHash?: (Uint8Array|null);

            /** The consensus time at which the maintenance window should begin. */
            startTime?: (hashgraph.proto.ITimestamp|null);

            /** The type of network freeze or upgrade operation to perform. */
            freezeType?: (hashgraph.proto.FreezeType|null);
        }

        /**
         * At consensus, sets the consensus time at which the platform should stop creating events and
         * accepting transactions, and enter a maintenance window.
         */
        class FreezeTransactionBody implements IFreezeTransactionBody {

            /**
             * Constructs a new FreezeTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IFreezeTransactionBody);

            /**
             * !! DEPRECATED and REJECTED by nodes
             * The start hour (in UTC time), a value between 0 and 23
             */
            public startHour: number;

            /**
             * !! DEPRECATED and REJECTED by nodes
             * The start minute (in UTC time), a value between 0 and 59
             */
            public startMin: number;

            /**
             * !! DEPRECATED and REJECTED by nodes
             * The end hour (in UTC time), a value between 0 and 23
             */
            public endHour: number;

            /**
             * !! DEPRECATED and REJECTED by nodes
             * The end minute (in UTC time), a value between 0 and 59
             */
            public endMin: number;

            /**
             * If set, the file whose contents should be used for a network software update during the
             * maintenance window.
             */
            public updateFile?: (hashgraph.proto.IFileID|null);

            /** If set, the expected hash of the contents of the update file (used to verify the update). */
            public fileHash: Uint8Array;

            /** The consensus time at which the maintenance window should begin. */
            public startTime?: (hashgraph.proto.ITimestamp|null);

            /** The type of network freeze or upgrade operation to perform. */
            public freezeType: hashgraph.proto.FreezeType;

            /**
             * Creates a new FreezeTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns FreezeTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.IFreezeTransactionBody): hashgraph.proto.FreezeTransactionBody;

            /**
             * Encodes the specified FreezeTransactionBody message. Does not implicitly {@link hashgraph.proto.FreezeTransactionBody.verify|verify} messages.
             * @param m FreezeTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IFreezeTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a FreezeTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns FreezeTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.FreezeTransactionBody;

            /**
             * Gets the default type url for FreezeTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /**
         * The type of network freeze or upgrade operation to be performed. This type dictates which
         * fields are required.
         */
        enum FreezeType {
            UNKNOWN_FREEZE_TYPE = 0,
            FREEZE_ONLY = 1,
            PREPARE_UPGRADE = 2,
            FREEZE_UPGRADE = 3,
            FREEZE_ABORT = 4,
            TELEMETRY_UPGRADE = 5
        }

        /** Properties of a ContractCallTransactionBody. */
        interface IContractCallTransactionBody {

            /** The contract to call */
            contractID?: (hashgraph.proto.IContractID|null);

            /** the maximum amount of gas to use for the call */
            gas?: (Long|null);

            /** number of tinybars sent (the function must be payable if this is nonzero) */
            amount?: (Long|null);

            /** which function to call, and the parameters to pass to the function */
            functionParameters?: (Uint8Array|null);
        }

        /**
         * Call a function of the given smart contract instance, giving it functionParameters as its inputs.
         * The call can use at maximum the given amount of gas – the paying account will not be charged for
         * any unspent gas.
         *
         * If this function results in data being stored, an amount of gas is calculated that reflects this
         * storage burden.
         *
         * The amount of gas used, as well as other attributes of the transaction, e.g. size, number of
         * signatures to be verified, determine the fee for the transaction – which is charged to the paying
         * account.
         */
        class ContractCallTransactionBody implements IContractCallTransactionBody {

            /**
             * Constructs a new ContractCallTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IContractCallTransactionBody);

            /** The contract to call */
            public contractID?: (hashgraph.proto.IContractID|null);

            /** the maximum amount of gas to use for the call */
            public gas: Long;

            /** number of tinybars sent (the function must be payable if this is nonzero) */
            public amount: Long;

            /** which function to call, and the parameters to pass to the function */
            public functionParameters: Uint8Array;

            /**
             * Creates a new ContractCallTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ContractCallTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.IContractCallTransactionBody): hashgraph.proto.ContractCallTransactionBody;

            /**
             * Encodes the specified ContractCallTransactionBody message. Does not implicitly {@link hashgraph.proto.ContractCallTransactionBody.verify|verify} messages.
             * @param m ContractCallTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IContractCallTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ContractCallTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ContractCallTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ContractCallTransactionBody;

            /**
             * Gets the default type url for ContractCallTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ContractCreateTransactionBody. */
        interface IContractCreateTransactionBody {

            /**
             * The file containing the smart contract initcode. A copy will be made and held by the
             * contract instance, and have the same expiration time as the instance.
             */
            fileID?: (hashgraph.proto.IFileID|null);

            /**
             * The bytes of the smart contract initcode. This is only useful if the smart contract init
             * is less than the hedera transaction limit. In those cases fileID must be used.
             */
            initcode?: (Uint8Array|null);

            /**
             * the state of the instance and its fields can be modified arbitrarily if this key signs a
             * transaction to modify it. If this is null, then such modifications are not possible, and
             * there is no administrator that can override the normal operation of this smart contract
             * instance. Note that if it is created with no admin keys, then there is no administrator to
             * authorize changing the admin keys, so there can never be any admin keys for that instance.
             */
            adminKey?: (hashgraph.proto.IKey|null);

            /** gas to run the constructor */
            gas?: (Long|null);

            /**
             * initial number of tinybars to put into the cryptocurrency account associated with and owned
             * by the smart contract
             */
            initialBalance?: (Long|null);

            /**
             * [Deprecated] ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an
             * invalid account, or is an account that isn't a node, then this account is automatically proxy
             * staked to a node chosen by the network, but without earning payments. If the proxyAccountID
             * account refuses to accept proxy staking , or if it is not currently running a node, then it
             * will behave as if  proxyAccountID was null.
             */
            proxyAccountID?: (hashgraph.proto.IAccountID|null);

            /** the instance will charge its account every this many seconds to renew for this long */
            autoRenewPeriod?: (hashgraph.proto.IDuration|null);

            /** parameters to pass to the constructor */
            constructorParameters?: (Uint8Array|null);

            /** shard in which to create this */
            shardID?: (hashgraph.proto.IShardID|null);

            /** realm in which to create this (leave this null to create a new realm) */
            realmID?: (hashgraph.proto.IRealmID|null);

            /** if realmID is null, then this the admin key for the new realm that will be created */
            newRealmAdminKey?: (hashgraph.proto.IKey|null);

            /** the memo that was submitted as part of the contract (max 100 bytes) */
            memo?: (string|null);

            /**
             * The maximum number of tokens that this contract can be automatically associated
             * with (i.e., receive air-drops from).
             */
            maxAutomaticTokenAssociations?: (number|null);

            /**
             * An account to charge for auto-renewal of this contract. If not set, or set to an
             * account with zero hbar balance, the contract's own hbar balance will be used to
             * cover auto-renewal fees.
             */
            autoRenewAccountId?: (hashgraph.proto.IAccountID|null);

            /** ID of the account to which this contract is staking. */
            stakedAccountId?: (hashgraph.proto.IAccountID|null);

            /** ID of the node this contract is staked to. */
            stakedNodeId?: (Long|null);

            /** If true, the contract declines receiving a staking reward. The default value is false. */
            declineReward?: (boolean|null);
        }

        /**
         * Start a new smart contract instance. After the instance is created, the ContractID for it is in
         * the receipt, and can be retrieved by the Record or with a GetByKey query. The instance will run
         * the bytecode, either stored in a previously created file or in the transaction body itself for
         * small contracts.
         *
         *
         * The constructor will be executed using the given amount of gas, and any unspent gas will be
         * refunded to the paying account. Constructor inputs come from the given constructorParameters.
         * - The instance will exist for autoRenewPeriod seconds. When that is reached, it will renew
         * itself for another autoRenewPeriod seconds by charging its associated cryptocurrency account
         * (which it creates here). If it has insufficient cryptocurrency to extend that long, it will
         * extend as long as it can. If its balance is zero, the instance will be deleted.
         *
         * - A smart contract instance normally enforces rules, so "the code is law". For example, an
         * ERC-20 contract prevents a transfer from being undone without a signature by the recipient of
         * the transfer. This is always enforced if the contract instance was created with the adminKeys
         * being null. But for some uses, it might be desirable to create something like an ERC-20
         * contract that has a specific group of trusted individuals who can act as a "supreme court"
         * with the ability to override the normal operation, when a sufficient number of them agree to
         * do so. If adminKeys is not null, then they can sign a transaction that can change the state of
         * the smart contract in arbitrary ways, such as to reverse a transaction that violates some
         * standard of behavior that is not covered by the code itself. The admin keys can also be used
         * to change the autoRenewPeriod, and change the adminKeys field itself. The API currently does
         * not implement this ability. But it does allow the adminKeys field to be set and queried, and
         * will in the future implement such admin abilities for any instance that has a non-null
         * adminKeys.
         *
         * - If this constructor stores information, it is charged gas to store it. There is a fee in hbars
         * to maintain that storage until the expiration time, and that fee is added as part of the
         * transaction fee.
         *
         * - An entity (account, file, or smart contract instance) must be created in a particular realm.
         * If the realmID is left null, then a new realm will be created with the given admin key. If a
         * new realm has a null adminKey, then anyone can create/modify/delete entities in that realm.
         * But if an admin key is given, then any transaction to create/modify/delete an entity in that
         * realm must be signed by that key, though anyone can still call functions on smart contract
         * instances that exist in that realm. A realm ceases to exist when everything within it has
         * expired and no longer exists.
         *
         * - The current API ignores shardID, realmID, and newRealmAdminKey, and creates everything in
         * shard 0 and realm 0, with a null key. Future versions of the API will support multiple realms
         * and multiple shards.
         *
         * - The optional memo field can contain a string whose length is up to 100 bytes. That is the size
         * after Unicode NFD then UTF-8 conversion. This field can be used to describe the smart contract.
         * It could also be used for other purposes. One recommended purpose is to hold a hexadecimal
         * string that is the SHA-384 hash of a PDF file containing a human-readable legal contract. Then,
         * if the admin keys are the public keys of human arbitrators, they can use that legal document to
         * guide their decisions during a binding arbitration tribunal, convened to consider any changes
         * to the smart contract in the future. The memo field can only be changed using the admin keys.
         * If there are no admin keys, then it cannot be changed after the smart contract is created.
         *
         * <b>Signing requirements:</b> If an admin key is set, it must sign the transaction. If an
         * auto-renew account is set, its key must sign the transaction.
         */
        class ContractCreateTransactionBody implements IContractCreateTransactionBody {

            /**
             * Constructs a new ContractCreateTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IContractCreateTransactionBody);

            /**
             * The file containing the smart contract initcode. A copy will be made and held by the
             * contract instance, and have the same expiration time as the instance.
             */
            public fileID?: (hashgraph.proto.IFileID|null);

            /**
             * The bytes of the smart contract initcode. This is only useful if the smart contract init
             * is less than the hedera transaction limit. In those cases fileID must be used.
             */
            public initcode?: (Uint8Array|null);

            /**
             * the state of the instance and its fields can be modified arbitrarily if this key signs a
             * transaction to modify it. If this is null, then such modifications are not possible, and
             * there is no administrator that can override the normal operation of this smart contract
             * instance. Note that if it is created with no admin keys, then there is no administrator to
             * authorize changing the admin keys, so there can never be any admin keys for that instance.
             */
            public adminKey?: (hashgraph.proto.IKey|null);

            /** gas to run the constructor */
            public gas: Long;

            /**
             * initial number of tinybars to put into the cryptocurrency account associated with and owned
             * by the smart contract
             */
            public initialBalance: Long;

            /**
             * [Deprecated] ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an
             * invalid account, or is an account that isn't a node, then this account is automatically proxy
             * staked to a node chosen by the network, but without earning payments. If the proxyAccountID
             * account refuses to accept proxy staking , or if it is not currently running a node, then it
             * will behave as if  proxyAccountID was null.
             */
            public proxyAccountID?: (hashgraph.proto.IAccountID|null);

            /** the instance will charge its account every this many seconds to renew for this long */
            public autoRenewPeriod?: (hashgraph.proto.IDuration|null);

            /** parameters to pass to the constructor */
            public constructorParameters: Uint8Array;

            /** shard in which to create this */
            public shardID?: (hashgraph.proto.IShardID|null);

            /** realm in which to create this (leave this null to create a new realm) */
            public realmID?: (hashgraph.proto.IRealmID|null);

            /** if realmID is null, then this the admin key for the new realm that will be created */
            public newRealmAdminKey?: (hashgraph.proto.IKey|null);

            /** the memo that was submitted as part of the contract (max 100 bytes) */
            public memo: string;

            /**
             * The maximum number of tokens that this contract can be automatically associated
             * with (i.e., receive air-drops from).
             */
            public maxAutomaticTokenAssociations: number;

            /**
             * An account to charge for auto-renewal of this contract. If not set, or set to an
             * account with zero hbar balance, the contract's own hbar balance will be used to
             * cover auto-renewal fees.
             */
            public autoRenewAccountId?: (hashgraph.proto.IAccountID|null);

            /** ID of the account to which this contract is staking. */
            public stakedAccountId?: (hashgraph.proto.IAccountID|null);

            /** ID of the node this contract is staked to. */
            public stakedNodeId?: (Long|null);

            /** If true, the contract declines receiving a staking reward. The default value is false. */
            public declineReward: boolean;

            /**
             * There are two ways to specify the initcode of a ContractCreateTransction. If the initcode is
             * large (> 5K) then it must be stored in a file as hex encoded ascii. If it is small then it may
             * either be stored as a hex encoded file or as a binary encoded field as part of the transaciton.
             */
            public initcodeSource?: ("fileID"|"initcode");

            /** ID of the new account or node to which this contract is staking. */
            public stakedId?: ("stakedAccountId"|"stakedNodeId");

            /**
             * Creates a new ContractCreateTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ContractCreateTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.IContractCreateTransactionBody): hashgraph.proto.ContractCreateTransactionBody;

            /**
             * Encodes the specified ContractCreateTransactionBody message. Does not implicitly {@link hashgraph.proto.ContractCreateTransactionBody.verify|verify} messages.
             * @param m ContractCreateTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IContractCreateTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ContractCreateTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ContractCreateTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ContractCreateTransactionBody;

            /**
             * Gets the default type url for ContractCreateTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ContractUpdateTransactionBody. */
        interface IContractUpdateTransactionBody {

            /** The id of the contract to be updated */
            contractID?: (hashgraph.proto.IContractID|null);

            /**
             * The new expiry of the contract, no earlier than the current expiry (resolves to
             * EXPIRATION_REDUCTION_NOT_ALLOWED otherwise)
             */
            expirationTime?: (hashgraph.proto.ITimestamp|null);

            /** The new key to control updates to the contract */
            adminKey?: (hashgraph.proto.IKey|null);

            /** [Deprecated] The new id of the account to which the contract is proxy staked */
            proxyAccountID?: (hashgraph.proto.IAccountID|null);

            /** If an auto-renew account is in use, the lifetime to be added by each auto-renewal. */
            autoRenewPeriod?: (hashgraph.proto.IDuration|null);

            /** This field is unused and will have no impact on the specified smart contract. */
            fileID?: (hashgraph.proto.IFileID|null);

            /**
             * [Deprecated] If set with a non-zero length, the new memo to be associated with the account
             * (UTF-8 encoding max 100 bytes)
             */
            memo?: (string|null);

            /** If set, the new memo to be associated with the account (UTF-8 encoding max 100 bytes) */
            memoWrapper?: (google.protobuf.IStringValue|null);

            /**
             * If set, the new maximum number of tokens that this contract can be
             * automatically associated with (i.e., receive air-drops from).
             */
            maxAutomaticTokenAssociations?: (google.protobuf.IInt32Value|null);

            /**
             * If set to the sentinel <tt>0.0.0</tt> AccountID, this field removes the contract's auto-renew
             * account. Otherwise it updates the contract's auto-renew account to the referenced account.
             */
            autoRenewAccountId?: (hashgraph.proto.IAccountID|null);

            /**
             * ID of the new account to which this contract is staking. If set to the sentinel <tt>0.0.0</tt> AccountID,
             * this field removes the contract's staked account ID.
             */
            stakedAccountId?: (hashgraph.proto.IAccountID|null);

            /**
             * ID of the new node this contract is staked to. If set to the sentinel <tt>-1</tt>, this field
             * removes the contract's staked node ID.
             */
            stakedNodeId?: (Long|null);

            /** If true, the contract declines receiving a staking reward. */
            declineReward?: (google.protobuf.IBoolValue|null);
        }

        /**
         * At consensus, updates the fields of a smart contract to the given values.
         *
         * If no value is given for a field, that field is left unchanged on the contract. For an immutable
         * smart contract (that is, a contract created without an adminKey), only the expirationTime may be
         * updated; setting any other field in this case will cause the transaction status to resolve to
         * MODIFYING_IMMUTABLE_CONTRACT.
         *
         * --- Signing Requirements ---
         * 1. Whether or not a contract has an admin key, its expiry can be extended with only the
         * transaction payer's signature.
         * 2. Updating any other field of a mutable contract requires the admin key's signature.
         * 3. If the update transaction includes a new admin key, this new key must also sign <b>unless</b>
         * it is exactly an empty <tt>KeyList</tt>. This special sentinel key removes the existing admin
         * key and causes the contract to become immutable. (Other <tt>Key</tt> structures without a
         * constituent <tt>Ed25519</tt> key will be rejected with <tt>INVALID_ADMIN_KEY</tt>.)
         * 4. If the update transaction sets the AccountID auto_renew_account_id wrapper field to anything
         * other than the sentinel <tt>0.0.0</tt> value, then the key of the referenced account must sign.
         */
        class ContractUpdateTransactionBody implements IContractUpdateTransactionBody {

            /**
             * Constructs a new ContractUpdateTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IContractUpdateTransactionBody);

            /** The id of the contract to be updated */
            public contractID?: (hashgraph.proto.IContractID|null);

            /**
             * The new expiry of the contract, no earlier than the current expiry (resolves to
             * EXPIRATION_REDUCTION_NOT_ALLOWED otherwise)
             */
            public expirationTime?: (hashgraph.proto.ITimestamp|null);

            /** The new key to control updates to the contract */
            public adminKey?: (hashgraph.proto.IKey|null);

            /** [Deprecated] The new id of the account to which the contract is proxy staked */
            public proxyAccountID?: (hashgraph.proto.IAccountID|null);

            /** If an auto-renew account is in use, the lifetime to be added by each auto-renewal. */
            public autoRenewPeriod?: (hashgraph.proto.IDuration|null);

            /** This field is unused and will have no impact on the specified smart contract. */
            public fileID?: (hashgraph.proto.IFileID|null);

            /**
             * [Deprecated] If set with a non-zero length, the new memo to be associated with the account
             * (UTF-8 encoding max 100 bytes)
             */
            public memo?: (string|null);

            /** If set, the new memo to be associated with the account (UTF-8 encoding max 100 bytes) */
            public memoWrapper?: (google.protobuf.IStringValue|null);

            /**
             * If set, the new maximum number of tokens that this contract can be
             * automatically associated with (i.e., receive air-drops from).
             */
            public maxAutomaticTokenAssociations?: (google.protobuf.IInt32Value|null);

            /**
             * If set to the sentinel <tt>0.0.0</tt> AccountID, this field removes the contract's auto-renew
             * account. Otherwise it updates the contract's auto-renew account to the referenced account.
             */
            public autoRenewAccountId?: (hashgraph.proto.IAccountID|null);

            /**
             * ID of the new account to which this contract is staking. If set to the sentinel <tt>0.0.0</tt> AccountID,
             * this field removes the contract's staked account ID.
             */
            public stakedAccountId?: (hashgraph.proto.IAccountID|null);

            /**
             * ID of the new node this contract is staked to. If set to the sentinel <tt>-1</tt>, this field
             * removes the contract's staked node ID.
             */
            public stakedNodeId?: (Long|null);

            /** If true, the contract declines receiving a staking reward. */
            public declineReward?: (google.protobuf.IBoolValue|null);

            /** The new contract memo, assumed to be Unicode encoded with UTF-8 (at most 100 bytes) */
            public memoField?: ("memo"|"memoWrapper");

            /** ID of the new account or node to which this contract is staking. */
            public stakedId?: ("stakedAccountId"|"stakedNodeId");

            /**
             * Creates a new ContractUpdateTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ContractUpdateTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.IContractUpdateTransactionBody): hashgraph.proto.ContractUpdateTransactionBody;

            /**
             * Encodes the specified ContractUpdateTransactionBody message. Does not implicitly {@link hashgraph.proto.ContractUpdateTransactionBody.verify|verify} messages.
             * @param m ContractUpdateTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IContractUpdateTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ContractUpdateTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ContractUpdateTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ContractUpdateTransactionBody;

            /**
             * Gets the default type url for ContractUpdateTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a LiveHash. */
        interface ILiveHash {

            /** The account to which the livehash is attached */
            accountId?: (hashgraph.proto.IAccountID|null);

            /** The SHA-384 hash of a credential or certificate */
            hash?: (Uint8Array|null);

            /** A list of keys (primitive or threshold), all of which must sign to attach the livehash to an account, and any one of which can later delete it. */
            keys?: (hashgraph.proto.IKeyList|null);

            /** The duration for which the livehash will remain valid */
            duration?: (hashgraph.proto.IDuration|null);
        }

        /**
         * A hash---presumably of some kind of credential or certificate---along with a list of keys, each
         * of which may be either a primitive or a threshold key.
         */
        class LiveHash implements ILiveHash {

            /**
             * Constructs a new LiveHash.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ILiveHash);

            /** The account to which the livehash is attached */
            public accountId?: (hashgraph.proto.IAccountID|null);

            /** The SHA-384 hash of a credential or certificate */
            public hash: Uint8Array;

            /** A list of keys (primitive or threshold), all of which must sign to attach the livehash to an account, and any one of which can later delete it. */
            public keys?: (hashgraph.proto.IKeyList|null);

            /** The duration for which the livehash will remain valid */
            public duration?: (hashgraph.proto.IDuration|null);

            /**
             * Creates a new LiveHash instance using the specified properties.
             * @param [properties] Properties to set
             * @returns LiveHash instance
             */
            public static create(properties?: hashgraph.proto.ILiveHash): hashgraph.proto.LiveHash;

            /**
             * Encodes the specified LiveHash message. Does not implicitly {@link hashgraph.proto.LiveHash.verify|verify} messages.
             * @param m LiveHash message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ILiveHash, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a LiveHash message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns LiveHash
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.LiveHash;

            /**
             * Gets the default type url for LiveHash
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a CryptoAddLiveHashTransactionBody. */
        interface ICryptoAddLiveHashTransactionBody {

            /** A hash of some credential or certificate, along with the keys of the entities that asserted it validity */
            liveHash?: (hashgraph.proto.ILiveHash|null);
        }

        /**
         * At consensus, attaches the given livehash to the given account.  The hash can be deleted by the
         * key controlling the account, or by any of the keys associated to the livehash.  Hence livehashes
         * provide a revocation service for their implied credentials; for example, when an authority grants
         * a credential to the account, the account owner will cosign with the authority (or authorities) to
         * attach a hash of the credential to the account---hence proving the grant. If the credential is
         * revoked, then any of the authorities may delete it (or the account owner). In this way, the
         * livehash mechanism acts as a revocation service.  An account cannot have two identical livehashes
         * associated. To modify the list of keys in a livehash, the livehash should first be deleted, then
         * recreated with a new list of keys.
         */
        class CryptoAddLiveHashTransactionBody implements ICryptoAddLiveHashTransactionBody {

            /**
             * Constructs a new CryptoAddLiveHashTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ICryptoAddLiveHashTransactionBody);

            /** A hash of some credential or certificate, along with the keys of the entities that asserted it validity */
            public liveHash?: (hashgraph.proto.ILiveHash|null);

            /**
             * Creates a new CryptoAddLiveHashTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns CryptoAddLiveHashTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.ICryptoAddLiveHashTransactionBody): hashgraph.proto.CryptoAddLiveHashTransactionBody;

            /**
             * Encodes the specified CryptoAddLiveHashTransactionBody message. Does not implicitly {@link hashgraph.proto.CryptoAddLiveHashTransactionBody.verify|verify} messages.
             * @param m CryptoAddLiveHashTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ICryptoAddLiveHashTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a CryptoAddLiveHashTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns CryptoAddLiveHashTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.CryptoAddLiveHashTransactionBody;

            /**
             * Gets the default type url for CryptoAddLiveHashTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a CryptoCreateTransactionBody. */
        interface ICryptoCreateTransactionBody {

            /**
             * The key that must sign each transfer out of the account. If receiverSigRequired is true, then
             * it must also sign any transfer into the account.
             */
            key?: (hashgraph.proto.IKey|null);

            /** The initial number of tinybars to put into the account */
            initialBalance?: (Long|null);

            /**
             * [Deprecated] ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an
             * invalid account, or is an account that isn't a node, then this account is automatically proxy
             * staked to a node chosen by the network, but without earning payments. If the proxyAccountID
             * account refuses to accept proxy staking , or if it is not currently running a node, then it
             * will behave as if proxyAccountID was null.
             */
            proxyAccountID?: (hashgraph.proto.IAccountID|null);

            /**
             * [Deprecated]. The threshold amount (in tinybars) for which an account record is created for
             * any send/withdraw transaction
             */
            sendRecordThreshold?: (Long|null);

            /**
             * [Deprecated]. The threshold amount (in tinybars) for which an account record is created for
             * any receive/deposit transaction
             */
            receiveRecordThreshold?: (Long|null);

            /**
             * If true, this account's key must sign any transaction depositing into this account (in
             * addition to all withdrawals)
             */
            receiverSigRequired?: (boolean|null);

            /**
             * The account is charged to extend its expiration date every this many seconds. If it doesn't
             * have enough balance, it extends as long as possible. If it is empty when it expires, then it
             * is deleted.
             */
            autoRenewPeriod?: (hashgraph.proto.IDuration|null);

            /** The shard in which this account is created */
            shardID?: (hashgraph.proto.IShardID|null);

            /** The realm in which this account is created (leave this null to create a new realm) */
            realmID?: (hashgraph.proto.IRealmID|null);

            /** If realmID is null, then this the admin key for the new realm that will be created */
            newRealmAdminKey?: (hashgraph.proto.IKey|null);

            /** The memo associated with the account (UTF-8 encoding max 100 bytes) */
            memo?: (string|null);

            /**
             * The maximum number of tokens that an Account can be implicitly associated with. Defaults to 0
             * and up to a maximum value of 1000.
             */
            maxAutomaticTokenAssociations?: (number|null);

            /** ID of the account to which this account is staking. */
            stakedAccountId?: (hashgraph.proto.IAccountID|null);

            /** ID of the node this account is staked to. */
            stakedNodeId?: (Long|null);

            /** If true, the account declines receiving a staking reward. The default value is false. */
            declineReward?: (boolean|null);

            /**
             * The bytes to be used as the account's alias. It will be the
             * serialization of a protobuf Key message for an ED25519/ECDSA_SECP256K1 primitive key type. Currently only primitive key bytes are
             * supported as the key for an account with an alias. ThresholdKey, KeyList, ContractID, and
             * delegatable_contract_id are not supported.
             *
             * May also be the EOA 20-byte address to create that is derived from the keccak-256 hash of a ECDSA_SECP256K1 primitive key.
             *
             * A given alias can map to at most one account on the network at a time. This uniqueness will be enforced
             * relative to aliases currently on the network at alias assignment.
             *
             * If a transaction creates an account using an alias, any further crypto transfers to that alias will
             * simply be deposited in that account, without creating anything, and with no creation fee being charged.
             */
            alias?: (Uint8Array|null);
        }

        /** Represents a CryptoCreateTransactionBody. */
        class CryptoCreateTransactionBody implements ICryptoCreateTransactionBody {

            /**
             * Constructs a new CryptoCreateTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ICryptoCreateTransactionBody);

            /**
             * The key that must sign each transfer out of the account. If receiverSigRequired is true, then
             * it must also sign any transfer into the account.
             */
            public key?: (hashgraph.proto.IKey|null);

            /** The initial number of tinybars to put into the account */
            public initialBalance: Long;

            /**
             * [Deprecated] ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an
             * invalid account, or is an account that isn't a node, then this account is automatically proxy
             * staked to a node chosen by the network, but without earning payments. If the proxyAccountID
             * account refuses to accept proxy staking , or if it is not currently running a node, then it
             * will behave as if proxyAccountID was null.
             */
            public proxyAccountID?: (hashgraph.proto.IAccountID|null);

            /**
             * [Deprecated]. The threshold amount (in tinybars) for which an account record is created for
             * any send/withdraw transaction
             */
            public sendRecordThreshold: Long;

            /**
             * [Deprecated]. The threshold amount (in tinybars) for which an account record is created for
             * any receive/deposit transaction
             */
            public receiveRecordThreshold: Long;

            /**
             * If true, this account's key must sign any transaction depositing into this account (in
             * addition to all withdrawals)
             */
            public receiverSigRequired: boolean;

            /**
             * The account is charged to extend its expiration date every this many seconds. If it doesn't
             * have enough balance, it extends as long as possible. If it is empty when it expires, then it
             * is deleted.
             */
            public autoRenewPeriod?: (hashgraph.proto.IDuration|null);

            /** The shard in which this account is created */
            public shardID?: (hashgraph.proto.IShardID|null);

            /** The realm in which this account is created (leave this null to create a new realm) */
            public realmID?: (hashgraph.proto.IRealmID|null);

            /** If realmID is null, then this the admin key for the new realm that will be created */
            public newRealmAdminKey?: (hashgraph.proto.IKey|null);

            /** The memo associated with the account (UTF-8 encoding max 100 bytes) */
            public memo: string;

            /**
             * The maximum number of tokens that an Account can be implicitly associated with. Defaults to 0
             * and up to a maximum value of 1000.
             */
            public maxAutomaticTokenAssociations: number;

            /** ID of the account to which this account is staking. */
            public stakedAccountId?: (hashgraph.proto.IAccountID|null);

            /** ID of the node this account is staked to. */
            public stakedNodeId?: (Long|null);

            /** If true, the account declines receiving a staking reward. The default value is false. */
            public declineReward: boolean;

            /**
             * The bytes to be used as the account's alias. It will be the
             * serialization of a protobuf Key message for an ED25519/ECDSA_SECP256K1 primitive key type. Currently only primitive key bytes are
             * supported as the key for an account with an alias. ThresholdKey, KeyList, ContractID, and
             * delegatable_contract_id are not supported.
             *
             * May also be the EOA 20-byte address to create that is derived from the keccak-256 hash of a ECDSA_SECP256K1 primitive key.
             *
             * A given alias can map to at most one account on the network at a time. This uniqueness will be enforced
             * relative to aliases currently on the network at alias assignment.
             *
             * If a transaction creates an account using an alias, any further crypto transfers to that alias will
             * simply be deposited in that account, without creating anything, and with no creation fee being charged.
             */
            public alias: Uint8Array;

            /** ID of the account or node to which this account is staking. */
            public stakedId?: ("stakedAccountId"|"stakedNodeId");

            /**
             * Creates a new CryptoCreateTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns CryptoCreateTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.ICryptoCreateTransactionBody): hashgraph.proto.CryptoCreateTransactionBody;

            /**
             * Encodes the specified CryptoCreateTransactionBody message. Does not implicitly {@link hashgraph.proto.CryptoCreateTransactionBody.verify|verify} messages.
             * @param m CryptoCreateTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ICryptoCreateTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a CryptoCreateTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns CryptoCreateTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.CryptoCreateTransactionBody;

            /**
             * Gets the default type url for CryptoCreateTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a CryptoDeleteTransactionBody. */
        interface ICryptoDeleteTransactionBody {

            /** The account ID which will receive all remaining hbars */
            transferAccountID?: (hashgraph.proto.IAccountID|null);

            /** The account ID which should be deleted */
            deleteAccountID?: (hashgraph.proto.IAccountID|null);
        }

        /**
         * Mark an account as deleted, moving all its current hbars to another account. It will remain in
         * the ledger, marked as deleted, until it expires. Transfers into it a deleted account fail. But a
         * deleted account can still have its expiration extended in the normal way.
         */
        class CryptoDeleteTransactionBody implements ICryptoDeleteTransactionBody {

            /**
             * Constructs a new CryptoDeleteTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ICryptoDeleteTransactionBody);

            /** The account ID which will receive all remaining hbars */
            public transferAccountID?: (hashgraph.proto.IAccountID|null);

            /** The account ID which should be deleted */
            public deleteAccountID?: (hashgraph.proto.IAccountID|null);

            /**
             * Creates a new CryptoDeleteTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns CryptoDeleteTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.ICryptoDeleteTransactionBody): hashgraph.proto.CryptoDeleteTransactionBody;

            /**
             * Encodes the specified CryptoDeleteTransactionBody message. Does not implicitly {@link hashgraph.proto.CryptoDeleteTransactionBody.verify|verify} messages.
             * @param m CryptoDeleteTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ICryptoDeleteTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a CryptoDeleteTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns CryptoDeleteTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.CryptoDeleteTransactionBody;

            /**
             * Gets the default type url for CryptoDeleteTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a CryptoDeleteLiveHashTransactionBody. */
        interface ICryptoDeleteLiveHashTransactionBody {

            /** The account owning the livehash */
            accountOfLiveHash?: (hashgraph.proto.IAccountID|null);

            /** The SHA-384 livehash to delete from the account */
            liveHashToDelete?: (Uint8Array|null);
        }

        /**
         * At consensus, deletes a livehash associated to the given account. The transaction must be signed
         * by either the key of the owning account, or at least one of the keys associated to the livehash.
         */
        class CryptoDeleteLiveHashTransactionBody implements ICryptoDeleteLiveHashTransactionBody {

            /**
             * Constructs a new CryptoDeleteLiveHashTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ICryptoDeleteLiveHashTransactionBody);

            /** The account owning the livehash */
            public accountOfLiveHash?: (hashgraph.proto.IAccountID|null);

            /** The SHA-384 livehash to delete from the account */
            public liveHashToDelete: Uint8Array;

            /**
             * Creates a new CryptoDeleteLiveHashTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns CryptoDeleteLiveHashTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.ICryptoDeleteLiveHashTransactionBody): hashgraph.proto.CryptoDeleteLiveHashTransactionBody;

            /**
             * Encodes the specified CryptoDeleteLiveHashTransactionBody message. Does not implicitly {@link hashgraph.proto.CryptoDeleteLiveHashTransactionBody.verify|verify} messages.
             * @param m CryptoDeleteLiveHashTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ICryptoDeleteLiveHashTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a CryptoDeleteLiveHashTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns CryptoDeleteLiveHashTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.CryptoDeleteLiveHashTransactionBody;

            /**
             * Gets the default type url for CryptoDeleteLiveHashTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a CryptoTransferTransactionBody. */
        interface ICryptoTransferTransactionBody {

            /** The desired hbar balance adjustments */
            transfers?: (hashgraph.proto.ITransferList|null);

            /**
             * The desired token unit balance adjustments; if any custom fees are assessed, the ledger will
             * try to deduct them from the payer of this CryptoTransfer, resolving the transaction to
             * INSUFFICIENT_PAYER_BALANCE_FOR_CUSTOM_FEE if this is not possible
             */
            tokenTransfers?: (hashgraph.proto.ITokenTransferList[]|null);
        }

        /**
         * Transfers cryptocurrency among two or more accounts by making the desired adjustments to their
         * balances. Each transfer list can specify up to 10 adjustments. Each negative amount is withdrawn
         * from the corresponding account (a sender), and each positive one is added to the corresponding
         * account (a receiver). The amounts list must sum to zero. Each amount is a number of tinybars
         * (there are 100,000,000 tinybars in one hbar).  If any sender account fails to have sufficient
         * hbars, then the entire transaction fails, and none of those transfers occur, though the
         * transaction fee is still charged. This transaction must be signed by the keys for all the sending
         * accounts, and for any receiving accounts that have receiverSigRequired == true. The signatures
         * are in the same order as the accounts, skipping those accounts that don't need a signature.
         */
        class CryptoTransferTransactionBody implements ICryptoTransferTransactionBody {

            /**
             * Constructs a new CryptoTransferTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ICryptoTransferTransactionBody);

            /** The desired hbar balance adjustments */
            public transfers?: (hashgraph.proto.ITransferList|null);

            /**
             * The desired token unit balance adjustments; if any custom fees are assessed, the ledger will
             * try to deduct them from the payer of this CryptoTransfer, resolving the transaction to
             * INSUFFICIENT_PAYER_BALANCE_FOR_CUSTOM_FEE if this is not possible
             */
            public tokenTransfers: hashgraph.proto.ITokenTransferList[];

            /**
             * Creates a new CryptoTransferTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns CryptoTransferTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.ICryptoTransferTransactionBody): hashgraph.proto.CryptoTransferTransactionBody;

            /**
             * Encodes the specified CryptoTransferTransactionBody message. Does not implicitly {@link hashgraph.proto.CryptoTransferTransactionBody.verify|verify} messages.
             * @param m CryptoTransferTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ICryptoTransferTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a CryptoTransferTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns CryptoTransferTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.CryptoTransferTransactionBody;

            /**
             * Gets the default type url for CryptoTransferTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a CryptoUpdateTransactionBody. */
        interface ICryptoUpdateTransactionBody {

            /** The account ID which is being updated in this transaction */
            accountIDToUpdate?: (hashgraph.proto.IAccountID|null);

            /** The new key */
            key?: (hashgraph.proto.IKey|null);

            /**
             * [Deprecated] ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an
             * invalid account, or is an account that isn't a node, then this account is automatically proxy
             * staked to a node chosen by the network, but without earning payments. If the proxyAccountID
             * account refuses to accept proxy staking , or if it is not currently running a node, then it
             * will behave as if proxyAccountID was null.
             */
            proxyAccountID?: (hashgraph.proto.IAccountID|null);

            /**
             * [Deprecated]. Payments earned from proxy staking are shared between the node and this
             * account, with proxyFraction / 10000 going to this account
             */
            proxyFraction?: (number|null);

            /**
             * [Deprecated]. The new threshold amount (in tinybars) for which an account record is
             * created for any send/withdraw transaction
             */
            sendRecordThreshold?: (Long|null);

            /**
             * [Deprecated]. The new threshold amount (in tinybars) for which an account record is
             * created for any send/withdraw transaction
             */
            sendRecordThresholdWrapper?: (google.protobuf.IUInt64Value|null);

            /**
             * [Deprecated]. The new threshold amount (in tinybars) for which an account record is
             * created for any receive/deposit transaction.
             */
            receiveRecordThreshold?: (Long|null);

            /**
             * [Deprecated]. The new threshold amount (in tinybars) for which an account record is
             * created for any receive/deposit transaction.
             */
            receiveRecordThresholdWrapper?: (google.protobuf.IUInt64Value|null);

            /**
             * The duration in which it will automatically extend the expiration period. If it doesn't have
             * enough balance, it extends as long as possible. If it is empty when it expires, then it is
             * deleted.
             */
            autoRenewPeriod?: (hashgraph.proto.IDuration|null);

            /** The new expiration time to extend to (ignored if equal to or before the current one) */
            expirationTime?: (hashgraph.proto.ITimestamp|null);

            /**
             * [Deprecated] Do NOT use this field to set a false value because the server cannot
             * distinguish from the default value. Use receiverSigRequiredWrapper field for this
             * purpose.
             */
            receiverSigRequired?: (boolean|null);

            /**
             * If true, this account's key must sign any transaction depositing into this account (in
             * addition to all withdrawals)
             */
            receiverSigRequiredWrapper?: (google.protobuf.IBoolValue|null);

            /** If set, the new memo to be associated with the account (UTF-8 encoding max 100 bytes) */
            memo?: (google.protobuf.IStringValue|null);

            /**
             * The maximum number of tokens that an Account can be implicitly associated with. Up to a 1000
             * including implicit and explicit associations.
             */
            maxAutomaticTokenAssociations?: (google.protobuf.IInt32Value|null);

            /**
             * ID of the new account to which this account is staking. If set to the sentinel <tt>0.0.0</tt> AccountID,
             * this field removes this account's staked account ID.
             */
            stakedAccountId?: (hashgraph.proto.IAccountID|null);

            /**
             * ID of the new node this account is staked to. If set to the sentinel <tt>-1</tt>, this field
             * removes this account's staked node ID.
             */
            stakedNodeId?: (Long|null);

            /** If true, the account declines receiving a staking reward. The default value is false. */
            declineReward?: (google.protobuf.IBoolValue|null);
        }

        /**
         * Change properties for the given account. Any null field is ignored (left unchanged). This
         * transaction must be signed by the existing key for this account. If the transaction is changing
         * the key field, then the transaction must be signed by both the old key (from before the change)
         * and the new key. The old key must sign for security. The new key must sign as a safeguard to
         * avoid accidentally changing to an invalid key, and then having no way to recover.
         * If the update transaction sets the <tt>auto_renew_account</tt> field to anything other
         * than the sentinel <tt>0.0.0</tt>, the key of the referenced account must sign.
         */
        class CryptoUpdateTransactionBody implements ICryptoUpdateTransactionBody {

            /**
             * Constructs a new CryptoUpdateTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ICryptoUpdateTransactionBody);

            /** The account ID which is being updated in this transaction */
            public accountIDToUpdate?: (hashgraph.proto.IAccountID|null);

            /** The new key */
            public key?: (hashgraph.proto.IKey|null);

            /**
             * [Deprecated] ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an
             * invalid account, or is an account that isn't a node, then this account is automatically proxy
             * staked to a node chosen by the network, but without earning payments. If the proxyAccountID
             * account refuses to accept proxy staking , or if it is not currently running a node, then it
             * will behave as if proxyAccountID was null.
             */
            public proxyAccountID?: (hashgraph.proto.IAccountID|null);

            /**
             * [Deprecated]. Payments earned from proxy staking are shared between the node and this
             * account, with proxyFraction / 10000 going to this account
             */
            public proxyFraction: number;

            /**
             * [Deprecated]. The new threshold amount (in tinybars) for which an account record is
             * created for any send/withdraw transaction
             */
            public sendRecordThreshold?: (Long|null);

            /**
             * [Deprecated]. The new threshold amount (in tinybars) for which an account record is
             * created for any send/withdraw transaction
             */
            public sendRecordThresholdWrapper?: (google.protobuf.IUInt64Value|null);

            /**
             * [Deprecated]. The new threshold amount (in tinybars) for which an account record is
             * created for any receive/deposit transaction.
             */
            public receiveRecordThreshold?: (Long|null);

            /**
             * [Deprecated]. The new threshold amount (in tinybars) for which an account record is
             * created for any receive/deposit transaction.
             */
            public receiveRecordThresholdWrapper?: (google.protobuf.IUInt64Value|null);

            /**
             * The duration in which it will automatically extend the expiration period. If it doesn't have
             * enough balance, it extends as long as possible. If it is empty when it expires, then it is
             * deleted.
             */
            public autoRenewPeriod?: (hashgraph.proto.IDuration|null);

            /** The new expiration time to extend to (ignored if equal to or before the current one) */
            public expirationTime?: (hashgraph.proto.ITimestamp|null);

            /**
             * [Deprecated] Do NOT use this field to set a false value because the server cannot
             * distinguish from the default value. Use receiverSigRequiredWrapper field for this
             * purpose.
             */
            public receiverSigRequired?: (boolean|null);

            /**
             * If true, this account's key must sign any transaction depositing into this account (in
             * addition to all withdrawals)
             */
            public receiverSigRequiredWrapper?: (google.protobuf.IBoolValue|null);

            /** If set, the new memo to be associated with the account (UTF-8 encoding max 100 bytes) */
            public memo?: (google.protobuf.IStringValue|null);

            /**
             * The maximum number of tokens that an Account can be implicitly associated with. Up to a 1000
             * including implicit and explicit associations.
             */
            public maxAutomaticTokenAssociations?: (google.protobuf.IInt32Value|null);

            /**
             * ID of the new account to which this account is staking. If set to the sentinel <tt>0.0.0</tt> AccountID,
             * this field removes this account's staked account ID.
             */
            public stakedAccountId?: (hashgraph.proto.IAccountID|null);

            /**
             * ID of the new node this account is staked to. If set to the sentinel <tt>-1</tt>, this field
             * removes this account's staked node ID.
             */
            public stakedNodeId?: (Long|null);

            /** If true, the account declines receiving a staking reward. The default value is false. */
            public declineReward?: (google.protobuf.IBoolValue|null);

            /** CryptoUpdateTransactionBody sendRecordThresholdField. */
            public sendRecordThresholdField?: ("sendRecordThreshold"|"sendRecordThresholdWrapper");

            /** CryptoUpdateTransactionBody receiveRecordThresholdField. */
            public receiveRecordThresholdField?: ("receiveRecordThreshold"|"receiveRecordThresholdWrapper");

            /** CryptoUpdateTransactionBody receiverSigRequiredField. */
            public receiverSigRequiredField?: ("receiverSigRequired"|"receiverSigRequiredWrapper");

            /** ID of the account or node to which this account is staking. */
            public stakedId?: ("stakedAccountId"|"stakedNodeId");

            /**
             * Creates a new CryptoUpdateTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns CryptoUpdateTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.ICryptoUpdateTransactionBody): hashgraph.proto.CryptoUpdateTransactionBody;

            /**
             * Encodes the specified CryptoUpdateTransactionBody message. Does not implicitly {@link hashgraph.proto.CryptoUpdateTransactionBody.verify|verify} messages.
             * @param m CryptoUpdateTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ICryptoUpdateTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a CryptoUpdateTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns CryptoUpdateTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.CryptoUpdateTransactionBody;

            /**
             * Gets the default type url for CryptoUpdateTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a CryptoApproveAllowanceTransactionBody. */
        interface ICryptoApproveAllowanceTransactionBody {

            /** List of hbar allowances approved by the account owner. */
            cryptoAllowances?: (hashgraph.proto.ICryptoAllowance[]|null);

            /** List of non-fungible token allowances approved by the account owner. */
            nftAllowances?: (hashgraph.proto.INftAllowance[]|null);

            /** List of fungible token allowances approved by the account owner. */
            tokenAllowances?: (hashgraph.proto.ITokenAllowance[]|null);
        }

        /**
         * Creates one or more hbar/token approved allowances <b>relative to the owner account specified in the allowances of
         * this transaction</b>. Each allowance grants a spender the right to transfer a pre-determined amount of the owner's
         * hbar/token to any other account of the spender's choice. If the owner is not specified in any allowance, the payer
         * of transaction is considered to be the owner for that particular allowance.
         * Setting the amount to zero in CryptoAllowance or TokenAllowance will remove the respective allowance for the spender.
         *
         * (So if account <tt>0.0.X</tt> pays for this transaction and owner is not specified in the allowance,
         * then at consensus each spender account will have new allowances to spend hbar or tokens from <tt>0.0.X</tt>).
         */
        class CryptoApproveAllowanceTransactionBody implements ICryptoApproveAllowanceTransactionBody {

            /**
             * Constructs a new CryptoApproveAllowanceTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ICryptoApproveAllowanceTransactionBody);

            /** List of hbar allowances approved by the account owner. */
            public cryptoAllowances: hashgraph.proto.ICryptoAllowance[];

            /** List of non-fungible token allowances approved by the account owner. */
            public nftAllowances: hashgraph.proto.INftAllowance[];

            /** List of fungible token allowances approved by the account owner. */
            public tokenAllowances: hashgraph.proto.ITokenAllowance[];

            /**
             * Creates a new CryptoApproveAllowanceTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns CryptoApproveAllowanceTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.ICryptoApproveAllowanceTransactionBody): hashgraph.proto.CryptoApproveAllowanceTransactionBody;

            /**
             * Encodes the specified CryptoApproveAllowanceTransactionBody message. Does not implicitly {@link hashgraph.proto.CryptoApproveAllowanceTransactionBody.verify|verify} messages.
             * @param m CryptoApproveAllowanceTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ICryptoApproveAllowanceTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a CryptoApproveAllowanceTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns CryptoApproveAllowanceTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.CryptoApproveAllowanceTransactionBody;

            /**
             * Gets the default type url for CryptoApproveAllowanceTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a CryptoAllowance. */
        interface ICryptoAllowance {

            /** The account ID of the hbar owner (ie. the grantor of the allowance). */
            owner?: (hashgraph.proto.IAccountID|null);

            /** The account ID of the spender of the hbar allowance. */
            spender?: (hashgraph.proto.IAccountID|null);

            /** The amount of the spender's allowance in tinybars. */
            amount?: (Long|null);
        }

        /** An approved allowance of hbar transfers for a spender. */
        class CryptoAllowance implements ICryptoAllowance {

            /**
             * Constructs a new CryptoAllowance.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ICryptoAllowance);

            /** The account ID of the hbar owner (ie. the grantor of the allowance). */
            public owner?: (hashgraph.proto.IAccountID|null);

            /** The account ID of the spender of the hbar allowance. */
            public spender?: (hashgraph.proto.IAccountID|null);

            /** The amount of the spender's allowance in tinybars. */
            public amount: Long;

            /**
             * Creates a new CryptoAllowance instance using the specified properties.
             * @param [properties] Properties to set
             * @returns CryptoAllowance instance
             */
            public static create(properties?: hashgraph.proto.ICryptoAllowance): hashgraph.proto.CryptoAllowance;

            /**
             * Encodes the specified CryptoAllowance message. Does not implicitly {@link hashgraph.proto.CryptoAllowance.verify|verify} messages.
             * @param m CryptoAllowance message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ICryptoAllowance, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a CryptoAllowance message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns CryptoAllowance
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.CryptoAllowance;

            /**
             * Gets the default type url for CryptoAllowance
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a NftAllowance. */
        interface INftAllowance {

            /** The NFT token type that the allowance pertains to. */
            tokenId?: (hashgraph.proto.ITokenID|null);

            /** The account ID of the token owner (ie. the grantor of the allowance). */
            owner?: (hashgraph.proto.IAccountID|null);

            /** The account ID of the token allowance spender. */
            spender?: (hashgraph.proto.IAccountID|null);

            /** The list of serial numbers that the spender is permitted to transfer. */
            serialNumbers?: (Long[]|null);

            /**
             * If true, the spender has access to all of the owner's NFT units of type tokenId (currently
             * owned and any in the future).
             */
            approvedForAll?: (google.protobuf.IBoolValue|null);

            /**
             * The account ID of the spender who is granted approvedForAll allowance and granting
             * approval on an NFT serial to another spender.
             */
            delegatingSpender?: (hashgraph.proto.IAccountID|null);
        }

        /** An approved allowance of non-fungible token transfers for a spender. */
        class NftAllowance implements INftAllowance {

            /**
             * Constructs a new NftAllowance.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.INftAllowance);

            /** The NFT token type that the allowance pertains to. */
            public tokenId?: (hashgraph.proto.ITokenID|null);

            /** The account ID of the token owner (ie. the grantor of the allowance). */
            public owner?: (hashgraph.proto.IAccountID|null);

            /** The account ID of the token allowance spender. */
            public spender?: (hashgraph.proto.IAccountID|null);

            /** The list of serial numbers that the spender is permitted to transfer. */
            public serialNumbers: Long[];

            /**
             * If true, the spender has access to all of the owner's NFT units of type tokenId (currently
             * owned and any in the future).
             */
            public approvedForAll?: (google.protobuf.IBoolValue|null);

            /**
             * The account ID of the spender who is granted approvedForAll allowance and granting
             * approval on an NFT serial to another spender.
             */
            public delegatingSpender?: (hashgraph.proto.IAccountID|null);

            /**
             * Creates a new NftAllowance instance using the specified properties.
             * @param [properties] Properties to set
             * @returns NftAllowance instance
             */
            public static create(properties?: hashgraph.proto.INftAllowance): hashgraph.proto.NftAllowance;

            /**
             * Encodes the specified NftAllowance message. Does not implicitly {@link hashgraph.proto.NftAllowance.verify|verify} messages.
             * @param m NftAllowance message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.INftAllowance, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a NftAllowance message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns NftAllowance
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.NftAllowance;

            /**
             * Gets the default type url for NftAllowance
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenAllowance. */
        interface ITokenAllowance {

            /** The token that the allowance pertains to. */
            tokenId?: (hashgraph.proto.ITokenID|null);

            /** The account ID of the token owner (ie. the grantor of the allowance). */
            owner?: (hashgraph.proto.IAccountID|null);

            /** The account ID of the token allowance spender. */
            spender?: (hashgraph.proto.IAccountID|null);

            /** The amount of the spender's token allowance. */
            amount?: (Long|null);
        }

        /** An approved allowance of fungible token transfers for a spender. */
        class TokenAllowance implements ITokenAllowance {

            /**
             * Constructs a new TokenAllowance.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenAllowance);

            /** The token that the allowance pertains to. */
            public tokenId?: (hashgraph.proto.ITokenID|null);

            /** The account ID of the token owner (ie. the grantor of the allowance). */
            public owner?: (hashgraph.proto.IAccountID|null);

            /** The account ID of the token allowance spender. */
            public spender?: (hashgraph.proto.IAccountID|null);

            /** The amount of the spender's token allowance. */
            public amount: Long;

            /**
             * Creates a new TokenAllowance instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenAllowance instance
             */
            public static create(properties?: hashgraph.proto.ITokenAllowance): hashgraph.proto.TokenAllowance;

            /**
             * Encodes the specified TokenAllowance message. Does not implicitly {@link hashgraph.proto.TokenAllowance.verify|verify} messages.
             * @param m TokenAllowance message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenAllowance, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenAllowance message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenAllowance
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenAllowance;

            /**
             * Gets the default type url for TokenAllowance
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a CryptoDeleteAllowanceTransactionBody. */
        interface ICryptoDeleteAllowanceTransactionBody {

            /** List of non-fungible token allowances to remove. */
            nftAllowances?: (hashgraph.proto.INftRemoveAllowance[]|null);
        }

        /**
         * Deletes one or more non-fungible approved allowances from an owner's account. This operation
         * will remove the allowances granted to one or more specific non-fungible token serial numbers. Each owner account
         * listed as wiping an allowance must sign the transaction. Hbar and fungible token allowances
         * can be removed by setting the amount to zero in CryptoApproveAllowance.
         */
        class CryptoDeleteAllowanceTransactionBody implements ICryptoDeleteAllowanceTransactionBody {

            /**
             * Constructs a new CryptoDeleteAllowanceTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ICryptoDeleteAllowanceTransactionBody);

            /** List of non-fungible token allowances to remove. */
            public nftAllowances: hashgraph.proto.INftRemoveAllowance[];

            /**
             * Creates a new CryptoDeleteAllowanceTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns CryptoDeleteAllowanceTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.ICryptoDeleteAllowanceTransactionBody): hashgraph.proto.CryptoDeleteAllowanceTransactionBody;

            /**
             * Encodes the specified CryptoDeleteAllowanceTransactionBody message. Does not implicitly {@link hashgraph.proto.CryptoDeleteAllowanceTransactionBody.verify|verify} messages.
             * @param m CryptoDeleteAllowanceTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ICryptoDeleteAllowanceTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a CryptoDeleteAllowanceTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns CryptoDeleteAllowanceTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.CryptoDeleteAllowanceTransactionBody;

            /**
             * Gets the default type url for CryptoDeleteAllowanceTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a NftRemoveAllowance. */
        interface INftRemoveAllowance {

            /** The token that the allowance pertains to. */
            tokenId?: (hashgraph.proto.ITokenID|null);

            /** The account ID of the token owner (ie. the grantor of the allowance). */
            owner?: (hashgraph.proto.IAccountID|null);

            /** The list of serial numbers to remove allowances from. */
            serialNumbers?: (Long[]|null);
        }

        /** Nft allowances to be removed on an owner account */
        class NftRemoveAllowance implements INftRemoveAllowance {

            /**
             * Constructs a new NftRemoveAllowance.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.INftRemoveAllowance);

            /** The token that the allowance pertains to. */
            public tokenId?: (hashgraph.proto.ITokenID|null);

            /** The account ID of the token owner (ie. the grantor of the allowance). */
            public owner?: (hashgraph.proto.IAccountID|null);

            /** The list of serial numbers to remove allowances from. */
            public serialNumbers: Long[];

            /**
             * Creates a new NftRemoveAllowance instance using the specified properties.
             * @param [properties] Properties to set
             * @returns NftRemoveAllowance instance
             */
            public static create(properties?: hashgraph.proto.INftRemoveAllowance): hashgraph.proto.NftRemoveAllowance;

            /**
             * Encodes the specified NftRemoveAllowance message. Does not implicitly {@link hashgraph.proto.NftRemoveAllowance.verify|verify} messages.
             * @param m NftRemoveAllowance message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.INftRemoveAllowance, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a NftRemoveAllowance message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns NftRemoveAllowance
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.NftRemoveAllowance;

            /**
             * Gets the default type url for NftRemoveAllowance
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of an EthereumTransactionBody. */
        interface IEthereumTransactionBody {

            /**
             * The raw Ethereum transaction (RLP encoded type 0, 1, and 2). Complete
             * unless the callData field is set.
             */
            ethereumData?: (Uint8Array|null);

            /**
             * For large transactions (for example contract create) this is the callData
             * of the ethereumData. The data in the ethereumData will be re-written with
             * the callData element as a zero length string with the original contents in
             * the referenced file at time of execution. The ethereumData will need to be
             * "rehydrated" with the callData for signature validation to pass.
             */
            callData?: (hashgraph.proto.IFileID|null);

            /**
             * The maximum amount, in tinybars, that the payer of the hedera transaction
             * is willing to pay to complete the transaction.
             *
             * Ordinarily the account with the ECDSA alias corresponding to the public
             * key that is extracted from the ethereum_data signature is responsible for
             * fees that result from the execution of the transaction. If that amount of
             * authorized fees is not sufficient then the payer of the transaction can be
             * charged, up to but not exceeding this amount. If the ethereum_data
             * transaction authorized an amount that was insufficient then the payer will
             * only be charged the amount needed to make up the difference. If the gas
             * price in the transaction was set to zero then the payer will be assessed
             * the entire fee.
             */
            maxGasAllowance?: (Long|null);
        }

        /** Represents an EthereumTransactionBody. */
        class EthereumTransactionBody implements IEthereumTransactionBody {

            /**
             * Constructs a new EthereumTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IEthereumTransactionBody);

            /**
             * The raw Ethereum transaction (RLP encoded type 0, 1, and 2). Complete
             * unless the callData field is set.
             */
            public ethereumData: Uint8Array;

            /**
             * For large transactions (for example contract create) this is the callData
             * of the ethereumData. The data in the ethereumData will be re-written with
             * the callData element as a zero length string with the original contents in
             * the referenced file at time of execution. The ethereumData will need to be
             * "rehydrated" with the callData for signature validation to pass.
             */
            public callData?: (hashgraph.proto.IFileID|null);

            /**
             * The maximum amount, in tinybars, that the payer of the hedera transaction
             * is willing to pay to complete the transaction.
             *
             * Ordinarily the account with the ECDSA alias corresponding to the public
             * key that is extracted from the ethereum_data signature is responsible for
             * fees that result from the execution of the transaction. If that amount of
             * authorized fees is not sufficient then the payer of the transaction can be
             * charged, up to but not exceeding this amount. If the ethereum_data
             * transaction authorized an amount that was insufficient then the payer will
             * only be charged the amount needed to make up the difference. If the gas
             * price in the transaction was set to zero then the payer will be assessed
             * the entire fee.
             */
            public maxGasAllowance: Long;

            /**
             * Creates a new EthereumTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns EthereumTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.IEthereumTransactionBody): hashgraph.proto.EthereumTransactionBody;

            /**
             * Encodes the specified EthereumTransactionBody message. Does not implicitly {@link hashgraph.proto.EthereumTransactionBody.verify|verify} messages.
             * @param m EthereumTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IEthereumTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an EthereumTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns EthereumTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.EthereumTransactionBody;

            /**
             * Gets the default type url for EthereumTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a FileAppendTransactionBody. */
        interface IFileAppendTransactionBody {

            /** The file to which the bytes will be appended */
            fileID?: (hashgraph.proto.IFileID|null);

            /** The bytes that will be appended to the end of the specified file */
            contents?: (Uint8Array|null);
        }

        /**
         * Append the given contents to the end of the specified file. If a file is too big to create with a
         * single FileCreateTransaction, then it can be created with the first part of its contents, and
         * then appended as many times as necessary to create the entire file. This transaction must be
         * signed by all initial M-of-M KeyList keys. If keys contains additional KeyList or ThresholdKey
         * then M-of-M secondary KeyList or ThresholdKey signing requirements must be meet.
         */
        class FileAppendTransactionBody implements IFileAppendTransactionBody {

            /**
             * Constructs a new FileAppendTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IFileAppendTransactionBody);

            /** The file to which the bytes will be appended */
            public fileID?: (hashgraph.proto.IFileID|null);

            /** The bytes that will be appended to the end of the specified file */
            public contents: Uint8Array;

            /**
             * Creates a new FileAppendTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns FileAppendTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.IFileAppendTransactionBody): hashgraph.proto.FileAppendTransactionBody;

            /**
             * Encodes the specified FileAppendTransactionBody message. Does not implicitly {@link hashgraph.proto.FileAppendTransactionBody.verify|verify} messages.
             * @param m FileAppendTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IFileAppendTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a FileAppendTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns FileAppendTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.FileAppendTransactionBody;

            /**
             * Gets the default type url for FileAppendTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a FileCreateTransactionBody. */
        interface IFileCreateTransactionBody {

            /**
             * The time at which this file should expire (unless FileUpdateTransaction is used before then
             * to extend its life)
             */
            expirationTime?: (hashgraph.proto.ITimestamp|null);

            /**
             * All keys at the top level of a key list must sign to create or modify the file. Any one of
             * the keys at the top level key list can sign to delete the file.
             */
            keys?: (hashgraph.proto.IKeyList|null);

            /** The bytes that are the contents of the file */
            contents?: (Uint8Array|null);

            /** Shard in which this file is created */
            shardID?: (hashgraph.proto.IShardID|null);

            /** The Realm in which to the file is created (leave this null to create a new realm) */
            realmID?: (hashgraph.proto.IRealmID|null);

            /** If realmID is null, then this the admin key for the new realm that will be created */
            newRealmAdminKey?: (hashgraph.proto.IKey|null);

            /** The memo associated with the file (UTF-8 encoding max 100 bytes) */
            memo?: (string|null);
        }

        /**
         * Create a new file, containing the given contents.
         * After the file is created, the FileID for it can be found in the receipt, or record, or retrieved
         * with a GetByKey query.
         *
         * The file contains the specified contents (possibly empty). The file will automatically disappear
         * at the expirationTime, unless its expiration is extended by another transaction before that time.
         * If the file is deleted, then its contents will become empty and it will be marked as deleted
         * until it expires, and then it will cease to exist.
         *
         * The keys field is a list of keys. All keys within the top-level key list must sign (M-M) to
         * create or modify a file. However, to delete the file, only one key (1-M) is required to sign from
         * the top-level key list.  Each of those "keys" may itself be threshold key containing other keys
         * (including other threshold keys). In other words, the behavior is an AND for create/modify, OR
         * for delete. This is useful for acting as a revocation server. If it is desired to have the
         * behavior be AND for all 3 operations (or OR for all 3), then the list should have only a single
         * Key, which is a threshold key, with N=1 for OR, N=M for AND. If the auto_renew_account field
         * is set, the key of the referenced account must sign.
         *
         * If a file is created without ANY keys in the keys field, the file is immutable and ONLY the
         * expirationTime of the file can be changed with a FileUpdate transaction. The file contents or its
         * keys cannot be changed.
         *
         * An entity (account, file, or smart contract instance) must be created in a particular realm. If
         * the realmID is left null, then a new realm will be created with the given admin key. If a new
         * realm has a null adminKey, then anyone can create/modify/delete entities in that realm. But if an
         * admin key is given, then any transaction to create/modify/delete an entity in that realm must be
         * signed by that key, though anyone can still call functions on smart contract instances that exist
         * in that realm. A realm ceases to exist when everything within it has expired and no longer
         * exists.
         *
         * The current API ignores shardID, realmID, and newRealmAdminKey, and creates everything in shard 0
         * and realm 0, with a null key. Future versions of the API will support multiple realms and
         * multiple shards.
         */
        class FileCreateTransactionBody implements IFileCreateTransactionBody {

            /**
             * Constructs a new FileCreateTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IFileCreateTransactionBody);

            /**
             * The time at which this file should expire (unless FileUpdateTransaction is used before then
             * to extend its life)
             */
            public expirationTime?: (hashgraph.proto.ITimestamp|null);

            /**
             * All keys at the top level of a key list must sign to create or modify the file. Any one of
             * the keys at the top level key list can sign to delete the file.
             */
            public keys?: (hashgraph.proto.IKeyList|null);

            /** The bytes that are the contents of the file */
            public contents: Uint8Array;

            /** Shard in which this file is created */
            public shardID?: (hashgraph.proto.IShardID|null);

            /** The Realm in which to the file is created (leave this null to create a new realm) */
            public realmID?: (hashgraph.proto.IRealmID|null);

            /** If realmID is null, then this the admin key for the new realm that will be created */
            public newRealmAdminKey?: (hashgraph.proto.IKey|null);

            /** The memo associated with the file (UTF-8 encoding max 100 bytes) */
            public memo: string;

            /**
             * Creates a new FileCreateTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns FileCreateTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.IFileCreateTransactionBody): hashgraph.proto.FileCreateTransactionBody;

            /**
             * Encodes the specified FileCreateTransactionBody message. Does not implicitly {@link hashgraph.proto.FileCreateTransactionBody.verify|verify} messages.
             * @param m FileCreateTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IFileCreateTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a FileCreateTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns FileCreateTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.FileCreateTransactionBody;

            /**
             * Gets the default type url for FileCreateTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a FileDeleteTransactionBody. */
        interface IFileDeleteTransactionBody {

            /** The file to delete. It will be marked as deleted until it expires. Then it will disappear. */
            fileID?: (hashgraph.proto.IFileID|null);
        }

        /**
         * Delete the given file. After deletion, it will be marked as deleted and will have no contents.
         * But information about it will continue to exist until it expires. A list of keys was given when
         * the file was created. All the top level keys on that list must sign transactions to create or
         * modify the file, but any single one of the top level keys can be used to delete the file. This
         * transaction must be signed by 1-of-M KeyList keys. If keys contains additional KeyList or
         * ThresholdKey then 1-of-M secondary KeyList or ThresholdKey signing requirements must be meet.
         */
        class FileDeleteTransactionBody implements IFileDeleteTransactionBody {

            /**
             * Constructs a new FileDeleteTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IFileDeleteTransactionBody);

            /** The file to delete. It will be marked as deleted until it expires. Then it will disappear. */
            public fileID?: (hashgraph.proto.IFileID|null);

            /**
             * Creates a new FileDeleteTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns FileDeleteTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.IFileDeleteTransactionBody): hashgraph.proto.FileDeleteTransactionBody;

            /**
             * Encodes the specified FileDeleteTransactionBody message. Does not implicitly {@link hashgraph.proto.FileDeleteTransactionBody.verify|verify} messages.
             * @param m FileDeleteTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IFileDeleteTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a FileDeleteTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns FileDeleteTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.FileDeleteTransactionBody;

            /**
             * Gets the default type url for FileDeleteTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a FileUpdateTransactionBody. */
        interface IFileUpdateTransactionBody {

            /** The ID of the file to update */
            fileID?: (hashgraph.proto.IFileID|null);

            /** The new expiry time (ignored if not later than the current expiry) */
            expirationTime?: (hashgraph.proto.ITimestamp|null);

            /** The new list of keys that can modify or delete the file */
            keys?: (hashgraph.proto.IKeyList|null);

            /** The new contents that should overwrite the file's current contents */
            contents?: (Uint8Array|null);

            /** If set, the new memo to be associated with the file (UTF-8 encoding max 100 bytes) */
            memo?: (google.protobuf.IStringValue|null);
        }

        /**
         * Modify the metadata and/or contents of a file. If a field is not set in the transaction body, the
         * corresponding file attribute will be unchanged. This transaction must be signed by all the keys
         * in the top level of a key list (M-of-M) of the file being updated. If the keys themselves are
         * being updated, then the transaction must also be signed by all the new keys. If the keys contain
         * additional KeyList or ThresholdKey then M-of-M secondary KeyList or ThresholdKey signing
         * requirements must be meet If the update transaction sets the <tt>auto_renew_account_id</tt> field
         * to anything other than the sentinel <tt>0.0.0</tt>, the key of the referenced account must sign.
         */
        class FileUpdateTransactionBody implements IFileUpdateTransactionBody {

            /**
             * Constructs a new FileUpdateTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IFileUpdateTransactionBody);

            /** The ID of the file to update */
            public fileID?: (hashgraph.proto.IFileID|null);

            /** The new expiry time (ignored if not later than the current expiry) */
            public expirationTime?: (hashgraph.proto.ITimestamp|null);

            /** The new list of keys that can modify or delete the file */
            public keys?: (hashgraph.proto.IKeyList|null);

            /** The new contents that should overwrite the file's current contents */
            public contents: Uint8Array;

            /** If set, the new memo to be associated with the file (UTF-8 encoding max 100 bytes) */
            public memo?: (google.protobuf.IStringValue|null);

            /**
             * Creates a new FileUpdateTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns FileUpdateTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.IFileUpdateTransactionBody): hashgraph.proto.FileUpdateTransactionBody;

            /**
             * Encodes the specified FileUpdateTransactionBody message. Does not implicitly {@link hashgraph.proto.FileUpdateTransactionBody.verify|verify} messages.
             * @param m FileUpdateTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IFileUpdateTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a FileUpdateTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns FileUpdateTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.FileUpdateTransactionBody;

            /**
             * Gets the default type url for FileUpdateTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ContractDeleteTransactionBody. */
        interface IContractDeleteTransactionBody {

            /** The id of the contract to be deleted */
            contractID?: (hashgraph.proto.IContractID|null);

            /** The id of an account to receive any remaining hBars from the deleted contract */
            transferAccountID?: (hashgraph.proto.IAccountID|null);

            /** The id of a contract to receive any remaining hBars from the deleted contract */
            transferContractID?: (hashgraph.proto.IContractID|null);

            /**
             * If set to true, means this is a "synthetic" system transaction being used to
             * alert mirror nodes that the contract is being permanently removed from the ledger.
             * <b>IMPORTANT:</b> User transactions cannot set this field to true, as permanent
             * removal is always managed by the ledger itself. Any ContractDeleteTransactionBody
             * submitted to HAPI with permanent_removal=true will be rejected with precheck status
             * PERMANENT_REMOVAL_REQUIRES_SYSTEM_INITIATION.
             */
            permanentRemoval?: (boolean|null);
        }

        /**
         * At consensus, marks a contract as deleted and transfers its remaining hBars, if any, to a
         * designated receiver. After a contract is deleted, it can no longer be called.
         *
         * If the target contract is immutable (that is, was created without an admin key), then this
         * transaction resolves to MODIFYING_IMMUTABLE_CONTRACT.
         *
         * --- Signing Requirements ---
         * 1. The admin key of the target contract must sign.
         * 2. If the transfer account or contract has receiverSigRequired, its associated key must also sign
         */
        class ContractDeleteTransactionBody implements IContractDeleteTransactionBody {

            /**
             * Constructs a new ContractDeleteTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IContractDeleteTransactionBody);

            /** The id of the contract to be deleted */
            public contractID?: (hashgraph.proto.IContractID|null);

            /** The id of an account to receive any remaining hBars from the deleted contract */
            public transferAccountID?: (hashgraph.proto.IAccountID|null);

            /** The id of a contract to receive any remaining hBars from the deleted contract */
            public transferContractID?: (hashgraph.proto.IContractID|null);

            /**
             * If set to true, means this is a "synthetic" system transaction being used to
             * alert mirror nodes that the contract is being permanently removed from the ledger.
             * <b>IMPORTANT:</b> User transactions cannot set this field to true, as permanent
             * removal is always managed by the ledger itself. Any ContractDeleteTransactionBody
             * submitted to HAPI with permanent_removal=true will be rejected with precheck status
             * PERMANENT_REMOVAL_REQUIRES_SYSTEM_INITIATION.
             */
            public permanentRemoval: boolean;

            /** ContractDeleteTransactionBody obtainers. */
            public obtainers?: ("transferAccountID"|"transferContractID");

            /**
             * Creates a new ContractDeleteTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ContractDeleteTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.IContractDeleteTransactionBody): hashgraph.proto.ContractDeleteTransactionBody;

            /**
             * Encodes the specified ContractDeleteTransactionBody message. Does not implicitly {@link hashgraph.proto.ContractDeleteTransactionBody.verify|verify} messages.
             * @param m ContractDeleteTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IContractDeleteTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ContractDeleteTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ContractDeleteTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ContractDeleteTransactionBody;

            /**
             * Gets the default type url for ContractDeleteTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ConsensusUpdateTopicTransactionBody. */
        interface IConsensusUpdateTopicTransactionBody {

            /** UNDOCUMENTED */
            topicID?: (hashgraph.proto.ITopicID|null);

            /** If set, the new memo to be associated with the topic (UTF-8 encoding max 100 bytes) */
            memo?: (google.protobuf.IStringValue|null);

            /**
             * Effective consensus timestamp at (and after) which all consensus transactions and queries will fail.
             * The expirationTime may be no longer than MAX_AUTORENEW_PERIOD (8000001 seconds) from the consensus timestamp of
             * this transaction.
             * On topics with no adminKey, extending the expirationTime is the only updateTopic option allowed on the topic.
             * If unspecified, no change.
             */
            expirationTime?: (hashgraph.proto.ITimestamp|null);

            /**
             * Access control for update/delete of the topic.
             * If unspecified, no change.
             * If empty keyList - the adminKey is cleared.
             */
            adminKey?: (hashgraph.proto.IKey|null);

            /**
             * Access control for ConsensusService.submitMessage.
             * If unspecified, no change.
             * If empty keyList - the submitKey is cleared.
             */
            submitKey?: (hashgraph.proto.IKey|null);

            /** ConsensusUpdateTopicTransactionBody autoRenewPeriod */
            autoRenewPeriod?: (hashgraph.proto.IDuration|null);

            /**
             * Optional account to be used at the topic's expirationTime to extend the life of the topic.
             * Once autoRenew functionality is supported by HAPI, the topic lifetime will be extended up to a maximum of the
             * autoRenewPeriod or however long the topic can be extended using all funds on the account (whichever is the
             * smaller duration/amount).
             * If specified as the default value (0.0.0), the autoRenewAccount will be removed.
             * If unspecified, no change.
             */
            autoRenewAccount?: (hashgraph.proto.IAccountID|null);
        }

        /**
         * All fields left null will not be updated.
         * See [ConsensusService.updateTopic()](#hashgraph.proto.ConsensusService)
         */
        class ConsensusUpdateTopicTransactionBody implements IConsensusUpdateTopicTransactionBody {

            /**
             * Constructs a new ConsensusUpdateTopicTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IConsensusUpdateTopicTransactionBody);

            /** UNDOCUMENTED */
            public topicID?: (hashgraph.proto.ITopicID|null);

            /** If set, the new memo to be associated with the topic (UTF-8 encoding max 100 bytes) */
            public memo?: (google.protobuf.IStringValue|null);

            /**
             * Effective consensus timestamp at (and after) which all consensus transactions and queries will fail.
             * The expirationTime may be no longer than MAX_AUTORENEW_PERIOD (8000001 seconds) from the consensus timestamp of
             * this transaction.
             * On topics with no adminKey, extending the expirationTime is the only updateTopic option allowed on the topic.
             * If unspecified, no change.
             */
            public expirationTime?: (hashgraph.proto.ITimestamp|null);

            /**
             * Access control for update/delete of the topic.
             * If unspecified, no change.
             * If empty keyList - the adminKey is cleared.
             */
            public adminKey?: (hashgraph.proto.IKey|null);

            /**
             * Access control for ConsensusService.submitMessage.
             * If unspecified, no change.
             * If empty keyList - the submitKey is cleared.
             */
            public submitKey?: (hashgraph.proto.IKey|null);

            /** ConsensusUpdateTopicTransactionBody autoRenewPeriod. */
            public autoRenewPeriod?: (hashgraph.proto.IDuration|null);

            /**
             * Optional account to be used at the topic's expirationTime to extend the life of the topic.
             * Once autoRenew functionality is supported by HAPI, the topic lifetime will be extended up to a maximum of the
             * autoRenewPeriod or however long the topic can be extended using all funds on the account (whichever is the
             * smaller duration/amount).
             * If specified as the default value (0.0.0), the autoRenewAccount will be removed.
             * If unspecified, no change.
             */
            public autoRenewAccount?: (hashgraph.proto.IAccountID|null);

            /**
             * Creates a new ConsensusUpdateTopicTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ConsensusUpdateTopicTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.IConsensusUpdateTopicTransactionBody): hashgraph.proto.ConsensusUpdateTopicTransactionBody;

            /**
             * Encodes the specified ConsensusUpdateTopicTransactionBody message. Does not implicitly {@link hashgraph.proto.ConsensusUpdateTopicTransactionBody.verify|verify} messages.
             * @param m ConsensusUpdateTopicTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IConsensusUpdateTopicTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ConsensusUpdateTopicTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ConsensusUpdateTopicTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ConsensusUpdateTopicTransactionBody;

            /**
             * Gets the default type url for ConsensusUpdateTopicTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ConsensusMessageChunkInfo. */
        interface IConsensusMessageChunkInfo {

            /** TransactionID of the first chunk, gets copied to every subsequent chunk in a fragmented message. */
            initialTransactionID?: (hashgraph.proto.ITransactionID|null);

            /** The total number of chunks in the message. */
            total?: (number|null);

            /** The sequence number (from 1 to total) of the current chunk in the message. */
            number?: (number|null);
        }

        /** UNDOCUMENTED */
        class ConsensusMessageChunkInfo implements IConsensusMessageChunkInfo {

            /**
             * Constructs a new ConsensusMessageChunkInfo.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IConsensusMessageChunkInfo);

            /** TransactionID of the first chunk, gets copied to every subsequent chunk in a fragmented message. */
            public initialTransactionID?: (hashgraph.proto.ITransactionID|null);

            /** The total number of chunks in the message. */
            public total: number;

            /** The sequence number (from 1 to total) of the current chunk in the message. */
            public number: number;

            /**
             * Creates a new ConsensusMessageChunkInfo instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ConsensusMessageChunkInfo instance
             */
            public static create(properties?: hashgraph.proto.IConsensusMessageChunkInfo): hashgraph.proto.ConsensusMessageChunkInfo;

            /**
             * Encodes the specified ConsensusMessageChunkInfo message. Does not implicitly {@link hashgraph.proto.ConsensusMessageChunkInfo.verify|verify} messages.
             * @param m ConsensusMessageChunkInfo message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IConsensusMessageChunkInfo, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ConsensusMessageChunkInfo message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ConsensusMessageChunkInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ConsensusMessageChunkInfo;

            /**
             * Gets the default type url for ConsensusMessageChunkInfo
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ConsensusSubmitMessageTransactionBody. */
        interface IConsensusSubmitMessageTransactionBody {

            /** Topic to submit message to. */
            topicID?: (hashgraph.proto.ITopicID|null);

            /** Message to be submitted. Max size of the Transaction (including signatures) is 6KiB. */
            message?: (Uint8Array|null);

            /** Optional information of the current chunk in a fragmented message. */
            chunkInfo?: (hashgraph.proto.IConsensusMessageChunkInfo|null);
        }

        /** UNDOCUMENTED */
        class ConsensusSubmitMessageTransactionBody implements IConsensusSubmitMessageTransactionBody {

            /**
             * Constructs a new ConsensusSubmitMessageTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IConsensusSubmitMessageTransactionBody);

            /** Topic to submit message to. */
            public topicID?: (hashgraph.proto.ITopicID|null);

            /** Message to be submitted. Max size of the Transaction (including signatures) is 6KiB. */
            public message: Uint8Array;

            /** Optional information of the current chunk in a fragmented message. */
            public chunkInfo?: (hashgraph.proto.IConsensusMessageChunkInfo|null);

            /**
             * Creates a new ConsensusSubmitMessageTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ConsensusSubmitMessageTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.IConsensusSubmitMessageTransactionBody): hashgraph.proto.ConsensusSubmitMessageTransactionBody;

            /**
             * Encodes the specified ConsensusSubmitMessageTransactionBody message. Does not implicitly {@link hashgraph.proto.ConsensusSubmitMessageTransactionBody.verify|verify} messages.
             * @param m ConsensusSubmitMessageTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IConsensusSubmitMessageTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ConsensusSubmitMessageTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ConsensusSubmitMessageTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ConsensusSubmitMessageTransactionBody;

            /**
             * Gets the default type url for ConsensusSubmitMessageTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of an UncheckedSubmitBody. */
        interface IUncheckedSubmitBody {

            /** The serialized bytes of the Transaction to be submitted without prechecks */
            transactionBytes?: (Uint8Array|null);
        }

        /**
         * Submit an arbitrary (serialized) Transaction to the network without prechecks. Requires superuser
         * privileges.
         */
        class UncheckedSubmitBody implements IUncheckedSubmitBody {

            /**
             * Constructs a new UncheckedSubmitBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IUncheckedSubmitBody);

            /** The serialized bytes of the Transaction to be submitted without prechecks */
            public transactionBytes: Uint8Array;

            /**
             * Creates a new UncheckedSubmitBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns UncheckedSubmitBody instance
             */
            public static create(properties?: hashgraph.proto.IUncheckedSubmitBody): hashgraph.proto.UncheckedSubmitBody;

            /**
             * Encodes the specified UncheckedSubmitBody message. Does not implicitly {@link hashgraph.proto.UncheckedSubmitBody.verify|verify} messages.
             * @param m UncheckedSubmitBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IUncheckedSubmitBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an UncheckedSubmitBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns UncheckedSubmitBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.UncheckedSubmitBody;

            /**
             * Gets the default type url for UncheckedSubmitBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenCreateTransactionBody. */
        interface ITokenCreateTransactionBody {

            /**
             * The publicly visible name of the token. The token name is specified as a Unicode string.
             * Its UTF-8 encoding cannot exceed 100 bytes, and cannot contain the 0 byte (NUL).
             */
            name?: (string|null);

            /**
             * The publicly visible token symbol. The token symbol is specified as a Unicode string.
             * Its UTF-8 encoding cannot exceed 100 bytes, and cannot contain the 0 byte (NUL).
             */
            symbol?: (string|null);

            /**
             * For tokens of type FUNGIBLE_COMMON - the number of decimal places a
             * token is divisible by. For tokens of type NON_FUNGIBLE_UNIQUE - value
             * must be 0
             */
            decimals?: (number|null);

            /**
             * Specifies the initial supply of tokens to be put in circulation. The
             * initial supply is sent to the Treasury Account. The supply is in the
             * lowest denomination possible. In the case for NON_FUNGIBLE_UNIQUE Type
             * the value must be 0
             */
            initialSupply?: (Long|null);

            /**
             * The account which will act as a treasury for the token. This account
             * will receive the specified initial supply or the newly minted NFTs in
             * the case for NON_FUNGIBLE_UNIQUE Type
             */
            treasury?: (hashgraph.proto.IAccountID|null);

            /**
             * The key which can perform update/delete operations on the token. If empty, the token can be
             * perceived as immutable (not being able to be updated/deleted)
             */
            adminKey?: (hashgraph.proto.IKey|null);

            /**
             * The key which can grant or revoke KYC of an account for the token's transactions. If empty,
             * KYC is not required, and KYC grant or revoke operations are not possible.
             */
            kycKey?: (hashgraph.proto.IKey|null);

            /**
             * The key which can sign to freeze or unfreeze an account for token transactions. If empty,
             * freezing is not possible
             */
            freezeKey?: (hashgraph.proto.IKey|null);

            /** The key which can wipe the token balance of an account. If empty, wipe is not possible */
            wipeKey?: (hashgraph.proto.IKey|null);

            /**
             * The key which can change the supply of a token. The key is used to sign Token Mint/Burn
             * operations
             */
            supplyKey?: (hashgraph.proto.IKey|null);

            /**
             * The default Freeze status (frozen or unfrozen) of Hedera accounts relative to this token. If
             * true, an account must be unfrozen before it can receive the token
             */
            freezeDefault?: (boolean|null);

            /**
             * The epoch second at which the token should expire; if an auto-renew account and period are
             * specified, this is coerced to the current epoch second plus the autoRenewPeriod
             */
            expiry?: (hashgraph.proto.ITimestamp|null);

            /**
             * An account which will be automatically charged to renew the token's expiration, at
             * autoRenewPeriod interval
             */
            autoRenewAccount?: (hashgraph.proto.IAccountID|null);

            /** The interval at which the auto-renew account will be charged to extend the token's expiry */
            autoRenewPeriod?: (hashgraph.proto.IDuration|null);

            /** The memo associated with the token (UTF-8 encoding max 100 bytes) */
            memo?: (string|null);

            /** IWA compatibility. Specifies the token type. Defaults to FUNGIBLE_COMMON */
            tokenType?: (hashgraph.proto.TokenType|null);

            /** IWA compatibility. Specified the token supply type. Defaults to INFINITE */
            supplyType?: (hashgraph.proto.TokenSupplyType|null);

            /**
             * IWA Compatibility. Depends on TokenSupplyType. For tokens of type FUNGIBLE_COMMON - the
             * maximum number of tokens that can be in circulation. For tokens of type NON_FUNGIBLE_UNIQUE -
             * the maximum number of NFTs (serial numbers) that can be minted. This field can never be
             * changed!
             */
            maxSupply?: (Long|null);

            /**
             * The key which can change the token's custom fee schedule; must sign a TokenFeeScheduleUpdate
             * transaction
             */
            feeScheduleKey?: (hashgraph.proto.IKey|null);

            /** The custom fees to be assessed during a CryptoTransfer that transfers units of this token */
            customFees?: (hashgraph.proto.ICustomFee[]|null);

            /**
             * The Key which can pause and unpause the Token.
             * If Empty the token pause status defaults to PauseNotApplicable, otherwise Unpaused.
             */
            pauseKey?: (hashgraph.proto.IKey|null);
        }

        /**
         * Create a new token. After the token is created, the Token ID for it is in the receipt.
         * The specified Treasury Account is receiving the initial supply of tokens as-well as the tokens
         * from the Token Mint operation once executed. The balance of the treasury account is decreased
         * when the Token Burn operation is executed.
         *
         * The <tt>initialSupply</tt> is the initial supply of the smallest parts of a token (like a
         * tinybar, not an hbar). These are the smallest units of the token which may be transferred.
         *
         * The supply can change over time. If the total supply at some moment is <i>S</i> parts of tokens,
         * and the token is using <i>D</i> decimals, then <i>S</i> must be less than or equal to
         * 2<sup>63</sup>-1, which is 9,223,372,036,854,775,807. The number of whole tokens (not parts) will
         * be <i>S / 10<sup>D</sup></i>.
         *
         * If decimals is 8 or 11, then the number of whole tokens can be at most a few billions or
         * millions, respectively. For example, it could match Bitcoin (21 million whole tokens with 8
         * decimals) or hbars (50 billion whole tokens with 8 decimals). It could even match Bitcoin with
         * milli-satoshis (21 million whole tokens with 11 decimals).
         *
         * Note that a created token is <i>immutable</i> if the <tt>adminKey</tt> is omitted. No property of
         * an immutable token can ever change, with the sole exception of its expiry. Anyone can pay to
         * extend the expiry time of an immutable token.
         *
         * A token can be either <i>FUNGIBLE_COMMON</i> or <i>NON_FUNGIBLE_UNIQUE</i>, based on its
         * <i>TokenType</i>. If it has been omitted, <i>FUNGIBLE_COMMON</i> type is used.
         *
         * A token can have either <i>INFINITE</i> or <i>FINITE</i> supply type, based on its
         * <i>TokenType</i>. If it has been omitted, <i>INFINITE</i> type is used.
         *
         * If a <i>FUNGIBLE</i> TokenType is used, <i>initialSupply</i> should explicitly be set to a
         * non-negative. If not, the transaction will resolve to INVALID_TOKEN_INITIAL_SUPPLY.
         *
         * If a <i>NON_FUNGIBLE_UNIQUE</i> TokenType is used, <i>initialSupply</i> should explicitly be set
         * to 0. If not, the transaction will resolve to INVALID_TOKEN_INITIAL_SUPPLY.
         *
         * If an <i>INFINITE</i> TokenSupplyType is used, <i>maxSupply</i> should explicitly be set to 0. If
         * it is not 0, the transaction will resolve to INVALID_TOKEN_MAX_SUPPLY.
         *
         * If a <i>FINITE</i> TokenSupplyType is used, <i>maxSupply</i> should be explicitly set to a
         * non-negative value. If it is not, the transaction will resolve to INVALID_TOKEN_MAX_SUPPLY.
         */
        class TokenCreateTransactionBody implements ITokenCreateTransactionBody {

            /**
             * Constructs a new TokenCreateTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenCreateTransactionBody);

            /**
             * The publicly visible name of the token. The token name is specified as a Unicode string.
             * Its UTF-8 encoding cannot exceed 100 bytes, and cannot contain the 0 byte (NUL).
             */
            public name: string;

            /**
             * The publicly visible token symbol. The token symbol is specified as a Unicode string.
             * Its UTF-8 encoding cannot exceed 100 bytes, and cannot contain the 0 byte (NUL).
             */
            public symbol: string;

            /**
             * For tokens of type FUNGIBLE_COMMON - the number of decimal places a
             * token is divisible by. For tokens of type NON_FUNGIBLE_UNIQUE - value
             * must be 0
             */
            public decimals: number;

            /**
             * Specifies the initial supply of tokens to be put in circulation. The
             * initial supply is sent to the Treasury Account. The supply is in the
             * lowest denomination possible. In the case for NON_FUNGIBLE_UNIQUE Type
             * the value must be 0
             */
            public initialSupply: Long;

            /**
             * The account which will act as a treasury for the token. This account
             * will receive the specified initial supply or the newly minted NFTs in
             * the case for NON_FUNGIBLE_UNIQUE Type
             */
            public treasury?: (hashgraph.proto.IAccountID|null);

            /**
             * The key which can perform update/delete operations on the token. If empty, the token can be
             * perceived as immutable (not being able to be updated/deleted)
             */
            public adminKey?: (hashgraph.proto.IKey|null);

            /**
             * The key which can grant or revoke KYC of an account for the token's transactions. If empty,
             * KYC is not required, and KYC grant or revoke operations are not possible.
             */
            public kycKey?: (hashgraph.proto.IKey|null);

            /**
             * The key which can sign to freeze or unfreeze an account for token transactions. If empty,
             * freezing is not possible
             */
            public freezeKey?: (hashgraph.proto.IKey|null);

            /** The key which can wipe the token balance of an account. If empty, wipe is not possible */
            public wipeKey?: (hashgraph.proto.IKey|null);

            /**
             * The key which can change the supply of a token. The key is used to sign Token Mint/Burn
             * operations
             */
            public supplyKey?: (hashgraph.proto.IKey|null);

            /**
             * The default Freeze status (frozen or unfrozen) of Hedera accounts relative to this token. If
             * true, an account must be unfrozen before it can receive the token
             */
            public freezeDefault: boolean;

            /**
             * The epoch second at which the token should expire; if an auto-renew account and period are
             * specified, this is coerced to the current epoch second plus the autoRenewPeriod
             */
            public expiry?: (hashgraph.proto.ITimestamp|null);

            /**
             * An account which will be automatically charged to renew the token's expiration, at
             * autoRenewPeriod interval
             */
            public autoRenewAccount?: (hashgraph.proto.IAccountID|null);

            /** The interval at which the auto-renew account will be charged to extend the token's expiry */
            public autoRenewPeriod?: (hashgraph.proto.IDuration|null);

            /** The memo associated with the token (UTF-8 encoding max 100 bytes) */
            public memo: string;

            /** IWA compatibility. Specifies the token type. Defaults to FUNGIBLE_COMMON */
            public tokenType: hashgraph.proto.TokenType;

            /** IWA compatibility. Specified the token supply type. Defaults to INFINITE */
            public supplyType: hashgraph.proto.TokenSupplyType;

            /**
             * IWA Compatibility. Depends on TokenSupplyType. For tokens of type FUNGIBLE_COMMON - the
             * maximum number of tokens that can be in circulation. For tokens of type NON_FUNGIBLE_UNIQUE -
             * the maximum number of NFTs (serial numbers) that can be minted. This field can never be
             * changed!
             */
            public maxSupply: Long;

            /**
             * The key which can change the token's custom fee schedule; must sign a TokenFeeScheduleUpdate
             * transaction
             */
            public feeScheduleKey?: (hashgraph.proto.IKey|null);

            /** The custom fees to be assessed during a CryptoTransfer that transfers units of this token */
            public customFees: hashgraph.proto.ICustomFee[];

            /**
             * The Key which can pause and unpause the Token.
             * If Empty the token pause status defaults to PauseNotApplicable, otherwise Unpaused.
             */
            public pauseKey?: (hashgraph.proto.IKey|null);

            /**
             * Creates a new TokenCreateTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenCreateTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.ITokenCreateTransactionBody): hashgraph.proto.TokenCreateTransactionBody;

            /**
             * Encodes the specified TokenCreateTransactionBody message. Does not implicitly {@link hashgraph.proto.TokenCreateTransactionBody.verify|verify} messages.
             * @param m TokenCreateTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenCreateTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenCreateTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenCreateTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenCreateTransactionBody;

            /**
             * Gets the default type url for TokenCreateTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a FractionalFee. */
        interface IFractionalFee {

            /** The fraction of the transferred units to assess as a fee */
            fractionalAmount?: (hashgraph.proto.IFraction|null);

            /** The minimum amount to assess */
            minimumAmount?: (Long|null);

            /** The maximum amount to assess (zero implies no maximum) */
            maximumAmount?: (Long|null);

            /**
             * If true, assesses the fee to the sender, so the receiver gets the full amount from the token
             * transfer list, and the sender is charged an additional fee; if false, the receiver does NOT get
             * the full amount, but only what is left over after paying the fractional fee
             */
            netOfTransfers?: (boolean|null);
        }

        /**
         * A fraction of the transferred units of a token to assess as a fee. The amount assessed will never
         * be less than the given minimum_amount, and never greater than the given maximum_amount.  The
         * denomination is always units of the token to which this fractional fee is attached.
         */
        class FractionalFee implements IFractionalFee {

            /**
             * Constructs a new FractionalFee.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IFractionalFee);

            /** The fraction of the transferred units to assess as a fee */
            public fractionalAmount?: (hashgraph.proto.IFraction|null);

            /** The minimum amount to assess */
            public minimumAmount: Long;

            /** The maximum amount to assess (zero implies no maximum) */
            public maximumAmount: Long;

            /**
             * If true, assesses the fee to the sender, so the receiver gets the full amount from the token
             * transfer list, and the sender is charged an additional fee; if false, the receiver does NOT get
             * the full amount, but only what is left over after paying the fractional fee
             */
            public netOfTransfers: boolean;

            /**
             * Creates a new FractionalFee instance using the specified properties.
             * @param [properties] Properties to set
             * @returns FractionalFee instance
             */
            public static create(properties?: hashgraph.proto.IFractionalFee): hashgraph.proto.FractionalFee;

            /**
             * Encodes the specified FractionalFee message. Does not implicitly {@link hashgraph.proto.FractionalFee.verify|verify} messages.
             * @param m FractionalFee message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IFractionalFee, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a FractionalFee message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns FractionalFee
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.FractionalFee;

            /**
             * Gets the default type url for FractionalFee
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a FixedFee. */
        interface IFixedFee {

            /** The number of units to assess as a fee */
            amount?: (Long|null);

            /**
             * The denomination of the fee; taken as hbar if left unset and, in a TokenCreate, taken as the id
             * of the newly created token if set to the sentinel value of 0.0.0
             */
            denominatingTokenId?: (hashgraph.proto.ITokenID|null);
        }

        /**
         * A fixed number of units (hbar or token) to assess as a fee during a CryptoTransfer that transfers
         * units of the token to which this fixed fee is attached.
         */
        class FixedFee implements IFixedFee {

            /**
             * Constructs a new FixedFee.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IFixedFee);

            /** The number of units to assess as a fee */
            public amount: Long;

            /**
             * The denomination of the fee; taken as hbar if left unset and, in a TokenCreate, taken as the id
             * of the newly created token if set to the sentinel value of 0.0.0
             */
            public denominatingTokenId?: (hashgraph.proto.ITokenID|null);

            /**
             * Creates a new FixedFee instance using the specified properties.
             * @param [properties] Properties to set
             * @returns FixedFee instance
             */
            public static create(properties?: hashgraph.proto.IFixedFee): hashgraph.proto.FixedFee;

            /**
             * Encodes the specified FixedFee message. Does not implicitly {@link hashgraph.proto.FixedFee.verify|verify} messages.
             * @param m FixedFee message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IFixedFee, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a FixedFee message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns FixedFee
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.FixedFee;

            /**
             * Gets the default type url for FixedFee
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a RoyaltyFee. */
        interface IRoyaltyFee {

            /** The fraction of fungible value exchanged for an NFT to collect as royalty */
            exchangeValueFraction?: (hashgraph.proto.IFraction|null);

            /**
             * If present, the fixed fee to assess to the NFT receiver when no fungible value is exchanged
             * with the sender
             */
            fallbackFee?: (hashgraph.proto.IFixedFee|null);
        }

        /**
         * A fee to assess during a CryptoTransfer that changes ownership of an NFT. Defines the fraction of
         * the fungible value exchanged for an NFT that the ledger should collect as a royalty. ("Fungible
         * value" includes both ℏ and units of fungible HTS tokens.) When the NFT sender does not receive
         * any fungible value, the ledger will assess the fallback fee, if present, to the new NFT owner.
         * Royalty fees can only be added to tokens of type type NON_FUNGIBLE_UNIQUE.
         *
         * **IMPORTANT:** Users must understand that native royalty fees are _strictly_ a convenience feature,
         * and that the network cannot enforce inescapable royalties on the exchange of a non-fractional NFT.
         * For example, if the counterparties agree to split their value transfer and NFT exchange into separate
         * transactions, the network cannot possibly intervene. (And note the counterparties could use a smart
         * contract to make this split transaction atomic if they do not trust each other.)
         *
         * Counterparties that _do_ wish to respect creator royalties should follow the pattern the network
         * recognizes: The NFT sender and receiver should both sign a single `CryptoTransfer` that credits
         * the sender with all the fungible value the receiver is exchanging for the NFT.
         *
         * Similarly, a marketplace using an approved spender account for an escrow transaction should credit
         * the account selling the NFT in the same `CryptoTransfer` that deducts fungible value from the buying
         * account.
         *
         * There is an [open HIP discussion](https://github.com/hashgraph/hedera-improvement-proposal/discussions/578)
         * that proposes to broaden the class of transactions for which the network automatically collects
         * royalties. If this interests or concerns you, please add your voice to that discussion.
         */
        class RoyaltyFee implements IRoyaltyFee {

            /**
             * Constructs a new RoyaltyFee.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IRoyaltyFee);

            /** The fraction of fungible value exchanged for an NFT to collect as royalty */
            public exchangeValueFraction?: (hashgraph.proto.IFraction|null);

            /**
             * If present, the fixed fee to assess to the NFT receiver when no fungible value is exchanged
             * with the sender
             */
            public fallbackFee?: (hashgraph.proto.IFixedFee|null);

            /**
             * Creates a new RoyaltyFee instance using the specified properties.
             * @param [properties] Properties to set
             * @returns RoyaltyFee instance
             */
            public static create(properties?: hashgraph.proto.IRoyaltyFee): hashgraph.proto.RoyaltyFee;

            /**
             * Encodes the specified RoyaltyFee message. Does not implicitly {@link hashgraph.proto.RoyaltyFee.verify|verify} messages.
             * @param m RoyaltyFee message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IRoyaltyFee, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a RoyaltyFee message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns RoyaltyFee
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.RoyaltyFee;

            /**
             * Gets the default type url for RoyaltyFee
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a CustomFee. */
        interface ICustomFee {

            /** Fixed fee to be charged */
            fixedFee?: (hashgraph.proto.IFixedFee|null);

            /** Fractional fee to be charged */
            fractionalFee?: (hashgraph.proto.IFractionalFee|null);

            /** Royalty fee to be charged */
            royaltyFee?: (hashgraph.proto.IRoyaltyFee|null);

            /** The account to receive the custom fee */
            feeCollectorAccountId?: (hashgraph.proto.IAccountID|null);

            /**
             * If true, exempts all the token's fee collection accounts from this fee.
             * (The token's treasury and the above fee_collector_account_id will always
             * be exempt. Please see <a href="https://hips.hedera.com/hip/hip-573">HIP-573</a>
             * for details.)
             */
            allCollectorsAreExempt?: (boolean|null);
        }

        /**
         * A transfer fee to assess during a CryptoTransfer that transfers units of the token to which the
         * fee is attached. A custom fee may be either fixed or fractional, and must specify a fee collector
         * account to receive the assessed fees. Only positive fees may be assessed.
         */
        class CustomFee implements ICustomFee {

            /**
             * Constructs a new CustomFee.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ICustomFee);

            /** Fixed fee to be charged */
            public fixedFee?: (hashgraph.proto.IFixedFee|null);

            /** Fractional fee to be charged */
            public fractionalFee?: (hashgraph.proto.IFractionalFee|null);

            /** Royalty fee to be charged */
            public royaltyFee?: (hashgraph.proto.IRoyaltyFee|null);

            /** The account to receive the custom fee */
            public feeCollectorAccountId?: (hashgraph.proto.IAccountID|null);

            /**
             * If true, exempts all the token's fee collection accounts from this fee.
             * (The token's treasury and the above fee_collector_account_id will always
             * be exempt. Please see <a href="https://hips.hedera.com/hip/hip-573">HIP-573</a>
             * for details.)
             */
            public allCollectorsAreExempt: boolean;

            /** CustomFee fee. */
            public fee?: ("fixedFee"|"fractionalFee"|"royaltyFee");

            /**
             * Creates a new CustomFee instance using the specified properties.
             * @param [properties] Properties to set
             * @returns CustomFee instance
             */
            public static create(properties?: hashgraph.proto.ICustomFee): hashgraph.proto.CustomFee;

            /**
             * Encodes the specified CustomFee message. Does not implicitly {@link hashgraph.proto.CustomFee.verify|verify} messages.
             * @param m CustomFee message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ICustomFee, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a CustomFee message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns CustomFee
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.CustomFee;

            /**
             * Gets the default type url for CustomFee
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of an AssessedCustomFee. */
        interface IAssessedCustomFee {

            /** The number of units assessed for the fee */
            amount?: (Long|null);

            /** The denomination of the fee; taken as hbar if left unset */
            tokenId?: (hashgraph.proto.ITokenID|null);

            /** The account to receive the assessed fee */
            feeCollectorAccountId?: (hashgraph.proto.IAccountID|null);

            /** The account(s) whose final balances would have been higher in the absence of this assessed fee */
            effectivePayerAccountId?: (hashgraph.proto.IAccountID[]|null);
        }

        /** A custom transfer fee that was assessed during handling of a CryptoTransfer. */
        class AssessedCustomFee implements IAssessedCustomFee {

            /**
             * Constructs a new AssessedCustomFee.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IAssessedCustomFee);

            /** The number of units assessed for the fee */
            public amount: Long;

            /** The denomination of the fee; taken as hbar if left unset */
            public tokenId?: (hashgraph.proto.ITokenID|null);

            /** The account to receive the assessed fee */
            public feeCollectorAccountId?: (hashgraph.proto.IAccountID|null);

            /** The account(s) whose final balances would have been higher in the absence of this assessed fee */
            public effectivePayerAccountId: hashgraph.proto.IAccountID[];

            /**
             * Creates a new AssessedCustomFee instance using the specified properties.
             * @param [properties] Properties to set
             * @returns AssessedCustomFee instance
             */
            public static create(properties?: hashgraph.proto.IAssessedCustomFee): hashgraph.proto.AssessedCustomFee;

            /**
             * Encodes the specified AssessedCustomFee message. Does not implicitly {@link hashgraph.proto.AssessedCustomFee.verify|verify} messages.
             * @param m AssessedCustomFee message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IAssessedCustomFee, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an AssessedCustomFee message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns AssessedCustomFee
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.AssessedCustomFee;

            /**
             * Gets the default type url for AssessedCustomFee
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenFreezeAccountTransactionBody. */
        interface ITokenFreezeAccountTransactionBody {

            /**
             * The token for which this account will be frozen. If token does not exist, transaction results
             * in INVALID_TOKEN_ID
             */
            token?: (hashgraph.proto.ITokenID|null);

            /** The account to be frozen */
            account?: (hashgraph.proto.IAccountID|null);
        }

        /**
         * Freezes transfers of the specified token for the account. Must be signed by the Token's freezeKey.
         * If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.
         * If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.
         * If the provided token is not found, the transaction will resolve to INVALID_TOKEN_ID.
         * If the provided token has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.
         * If an Association between the provided token and account is not found, the transaction will
         * resolve to TOKEN_NOT_ASSOCIATED_TO_ACCOUNT.
         * If no Freeze Key is defined, the transaction will resolve to TOKEN_HAS_NO_FREEZE_KEY.
         * Once executed the Account is marked as Frozen and will not be able to receive or send tokens
         * unless unfrozen. The operation is idempotent.
         */
        class TokenFreezeAccountTransactionBody implements ITokenFreezeAccountTransactionBody {

            /**
             * Constructs a new TokenFreezeAccountTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenFreezeAccountTransactionBody);

            /**
             * The token for which this account will be frozen. If token does not exist, transaction results
             * in INVALID_TOKEN_ID
             */
            public token?: (hashgraph.proto.ITokenID|null);

            /** The account to be frozen */
            public account?: (hashgraph.proto.IAccountID|null);

            /**
             * Creates a new TokenFreezeAccountTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenFreezeAccountTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.ITokenFreezeAccountTransactionBody): hashgraph.proto.TokenFreezeAccountTransactionBody;

            /**
             * Encodes the specified TokenFreezeAccountTransactionBody message. Does not implicitly {@link hashgraph.proto.TokenFreezeAccountTransactionBody.verify|verify} messages.
             * @param m TokenFreezeAccountTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenFreezeAccountTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenFreezeAccountTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenFreezeAccountTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenFreezeAccountTransactionBody;

            /**
             * Gets the default type url for TokenFreezeAccountTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenUnfreezeAccountTransactionBody. */
        interface ITokenUnfreezeAccountTransactionBody {

            /**
             * The token for which this account will be unfrozen. If token does not exist, transaction
             * results in INVALID_TOKEN_ID
             */
            token?: (hashgraph.proto.ITokenID|null);

            /** The account to be unfrozen */
            account?: (hashgraph.proto.IAccountID|null);
        }

        /**
         * Unfreezes transfers of the specified token for the account. Must be signed by the Token's
         * freezeKey.
         * If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.
         * If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.
         * If the provided token is not found, the transaction will resolve to INVALID_TOKEN_ID.
         * If the provided token has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.
         * If an Association between the provided token and account is not found, the transaction will
         * resolve to TOKEN_NOT_ASSOCIATED_TO_ACCOUNT.
         * If no Freeze Key is defined, the transaction will resolve to TOKEN_HAS_NO_FREEZE_KEY.
         * Once executed the Account is marked as Unfrozen and will be able to receive or send tokens. The
         * operation is idempotent.
         */
        class TokenUnfreezeAccountTransactionBody implements ITokenUnfreezeAccountTransactionBody {

            /**
             * Constructs a new TokenUnfreezeAccountTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenUnfreezeAccountTransactionBody);

            /**
             * The token for which this account will be unfrozen. If token does not exist, transaction
             * results in INVALID_TOKEN_ID
             */
            public token?: (hashgraph.proto.ITokenID|null);

            /** The account to be unfrozen */
            public account?: (hashgraph.proto.IAccountID|null);

            /**
             * Creates a new TokenUnfreezeAccountTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenUnfreezeAccountTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.ITokenUnfreezeAccountTransactionBody): hashgraph.proto.TokenUnfreezeAccountTransactionBody;

            /**
             * Encodes the specified TokenUnfreezeAccountTransactionBody message. Does not implicitly {@link hashgraph.proto.TokenUnfreezeAccountTransactionBody.verify|verify} messages.
             * @param m TokenUnfreezeAccountTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenUnfreezeAccountTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenUnfreezeAccountTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenUnfreezeAccountTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenUnfreezeAccountTransactionBody;

            /**
             * Gets the default type url for TokenUnfreezeAccountTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenGrantKycTransactionBody. */
        interface ITokenGrantKycTransactionBody {

            /**
             * The token for which this account will be granted KYC. If token does not exist, transaction
             * results in INVALID_TOKEN_ID
             */
            token?: (hashgraph.proto.ITokenID|null);

            /** The account to be KYCed */
            account?: (hashgraph.proto.IAccountID|null);
        }

        /**
         * Grants KYC to the account for the given token. Must be signed by the Token's kycKey.
         * If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.
         * If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.
         * If the provided token is not found, the transaction will resolve to INVALID_TOKEN_ID.
         * If the provided token has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.
         * If an Association between the provided token and account is not found, the transaction will
         * resolve to TOKEN_NOT_ASSOCIATED_TO_ACCOUNT.
         * If no KYC Key is defined, the transaction will resolve to TOKEN_HAS_NO_KYC_KEY.
         * Once executed the Account is marked as KYC Granted.
         */
        class TokenGrantKycTransactionBody implements ITokenGrantKycTransactionBody {

            /**
             * Constructs a new TokenGrantKycTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenGrantKycTransactionBody);

            /**
             * The token for which this account will be granted KYC. If token does not exist, transaction
             * results in INVALID_TOKEN_ID
             */
            public token?: (hashgraph.proto.ITokenID|null);

            /** The account to be KYCed */
            public account?: (hashgraph.proto.IAccountID|null);

            /**
             * Creates a new TokenGrantKycTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenGrantKycTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.ITokenGrantKycTransactionBody): hashgraph.proto.TokenGrantKycTransactionBody;

            /**
             * Encodes the specified TokenGrantKycTransactionBody message. Does not implicitly {@link hashgraph.proto.TokenGrantKycTransactionBody.verify|verify} messages.
             * @param m TokenGrantKycTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenGrantKycTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenGrantKycTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenGrantKycTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenGrantKycTransactionBody;

            /**
             * Gets the default type url for TokenGrantKycTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenRevokeKycTransactionBody. */
        interface ITokenRevokeKycTransactionBody {

            /**
             * The token for which this account will get his KYC revoked. If token does not exist,
             * transaction results in INVALID_TOKEN_ID
             */
            token?: (hashgraph.proto.ITokenID|null);

            /** The account to be KYC Revoked */
            account?: (hashgraph.proto.IAccountID|null);
        }

        /**
         * Revokes KYC to the account for the given token. Must be signed by the Token's kycKey.
         * If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.
         * If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.
         * If the provided token is not found, the transaction will resolve to INVALID_TOKEN_ID.
         * If the provided token has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.
         * If an Association between the provided token and account is not found, the transaction will
         * resolve to TOKEN_NOT_ASSOCIATED_TO_ACCOUNT.
         * If no KYC Key is defined, the transaction will resolve to TOKEN_HAS_NO_KYC_KEY.
         * Once executed the Account is marked as KYC Revoked
         */
        class TokenRevokeKycTransactionBody implements ITokenRevokeKycTransactionBody {

            /**
             * Constructs a new TokenRevokeKycTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenRevokeKycTransactionBody);

            /**
             * The token for which this account will get his KYC revoked. If token does not exist,
             * transaction results in INVALID_TOKEN_ID
             */
            public token?: (hashgraph.proto.ITokenID|null);

            /** The account to be KYC Revoked */
            public account?: (hashgraph.proto.IAccountID|null);

            /**
             * Creates a new TokenRevokeKycTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenRevokeKycTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.ITokenRevokeKycTransactionBody): hashgraph.proto.TokenRevokeKycTransactionBody;

            /**
             * Encodes the specified TokenRevokeKycTransactionBody message. Does not implicitly {@link hashgraph.proto.TokenRevokeKycTransactionBody.verify|verify} messages.
             * @param m TokenRevokeKycTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenRevokeKycTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenRevokeKycTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenRevokeKycTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenRevokeKycTransactionBody;

            /**
             * Gets the default type url for TokenRevokeKycTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenDeleteTransactionBody. */
        interface ITokenDeleteTransactionBody {

            /**
             * The token to be deleted. If invalid token is specified, transaction will
             * result in INVALID_TOKEN_ID
             */
            token?: (hashgraph.proto.ITokenID|null);
        }

        /**
         * Marks a token as deleted, though it will remain in the ledger.
         * The operation must be signed by the specified Admin Key of the Token. If
         * admin key is not set, Transaction will result in TOKEN_IS_IMMUTABlE.
         * Once deleted update, mint, burn, wipe, freeze, unfreeze, grant kyc, revoke
         * kyc and token transfer transactions will resolve to TOKEN_WAS_DELETED.
         */
        class TokenDeleteTransactionBody implements ITokenDeleteTransactionBody {

            /**
             * Constructs a new TokenDeleteTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenDeleteTransactionBody);

            /**
             * The token to be deleted. If invalid token is specified, transaction will
             * result in INVALID_TOKEN_ID
             */
            public token?: (hashgraph.proto.ITokenID|null);

            /**
             * Creates a new TokenDeleteTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenDeleteTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.ITokenDeleteTransactionBody): hashgraph.proto.TokenDeleteTransactionBody;

            /**
             * Encodes the specified TokenDeleteTransactionBody message. Does not implicitly {@link hashgraph.proto.TokenDeleteTransactionBody.verify|verify} messages.
             * @param m TokenDeleteTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenDeleteTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenDeleteTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenDeleteTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenDeleteTransactionBody;

            /**
             * Gets the default type url for TokenDeleteTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenUpdateTransactionBody. */
        interface ITokenUpdateTransactionBody {

            /** The Token to be updated */
            token?: (hashgraph.proto.ITokenID|null);

            /**
             * The new publicly visible token symbol. The token symbol is specified as a Unicode string.
             * Its UTF-8 encoding cannot exceed 100 bytes, and cannot contain the 0 byte (NUL).
             */
            symbol?: (string|null);

            /**
             * The new publicly visible name of the token. The token name is specified as a Unicode string.
             * Its UTF-8 encoding cannot exceed 100 bytes, and cannot contain the 0 byte (NUL).
             */
            name?: (string|null);

            /**
             * The new Treasury account of the Token. If the provided treasury account is not existing or
             * deleted, the response will be INVALID_TREASURY_ACCOUNT_FOR_TOKEN. If successful, the Token
             * balance held in the previous Treasury Account is transferred to the new one.
             */
            treasury?: (hashgraph.proto.IAccountID|null);

            /**
             * The new admin key of the Token. If Token is immutable, transaction will resolve to
             * TOKEN_IS_IMMUTABlE.
             */
            adminKey?: (hashgraph.proto.IKey|null);

            /**
             * The new KYC key of the Token. If Token does not have currently a KYC key, transaction will
             * resolve to TOKEN_HAS_NO_KYC_KEY.
             */
            kycKey?: (hashgraph.proto.IKey|null);

            /**
             * The new Freeze key of the Token. If the Token does not have currently a Freeze key,
             * transaction will resolve to TOKEN_HAS_NO_FREEZE_KEY.
             */
            freezeKey?: (hashgraph.proto.IKey|null);

            /**
             * The new Wipe key of the Token. If the Token does not have currently a Wipe key, transaction
             * will resolve to TOKEN_HAS_NO_WIPE_KEY.
             */
            wipeKey?: (hashgraph.proto.IKey|null);

            /**
             * The new Supply key of the Token. If the Token does not have currently a Supply key,
             * transaction will resolve to TOKEN_HAS_NO_SUPPLY_KEY.
             */
            supplyKey?: (hashgraph.proto.IKey|null);

            /**
             * The new account which will be automatically charged to renew the token's expiration, at
             * autoRenewPeriod interval.
             */
            autoRenewAccount?: (hashgraph.proto.IAccountID|null);

            /**
             * The new interval at which the auto-renew account will be charged to extend the token's
             * expiry.
             */
            autoRenewPeriod?: (hashgraph.proto.IDuration|null);

            /**
             * The new expiry time of the token. Expiry can be updated even if admin key is not set. If the
             * provided expiry is earlier than the current token expiry, transaction wil resolve to
             * INVALID_EXPIRATION_TIME
             */
            expiry?: (hashgraph.proto.ITimestamp|null);

            /** If set, the new memo to be associated with the token (UTF-8 encoding max 100 bytes) */
            memo?: (google.protobuf.IStringValue|null);

            /**
             * If set, the new key to use to update the token's custom fee schedule; if the token does not
             * currently have this key, transaction will resolve to TOKEN_HAS_NO_FEE_SCHEDULE_KEY
             */
            feeScheduleKey?: (hashgraph.proto.IKey|null);

            /**
             * The Key which can pause and unpause the Token. If the Token does not currently have a pause key,
             * transaction will resolve to TOKEN_HAS_NO_PAUSE_KEY
             */
            pauseKey?: (hashgraph.proto.IKey|null);
        }

        /**
         * At consensus, updates an already created token to the given values.
         *
         * If no value is given for a field, that field is left unchanged. For an immutable tokens (that is,
         * a token without an admin key), only the expiry may be updated. Setting any other field in that
         * case will cause the transaction status to resolve to TOKEN_IS_IMMUTABLE.
         *
         * --- Signing Requirements ---
         * 1. Whether or not a token has an admin key, its expiry can be extended with only the transaction
         * payer's signature.
         * 2. Updating any other field of a mutable token requires the admin key's signature.
         * 3. If a new admin key is set, this new key must sign <b>unless</b> it is exactly an empty
         * <tt>KeyList</tt>. This special sentinel key removes the existing admin key and causes the
         * token to become immutable. (Other <tt>Key</tt> structures without a constituent
         * <tt>Ed25519</tt> key will be rejected with <tt>INVALID_ADMIN_KEY</tt>.)
         * 4. If a new treasury is set, the new treasury account's key must sign the transaction.
         *
         * --- Nft Requirements ---
         * 1. If a non fungible token has a positive treasury balance, the operation will abort with
         * CURRENT_TREASURY_STILL_OWNS_NFTS.
         */
        class TokenUpdateTransactionBody implements ITokenUpdateTransactionBody {

            /**
             * Constructs a new TokenUpdateTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenUpdateTransactionBody);

            /** The Token to be updated */
            public token?: (hashgraph.proto.ITokenID|null);

            /**
             * The new publicly visible token symbol. The token symbol is specified as a Unicode string.
             * Its UTF-8 encoding cannot exceed 100 bytes, and cannot contain the 0 byte (NUL).
             */
            public symbol: string;

            /**
             * The new publicly visible name of the token. The token name is specified as a Unicode string.
             * Its UTF-8 encoding cannot exceed 100 bytes, and cannot contain the 0 byte (NUL).
             */
            public name: string;

            /**
             * The new Treasury account of the Token. If the provided treasury account is not existing or
             * deleted, the response will be INVALID_TREASURY_ACCOUNT_FOR_TOKEN. If successful, the Token
             * balance held in the previous Treasury Account is transferred to the new one.
             */
            public treasury?: (hashgraph.proto.IAccountID|null);

            /**
             * The new admin key of the Token. If Token is immutable, transaction will resolve to
             * TOKEN_IS_IMMUTABlE.
             */
            public adminKey?: (hashgraph.proto.IKey|null);

            /**
             * The new KYC key of the Token. If Token does not have currently a KYC key, transaction will
             * resolve to TOKEN_HAS_NO_KYC_KEY.
             */
            public kycKey?: (hashgraph.proto.IKey|null);

            /**
             * The new Freeze key of the Token. If the Token does not have currently a Freeze key,
             * transaction will resolve to TOKEN_HAS_NO_FREEZE_KEY.
             */
            public freezeKey?: (hashgraph.proto.IKey|null);

            /**
             * The new Wipe key of the Token. If the Token does not have currently a Wipe key, transaction
             * will resolve to TOKEN_HAS_NO_WIPE_KEY.
             */
            public wipeKey?: (hashgraph.proto.IKey|null);

            /**
             * The new Supply key of the Token. If the Token does not have currently a Supply key,
             * transaction will resolve to TOKEN_HAS_NO_SUPPLY_KEY.
             */
            public supplyKey?: (hashgraph.proto.IKey|null);

            /**
             * The new account which will be automatically charged to renew the token's expiration, at
             * autoRenewPeriod interval.
             */
            public autoRenewAccount?: (hashgraph.proto.IAccountID|null);

            /**
             * The new interval at which the auto-renew account will be charged to extend the token's
             * expiry.
             */
            public autoRenewPeriod?: (hashgraph.proto.IDuration|null);

            /**
             * The new expiry time of the token. Expiry can be updated even if admin key is not set. If the
             * provided expiry is earlier than the current token expiry, transaction wil resolve to
             * INVALID_EXPIRATION_TIME
             */
            public expiry?: (hashgraph.proto.ITimestamp|null);

            /** If set, the new memo to be associated with the token (UTF-8 encoding max 100 bytes) */
            public memo?: (google.protobuf.IStringValue|null);

            /**
             * If set, the new key to use to update the token's custom fee schedule; if the token does not
             * currently have this key, transaction will resolve to TOKEN_HAS_NO_FEE_SCHEDULE_KEY
             */
            public feeScheduleKey?: (hashgraph.proto.IKey|null);

            /**
             * The Key which can pause and unpause the Token. If the Token does not currently have a pause key,
             * transaction will resolve to TOKEN_HAS_NO_PAUSE_KEY
             */
            public pauseKey?: (hashgraph.proto.IKey|null);

            /**
             * Creates a new TokenUpdateTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenUpdateTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.ITokenUpdateTransactionBody): hashgraph.proto.TokenUpdateTransactionBody;

            /**
             * Encodes the specified TokenUpdateTransactionBody message. Does not implicitly {@link hashgraph.proto.TokenUpdateTransactionBody.verify|verify} messages.
             * @param m TokenUpdateTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenUpdateTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenUpdateTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenUpdateTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenUpdateTransactionBody;

            /**
             * Gets the default type url for TokenUpdateTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenMintTransactionBody. */
        interface ITokenMintTransactionBody {

            /**
             * The token for which to mint tokens. If token does not exist, transaction results in
             * INVALID_TOKEN_ID
             */
            token?: (hashgraph.proto.ITokenID|null);

            /**
             * Applicable to tokens of type FUNGIBLE_COMMON. The amount to mint to the Treasury Account.
             * Amount must be a positive non-zero number represented in the lowest denomination of the
             * token. The new supply must be lower than 2^63.
             */
            amount?: (Long|null);

            /**
             * Applicable to tokens of type NON_FUNGIBLE_UNIQUE. A list of metadata that are being created.
             * Maximum allowed size of each metadata is 100 bytes
             */
            metadata?: (Uint8Array[]|null);
        }

        /**
         * Mints tokens to the Token's treasury Account. If no Supply Key is defined, the transaction will
         * resolve to TOKEN_HAS_NO_SUPPLY_KEY.
         * The operation increases the Total Supply of the Token. The maximum total supply a token can have
         * is 2^63-1.
         * The amount provided must be in the lowest denomination possible. Example:
         * Token A has 2 decimals. In order to mint 100 tokens, one must provide amount of 10000. In order
         * to mint 100.55 tokens, one must provide amount of 10055.
         * If both amount and metadata list get filled, a INVALID_TRANSACTION_BODY response code will be
         * returned.
         * If the metadata list contains metadata which is too large, a METADATA_TOO_LONG response code will
         * be returned.
         * If the metadata list is not filled for a non-fungible token type, a INVALID_TOKEN_MINT_AMOUNT response
         * code will be returned.
         * If a zero amount is provided for a fungible token type, it will be treated as a regular transaction.
         * If the metadata list count is greater than the batch size limit global dynamic property, a
         * BATCH_SIZE_LIMIT_EXCEEDED response code will be returned.
         */
        class TokenMintTransactionBody implements ITokenMintTransactionBody {

            /**
             * Constructs a new TokenMintTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenMintTransactionBody);

            /**
             * The token for which to mint tokens. If token does not exist, transaction results in
             * INVALID_TOKEN_ID
             */
            public token?: (hashgraph.proto.ITokenID|null);

            /**
             * Applicable to tokens of type FUNGIBLE_COMMON. The amount to mint to the Treasury Account.
             * Amount must be a positive non-zero number represented in the lowest denomination of the
             * token. The new supply must be lower than 2^63.
             */
            public amount: Long;

            /**
             * Applicable to tokens of type NON_FUNGIBLE_UNIQUE. A list of metadata that are being created.
             * Maximum allowed size of each metadata is 100 bytes
             */
            public metadata: Uint8Array[];

            /**
             * Creates a new TokenMintTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenMintTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.ITokenMintTransactionBody): hashgraph.proto.TokenMintTransactionBody;

            /**
             * Encodes the specified TokenMintTransactionBody message. Does not implicitly {@link hashgraph.proto.TokenMintTransactionBody.verify|verify} messages.
             * @param m TokenMintTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenMintTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenMintTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenMintTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenMintTransactionBody;

            /**
             * Gets the default type url for TokenMintTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenBurnTransactionBody. */
        interface ITokenBurnTransactionBody {

            /**
             * The token for which to burn tokens. If token does not exist, transaction results in
             * INVALID_TOKEN_ID
             */
            token?: (hashgraph.proto.ITokenID|null);

            /**
             * Applicable to tokens of type FUNGIBLE_COMMON. The amount to burn from the Treasury Account.
             * Amount must be a positive non-zero number, not bigger than the token balance of the treasury
             * account (0; balance], represented in the lowest denomination.
             */
            amount?: (Long|null);

            /** Applicable to tokens of type NON_FUNGIBLE_UNIQUE. The list of serial numbers to be burned. */
            serialNumbers?: (Long[]|null);
        }

        /**
         * Burns tokens from the Token's treasury Account. If no Supply Key is defined, the transaction will
         * resolve to TOKEN_HAS_NO_SUPPLY_KEY.
         * The operation decreases the Total Supply of the Token. Total supply cannot go below zero.
         * The amount provided must be in the lowest denomination possible. Example:
         * Token A has 2 decimals. In order to burn 100 tokens, one must provide amount of 10000. In order
         * to burn 100.55 tokens, one must provide amount of 10055.
         * For non fungible tokens the transaction body accepts serialNumbers list of integers as a parameter.
         *
         * If the serialNumbers don't get filled for non-fungible token type, a INVALID_TOKEN_BURN_AMOUNT response
         * code will be returned.
         * If a zero amount is provided for a fungible token type, it will be treated as a regular transaction.
         * If both amount and serialNumbers get filled, a INVALID_TRANSACTION_BODY response code will be
         * returned.
         * If the serialNumbers' list count is greater than the batch size limit global dynamic property, a
         * BATCH_SIZE_LIMIT_EXCEEDED response code will be returned.
         * If the serialNumbers list contains a non-positive integer as a serial number, a INVALID_NFT_ID
         * response code will be returned.
         */
        class TokenBurnTransactionBody implements ITokenBurnTransactionBody {

            /**
             * Constructs a new TokenBurnTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenBurnTransactionBody);

            /**
             * The token for which to burn tokens. If token does not exist, transaction results in
             * INVALID_TOKEN_ID
             */
            public token?: (hashgraph.proto.ITokenID|null);

            /**
             * Applicable to tokens of type FUNGIBLE_COMMON. The amount to burn from the Treasury Account.
             * Amount must be a positive non-zero number, not bigger than the token balance of the treasury
             * account (0; balance], represented in the lowest denomination.
             */
            public amount: Long;

            /** Applicable to tokens of type NON_FUNGIBLE_UNIQUE. The list of serial numbers to be burned. */
            public serialNumbers: Long[];

            /**
             * Creates a new TokenBurnTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenBurnTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.ITokenBurnTransactionBody): hashgraph.proto.TokenBurnTransactionBody;

            /**
             * Encodes the specified TokenBurnTransactionBody message. Does not implicitly {@link hashgraph.proto.TokenBurnTransactionBody.verify|verify} messages.
             * @param m TokenBurnTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenBurnTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenBurnTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenBurnTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenBurnTransactionBody;

            /**
             * Gets the default type url for TokenBurnTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenWipeAccountTransactionBody. */
        interface ITokenWipeAccountTransactionBody {

            /**
             * The token for which the account will be wiped. If token does not exist, transaction results
             * in INVALID_TOKEN_ID
             */
            token?: (hashgraph.proto.ITokenID|null);

            /** The account to be wiped */
            account?: (hashgraph.proto.IAccountID|null);

            /**
             * Applicable to tokens of type FUNGIBLE_COMMON. The amount of tokens to wipe from the specified
             * account. Amount must be a positive non-zero number in the lowest denomination possible, not
             * bigger than the token balance of the account (0; balance]
             */
            amount?: (Long|null);

            /** Applicable to tokens of type NON_FUNGIBLE_UNIQUE. The list of serial numbers to be wiped. */
            serialNumbers?: (Long[]|null);
        }

        /**
         * Wipes the provided amount of tokens from the specified Account. Must be signed by the Token's
         * Wipe key.
         * If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.
         * If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.
         * If the provided token is not found, the transaction will resolve to INVALID_TOKEN_ID.
         * If the provided token has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.
         * If an Association between the provided token and account is not found, the transaction will
         * resolve to TOKEN_NOT_ASSOCIATED_TO_ACCOUNT.
         * If Wipe Key is not present in the Token, transaction results in TOKEN_HAS_NO_WIPE_KEY.
         * If the provided account is the Token's Treasury Account, transaction results in
         * CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT
         * On success, tokens are removed from the account and the total supply of the token is decreased by
         * the wiped amount.
         *
         * If both amount and serialNumbers get filled, a INVALID_TRANSACTION_BODY response code will be
         * returned.
         * If the serialNumbers don't get filled for a non-fungible token type, a INVALID_WIPING_AMOUNT response
         * code will be returned.
         * If a zero amount is provided for a fungible token type, it will be treated as a regular transaction.
         * If the serialNumbers list contains a non-positive integer as a serial number, a INVALID_NFT_ID
         * response code will be returned.
         * If the serialNumbers' list count is greater than the batch size limit global dynamic property, a
         * BATCH_SIZE_LIMIT_EXCEEDED response code will be returned.
         *
         * The amount provided is in the lowest denomination possible. Example:
         * Token A has 2 decimals. In order to wipe 100 tokens from account, one must provide amount of
         * 10000. In order to wipe 100.55 tokens, one must provide amount of 10055.
         */
        class TokenWipeAccountTransactionBody implements ITokenWipeAccountTransactionBody {

            /**
             * Constructs a new TokenWipeAccountTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenWipeAccountTransactionBody);

            /**
             * The token for which the account will be wiped. If token does not exist, transaction results
             * in INVALID_TOKEN_ID
             */
            public token?: (hashgraph.proto.ITokenID|null);

            /** The account to be wiped */
            public account?: (hashgraph.proto.IAccountID|null);

            /**
             * Applicable to tokens of type FUNGIBLE_COMMON. The amount of tokens to wipe from the specified
             * account. Amount must be a positive non-zero number in the lowest denomination possible, not
             * bigger than the token balance of the account (0; balance]
             */
            public amount: Long;

            /** Applicable to tokens of type NON_FUNGIBLE_UNIQUE. The list of serial numbers to be wiped. */
            public serialNumbers: Long[];

            /**
             * Creates a new TokenWipeAccountTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenWipeAccountTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.ITokenWipeAccountTransactionBody): hashgraph.proto.TokenWipeAccountTransactionBody;

            /**
             * Encodes the specified TokenWipeAccountTransactionBody message. Does not implicitly {@link hashgraph.proto.TokenWipeAccountTransactionBody.verify|verify} messages.
             * @param m TokenWipeAccountTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenWipeAccountTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenWipeAccountTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenWipeAccountTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenWipeAccountTransactionBody;

            /**
             * Gets the default type url for TokenWipeAccountTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenAssociateTransactionBody. */
        interface ITokenAssociateTransactionBody {

            /** The account to be associated with the provided tokens */
            account?: (hashgraph.proto.IAccountID|null);

            /**
             * The tokens to be associated with the provided account. In the case of NON_FUNGIBLE_UNIQUE
             * Type, once an account is associated, it can hold any number of NFTs (serial numbers) of that
             * token type
             */
            tokens?: (hashgraph.proto.ITokenID[]|null);
        }

        /**
         * Associates the provided account with the provided tokens. Must be signed by the provided
         * Account's key.
         * If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.
         * If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.
         * If any of the provided tokens is not found, the transaction will resolve to INVALID_TOKEN_REF.
         * If any of the provided tokens has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.
         * If an association between the provided account and any of the tokens already exists, the
         * transaction will resolve to TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT.
         * If the provided account's associations count exceed the constraint of maximum token associations
         * per account, the transaction will resolve to TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED.
         * On success, associations between the provided account and tokens are made and the account is
         * ready to interact with the tokens.
         */
        class TokenAssociateTransactionBody implements ITokenAssociateTransactionBody {

            /**
             * Constructs a new TokenAssociateTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenAssociateTransactionBody);

            /** The account to be associated with the provided tokens */
            public account?: (hashgraph.proto.IAccountID|null);

            /**
             * The tokens to be associated with the provided account. In the case of NON_FUNGIBLE_UNIQUE
             * Type, once an account is associated, it can hold any number of NFTs (serial numbers) of that
             * token type
             */
            public tokens: hashgraph.proto.ITokenID[];

            /**
             * Creates a new TokenAssociateTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenAssociateTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.ITokenAssociateTransactionBody): hashgraph.proto.TokenAssociateTransactionBody;

            /**
             * Encodes the specified TokenAssociateTransactionBody message. Does not implicitly {@link hashgraph.proto.TokenAssociateTransactionBody.verify|verify} messages.
             * @param m TokenAssociateTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenAssociateTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenAssociateTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenAssociateTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenAssociateTransactionBody;

            /**
             * Gets the default type url for TokenAssociateTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenDissociateTransactionBody. */
        interface ITokenDissociateTransactionBody {

            /** The account to be dissociated with the provided tokens */
            account?: (hashgraph.proto.IAccountID|null);

            /** The tokens to be dissociated with the provided account */
            tokens?: (hashgraph.proto.ITokenID[]|null);
        }

        /**
         * Dissociates the provided account with the provided tokens. Must be signed by the provided
         * Account's key.
         * If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.
         * If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.
         * If any of the provided tokens is not found, the transaction will resolve to INVALID_TOKEN_REF.
         * If any of the provided tokens has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.
         * If an association between the provided account and any of the tokens does not exist, the
         * transaction will resolve to TOKEN_NOT_ASSOCIATED_TO_ACCOUNT.
         * If a token has not been deleted and has not expired, and the user has a nonzero balance, the
         * transaction will resolve to TRANSACTION_REQUIRES_ZERO_TOKEN_BALANCES.
         * If a <b>fungible token</b> has expired, the user can disassociate even if their token balance is
         * not zero.
         * If a <b>non fungible token</b> has expired, the user can <b>not</b> disassociate if their token
         * balance is not zero. The transaction will resolve to TRANSACTION_REQUIRED_ZERO_TOKEN_BALANCES.
         * On success, associations between the provided account and tokens are removed.
         */
        class TokenDissociateTransactionBody implements ITokenDissociateTransactionBody {

            /**
             * Constructs a new TokenDissociateTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenDissociateTransactionBody);

            /** The account to be dissociated with the provided tokens */
            public account?: (hashgraph.proto.IAccountID|null);

            /** The tokens to be dissociated with the provided account */
            public tokens: hashgraph.proto.ITokenID[];

            /**
             * Creates a new TokenDissociateTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenDissociateTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.ITokenDissociateTransactionBody): hashgraph.proto.TokenDissociateTransactionBody;

            /**
             * Encodes the specified TokenDissociateTransactionBody message. Does not implicitly {@link hashgraph.proto.TokenDissociateTransactionBody.verify|verify} messages.
             * @param m TokenDissociateTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenDissociateTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenDissociateTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenDissociateTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenDissociateTransactionBody;

            /**
             * Gets the default type url for TokenDissociateTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenFeeScheduleUpdateTransactionBody. */
        interface ITokenFeeScheduleUpdateTransactionBody {

            /** The token whose fee schedule is to be updated */
            tokenId?: (hashgraph.proto.ITokenID|null);

            /** The new custom fees to be assessed during a CryptoTransfer that transfers units of this token */
            customFees?: (hashgraph.proto.ICustomFee[]|null);
        }

        /**
         * At consensus, updates a token type's fee schedule to the given list of custom fees.
         *
         * If the target token type has no fee_schedule_key, resolves to TOKEN_HAS_NO_FEE_SCHEDULE_KEY.
         * Otherwise this transaction must be signed to the fee_schedule_key, or the transaction will
         * resolve to INVALID_SIGNATURE.
         *
         * If the custom_fees list is empty, clears the fee schedule or resolves to
         * CUSTOM_SCHEDULE_ALREADY_HAS_NO_FEES if the fee schedule was already empty.
         */
        class TokenFeeScheduleUpdateTransactionBody implements ITokenFeeScheduleUpdateTransactionBody {

            /**
             * Constructs a new TokenFeeScheduleUpdateTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenFeeScheduleUpdateTransactionBody);

            /** The token whose fee schedule is to be updated */
            public tokenId?: (hashgraph.proto.ITokenID|null);

            /** The new custom fees to be assessed during a CryptoTransfer that transfers units of this token */
            public customFees: hashgraph.proto.ICustomFee[];

            /**
             * Creates a new TokenFeeScheduleUpdateTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenFeeScheduleUpdateTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.ITokenFeeScheduleUpdateTransactionBody): hashgraph.proto.TokenFeeScheduleUpdateTransactionBody;

            /**
             * Encodes the specified TokenFeeScheduleUpdateTransactionBody message. Does not implicitly {@link hashgraph.proto.TokenFeeScheduleUpdateTransactionBody.verify|verify} messages.
             * @param m TokenFeeScheduleUpdateTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenFeeScheduleUpdateTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenFeeScheduleUpdateTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenFeeScheduleUpdateTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenFeeScheduleUpdateTransactionBody;

            /**
             * Gets the default type url for TokenFeeScheduleUpdateTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenPauseTransactionBody. */
        interface ITokenPauseTransactionBody {

            /** The token to be paused. */
            token?: (hashgraph.proto.ITokenID|null);
        }

        /**
         * Pauses the Token from being involved in any kind of Transaction until it is unpaused.
         * Must be signed with the Token's pause key.
         * If the provided token is not found, the transaction will resolve to INVALID_TOKEN_ID.
         * If the provided token has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.
         * If no Pause Key is defined, the transaction will resolve to TOKEN_HAS_NO_PAUSE_KEY.
         * Once executed the Token is marked as paused and will be not able to be a part of any transaction.
         * The operation is idempotent - becomes a no-op if the Token is already Paused.
         */
        class TokenPauseTransactionBody implements ITokenPauseTransactionBody {

            /**
             * Constructs a new TokenPauseTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenPauseTransactionBody);

            /** The token to be paused. */
            public token?: (hashgraph.proto.ITokenID|null);

            /**
             * Creates a new TokenPauseTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenPauseTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.ITokenPauseTransactionBody): hashgraph.proto.TokenPauseTransactionBody;

            /**
             * Encodes the specified TokenPauseTransactionBody message. Does not implicitly {@link hashgraph.proto.TokenPauseTransactionBody.verify|verify} messages.
             * @param m TokenPauseTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenPauseTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenPauseTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenPauseTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenPauseTransactionBody;

            /**
             * Gets the default type url for TokenPauseTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenUnpauseTransactionBody. */
        interface ITokenUnpauseTransactionBody {

            /** The token to be unpaused. */
            token?: (hashgraph.proto.ITokenID|null);
        }

        /**
         * Unpauses the Token. Must be signed with the Token's pause key.
         * If the provided token is not found, the transaction will resolve to INVALID_TOKEN_ID.
         * If the provided token has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.
         * If no Pause Key is defined, the transaction will resolve to TOKEN_HAS_NO_PAUSE_KEY.
         * Once executed the Token is marked as Unpaused and can be used in Transactions.
         * The operation is idempotent - becomes a no-op if the Token is already unpaused.
         */
        class TokenUnpauseTransactionBody implements ITokenUnpauseTransactionBody {

            /**
             * Constructs a new TokenUnpauseTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenUnpauseTransactionBody);

            /** The token to be unpaused. */
            public token?: (hashgraph.proto.ITokenID|null);

            /**
             * Creates a new TokenUnpauseTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenUnpauseTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.ITokenUnpauseTransactionBody): hashgraph.proto.TokenUnpauseTransactionBody;

            /**
             * Encodes the specified TokenUnpauseTransactionBody message. Does not implicitly {@link hashgraph.proto.TokenUnpauseTransactionBody.verify|verify} messages.
             * @param m TokenUnpauseTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenUnpauseTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenUnpauseTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenUnpauseTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenUnpauseTransactionBody;

            /**
             * Gets the default type url for TokenUnpauseTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ScheduleCreateTransactionBody. */
        interface IScheduleCreateTransactionBody {

            /** The scheduled transaction */
            scheduledTransactionBody?: (hashgraph.proto.ISchedulableTransactionBody|null);

            /**
             * An optional memo with a UTF-8 encoding of no more than 100 bytes which does not contain the
             * zero byte
             */
            memo?: (string|null);

            /** An optional Hedera key which can be used to sign a ScheduleDelete and remove the schedule */
            adminKey?: (hashgraph.proto.IKey|null);

            /**
             * An optional id of the account to be charged the service fee for the scheduled transaction at
             * the consensus time that it executes (if ever); defaults to the ScheduleCreate payer if not
             * given
             */
            payerAccountID?: (hashgraph.proto.IAccountID|null);

            /**
             * An optional timestamp for specifying when the transaction should be evaluated for execution and then expire.
             * Defaults to 30 minutes after the transaction's consensus timestamp.
             *
             * Note: This field is unused and forced to be unset until Long Term Scheduled Transactions are enabled - Transactions will always
             * expire in 30 minutes if Long Term Scheduled Transactions are not enabled.
             */
            expirationTime?: (hashgraph.proto.ITimestamp|null);

            /**
             * When set to true, the transaction will be evaluated for execution at expiration_time instead
             * of when all required signatures are received.
             * When set to false, the transaction will execute immediately after sufficient signatures are received
             * to sign the contained transaction. During the initial ScheduleCreate transaction or via ScheduleSign transactions.
             *
             * Defaults to false.
             *
             * Setting this to false does not necessarily mean that the transaction will never execute at expiration_time.
             * For Example - If the signature requirements for a Scheduled Transaction change via external means (e.g. CryptoUpdate)
             * such that the Scheduled Transaction would be allowed to execute, it will do so autonomously at expiration_time, unless a
             * ScheduleSign comes in to “poke” it and force it to go through immediately.
             *
             * Note: This field is unused and forced to be unset until Long Term Scheduled Transactions are enabled. Before Long Term
             * Scheduled Transactions are enabled, Scheduled Transactions will _never_ execute at expiration  - they will _only_
             * execute during the initial ScheduleCreate transaction or via ScheduleSign transactions and will _always_
             * expire at expiration_time.
             */
            waitForExpiry?: (boolean|null);
        }

        /**
         * Create a new <i>schedule entity</i> (or simply, <i>schedule</i>) in the network's action queue.
         * Upon <tt>SUCCESS</tt>, the receipt contains the `ScheduleID` of the created schedule. A schedule
         * entity includes a <tt>scheduledTransactionBody</tt> to be executed.
         * When the schedule has collected enough signing Ed25519 keys to satisfy the schedule's signing
         * requirements, the schedule can be executed.
         *
         * If Long Term Scheduled Transactions are enabled and <tt>wait_for_expiry</tt> is set to <tt>true</tt>, then the schedule
         * will execute at it's <tt>expiration_time</tt>.
         *
         * Otherwise it will execute immediately after the transaction that provided enough Ed25519 keys, a <tt>ScheduleCreate</tt>
         * or <tt>ScheduleSign</tt>.
         *
         * Upon `SUCCESS`, the receipt also includes the <tt>scheduledTransactionID</tt> to
         * use to query for the record of the scheduled transaction's execution (if it occurs).
         *
         * The expiration time of a schedule is controlled by it's <tt>expiration_time</tt>. It remains in state and can be queried
         * using <tt>GetScheduleInfo</tt> until expiration, no matter if the scheduled transaction has
         * executed or marked deleted. If Long Term Scheduled Transactions are disabled, the <tt>expiration_time</tt> is always
         * 30 minutes in the future.
         *
         * If the <tt>adminKey</tt> field is omitted, the resulting schedule is immutable. If the
         * <tt>adminKey</tt> is set, the <tt>ScheduleDelete</tt> transaction can be used to mark it as
         * deleted. The creator may also specify an optional <tt>memo</tt> whose UTF-8 encoding is at most
         * 100 bytes and does not include the zero byte is also supported.
         *
         * When a <tt>scheduledTransactionBody</tt> is executed, the
         * network only charges its payer the service fee, and not the node and network fees. If the
         * optional <tt>payerAccountID</tt> is set, the network charges this account. Otherwise it charges
         * the payer of the originating <tt>ScheduleCreate</tt>.
         *
         * Two <tt>ScheduleCreate</tt> transactions are <i>identical</i> if they are equal in all their
         * fields other than <tt>payerAccountID</tt>.  (For the <tt>scheduledTransactionBody</tt> field,
         * "equal" should be understood in the sense of
         * gRPC object equality in the network software runtime. In particular, a gRPC object with <a
         * href="https://developers.google.com/protocol-buffers/docs/proto3#unknowns">unknown fields</a> is
         * not equal to a gRPC object without unknown fields, even if they agree on all known fields.)
         *
         * A <tt>ScheduleCreate</tt> transaction that attempts to re-create an identical schedule already in
         * state will receive a receipt with status <tt>IDENTICAL_SCHEDULE_ALREADY_CREATED</tt>; the receipt
         * will include the <tt>ScheduleID</tt> of the extant schedule, which may be used in a subsequent
         * <tt>ScheduleSign</tt> transaction. (The receipt will also include the <tt>TransactionID</tt> to
         * use in querying for the receipt or record of the scheduled transaction.)
         *
         * Other notable response codes include, <tt>INVALID_ACCOUNT_ID</tt>,
         * <tt>UNSCHEDULABLE_TRANSACTION</tt>, <tt>UNRESOLVABLE_REQUIRED_SIGNERS</tt>,
         * <tt>INVALID_SIGNATURE</tt>. For more information please see the section of this documentation on
         * the <tt>ResponseCode</tt> enum.
         */
        class ScheduleCreateTransactionBody implements IScheduleCreateTransactionBody {

            /**
             * Constructs a new ScheduleCreateTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IScheduleCreateTransactionBody);

            /** The scheduled transaction */
            public scheduledTransactionBody?: (hashgraph.proto.ISchedulableTransactionBody|null);

            /**
             * An optional memo with a UTF-8 encoding of no more than 100 bytes which does not contain the
             * zero byte
             */
            public memo: string;

            /** An optional Hedera key which can be used to sign a ScheduleDelete and remove the schedule */
            public adminKey?: (hashgraph.proto.IKey|null);

            /**
             * An optional id of the account to be charged the service fee for the scheduled transaction at
             * the consensus time that it executes (if ever); defaults to the ScheduleCreate payer if not
             * given
             */
            public payerAccountID?: (hashgraph.proto.IAccountID|null);

            /**
             * An optional timestamp for specifying when the transaction should be evaluated for execution and then expire.
             * Defaults to 30 minutes after the transaction's consensus timestamp.
             *
             * Note: This field is unused and forced to be unset until Long Term Scheduled Transactions are enabled - Transactions will always
             * expire in 30 minutes if Long Term Scheduled Transactions are not enabled.
             */
            public expirationTime?: (hashgraph.proto.ITimestamp|null);

            /**
             * When set to true, the transaction will be evaluated for execution at expiration_time instead
             * of when all required signatures are received.
             * When set to false, the transaction will execute immediately after sufficient signatures are received
             * to sign the contained transaction. During the initial ScheduleCreate transaction or via ScheduleSign transactions.
             *
             * Defaults to false.
             *
             * Setting this to false does not necessarily mean that the transaction will never execute at expiration_time.
             * For Example - If the signature requirements for a Scheduled Transaction change via external means (e.g. CryptoUpdate)
             * such that the Scheduled Transaction would be allowed to execute, it will do so autonomously at expiration_time, unless a
             * ScheduleSign comes in to “poke” it and force it to go through immediately.
             *
             * Note: This field is unused and forced to be unset until Long Term Scheduled Transactions are enabled. Before Long Term
             * Scheduled Transactions are enabled, Scheduled Transactions will _never_ execute at expiration  - they will _only_
             * execute during the initial ScheduleCreate transaction or via ScheduleSign transactions and will _always_
             * expire at expiration_time.
             */
            public waitForExpiry: boolean;

            /**
             * Creates a new ScheduleCreateTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ScheduleCreateTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.IScheduleCreateTransactionBody): hashgraph.proto.ScheduleCreateTransactionBody;

            /**
             * Encodes the specified ScheduleCreateTransactionBody message. Does not implicitly {@link hashgraph.proto.ScheduleCreateTransactionBody.verify|verify} messages.
             * @param m ScheduleCreateTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IScheduleCreateTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ScheduleCreateTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ScheduleCreateTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ScheduleCreateTransactionBody;

            /**
             * Gets the default type url for ScheduleCreateTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a SchedulableTransactionBody. */
        interface ISchedulableTransactionBody {

            /** The maximum transaction fee the client is willing to pay */
            transactionFee?: (Long|null);

            /**
             * A memo to include the execution record; the UTF-8 encoding may be up to 100 bytes and must not
             * include the zero byte
             */
            memo?: (string|null);

            /** Calls a function of a contract instance */
            contractCall?: (hashgraph.proto.IContractCallTransactionBody|null);

            /** Creates a contract instance */
            contractCreateInstance?: (hashgraph.proto.IContractCreateTransactionBody|null);

            /** Updates a contract */
            contractUpdateInstance?: (hashgraph.proto.IContractUpdateTransactionBody|null);

            /** Delete contract and transfer remaining balance into specified account */
            contractDeleteInstance?: (hashgraph.proto.IContractDeleteTransactionBody|null);

            /** Adds one or more approved allowances for spenders to transfer the paying account's hbar or tokens. */
            cryptoApproveAllowance?: (hashgraph.proto.ICryptoApproveAllowanceTransactionBody|null);

            /** Deletes one or more of the specific approved NFT serial numbers on an owner account. */
            cryptoDeleteAllowance?: (hashgraph.proto.ICryptoDeleteAllowanceTransactionBody|null);

            /** Create a new cryptocurrency account */
            cryptoCreateAccount?: (hashgraph.proto.ICryptoCreateTransactionBody|null);

            /** Delete a cryptocurrency account (mark as deleted, and transfer hbars out) */
            cryptoDelete?: (hashgraph.proto.ICryptoDeleteTransactionBody|null);

            /** Transfer amount between accounts */
            cryptoTransfer?: (hashgraph.proto.ICryptoTransferTransactionBody|null);

            /** Modify information such as the expiration date for an account */
            cryptoUpdateAccount?: (hashgraph.proto.ICryptoUpdateTransactionBody|null);

            /** Add bytes to the end of the contents of a file */
            fileAppend?: (hashgraph.proto.IFileAppendTransactionBody|null);

            /** Create a new file */
            fileCreate?: (hashgraph.proto.IFileCreateTransactionBody|null);

            /** Delete a file (remove contents and mark as deleted until it expires) */
            fileDelete?: (hashgraph.proto.IFileDeleteTransactionBody|null);

            /** Modify information such as the expiration date for a file */
            fileUpdate?: (hashgraph.proto.IFileUpdateTransactionBody|null);

            /** Hedera administrative deletion of a file or smart contract */
            systemDelete?: (hashgraph.proto.ISystemDeleteTransactionBody|null);

            /** To undelete an entity deleted by SystemDelete */
            systemUndelete?: (hashgraph.proto.ISystemUndeleteTransactionBody|null);

            /** Freeze the nodes */
            freeze?: (hashgraph.proto.IFreezeTransactionBody|null);

            /** Creates a topic */
            consensusCreateTopic?: (hashgraph.proto.IConsensusCreateTopicTransactionBody|null);

            /** Updates a topic */
            consensusUpdateTopic?: (hashgraph.proto.IConsensusUpdateTopicTransactionBody|null);

            /** Deletes a topic */
            consensusDeleteTopic?: (hashgraph.proto.IConsensusDeleteTopicTransactionBody|null);

            /** Submits message to a topic */
            consensusSubmitMessage?: (hashgraph.proto.IConsensusSubmitMessageTransactionBody|null);

            /** Creates a token instance */
            tokenCreation?: (hashgraph.proto.ITokenCreateTransactionBody|null);

            /** Freezes account not to be able to transact with a token */
            tokenFreeze?: (hashgraph.proto.ITokenFreezeAccountTransactionBody|null);

            /** Unfreezes account for a token */
            tokenUnfreeze?: (hashgraph.proto.ITokenUnfreezeAccountTransactionBody|null);

            /** Grants KYC to an account for a token */
            tokenGrantKyc?: (hashgraph.proto.ITokenGrantKycTransactionBody|null);

            /** Revokes KYC of an account for a token */
            tokenRevokeKyc?: (hashgraph.proto.ITokenRevokeKycTransactionBody|null);

            /** Deletes a token instance */
            tokenDeletion?: (hashgraph.proto.ITokenDeleteTransactionBody|null);

            /** Updates a token instance */
            tokenUpdate?: (hashgraph.proto.ITokenUpdateTransactionBody|null);

            /** Mints new tokens to a token's treasury account */
            tokenMint?: (hashgraph.proto.ITokenMintTransactionBody|null);

            /** Burns tokens from a token's treasury account */
            tokenBurn?: (hashgraph.proto.ITokenBurnTransactionBody|null);

            /** Wipes amount of tokens from an account */
            tokenWipe?: (hashgraph.proto.ITokenWipeAccountTransactionBody|null);

            /** Associate tokens to an account */
            tokenAssociate?: (hashgraph.proto.ITokenAssociateTransactionBody|null);

            /** Dissociate tokens from an account */
            tokenDissociate?: (hashgraph.proto.ITokenDissociateTransactionBody|null);

            /** Updates a token's custom fee schedule */
            tokenFeeScheduleUpdate?: (hashgraph.proto.ITokenFeeScheduleUpdateTransactionBody|null);

            /** Pauses the Token */
            tokenPause?: (hashgraph.proto.ITokenPauseTransactionBody|null);

            /** Unpauses the Token */
            tokenUnpause?: (hashgraph.proto.ITokenUnpauseTransactionBody|null);

            /** Marks a schedule in the network's action queue as deleted, preventing it from executing */
            scheduleDelete?: (hashgraph.proto.IScheduleDeleteTransactionBody|null);

            /** Generates a pseudorandom number. */
            utilPrng?: (hashgraph.proto.IUtilPrngTransactionBody|null);
        }

        /**
         * A schedulable transaction. Note that the global/dynamic system property
         * <tt>scheduling.whitelist</tt> controls which transaction types may be scheduled. As of Hedera
         * Services 0.24.0 this list includes <tt>ConsensusSubmitMessage</tt>, <tt>CryptoTransfer</tt>, <tt>TokenMint</tt>, and <tt>TokenBurn</tt>
         * functions.
         */
        class SchedulableTransactionBody implements ISchedulableTransactionBody {

            /**
             * Constructs a new SchedulableTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ISchedulableTransactionBody);

            /** The maximum transaction fee the client is willing to pay */
            public transactionFee: Long;

            /**
             * A memo to include the execution record; the UTF-8 encoding may be up to 100 bytes and must not
             * include the zero byte
             */
            public memo: string;

            /** Calls a function of a contract instance */
            public contractCall?: (hashgraph.proto.IContractCallTransactionBody|null);

            /** Creates a contract instance */
            public contractCreateInstance?: (hashgraph.proto.IContractCreateTransactionBody|null);

            /** Updates a contract */
            public contractUpdateInstance?: (hashgraph.proto.IContractUpdateTransactionBody|null);

            /** Delete contract and transfer remaining balance into specified account */
            public contractDeleteInstance?: (hashgraph.proto.IContractDeleteTransactionBody|null);

            /** Adds one or more approved allowances for spenders to transfer the paying account's hbar or tokens. */
            public cryptoApproveAllowance?: (hashgraph.proto.ICryptoApproveAllowanceTransactionBody|null);

            /** Deletes one or more of the specific approved NFT serial numbers on an owner account. */
            public cryptoDeleteAllowance?: (hashgraph.proto.ICryptoDeleteAllowanceTransactionBody|null);

            /** Create a new cryptocurrency account */
            public cryptoCreateAccount?: (hashgraph.proto.ICryptoCreateTransactionBody|null);

            /** Delete a cryptocurrency account (mark as deleted, and transfer hbars out) */
            public cryptoDelete?: (hashgraph.proto.ICryptoDeleteTransactionBody|null);

            /** Transfer amount between accounts */
            public cryptoTransfer?: (hashgraph.proto.ICryptoTransferTransactionBody|null);

            /** Modify information such as the expiration date for an account */
            public cryptoUpdateAccount?: (hashgraph.proto.ICryptoUpdateTransactionBody|null);

            /** Add bytes to the end of the contents of a file */
            public fileAppend?: (hashgraph.proto.IFileAppendTransactionBody|null);

            /** Create a new file */
            public fileCreate?: (hashgraph.proto.IFileCreateTransactionBody|null);

            /** Delete a file (remove contents and mark as deleted until it expires) */
            public fileDelete?: (hashgraph.proto.IFileDeleteTransactionBody|null);

            /** Modify information such as the expiration date for a file */
            public fileUpdate?: (hashgraph.proto.IFileUpdateTransactionBody|null);

            /** Hedera administrative deletion of a file or smart contract */
            public systemDelete?: (hashgraph.proto.ISystemDeleteTransactionBody|null);

            /** To undelete an entity deleted by SystemDelete */
            public systemUndelete?: (hashgraph.proto.ISystemUndeleteTransactionBody|null);

            /** Freeze the nodes */
            public freeze?: (hashgraph.proto.IFreezeTransactionBody|null);

            /** Creates a topic */
            public consensusCreateTopic?: (hashgraph.proto.IConsensusCreateTopicTransactionBody|null);

            /** Updates a topic */
            public consensusUpdateTopic?: (hashgraph.proto.IConsensusUpdateTopicTransactionBody|null);

            /** Deletes a topic */
            public consensusDeleteTopic?: (hashgraph.proto.IConsensusDeleteTopicTransactionBody|null);

            /** Submits message to a topic */
            public consensusSubmitMessage?: (hashgraph.proto.IConsensusSubmitMessageTransactionBody|null);

            /** Creates a token instance */
            public tokenCreation?: (hashgraph.proto.ITokenCreateTransactionBody|null);

            /** Freezes account not to be able to transact with a token */
            public tokenFreeze?: (hashgraph.proto.ITokenFreezeAccountTransactionBody|null);

            /** Unfreezes account for a token */
            public tokenUnfreeze?: (hashgraph.proto.ITokenUnfreezeAccountTransactionBody|null);

            /** Grants KYC to an account for a token */
            public tokenGrantKyc?: (hashgraph.proto.ITokenGrantKycTransactionBody|null);

            /** Revokes KYC of an account for a token */
            public tokenRevokeKyc?: (hashgraph.proto.ITokenRevokeKycTransactionBody|null);

            /** Deletes a token instance */
            public tokenDeletion?: (hashgraph.proto.ITokenDeleteTransactionBody|null);

            /** Updates a token instance */
            public tokenUpdate?: (hashgraph.proto.ITokenUpdateTransactionBody|null);

            /** Mints new tokens to a token's treasury account */
            public tokenMint?: (hashgraph.proto.ITokenMintTransactionBody|null);

            /** Burns tokens from a token's treasury account */
            public tokenBurn?: (hashgraph.proto.ITokenBurnTransactionBody|null);

            /** Wipes amount of tokens from an account */
            public tokenWipe?: (hashgraph.proto.ITokenWipeAccountTransactionBody|null);

            /** Associate tokens to an account */
            public tokenAssociate?: (hashgraph.proto.ITokenAssociateTransactionBody|null);

            /** Dissociate tokens from an account */
            public tokenDissociate?: (hashgraph.proto.ITokenDissociateTransactionBody|null);

            /** Updates a token's custom fee schedule */
            public tokenFeeScheduleUpdate?: (hashgraph.proto.ITokenFeeScheduleUpdateTransactionBody|null);

            /** Pauses the Token */
            public tokenPause?: (hashgraph.proto.ITokenPauseTransactionBody|null);

            /** Unpauses the Token */
            public tokenUnpause?: (hashgraph.proto.ITokenUnpauseTransactionBody|null);

            /** Marks a schedule in the network's action queue as deleted, preventing it from executing */
            public scheduleDelete?: (hashgraph.proto.IScheduleDeleteTransactionBody|null);

            /** Generates a pseudorandom number. */
            public utilPrng?: (hashgraph.proto.IUtilPrngTransactionBody|null);

            /** The choices here are arranged by service in roughly lexicographical order. The field ordinals are non-sequential, and a result of the historical order of implementation. */
            public data?: ("contractCall"|"contractCreateInstance"|"contractUpdateInstance"|"contractDeleteInstance"|"cryptoApproveAllowance"|"cryptoDeleteAllowance"|"cryptoCreateAccount"|"cryptoDelete"|"cryptoTransfer"|"cryptoUpdateAccount"|"fileAppend"|"fileCreate"|"fileDelete"|"fileUpdate"|"systemDelete"|"systemUndelete"|"freeze"|"consensusCreateTopic"|"consensusUpdateTopic"|"consensusDeleteTopic"|"consensusSubmitMessage"|"tokenCreation"|"tokenFreeze"|"tokenUnfreeze"|"tokenGrantKyc"|"tokenRevokeKyc"|"tokenDeletion"|"tokenUpdate"|"tokenMint"|"tokenBurn"|"tokenWipe"|"tokenAssociate"|"tokenDissociate"|"tokenFeeScheduleUpdate"|"tokenPause"|"tokenUnpause"|"scheduleDelete"|"utilPrng");

            /**
             * Creates a new SchedulableTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns SchedulableTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.ISchedulableTransactionBody): hashgraph.proto.SchedulableTransactionBody;

            /**
             * Encodes the specified SchedulableTransactionBody message. Does not implicitly {@link hashgraph.proto.SchedulableTransactionBody.verify|verify} messages.
             * @param m SchedulableTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ISchedulableTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a SchedulableTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns SchedulableTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.SchedulableTransactionBody;

            /**
             * Gets the default type url for SchedulableTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ScheduleDeleteTransactionBody. */
        interface IScheduleDeleteTransactionBody {

            /** The ID of the Scheduled Entity */
            scheduleID?: (hashgraph.proto.IScheduleID|null);
        }

        /**
         * Marks a schedule in the network's action queue as deleted. Must be signed by the admin key of the
         * target schedule.  A deleted schedule cannot receive any additional signing keys, nor will it be
         * executed.
         *
         * Other notable response codes include, <tt>INVALID_SCHEDULE_ID</tt>, <tt>SCHEDULE_PENDING_EXPIRATION</tt>,
         * <tt>SCHEDULE_ALREADY_DELETED</tt>, <tt>SCHEDULE_ALREADY_EXECUTED</tt>, <tt>SCHEDULE_IS_IMMUTABLE</tt>.
         * For more information please see the section of this documentation on the <tt>ResponseCode</tt>
         * enum.
         */
        class ScheduleDeleteTransactionBody implements IScheduleDeleteTransactionBody {

            /**
             * Constructs a new ScheduleDeleteTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IScheduleDeleteTransactionBody);

            /** The ID of the Scheduled Entity */
            public scheduleID?: (hashgraph.proto.IScheduleID|null);

            /**
             * Creates a new ScheduleDeleteTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ScheduleDeleteTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.IScheduleDeleteTransactionBody): hashgraph.proto.ScheduleDeleteTransactionBody;

            /**
             * Encodes the specified ScheduleDeleteTransactionBody message. Does not implicitly {@link hashgraph.proto.ScheduleDeleteTransactionBody.verify|verify} messages.
             * @param m ScheduleDeleteTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IScheduleDeleteTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ScheduleDeleteTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ScheduleDeleteTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ScheduleDeleteTransactionBody;

            /**
             * Gets the default type url for ScheduleDeleteTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of an UtilPrngTransactionBody. */
        interface IUtilPrngTransactionBody {

            /**
             * If provided and is positive, returns a 32-bit pseudorandom number from the given range in the transaction record.
             * If not set or set to zero, will return a 384-bit pseudorandom number in the record.
             */
            range?: (number|null);
        }

        /** Generates a pseudorandom number */
        class UtilPrngTransactionBody implements IUtilPrngTransactionBody {

            /**
             * Constructs a new UtilPrngTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IUtilPrngTransactionBody);

            /**
             * If provided and is positive, returns a 32-bit pseudorandom number from the given range in the transaction record.
             * If not set or set to zero, will return a 384-bit pseudorandom number in the record.
             */
            public range: number;

            /**
             * Creates a new UtilPrngTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns UtilPrngTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.IUtilPrngTransactionBody): hashgraph.proto.UtilPrngTransactionBody;

            /**
             * Encodes the specified UtilPrngTransactionBody message. Does not implicitly {@link hashgraph.proto.UtilPrngTransactionBody.verify|verify} messages.
             * @param m UtilPrngTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IUtilPrngTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an UtilPrngTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns UtilPrngTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.UtilPrngTransactionBody;

            /**
             * Gets the default type url for UtilPrngTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ScheduleSignTransactionBody. */
        interface IScheduleSignTransactionBody {

            /** The id of the schedule to add signing keys to */
            scheduleID?: (hashgraph.proto.IScheduleID|null);
        }

        /**
         * Adds zero or more signing keys to a schedule.
         *
         * If Long Term Scheduled Transactions are enabled and <tt>wait_for_expiry</tt> was set to <tt>true</tt> on the
         * <tt>ScheduleCreate</tt> then the transaction will always wait till it's `expiration_time` to execute.
         *
         * Otherwise, if the resulting set of signing keys satisfy the
         * scheduled transaction's signing requirements, it will be executed immediately after the
         * triggering <tt>ScheduleSign</tt>.
         *
         * Upon <tt>SUCCESS</tt>, the receipt includes the <tt>scheduledTransactionID</tt> to use to query
         * for the record of the scheduled transaction's execution (if it occurs).
         *
         * Other notable response codes include <tt>INVALID_SCHEDULE_ID</tt>, <tt>SCHEDULE_ALREADY_DELETED</tt>,
         * <tt>SCHEDULE_PENDING_EXPIRATION</tt>, <tt>SCHEDULE_ALREADY_EXPIRED</tt>,
         * <tt>INVALID_ACCOUNT_ID</tt>, <tt>UNRESOLVABLE_REQUIRED_SIGNERS</tt>,
         * <tt>SOME_SIGNATURES_WERE_INVALID</tt>, and <tt>NO_NEW_VALID_SIGNATURES</tt>. For more information
         * please see the section of this documentation on the <tt>ResponseCode</tt> enum.
         */
        class ScheduleSignTransactionBody implements IScheduleSignTransactionBody {

            /**
             * Constructs a new ScheduleSignTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IScheduleSignTransactionBody);

            /** The id of the schedule to add signing keys to */
            public scheduleID?: (hashgraph.proto.IScheduleID|null);

            /**
             * Creates a new ScheduleSignTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ScheduleSignTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.IScheduleSignTransactionBody): hashgraph.proto.ScheduleSignTransactionBody;

            /**
             * Encodes the specified ScheduleSignTransactionBody message. Does not implicitly {@link hashgraph.proto.ScheduleSignTransactionBody.verify|verify} messages.
             * @param m ScheduleSignTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IScheduleSignTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ScheduleSignTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ScheduleSignTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ScheduleSignTransactionBody;

            /**
             * Gets the default type url for ScheduleSignTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a NodeStakeUpdateTransactionBody. */
        interface INodeStakeUpdateTransactionBody {

            /** Time and date of the end of the staking period that is ending */
            endOfStakingPeriod?: (hashgraph.proto.ITimestamp|null);

            /** Staking info of each node at the beginning of the new staking period */
            nodeStake?: (hashgraph.proto.INodeStake[]|null);

            /** The maximum reward rate, in tinybars per whole hbar, that any account can receive in a day. */
            maxStakingRewardRatePerHbar?: (Long|null);

            /** The fraction of the network and service fees paid to the node reward account 0.0.801. */
            nodeRewardFeeFraction?: (hashgraph.proto.IFraction|null);

            /**
             * The maximum number of trailing periods for which a user can collect rewards. For example, if this
             * is 365 with a UTC calendar day period, then users must collect rewards at least once per calendar
             * year to avoid missing any value.
             */
            stakingPeriodsStored?: (Long|null);

            /**
             * The number of minutes in a staking period. Note for the special case of 1440 minutes, periods are
             * treated as UTC calendar days, rather than repeating 1440 minute periods left-aligned at the epoch.
             */
            stakingPeriod?: (Long|null);

            /** The fraction of the network and service fees paid to the staking reward account 0.0.800. */
            stakingRewardFeeFraction?: (hashgraph.proto.IFraction|null);

            /** The minimum balance of staking reward account 0.0.800 required to active rewards. */
            stakingStartThreshold?: (Long|null);

            /** The total number of tinybars to be distributed as staking rewards each period. */
            stakingRewardRate?: (Long|null);
        }

        /** Updates the staking info at the end of staking period to indicate new staking period has started. */
        class NodeStakeUpdateTransactionBody implements INodeStakeUpdateTransactionBody {

            /**
             * Constructs a new NodeStakeUpdateTransactionBody.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.INodeStakeUpdateTransactionBody);

            /** Time and date of the end of the staking period that is ending */
            public endOfStakingPeriod?: (hashgraph.proto.ITimestamp|null);

            /** Staking info of each node at the beginning of the new staking period */
            public nodeStake: hashgraph.proto.INodeStake[];

            /** The maximum reward rate, in tinybars per whole hbar, that any account can receive in a day. */
            public maxStakingRewardRatePerHbar: Long;

            /** The fraction of the network and service fees paid to the node reward account 0.0.801. */
            public nodeRewardFeeFraction?: (hashgraph.proto.IFraction|null);

            /**
             * The maximum number of trailing periods for which a user can collect rewards. For example, if this
             * is 365 with a UTC calendar day period, then users must collect rewards at least once per calendar
             * year to avoid missing any value.
             */
            public stakingPeriodsStored: Long;

            /**
             * The number of minutes in a staking period. Note for the special case of 1440 minutes, periods are
             * treated as UTC calendar days, rather than repeating 1440 minute periods left-aligned at the epoch.
             */
            public stakingPeriod: Long;

            /** The fraction of the network and service fees paid to the staking reward account 0.0.800. */
            public stakingRewardFeeFraction?: (hashgraph.proto.IFraction|null);

            /** The minimum balance of staking reward account 0.0.800 required to active rewards. */
            public stakingStartThreshold: Long;

            /** The total number of tinybars to be distributed as staking rewards each period. */
            public stakingRewardRate: Long;

            /**
             * Creates a new NodeStakeUpdateTransactionBody instance using the specified properties.
             * @param [properties] Properties to set
             * @returns NodeStakeUpdateTransactionBody instance
             */
            public static create(properties?: hashgraph.proto.INodeStakeUpdateTransactionBody): hashgraph.proto.NodeStakeUpdateTransactionBody;

            /**
             * Encodes the specified NodeStakeUpdateTransactionBody message. Does not implicitly {@link hashgraph.proto.NodeStakeUpdateTransactionBody.verify|verify} messages.
             * @param m NodeStakeUpdateTransactionBody message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.INodeStakeUpdateTransactionBody, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a NodeStakeUpdateTransactionBody message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns NodeStakeUpdateTransactionBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.NodeStakeUpdateTransactionBody;

            /**
             * Gets the default type url for NodeStakeUpdateTransactionBody
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a NodeStake. */
        interface INodeStake {

            /**
             * The maximum stake (rewarded or not rewarded) this node can have as consensus weight. If its stake to
             * reward is above this maximum at the start of a period, then accounts staking to the node in that
             * period will be rewarded at a lower rate scaled by (maxStake / stakeRewardStart).
             */
            maxStake?: (Long|null);

            /**
             * The minimum stake (rewarded or not rewarded) this node must reach before having non-zero consensus weight.
             * If its total stake is below this minimum at the start of a period, then accounts staking to the node in
             * that period will receive no rewards.
             */
            minStake?: (Long|null);

            /** The id of this node. */
            nodeId?: (Long|null);

            /**
             * The reward rate _per whole hbar_ that was staked to this node with declineReward=false from the start of
             * the staking period that is ending.
             */
            rewardRate?: (Long|null);

            /** Consensus weight of this node for the new staking period. */
            stake?: (Long|null);

            /**
             * Total of (balance + stakedToMe) for all accounts staked to this node with declineReward=true, at the
             * beginning of the new staking period.
             */
            stakeNotRewarded?: (Long|null);

            /**
             * Total of (balance + stakedToMe) for all accounts staked to this node with declineReward=false, at the
             * beginning of the new staking period.
             */
            stakeRewarded?: (Long|null);
        }

        /** Staking info for each node at the end of a staking period. */
        class NodeStake implements INodeStake {

            /**
             * Constructs a new NodeStake.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.INodeStake);

            /**
             * The maximum stake (rewarded or not rewarded) this node can have as consensus weight. If its stake to
             * reward is above this maximum at the start of a period, then accounts staking to the node in that
             * period will be rewarded at a lower rate scaled by (maxStake / stakeRewardStart).
             */
            public maxStake: Long;

            /**
             * The minimum stake (rewarded or not rewarded) this node must reach before having non-zero consensus weight.
             * If its total stake is below this minimum at the start of a period, then accounts staking to the node in
             * that period will receive no rewards.
             */
            public minStake: Long;

            /** The id of this node. */
            public nodeId: Long;

            /**
             * The reward rate _per whole hbar_ that was staked to this node with declineReward=false from the start of
             * the staking period that is ending.
             */
            public rewardRate: Long;

            /** Consensus weight of this node for the new staking period. */
            public stake: Long;

            /**
             * Total of (balance + stakedToMe) for all accounts staked to this node with declineReward=true, at the
             * beginning of the new staking period.
             */
            public stakeNotRewarded: Long;

            /**
             * Total of (balance + stakedToMe) for all accounts staked to this node with declineReward=false, at the
             * beginning of the new staking period.
             */
            public stakeRewarded: Long;

            /**
             * Creates a new NodeStake instance using the specified properties.
             * @param [properties] Properties to set
             * @returns NodeStake instance
             */
            public static create(properties?: hashgraph.proto.INodeStake): hashgraph.proto.NodeStake;

            /**
             * Encodes the specified NodeStake message. Does not implicitly {@link hashgraph.proto.NodeStake.verify|verify} messages.
             * @param m NodeStake message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.INodeStake, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a NodeStake message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns NodeStake
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.NodeStake;

            /**
             * Gets the default type url for NodeStake
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ResponseHeader. */
        interface IResponseHeader {

            /** Result of fee transaction precheck, saying it passed, or why it failed */
            nodeTransactionPrecheckCode?: (hashgraph.proto.ResponseCodeEnum|null);

            /** The requested response is repeated back here, for convenience */
            responseType?: (hashgraph.proto.ResponseType|null);

            /**
             * The fee that would be charged to get the requested information (if a cost was requested).
             * Note: This cost only includes the query fee and does not include the transfer fee(which is
             * required to execute the transfer transaction to debit the payer account and credit the node
             * account with query fee)
             */
            cost?: (Long|null);

            /** The state proof for this information (if a state proof was requested, and is available) */
            stateProof?: (Uint8Array|null);
        }

        /**
         * Every query receives a response containing the QueryResponseHeader. Either or both of the cost
         * and stateProof fields may be blank, if the responseType didn't ask for the cost or stateProof.
         */
        class ResponseHeader implements IResponseHeader {

            /**
             * Constructs a new ResponseHeader.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IResponseHeader);

            /** Result of fee transaction precheck, saying it passed, or why it failed */
            public nodeTransactionPrecheckCode: hashgraph.proto.ResponseCodeEnum;

            /** The requested response is repeated back here, for convenience */
            public responseType: hashgraph.proto.ResponseType;

            /**
             * The fee that would be charged to get the requested information (if a cost was requested).
             * Note: This cost only includes the query fee and does not include the transfer fee(which is
             * required to execute the transfer transaction to debit the payer account and credit the node
             * account with query fee)
             */
            public cost: Long;

            /** The state proof for this information (if a state proof was requested, and is available) */
            public stateProof: Uint8Array;

            /**
             * Creates a new ResponseHeader instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ResponseHeader instance
             */
            public static create(properties?: hashgraph.proto.IResponseHeader): hashgraph.proto.ResponseHeader;

            /**
             * Encodes the specified ResponseHeader message. Does not implicitly {@link hashgraph.proto.ResponseHeader.verify|verify} messages.
             * @param m ResponseHeader message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IResponseHeader, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ResponseHeader message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ResponseHeader
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ResponseHeader;

            /**
             * Gets the default type url for ResponseHeader
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TransactionResponse. */
        interface ITransactionResponse {

            /** The response code that indicates the current status of the transaction. */
            nodeTransactionPrecheckCode?: (hashgraph.proto.ResponseCodeEnum|null);

            /**
             * If the response code was INSUFFICIENT_TX_FEE, the actual transaction fee that would be
             * required to execute the transaction.
             */
            cost?: (Long|null);
        }

        /**
         * When the client sends the node a transaction of any kind, the node replies with this, which
         * simply says that the transaction passed the precheck (so the node will submit it to the network)
         * or it failed (so it won't). If the fee offered was insufficient, this will also contain the
         * amount of the required fee. To learn the consensus result, the client should later obtain a
         * receipt (free), or can buy a more detailed record (not free).
         */
        class TransactionResponse implements ITransactionResponse {

            /**
             * Constructs a new TransactionResponse.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITransactionResponse);

            /** * The response code that indicates the current status of the transaction. */
            public nodeTransactionPrecheckCode: hashgraph.proto.ResponseCodeEnum;

            /**
             * If the response code was INSUFFICIENT_TX_FEE, the actual transaction fee that would be
             * required to execute the transaction.
             */
            public cost: Long;

            /**
             * Creates a new TransactionResponse instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TransactionResponse instance
             */
            public static create(properties?: hashgraph.proto.ITransactionResponse): hashgraph.proto.TransactionResponse;

            /**
             * Encodes the specified TransactionResponse message. Does not implicitly {@link hashgraph.proto.TransactionResponse.verify|verify} messages.
             * @param m TransactionResponse message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITransactionResponse, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TransactionResponse message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TransactionResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TransactionResponse;

            /**
             * Gets the default type url for TransactionResponse
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** UNDOCUMENTED */
        enum ResponseCodeEnum {
            OK = 0,
            INVALID_TRANSACTION = 1,
            PAYER_ACCOUNT_NOT_FOUND = 2,
            INVALID_NODE_ACCOUNT = 3,
            TRANSACTION_EXPIRED = 4,
            INVALID_TRANSACTION_START = 5,
            INVALID_TRANSACTION_DURATION = 6,
            INVALID_SIGNATURE = 7,
            MEMO_TOO_LONG = 8,
            INSUFFICIENT_TX_FEE = 9,
            INSUFFICIENT_PAYER_BALANCE = 10,
            DUPLICATE_TRANSACTION = 11,
            BUSY = 12,
            NOT_SUPPORTED = 13,
            INVALID_FILE_ID = 14,
            INVALID_ACCOUNT_ID = 15,
            INVALID_CONTRACT_ID = 16,
            INVALID_TRANSACTION_ID = 17,
            RECEIPT_NOT_FOUND = 18,
            RECORD_NOT_FOUND = 19,
            INVALID_SOLIDITY_ID = 20,
            UNKNOWN = 21,
            SUCCESS = 22,
            FAIL_INVALID = 23,
            FAIL_FEE = 24,
            FAIL_BALANCE = 25,
            KEY_REQUIRED = 26,
            BAD_ENCODING = 27,
            INSUFFICIENT_ACCOUNT_BALANCE = 28,
            INVALID_SOLIDITY_ADDRESS = 29,
            INSUFFICIENT_GAS = 30,
            CONTRACT_SIZE_LIMIT_EXCEEDED = 31,
            LOCAL_CALL_MODIFICATION_EXCEPTION = 32,
            CONTRACT_REVERT_EXECUTED = 33,
            CONTRACT_EXECUTION_EXCEPTION = 34,
            INVALID_RECEIVING_NODE_ACCOUNT = 35,
            MISSING_QUERY_HEADER = 36,
            ACCOUNT_UPDATE_FAILED = 37,
            INVALID_KEY_ENCODING = 38,
            NULL_SOLIDITY_ADDRESS = 39,
            CONTRACT_UPDATE_FAILED = 40,
            INVALID_QUERY_HEADER = 41,
            INVALID_FEE_SUBMITTED = 42,
            INVALID_PAYER_SIGNATURE = 43,
            KEY_NOT_PROVIDED = 44,
            INVALID_EXPIRATION_TIME = 45,
            NO_WACL_KEY = 46,
            FILE_CONTENT_EMPTY = 47,
            INVALID_ACCOUNT_AMOUNTS = 48,
            EMPTY_TRANSACTION_BODY = 49,
            INVALID_TRANSACTION_BODY = 50,
            INVALID_SIGNATURE_TYPE_MISMATCHING_KEY = 51,
            INVALID_SIGNATURE_COUNT_MISMATCHING_KEY = 52,
            EMPTY_LIVE_HASH_BODY = 53,
            EMPTY_LIVE_HASH = 54,
            EMPTY_LIVE_HASH_KEYS = 55,
            INVALID_LIVE_HASH_SIZE = 56,
            EMPTY_QUERY_BODY = 57,
            EMPTY_LIVE_HASH_QUERY = 58,
            LIVE_HASH_NOT_FOUND = 59,
            ACCOUNT_ID_DOES_NOT_EXIST = 60,
            LIVE_HASH_ALREADY_EXISTS = 61,
            INVALID_FILE_WACL = 62,
            SERIALIZATION_FAILED = 63,
            TRANSACTION_OVERSIZE = 64,
            TRANSACTION_TOO_MANY_LAYERS = 65,
            CONTRACT_DELETED = 66,
            PLATFORM_NOT_ACTIVE = 67,
            KEY_PREFIX_MISMATCH = 68,
            PLATFORM_TRANSACTION_NOT_CREATED = 69,
            INVALID_RENEWAL_PERIOD = 70,
            INVALID_PAYER_ACCOUNT_ID = 71,
            ACCOUNT_DELETED = 72,
            FILE_DELETED = 73,
            ACCOUNT_REPEATED_IN_ACCOUNT_AMOUNTS = 74,
            SETTING_NEGATIVE_ACCOUNT_BALANCE = 75,
            OBTAINER_REQUIRED = 76,
            OBTAINER_SAME_CONTRACT_ID = 77,
            OBTAINER_DOES_NOT_EXIST = 78,
            MODIFYING_IMMUTABLE_CONTRACT = 79,
            FILE_SYSTEM_EXCEPTION = 80,
            AUTORENEW_DURATION_NOT_IN_RANGE = 81,
            ERROR_DECODING_BYTESTRING = 82,
            CONTRACT_FILE_EMPTY = 83,
            CONTRACT_BYTECODE_EMPTY = 84,
            INVALID_INITIAL_BALANCE = 85,
            INVALID_RECEIVE_RECORD_THRESHOLD = 86,
            INVALID_SEND_RECORD_THRESHOLD = 87,
            ACCOUNT_IS_NOT_GENESIS_ACCOUNT = 88,
            PAYER_ACCOUNT_UNAUTHORIZED = 89,
            INVALID_FREEZE_TRANSACTION_BODY = 90,
            FREEZE_TRANSACTION_BODY_NOT_FOUND = 91,
            TRANSFER_LIST_SIZE_LIMIT_EXCEEDED = 92,
            RESULT_SIZE_LIMIT_EXCEEDED = 93,
            NOT_SPECIAL_ACCOUNT = 94,
            CONTRACT_NEGATIVE_GAS = 95,
            CONTRACT_NEGATIVE_VALUE = 96,
            INVALID_FEE_FILE = 97,
            INVALID_EXCHANGE_RATE_FILE = 98,
            INSUFFICIENT_LOCAL_CALL_GAS = 99,
            ENTITY_NOT_ALLOWED_TO_DELETE = 100,
            AUTHORIZATION_FAILED = 101,
            FILE_UPLOADED_PROTO_INVALID = 102,
            FILE_UPLOADED_PROTO_NOT_SAVED_TO_DISK = 103,
            FEE_SCHEDULE_FILE_PART_UPLOADED = 104,
            EXCHANGE_RATE_CHANGE_LIMIT_EXCEEDED = 105,
            MAX_CONTRACT_STORAGE_EXCEEDED = 106,
            TRANSFER_ACCOUNT_SAME_AS_DELETE_ACCOUNT = 107,
            TOTAL_LEDGER_BALANCE_INVALID = 108,
            EXPIRATION_REDUCTION_NOT_ALLOWED = 110,
            MAX_GAS_LIMIT_EXCEEDED = 111,
            MAX_FILE_SIZE_EXCEEDED = 112,
            RECEIVER_SIG_REQUIRED = 113,
            INVALID_TOPIC_ID = 150,
            INVALID_ADMIN_KEY = 155,
            INVALID_SUBMIT_KEY = 156,
            UNAUTHORIZED = 157,
            INVALID_TOPIC_MESSAGE = 158,
            INVALID_AUTORENEW_ACCOUNT = 159,
            AUTORENEW_ACCOUNT_NOT_ALLOWED = 160,
            TOPIC_EXPIRED = 162,
            INVALID_CHUNK_NUMBER = 163,
            INVALID_CHUNK_TRANSACTION_ID = 164,
            ACCOUNT_FROZEN_FOR_TOKEN = 165,
            TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED = 166,
            INVALID_TOKEN_ID = 167,
            INVALID_TOKEN_DECIMALS = 168,
            INVALID_TOKEN_INITIAL_SUPPLY = 169,
            INVALID_TREASURY_ACCOUNT_FOR_TOKEN = 170,
            INVALID_TOKEN_SYMBOL = 171,
            TOKEN_HAS_NO_FREEZE_KEY = 172,
            TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN = 173,
            MISSING_TOKEN_SYMBOL = 174,
            TOKEN_SYMBOL_TOO_LONG = 175,
            ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN = 176,
            TOKEN_HAS_NO_KYC_KEY = 177,
            INSUFFICIENT_TOKEN_BALANCE = 178,
            TOKEN_WAS_DELETED = 179,
            TOKEN_HAS_NO_SUPPLY_KEY = 180,
            TOKEN_HAS_NO_WIPE_KEY = 181,
            INVALID_TOKEN_MINT_AMOUNT = 182,
            INVALID_TOKEN_BURN_AMOUNT = 183,
            TOKEN_NOT_ASSOCIATED_TO_ACCOUNT = 184,
            CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT = 185,
            INVALID_KYC_KEY = 186,
            INVALID_WIPE_KEY = 187,
            INVALID_FREEZE_KEY = 188,
            INVALID_SUPPLY_KEY = 189,
            MISSING_TOKEN_NAME = 190,
            TOKEN_NAME_TOO_LONG = 191,
            INVALID_WIPING_AMOUNT = 192,
            TOKEN_IS_IMMUTABLE = 193,
            TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT = 194,
            TRANSACTION_REQUIRES_ZERO_TOKEN_BALANCES = 195,
            ACCOUNT_IS_TREASURY = 196,
            TOKEN_ID_REPEATED_IN_TOKEN_LIST = 197,
            TOKEN_TRANSFER_LIST_SIZE_LIMIT_EXCEEDED = 198,
            EMPTY_TOKEN_TRANSFER_BODY = 199,
            EMPTY_TOKEN_TRANSFER_ACCOUNT_AMOUNTS = 200,
            INVALID_SCHEDULE_ID = 201,
            SCHEDULE_IS_IMMUTABLE = 202,
            INVALID_SCHEDULE_PAYER_ID = 203,
            INVALID_SCHEDULE_ACCOUNT_ID = 204,
            NO_NEW_VALID_SIGNATURES = 205,
            UNRESOLVABLE_REQUIRED_SIGNERS = 206,
            SCHEDULED_TRANSACTION_NOT_IN_WHITELIST = 207,
            SOME_SIGNATURES_WERE_INVALID = 208,
            TRANSACTION_ID_FIELD_NOT_ALLOWED = 209,
            IDENTICAL_SCHEDULE_ALREADY_CREATED = 210,
            INVALID_ZERO_BYTE_IN_STRING = 211,
            SCHEDULE_ALREADY_DELETED = 212,
            SCHEDULE_ALREADY_EXECUTED = 213,
            MESSAGE_SIZE_TOO_LARGE = 214,
            OPERATION_REPEATED_IN_BUCKET_GROUPS = 215,
            BUCKET_CAPACITY_OVERFLOW = 216,
            NODE_CAPACITY_NOT_SUFFICIENT_FOR_OPERATION = 217,
            BUCKET_HAS_NO_THROTTLE_GROUPS = 218,
            THROTTLE_GROUP_HAS_ZERO_OPS_PER_SEC = 219,
            SUCCESS_BUT_MISSING_EXPECTED_OPERATION = 220,
            UNPARSEABLE_THROTTLE_DEFINITIONS = 221,
            INVALID_THROTTLE_DEFINITIONS = 222,
            ACCOUNT_EXPIRED_AND_PENDING_REMOVAL = 223,
            INVALID_TOKEN_MAX_SUPPLY = 224,
            INVALID_TOKEN_NFT_SERIAL_NUMBER = 225,
            INVALID_NFT_ID = 226,
            METADATA_TOO_LONG = 227,
            BATCH_SIZE_LIMIT_EXCEEDED = 228,
            INVALID_QUERY_RANGE = 229,
            FRACTION_DIVIDES_BY_ZERO = 230,
            INSUFFICIENT_PAYER_BALANCE_FOR_CUSTOM_FEE = 231,
            CUSTOM_FEES_LIST_TOO_LONG = 232,
            INVALID_CUSTOM_FEE_COLLECTOR = 233,
            INVALID_TOKEN_ID_IN_CUSTOM_FEES = 234,
            TOKEN_NOT_ASSOCIATED_TO_FEE_COLLECTOR = 235,
            TOKEN_MAX_SUPPLY_REACHED = 236,
            SENDER_DOES_NOT_OWN_NFT_SERIAL_NO = 237,
            CUSTOM_FEE_NOT_FULLY_SPECIFIED = 238,
            CUSTOM_FEE_MUST_BE_POSITIVE = 239,
            TOKEN_HAS_NO_FEE_SCHEDULE_KEY = 240,
            CUSTOM_FEE_OUTSIDE_NUMERIC_RANGE = 241,
            ROYALTY_FRACTION_CANNOT_EXCEED_ONE = 242,
            FRACTIONAL_FEE_MAX_AMOUNT_LESS_THAN_MIN_AMOUNT = 243,
            CUSTOM_SCHEDULE_ALREADY_HAS_NO_FEES = 244,
            CUSTOM_FEE_DENOMINATION_MUST_BE_FUNGIBLE_COMMON = 245,
            CUSTOM_FRACTIONAL_FEE_ONLY_ALLOWED_FOR_FUNGIBLE_COMMON = 246,
            INVALID_CUSTOM_FEE_SCHEDULE_KEY = 247,
            INVALID_TOKEN_MINT_METADATA = 248,
            INVALID_TOKEN_BURN_METADATA = 249,
            CURRENT_TREASURY_STILL_OWNS_NFTS = 250,
            ACCOUNT_STILL_OWNS_NFTS = 251,
            TREASURY_MUST_OWN_BURNED_NFT = 252,
            ACCOUNT_DOES_NOT_OWN_WIPED_NFT = 253,
            ACCOUNT_AMOUNT_TRANSFERS_ONLY_ALLOWED_FOR_FUNGIBLE_COMMON = 254,
            MAX_NFTS_IN_PRICE_REGIME_HAVE_BEEN_MINTED = 255,
            PAYER_ACCOUNT_DELETED = 256,
            CUSTOM_FEE_CHARGING_EXCEEDED_MAX_RECURSION_DEPTH = 257,
            CUSTOM_FEE_CHARGING_EXCEEDED_MAX_ACCOUNT_AMOUNTS = 258,
            INSUFFICIENT_SENDER_ACCOUNT_BALANCE_FOR_CUSTOM_FEE = 259,
            SERIAL_NUMBER_LIMIT_REACHED = 260,
            CUSTOM_ROYALTY_FEE_ONLY_ALLOWED_FOR_NON_FUNGIBLE_UNIQUE = 261,
            NO_REMAINING_AUTOMATIC_ASSOCIATIONS = 262,
            EXISTING_AUTOMATIC_ASSOCIATIONS_EXCEED_GIVEN_LIMIT = 263,
            REQUESTED_NUM_AUTOMATIC_ASSOCIATIONS_EXCEEDS_ASSOCIATION_LIMIT = 264,
            TOKEN_IS_PAUSED = 265,
            TOKEN_HAS_NO_PAUSE_KEY = 266,
            INVALID_PAUSE_KEY = 267,
            FREEZE_UPDATE_FILE_DOES_NOT_EXIST = 268,
            FREEZE_UPDATE_FILE_HASH_DOES_NOT_MATCH = 269,
            NO_UPGRADE_HAS_BEEN_PREPARED = 270,
            NO_FREEZE_IS_SCHEDULED = 271,
            UPDATE_FILE_HASH_CHANGED_SINCE_PREPARE_UPGRADE = 272,
            FREEZE_START_TIME_MUST_BE_FUTURE = 273,
            PREPARED_UPDATE_FILE_IS_IMMUTABLE = 274,
            FREEZE_ALREADY_SCHEDULED = 275,
            FREEZE_UPGRADE_IN_PROGRESS = 276,
            UPDATE_FILE_ID_DOES_NOT_MATCH_PREPARED = 277,
            UPDATE_FILE_HASH_DOES_NOT_MATCH_PREPARED = 278,
            CONSENSUS_GAS_EXHAUSTED = 279,
            REVERTED_SUCCESS = 280,
            MAX_STORAGE_IN_PRICE_REGIME_HAS_BEEN_USED = 281,
            INVALID_ALIAS_KEY = 282,
            UNEXPECTED_TOKEN_DECIMALS = 283,
            INVALID_PROXY_ACCOUNT_ID = 284,
            INVALID_TRANSFER_ACCOUNT_ID = 285,
            INVALID_FEE_COLLECTOR_ACCOUNT_ID = 286,
            ALIAS_IS_IMMUTABLE = 287,
            SPENDER_ACCOUNT_SAME_AS_OWNER = 288,
            AMOUNT_EXCEEDS_TOKEN_MAX_SUPPLY = 289,
            NEGATIVE_ALLOWANCE_AMOUNT = 290,
            CANNOT_APPROVE_FOR_ALL_FUNGIBLE_COMMON = 291,
            SPENDER_DOES_NOT_HAVE_ALLOWANCE = 292,
            AMOUNT_EXCEEDS_ALLOWANCE = 293,
            MAX_ALLOWANCES_EXCEEDED = 294,
            EMPTY_ALLOWANCES = 295,
            SPENDER_ACCOUNT_REPEATED_IN_ALLOWANCES = 296,
            REPEATED_SERIAL_NUMS_IN_NFT_ALLOWANCES = 297,
            FUNGIBLE_TOKEN_IN_NFT_ALLOWANCES = 298,
            NFT_IN_FUNGIBLE_TOKEN_ALLOWANCES = 299,
            INVALID_ALLOWANCE_OWNER_ID = 300,
            INVALID_ALLOWANCE_SPENDER_ID = 301,
            REPEATED_ALLOWANCES_TO_DELETE = 302,
            INVALID_DELEGATING_SPENDER = 303,
            DELEGATING_SPENDER_CANNOT_GRANT_APPROVE_FOR_ALL = 304,
            DELEGATING_SPENDER_DOES_NOT_HAVE_APPROVE_FOR_ALL = 305,
            SCHEDULE_EXPIRATION_TIME_TOO_FAR_IN_FUTURE = 306,
            SCHEDULE_EXPIRATION_TIME_MUST_BE_HIGHER_THAN_CONSENSUS_TIME = 307,
            SCHEDULE_FUTURE_THROTTLE_EXCEEDED = 308,
            SCHEDULE_FUTURE_GAS_LIMIT_EXCEEDED = 309,
            INVALID_ETHEREUM_TRANSACTION = 310,
            WRONG_CHAIN_ID = 311,
            WRONG_NONCE = 312,
            ACCESS_LIST_UNSUPPORTED = 313,
            SCHEDULE_PENDING_EXPIRATION = 314,
            CONTRACT_IS_TOKEN_TREASURY = 315,
            CONTRACT_HAS_NON_ZERO_TOKEN_BALANCES = 316,
            CONTRACT_EXPIRED_AND_PENDING_REMOVAL = 317,
            CONTRACT_HAS_NO_AUTO_RENEW_ACCOUNT = 318,
            PERMANENT_REMOVAL_REQUIRES_SYSTEM_INITIATION = 319,
            PROXY_ACCOUNT_ID_FIELD_IS_DEPRECATED = 320,
            SELF_STAKING_IS_NOT_ALLOWED = 321,
            INVALID_STAKING_ID = 322,
            STAKING_NOT_ENABLED = 323,
            INVALID_PRNG_RANGE = 324,
            MAX_ENTITIES_IN_PRICE_REGIME_HAVE_BEEN_CREATED = 325,
            INVALID_FULL_PREFIX_SIGNATURE_FOR_PRECOMPILE = 326,
            INSUFFICIENT_BALANCES_FOR_STORAGE_RENT = 327,
            MAX_CHILD_RECORDS_EXCEEDED = 328,
            INSUFFICIENT_BALANCES_FOR_RENEWAL_FEES = 329,
            TRANSACTION_HAS_UNKNOWN_FIELDS = 330,
            ACCOUNT_IS_IMMUTABLE = 331,
            ALIAS_ALREADY_ASSIGNED = 332
        }

        /** Properties of a ConsensusTopicInfo. */
        interface IConsensusTopicInfo {

            /** The memo associated with the topic (UTF-8 encoding max 100 bytes) */
            memo?: (string|null);

            /**
             * When a topic is created, its running hash is initialized to 48 bytes of binary zeros.
             * For each submitted message, the topic's running hash is then updated to the output
             * of a particular SHA-384 digest whose input data include the previous running hash.
             *
             * See the TransactionReceipt.proto documentation for an exact description of the
             * data included in the SHA-384 digest used for the update.
             */
            runningHash?: (Uint8Array|null);

            /** Sequence number (starting at 1 for the first submitMessage) of messages on the topic. */
            sequenceNumber?: (Long|null);

            /**
             * Effective consensus timestamp at (and after) which submitMessage calls will no longer succeed on the topic
             * and the topic will expire and after AUTORENEW_GRACE_PERIOD be automatically deleted.
             */
            expirationTime?: (hashgraph.proto.ITimestamp|null);

            /** Access control for update/delete of the topic. Null if there is no key. */
            adminKey?: (hashgraph.proto.IKey|null);

            /** Access control for ConsensusService.submitMessage. Null if there is no key. */
            submitKey?: (hashgraph.proto.IKey|null);

            /**
             * If an auto-renew account is specified, when the topic expires, its lifetime will be extended
             * by up to this duration (depending on the solvency of the auto-renew account). If the
             * auto-renew account has no funds at all, the topic will be deleted instead.
             */
            autoRenewPeriod?: (hashgraph.proto.IDuration|null);

            /** The account, if any, to charge for automatic renewal of the topic's lifetime upon expiry. */
            autoRenewAccount?: (hashgraph.proto.IAccountID|null);

            /** The ledger ID the response was returned from; please see <a href="https://github.com/hashgraph/hedera-improvement-proposal/blob/master/HIP/hip-198.md">HIP-198</a> for the network-specific IDs. */
            ledgerId?: (Uint8Array|null);
        }

        /** Current state of a topic. */
        class ConsensusTopicInfo implements IConsensusTopicInfo {

            /**
             * Constructs a new ConsensusTopicInfo.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IConsensusTopicInfo);

            /** The memo associated with the topic (UTF-8 encoding max 100 bytes) */
            public memo: string;

            /**
             * When a topic is created, its running hash is initialized to 48 bytes of binary zeros.
             * For each submitted message, the topic's running hash is then updated to the output
             * of a particular SHA-384 digest whose input data include the previous running hash.
             *
             * See the TransactionReceipt.proto documentation for an exact description of the
             * data included in the SHA-384 digest used for the update.
             */
            public runningHash: Uint8Array;

            /** Sequence number (starting at 1 for the first submitMessage) of messages on the topic. */
            public sequenceNumber: Long;

            /**
             * Effective consensus timestamp at (and after) which submitMessage calls will no longer succeed on the topic
             * and the topic will expire and after AUTORENEW_GRACE_PERIOD be automatically deleted.
             */
            public expirationTime?: (hashgraph.proto.ITimestamp|null);

            /** Access control for update/delete of the topic. Null if there is no key. */
            public adminKey?: (hashgraph.proto.IKey|null);

            /** Access control for ConsensusService.submitMessage. Null if there is no key. */
            public submitKey?: (hashgraph.proto.IKey|null);

            /**
             * If an auto-renew account is specified, when the topic expires, its lifetime will be extended
             * by up to this duration (depending on the solvency of the auto-renew account). If the
             * auto-renew account has no funds at all, the topic will be deleted instead.
             */
            public autoRenewPeriod?: (hashgraph.proto.IDuration|null);

            /** The account, if any, to charge for automatic renewal of the topic's lifetime upon expiry. */
            public autoRenewAccount?: (hashgraph.proto.IAccountID|null);

            /** The ledger ID the response was returned from; please see <a href="https://github.com/hashgraph/hedera-improvement-proposal/blob/master/HIP/hip-198.md">HIP-198</a> for the network-specific IDs. */
            public ledgerId: Uint8Array;

            /**
             * Creates a new ConsensusTopicInfo instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ConsensusTopicInfo instance
             */
            public static create(properties?: hashgraph.proto.IConsensusTopicInfo): hashgraph.proto.ConsensusTopicInfo;

            /**
             * Encodes the specified ConsensusTopicInfo message. Does not implicitly {@link hashgraph.proto.ConsensusTopicInfo.verify|verify} messages.
             * @param m ConsensusTopicInfo message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IConsensusTopicInfo, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ConsensusTopicInfo message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ConsensusTopicInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ConsensusTopicInfo;

            /**
             * Gets the default type url for ConsensusTopicInfo
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /**
         * The Consensus Service provides the ability for Hedera Hashgraph to provide aBFT consensus as to
         * the order and validity of messages submitted to a *topic*, as well as a *consensus timestamp* for
         * those messages.
         *
         * Automatic renewal can be configured via an autoRenewAccount.
         * Any time an autoRenewAccount is added to a topic, that createTopic/updateTopic transaction must
         * be signed by the autoRenewAccount.
         *
         * The autoRenewPeriod on an account must currently be set a value in createTopic between
         * MIN_AUTORENEW_PERIOD (6999999 seconds) and MAX_AUTORENEW_PERIOD (8000001 seconds). During
         * creation this sets the initial expirationTime of the topic (see more below).
         *
         * If no adminKey is on a topic, there may not be an autoRenewAccount on the topic, deleteTopic is
         * not allowed, and the only change allowed via an updateTopic is to extend the expirationTime.
         *
         * If an adminKey is on a topic, every updateTopic and deleteTopic transaction must be signed by the
         * adminKey, except for updateTopics which only extend the topic's expirationTime (no adminKey
         * authorization required).
         *
         * If an updateTopic modifies the adminKey of a topic, the transaction signatures on the updateTopic
         * must fulfill both the pre-update and post-update adminKey signature requirements.
         *
         * Mirrornet ConsensusService may be used to subscribe to changes on the topic, including changes to
         * the topic definition and the consensus ordering and timestamp of submitted messages.
         *
         * Until autoRenew functionality is supported by HAPI, the topic will not expire, the
         * autoRenewAccount will not be charged, and the topic will not automatically be deleted.
         *
         * Once autoRenew functionality is supported by HAPI:
         *
         * 1. Once the expirationTime is encountered, if an autoRenewAccount is configured on the topic, the
         * account will be charged automatically at the expirationTime, to extend the expirationTime of the
         * topic up to the topic's autoRenewPeriod (or as much extension as the account's balance will
         * supply).
         *
         * 2. If the topic expires and is not automatically renewed, the topic will enter the EXPIRED state.
         * All transactions on the topic will fail with TOPIC_EXPIRED, except an updateTopic() call that
         * modifies only the expirationTime.  getTopicInfo() will succeed. This state will be available for
         * a AUTORENEW_GRACE_PERIOD grace period (7 days).
         *
         * 3. After the grace period, if the topic's expirationTime is not extended, the topic will be
         * automatically deleted and no transactions or queries on the topic will succeed after that point.
         */
        class ConsensusService extends $protobuf.rpc.Service {

            /**
             * Constructs a new ConsensusService service.
             * @param rpcImpl RPC implementation
             * @param [requestDelimited=false] Whether requests are length-delimited
             * @param [responseDelimited=false] Whether responses are length-delimited
             */
            constructor(rpcImpl: $protobuf.RPCImpl, requestDelimited?: boolean, responseDelimited?: boolean);

            /**
             * Creates new ConsensusService service using the specified rpc implementation.
             * @param rpcImpl RPC implementation
             * @param [requestDelimited=false] Whether requests are length-delimited
             * @param [responseDelimited=false] Whether responses are length-delimited
             * @returns RPC service. Useful where requests and/or responses are streamed.
             */
            public static create(rpcImpl: $protobuf.RPCImpl, requestDelimited?: boolean, responseDelimited?: boolean): ConsensusService;

            /**
             * Create a topic to be used for consensus.
             * If an autoRenewAccount is specified, that account must also sign this transaction.
             * If an adminKey is specified, the adminKey must sign the transaction.
             * On success, the resulting TransactionReceipt contains the newly created TopicId.
             * Request is [ConsensusCreateTopicTransactionBody](#hashgraph.proto.ConsensusCreateTopicTransactionBody)
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public createTopic(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.ConsensusService.createTopicCallback): void;

            /**
             * Create a topic to be used for consensus.
             * If an autoRenewAccount is specified, that account must also sign this transaction.
             * If an adminKey is specified, the adminKey must sign the transaction.
             * On success, the resulting TransactionReceipt contains the newly created TopicId.
             * Request is [ConsensusCreateTopicTransactionBody](#hashgraph.proto.ConsensusCreateTopicTransactionBody)
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public createTopic(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Update a topic.
             * If there is no adminKey, the only authorized update (available to anyone) is to extend the expirationTime.
             * Otherwise transaction must be signed by the adminKey.
             * If an adminKey is updated, the transaction must be signed by the pre-update adminKey and post-update adminKey.
             * If a new autoRenewAccount is specified (not just being removed), that account must also sign the transaction.
             * Request is [ConsensusUpdateTopicTransactionBody](#hashgraph.proto.ConsensusUpdateTopicTransactionBody)
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public updateTopic(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.ConsensusService.updateTopicCallback): void;

            /**
             * Update a topic.
             * If there is no adminKey, the only authorized update (available to anyone) is to extend the expirationTime.
             * Otherwise transaction must be signed by the adminKey.
             * If an adminKey is updated, the transaction must be signed by the pre-update adminKey and post-update adminKey.
             * If a new autoRenewAccount is specified (not just being removed), that account must also sign the transaction.
             * Request is [ConsensusUpdateTopicTransactionBody](#hashgraph.proto.ConsensusUpdateTopicTransactionBody)
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public updateTopic(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Delete a topic. No more transactions or queries on the topic (via HAPI) will succeed.
             * If an adminKey is set, this transaction must be signed by that key.
             * If there is no adminKey, this transaction will fail UNAUTHORIZED.
             * Request is [ConsensusDeleteTopicTransactionBody](#hashgraph.proto.ConsensusDeleteTopicTransactionBody)
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public deleteTopic(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.ConsensusService.deleteTopicCallback): void;

            /**
             * Delete a topic. No more transactions or queries on the topic (via HAPI) will succeed.
             * If an adminKey is set, this transaction must be signed by that key.
             * If there is no adminKey, this transaction will fail UNAUTHORIZED.
             * Request is [ConsensusDeleteTopicTransactionBody](#hashgraph.proto.ConsensusDeleteTopicTransactionBody)
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public deleteTopic(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Retrieve the latest state of a topic. This method is unrestricted and allowed on any topic by any payer account.
             * Deleted accounts will not be returned.
             * Request is [ConsensusGetTopicInfoQuery](#hashgraph.proto.ConsensusGetTopicInfoQuery)
             * Response is [ConsensusGetTopicInfoResponse](#hashgraph.proto.ConsensusGetTopicInfoResponse)
             * @param request Query message or plain object
             * @param callback Node-style callback called with the error, if any, and Response
             */
            public getTopicInfo(request: hashgraph.proto.IQuery, callback: hashgraph.proto.ConsensusService.getTopicInfoCallback): void;

            /**
             * Retrieve the latest state of a topic. This method is unrestricted and allowed on any topic by any payer account.
             * Deleted accounts will not be returned.
             * Request is [ConsensusGetTopicInfoQuery](#hashgraph.proto.ConsensusGetTopicInfoQuery)
             * Response is [ConsensusGetTopicInfoResponse](#hashgraph.proto.ConsensusGetTopicInfoResponse)
             * @param request Query message or plain object
             * @returns Promise
             */
            public getTopicInfo(request: hashgraph.proto.IQuery): Promise<hashgraph.proto.Response>;

            /**
             * Submit a message for consensus.
             * Valid and authorized messages on valid topics will be ordered by the consensus service, gossipped to the
             * mirror net, and published (in order) to all subscribers (from the mirror net) on this topic.
             * The submitKey (if any) must sign this transaction.
             * On success, the resulting TransactionReceipt contains the topic's updated topicSequenceNumber and
             * topicRunningHash.
             * Request is [ConsensusSubmitMessageTransactionBody](#hashgraph.proto.ConsensusSubmitMessageTransactionBody)
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public submitMessage(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.ConsensusService.submitMessageCallback): void;

            /**
             * Submit a message for consensus.
             * Valid and authorized messages on valid topics will be ordered by the consensus service, gossipped to the
             * mirror net, and published (in order) to all subscribers (from the mirror net) on this topic.
             * The submitKey (if any) must sign this transaction.
             * On success, the resulting TransactionReceipt contains the topic's updated topicSequenceNumber and
             * topicRunningHash.
             * Request is [ConsensusSubmitMessageTransactionBody](#hashgraph.proto.ConsensusSubmitMessageTransactionBody)
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public submitMessage(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;
        }

        namespace ConsensusService {

            /**
             * Callback as used by {@link hashgraph.proto.ConsensusService#createTopic}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type createTopicCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.ConsensusService#updateTopic}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type updateTopicCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.ConsensusService#deleteTopic}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type deleteTopicCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.ConsensusService#getTopicInfo}.
             * @param error Error, if any
             * @param [response] Response
             */
            type getTopicInfoCallback = (error: (Error|null), response?: hashgraph.proto.Response) => void;

            /**
             * Callback as used by {@link hashgraph.proto.ConsensusService#submitMessage}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type submitMessageCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;
        }

        /** Properties of a Query. */
        interface IQuery {

            /** Get all entities associated with a given key */
            getByKey?: (hashgraph.proto.IGetByKeyQuery|null);

            /** Get the IDs in the format used in transactions, given the format used in Solidity */
            getBySolidityID?: (hashgraph.proto.IGetBySolidityIDQuery|null);

            /** Call a function of a smart contract instance */
            contractCallLocal?: (hashgraph.proto.IContractCallLocalQuery|null);

            /** Get information about a smart contract instance */
            contractGetInfo?: (hashgraph.proto.IContractGetInfoQuery|null);

            /** Get runtime code used by a smart contract instance */
            contractGetBytecode?: (hashgraph.proto.IContractGetBytecodeQuery|null);

            /** Get Records of the contract instance */
            ContractGetRecords?: (hashgraph.proto.IContractGetRecordsQuery|null);

            /** Get the current balance in a cryptocurrency account */
            cryptogetAccountBalance?: (hashgraph.proto.ICryptoGetAccountBalanceQuery|null);

            /** Get all the records that currently exist for transactions involving an account */
            cryptoGetAccountRecords?: (hashgraph.proto.ICryptoGetAccountRecordsQuery|null);

            /** Get all information about an account */
            cryptoGetInfo?: (hashgraph.proto.ICryptoGetInfoQuery|null);

            /** Get a single livehash from a single account, if present */
            cryptoGetLiveHash?: (hashgraph.proto.ICryptoGetLiveHashQuery|null);

            /**
             * Get all the accounts that proxy stake to a given account, and how much they proxy stake
             * (not yet implemented in the current API)
             */
            cryptoGetProxyStakers?: (hashgraph.proto.ICryptoGetStakersQuery|null);

            /** Get the contents of a file (the bytes stored in it) */
            fileGetContents?: (hashgraph.proto.IFileGetContentsQuery|null);

            /** Get information about a file, such as its expiration date */
            fileGetInfo?: (hashgraph.proto.IFileGetInfoQuery|null);

            /** Get a receipt for a transaction (lasts 180 seconds) */
            transactionGetReceipt?: (hashgraph.proto.ITransactionGetReceiptQuery|null);

            /** Get a record for a transaction */
            transactionGetRecord?: (hashgraph.proto.ITransactionGetRecordQuery|null);

            /** Get a record for a transaction (lasts 180 seconds) */
            transactionGetFastRecord?: (hashgraph.proto.ITransactionGetFastRecordQuery|null);

            /** Get the parameters of and state of a consensus topic. */
            consensusGetTopicInfo?: (hashgraph.proto.IConsensusGetTopicInfoQuery|null);

            /**
             * Get the versions of the HAPI protobuf and Hedera Services software deployed on the
             * responding node.
             */
            networkGetVersionInfo?: (hashgraph.proto.INetworkGetVersionInfoQuery|null);

            /** Get all information about a token */
            tokenGetInfo?: (hashgraph.proto.ITokenGetInfoQuery|null);

            /** Get all information about a scheduled entity */
            scheduleGetInfo?: (hashgraph.proto.IScheduleGetInfoQuery|null);

            /** Get a list of NFTs associated with the account */
            tokenGetAccountNftInfos?: (hashgraph.proto.ITokenGetAccountNftInfosQuery|null);

            /** Get all information about a NFT */
            tokenGetNftInfo?: (hashgraph.proto.ITokenGetNftInfoQuery|null);

            /** Get a list of NFTs for the token */
            tokenGetNftInfos?: (hashgraph.proto.ITokenGetNftInfosQuery|null);

            /** Gets <tt>handleTransaction</tt> times for one or more "sufficiently recent" TransactionIDs */
            networkGetExecutionTime?: (hashgraph.proto.INetworkGetExecutionTimeQuery|null);

            /** Gets all information about an account including allowances granted by the account */
            accountDetails?: (hashgraph.proto.IGetAccountDetailsQuery|null);
        }

        /**
         * A single query, which is sent from the client to a node. This includes all possible queries. Each
         * Query should not have more than 50 levels.
         */
        class Query implements IQuery {

            /**
             * Constructs a new Query.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IQuery);

            /** Get all entities associated with a given key */
            public getByKey?: (hashgraph.proto.IGetByKeyQuery|null);

            /** Get the IDs in the format used in transactions, given the format used in Solidity */
            public getBySolidityID?: (hashgraph.proto.IGetBySolidityIDQuery|null);

            /** Call a function of a smart contract instance */
            public contractCallLocal?: (hashgraph.proto.IContractCallLocalQuery|null);

            /** Get information about a smart contract instance */
            public contractGetInfo?: (hashgraph.proto.IContractGetInfoQuery|null);

            /** Get runtime code used by a smart contract instance */
            public contractGetBytecode?: (hashgraph.proto.IContractGetBytecodeQuery|null);

            /** Get Records of the contract instance */
            public ContractGetRecords?: (hashgraph.proto.IContractGetRecordsQuery|null);

            /** Get the current balance in a cryptocurrency account */
            public cryptogetAccountBalance?: (hashgraph.proto.ICryptoGetAccountBalanceQuery|null);

            /** Get all the records that currently exist for transactions involving an account */
            public cryptoGetAccountRecords?: (hashgraph.proto.ICryptoGetAccountRecordsQuery|null);

            /** Get all information about an account */
            public cryptoGetInfo?: (hashgraph.proto.ICryptoGetInfoQuery|null);

            /** Get a single livehash from a single account, if present */
            public cryptoGetLiveHash?: (hashgraph.proto.ICryptoGetLiveHashQuery|null);

            /**
             * Get all the accounts that proxy stake to a given account, and how much they proxy stake
             * (not yet implemented in the current API)
             */
            public cryptoGetProxyStakers?: (hashgraph.proto.ICryptoGetStakersQuery|null);

            /** Get the contents of a file (the bytes stored in it) */
            public fileGetContents?: (hashgraph.proto.IFileGetContentsQuery|null);

            /** Get information about a file, such as its expiration date */
            public fileGetInfo?: (hashgraph.proto.IFileGetInfoQuery|null);

            /** Get a receipt for a transaction (lasts 180 seconds) */
            public transactionGetReceipt?: (hashgraph.proto.ITransactionGetReceiptQuery|null);

            /** Get a record for a transaction */
            public transactionGetRecord?: (hashgraph.proto.ITransactionGetRecordQuery|null);

            /** Get a record for a transaction (lasts 180 seconds) */
            public transactionGetFastRecord?: (hashgraph.proto.ITransactionGetFastRecordQuery|null);

            /** Get the parameters of and state of a consensus topic. */
            public consensusGetTopicInfo?: (hashgraph.proto.IConsensusGetTopicInfoQuery|null);

            /**
             * Get the versions of the HAPI protobuf and Hedera Services software deployed on the
             * responding node.
             */
            public networkGetVersionInfo?: (hashgraph.proto.INetworkGetVersionInfoQuery|null);

            /** Get all information about a token */
            public tokenGetInfo?: (hashgraph.proto.ITokenGetInfoQuery|null);

            /** Get all information about a scheduled entity */
            public scheduleGetInfo?: (hashgraph.proto.IScheduleGetInfoQuery|null);

            /** Get a list of NFTs associated with the account */
            public tokenGetAccountNftInfos?: (hashgraph.proto.ITokenGetAccountNftInfosQuery|null);

            /** Get all information about a NFT */
            public tokenGetNftInfo?: (hashgraph.proto.ITokenGetNftInfoQuery|null);

            /** Get a list of NFTs for the token */
            public tokenGetNftInfos?: (hashgraph.proto.ITokenGetNftInfosQuery|null);

            /** Gets <tt>handleTransaction</tt> times for one or more "sufficiently recent" TransactionIDs */
            public networkGetExecutionTime?: (hashgraph.proto.INetworkGetExecutionTimeQuery|null);

            /** Gets all information about an account including allowances granted by the account */
            public accountDetails?: (hashgraph.proto.IGetAccountDetailsQuery|null);

            /** Query query. */
            public query?: ("getByKey"|"getBySolidityID"|"contractCallLocal"|"contractGetInfo"|"contractGetBytecode"|"ContractGetRecords"|"cryptogetAccountBalance"|"cryptoGetAccountRecords"|"cryptoGetInfo"|"cryptoGetLiveHash"|"cryptoGetProxyStakers"|"fileGetContents"|"fileGetInfo"|"transactionGetReceipt"|"transactionGetRecord"|"transactionGetFastRecord"|"consensusGetTopicInfo"|"networkGetVersionInfo"|"tokenGetInfo"|"scheduleGetInfo"|"tokenGetAccountNftInfos"|"tokenGetNftInfo"|"tokenGetNftInfos"|"networkGetExecutionTime"|"accountDetails");

            /**
             * Creates a new Query instance using the specified properties.
             * @param [properties] Properties to set
             * @returns Query instance
             */
            public static create(properties?: hashgraph.proto.IQuery): hashgraph.proto.Query;

            /**
             * Encodes the specified Query message. Does not implicitly {@link hashgraph.proto.Query.verify|verify} messages.
             * @param m Query message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IQuery, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a Query message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns Query
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.Query;

            /**
             * Gets the default type url for Query
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a GetByKeyQuery. */
        interface IGetByKeyQuery {

            /**
             * Standard info sent from client to node, including the signed payment, and what kind of
             * response is requested (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IQueryHeader|null);

            /** The key to search for. It must not contain a contractID nor a ThresholdSignature. */
            key?: (hashgraph.proto.IKey|null);
        }

        /**
         * Get all accounts, claims, files, and smart contract instances whose associated keys include the
         * given Key. The given Key must not be a contractID or a ThresholdKey. This is not yet implemented
         * in the API, but will be in the future.
         */
        class GetByKeyQuery implements IGetByKeyQuery {

            /**
             * Constructs a new GetByKeyQuery.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IGetByKeyQuery);

            /**
             * Standard info sent from client to node, including the signed payment, and what kind of
             * response is requested (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IQueryHeader|null);

            /** The key to search for. It must not contain a contractID nor a ThresholdSignature. */
            public key?: (hashgraph.proto.IKey|null);

            /**
             * Creates a new GetByKeyQuery instance using the specified properties.
             * @param [properties] Properties to set
             * @returns GetByKeyQuery instance
             */
            public static create(properties?: hashgraph.proto.IGetByKeyQuery): hashgraph.proto.GetByKeyQuery;

            /**
             * Encodes the specified GetByKeyQuery message. Does not implicitly {@link hashgraph.proto.GetByKeyQuery.verify|verify} messages.
             * @param m GetByKeyQuery message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IGetByKeyQuery, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a GetByKeyQuery message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns GetByKeyQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.GetByKeyQuery;

            /**
             * Gets the default type url for GetByKeyQuery
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of an EntityID. */
        interface IEntityID {

            /** The Account ID for the cryptocurrency account */
            accountID?: (hashgraph.proto.IAccountID|null);

            /** A uniquely identifying livehash of an acount */
            liveHash?: (hashgraph.proto.ILiveHash|null);

            /** The file ID of the file */
            fileID?: (hashgraph.proto.IFileID|null);

            /** The smart contract ID that identifies instance */
            contractID?: (hashgraph.proto.IContractID|null);
        }

        /** the ID for a single entity (account, livehash, file, or smart contract instance) */
        class EntityID implements IEntityID {

            /**
             * Constructs a new EntityID.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IEntityID);

            /** The Account ID for the cryptocurrency account */
            public accountID?: (hashgraph.proto.IAccountID|null);

            /** A uniquely identifying livehash of an acount */
            public liveHash?: (hashgraph.proto.ILiveHash|null);

            /** The file ID of the file */
            public fileID?: (hashgraph.proto.IFileID|null);

            /** The smart contract ID that identifies instance */
            public contractID?: (hashgraph.proto.IContractID|null);

            /** EntityID entity. */
            public entity?: ("accountID"|"liveHash"|"fileID"|"contractID");

            /**
             * Creates a new EntityID instance using the specified properties.
             * @param [properties] Properties to set
             * @returns EntityID instance
             */
            public static create(properties?: hashgraph.proto.IEntityID): hashgraph.proto.EntityID;

            /**
             * Encodes the specified EntityID message. Does not implicitly {@link hashgraph.proto.EntityID.verify|verify} messages.
             * @param m EntityID message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IEntityID, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an EntityID message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns EntityID
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.EntityID;

            /**
             * Gets the default type url for EntityID
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a GetByKeyResponse. */
        interface IGetByKeyResponse {

            /**
             * Standard response from node to client, including the requested fields: cost, or state proof,
             * or both, or neither
             */
            header?: (hashgraph.proto.IResponseHeader|null);

            /** The list of entities that include this public key in their associated Key list */
            entities?: (hashgraph.proto.IEntityID[]|null);
        }

        /** Response when the client sends the node GetByKeyQuery */
        class GetByKeyResponse implements IGetByKeyResponse {

            /**
             * Constructs a new GetByKeyResponse.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IGetByKeyResponse);

            /**
             * Standard response from node to client, including the requested fields: cost, or state proof,
             * or both, or neither
             */
            public header?: (hashgraph.proto.IResponseHeader|null);

            /** The list of entities that include this public key in their associated Key list */
            public entities: hashgraph.proto.IEntityID[];

            /**
             * Creates a new GetByKeyResponse instance using the specified properties.
             * @param [properties] Properties to set
             * @returns GetByKeyResponse instance
             */
            public static create(properties?: hashgraph.proto.IGetByKeyResponse): hashgraph.proto.GetByKeyResponse;

            /**
             * Encodes the specified GetByKeyResponse message. Does not implicitly {@link hashgraph.proto.GetByKeyResponse.verify|verify} messages.
             * @param m GetByKeyResponse message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IGetByKeyResponse, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a GetByKeyResponse message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns GetByKeyResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.GetByKeyResponse;

            /**
             * Gets the default type url for GetByKeyResponse
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a GetBySolidityIDQuery. */
        interface IGetBySolidityIDQuery {

            /**
             * Standard info sent from client to node, including the signed payment, and what kind of
             * response is requested (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IQueryHeader|null);

            /** The ID in the format used by Solidity */
            solidityID?: (string|null);
        }

        /**
         * Get the IDs in the format used by transactions, given the ID in the format used by Solidity. If
         * the Solidity ID is for a smart contract instance, then both the ContractID and associated
         * AccountID will be returned.
         */
        class GetBySolidityIDQuery implements IGetBySolidityIDQuery {

            /**
             * Constructs a new GetBySolidityIDQuery.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IGetBySolidityIDQuery);

            /**
             * Standard info sent from client to node, including the signed payment, and what kind of
             * response is requested (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IQueryHeader|null);

            /** The ID in the format used by Solidity */
            public solidityID: string;

            /**
             * Creates a new GetBySolidityIDQuery instance using the specified properties.
             * @param [properties] Properties to set
             * @returns GetBySolidityIDQuery instance
             */
            public static create(properties?: hashgraph.proto.IGetBySolidityIDQuery): hashgraph.proto.GetBySolidityIDQuery;

            /**
             * Encodes the specified GetBySolidityIDQuery message. Does not implicitly {@link hashgraph.proto.GetBySolidityIDQuery.verify|verify} messages.
             * @param m GetBySolidityIDQuery message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IGetBySolidityIDQuery, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a GetBySolidityIDQuery message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns GetBySolidityIDQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.GetBySolidityIDQuery;

            /**
             * Gets the default type url for GetBySolidityIDQuery
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a GetBySolidityIDResponse. */
        interface IGetBySolidityIDResponse {

            /**
             * Standard response from node to client, including the requested fields: cost, or state proof,
             * or both, or neither
             */
            header?: (hashgraph.proto.IResponseHeader|null);

            /** The Account ID for the cryptocurrency account */
            accountID?: (hashgraph.proto.IAccountID|null);

            /** The file Id for the file */
            fileID?: (hashgraph.proto.IFileID|null);

            /**
             * A smart contract ID for the instance (if this is included, then the associated accountID will
             * also be included)
             */
            contractID?: (hashgraph.proto.IContractID|null);
        }

        /** Response when the client sends the node GetBySolidityIDQuery */
        class GetBySolidityIDResponse implements IGetBySolidityIDResponse {

            /**
             * Constructs a new GetBySolidityIDResponse.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IGetBySolidityIDResponse);

            /**
             * Standard response from node to client, including the requested fields: cost, or state proof,
             * or both, or neither
             */
            public header?: (hashgraph.proto.IResponseHeader|null);

            /** The Account ID for the cryptocurrency account */
            public accountID?: (hashgraph.proto.IAccountID|null);

            /** The file Id for the file */
            public fileID?: (hashgraph.proto.IFileID|null);

            /**
             * A smart contract ID for the instance (if this is included, then the associated accountID will
             * also be included)
             */
            public contractID?: (hashgraph.proto.IContractID|null);

            /**
             * Creates a new GetBySolidityIDResponse instance using the specified properties.
             * @param [properties] Properties to set
             * @returns GetBySolidityIDResponse instance
             */
            public static create(properties?: hashgraph.proto.IGetBySolidityIDResponse): hashgraph.proto.GetBySolidityIDResponse;

            /**
             * Encodes the specified GetBySolidityIDResponse message. Does not implicitly {@link hashgraph.proto.GetBySolidityIDResponse.verify|verify} messages.
             * @param m GetBySolidityIDResponse message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IGetBySolidityIDResponse, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a GetBySolidityIDResponse message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns GetBySolidityIDResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.GetBySolidityIDResponse;

            /**
             * Gets the default type url for GetBySolidityIDResponse
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ContractLoginfo. */
        interface IContractLoginfo {

            /** address of a contract that emitted the event */
            contractID?: (hashgraph.proto.IContractID|null);

            /** bloom filter for a particular log */
            bloom?: (Uint8Array|null);

            /** topics of a particular event */
            topic?: (Uint8Array[]|null);

            /** event data */
            data?: (Uint8Array|null);
        }

        /**
         * The log information for an event returned by a smart contract function call. One function call
         * may return several such events.
         */
        class ContractLoginfo implements IContractLoginfo {

            /**
             * Constructs a new ContractLoginfo.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IContractLoginfo);

            /** address of a contract that emitted the event */
            public contractID?: (hashgraph.proto.IContractID|null);

            /** bloom filter for a particular log */
            public bloom: Uint8Array;

            /** topics of a particular event */
            public topic: Uint8Array[];

            /** event data */
            public data: Uint8Array;

            /**
             * Creates a new ContractLoginfo instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ContractLoginfo instance
             */
            public static create(properties?: hashgraph.proto.IContractLoginfo): hashgraph.proto.ContractLoginfo;

            /**
             * Encodes the specified ContractLoginfo message. Does not implicitly {@link hashgraph.proto.ContractLoginfo.verify|verify} messages.
             * @param m ContractLoginfo message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IContractLoginfo, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ContractLoginfo message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ContractLoginfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ContractLoginfo;

            /**
             * Gets the default type url for ContractLoginfo
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ContractFunctionResult. */
        interface IContractFunctionResult {

            /** the smart contract instance whose function was called */
            contractID?: (hashgraph.proto.IContractID|null);

            /** the result returned by the function */
            contractCallResult?: (Uint8Array|null);

            /** message In case there was an error during smart contract execution */
            errorMessage?: (string|null);

            /** bloom filter for record */
            bloom?: (Uint8Array|null);

            /** units of gas used to execute contract */
            gasUsed?: (Long|null);

            /** the log info for events returned by the function */
            logInfo?: (hashgraph.proto.IContractLoginfo[]|null);

            /**
             * [DEPRECATED] the list of smart contracts that were created by the function call.
             *
             * The created ids will now _also_ be externalized through internal transaction
             * records, where each record has its alias field populated with the new contract's
             * EVM address. (This is needed for contracts created with CREATE2, since
             * there is no longer a simple relationship between the new contract's 0.0.X id
             * and its Solidity address.)
             */
            createdContractIDs?: (hashgraph.proto.IContractID[]|null);

            /**
             * The new contract's 20-byte EVM address. Only populated after release 0.23,
             * where each created contract will have its own record. (This is an important
             * point--the field is not <tt>repeated</tt> because there will be a separate
             * child record for each created contract.)
             *
             * Every contract has an EVM address determined by its <tt>shard.realm.num</tt> id.
             * This address is as follows:
             * <ol>
             * <li>The first 4 bytes are the big-endian representation of the shard.</li>
             * <li>The next 8 bytes are the big-endian representation of the realm.</li>
             * <li>The final 8 bytes are the big-endian representation of the number.</li>
             * </ol>
             *
             * Contracts created via CREATE2 have an <b>additional, primary address</b> that is
             * derived from the <a href="https://eips.ethereum.org/EIPS/eip-1014">EIP-1014</a>
             * specification, and does not have a simple relation to a <tt>shard.realm.num</tt> id.
             *
             * (Please do note that CREATE2 contracts can also be referenced by the three-part
             * EVM address described above.)
             */
            evmAddress?: (google.protobuf.IBytesValue|null);

            /**
             * The amount of gas available for the call, aka the gasLimit.
             *
             * This field should only be populated when the paired TransactionBody in the record stream is not a
             * ContractCreateTransactionBody or a ContractCallTransactionBody.
             */
            gas?: (Long|null);

            /**
             * Number of tinybars sent (the function must be payable if this is nonzero).
             *
             * This field should only be populated when the paired TransactionBody in the record stream is not a
             * ContractCreateTransactionBody or a ContractCallTransactionBody.
             */
            amount?: (Long|null);

            /**
             * The parameters passed into the contract call.
             *
             * This field should only be populated when the paired TransactionBody in the record stream is not a
             * ContractCreateTransactionBody or a ContractCallTransactionBody.
             */
            functionParameters?: (Uint8Array|null);

            /**
             * The account that is the "sender." If not present it is the accountId from the transactionId.
             *
             * This field should only be populated when the paired TransactionBody in the record stream is not a
             * ContractCreateTransactionBody or a ContractCallTransactionBody.
             */
            senderId?: (hashgraph.proto.IAccountID|null);
        }

        /**
         * The result returned by a call to a smart contract function. This is part of the response to a
         * ContractCallLocal query, and is in the record for a ContractCall or ContractCreateInstance
         * transaction. The ContractCreateInstance transaction record has the results of the call to the
         * constructor.
         */
        class ContractFunctionResult implements IContractFunctionResult {

            /**
             * Constructs a new ContractFunctionResult.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IContractFunctionResult);

            /** the smart contract instance whose function was called */
            public contractID?: (hashgraph.proto.IContractID|null);

            /** the result returned by the function */
            public contractCallResult: Uint8Array;

            /** message In case there was an error during smart contract execution */
            public errorMessage: string;

            /** bloom filter for record */
            public bloom: Uint8Array;

            /** units of gas used to execute contract */
            public gasUsed: Long;

            /** the log info for events returned by the function */
            public logInfo: hashgraph.proto.IContractLoginfo[];

            /**
             * [DEPRECATED] the list of smart contracts that were created by the function call.
             *
             * The created ids will now _also_ be externalized through internal transaction
             * records, where each record has its alias field populated with the new contract's
             * EVM address. (This is needed for contracts created with CREATE2, since
             * there is no longer a simple relationship between the new contract's 0.0.X id
             * and its Solidity address.)
             */
            public createdContractIDs: hashgraph.proto.IContractID[];

            /**
             * The new contract's 20-byte EVM address. Only populated after release 0.23,
             * where each created contract will have its own record. (This is an important
             * point--the field is not <tt>repeated</tt> because there will be a separate
             * child record for each created contract.)
             *
             * Every contract has an EVM address determined by its <tt>shard.realm.num</tt> id.
             * This address is as follows:
             * <ol>
             * <li>The first 4 bytes are the big-endian representation of the shard.</li>
             * <li>The next 8 bytes are the big-endian representation of the realm.</li>
             * <li>The final 8 bytes are the big-endian representation of the number.</li>
             * </ol>
             *
             * Contracts created via CREATE2 have an <b>additional, primary address</b> that is
             * derived from the <a href="https://eips.ethereum.org/EIPS/eip-1014">EIP-1014</a>
             * specification, and does not have a simple relation to a <tt>shard.realm.num</tt> id.
             *
             * (Please do note that CREATE2 contracts can also be referenced by the three-part
             * EVM address described above.)
             */
            public evmAddress?: (google.protobuf.IBytesValue|null);

            /**
             * The amount of gas available for the call, aka the gasLimit.
             *
             * This field should only be populated when the paired TransactionBody in the record stream is not a
             * ContractCreateTransactionBody or a ContractCallTransactionBody.
             */
            public gas: Long;

            /**
             * Number of tinybars sent (the function must be payable if this is nonzero).
             *
             * This field should only be populated when the paired TransactionBody in the record stream is not a
             * ContractCreateTransactionBody or a ContractCallTransactionBody.
             */
            public amount: Long;

            /**
             * The parameters passed into the contract call.
             *
             * This field should only be populated when the paired TransactionBody in the record stream is not a
             * ContractCreateTransactionBody or a ContractCallTransactionBody.
             */
            public functionParameters: Uint8Array;

            /**
             * The account that is the "sender." If not present it is the accountId from the transactionId.
             *
             * This field should only be populated when the paired TransactionBody in the record stream is not a
             * ContractCreateTransactionBody or a ContractCallTransactionBody.
             */
            public senderId?: (hashgraph.proto.IAccountID|null);

            /**
             * Creates a new ContractFunctionResult instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ContractFunctionResult instance
             */
            public static create(properties?: hashgraph.proto.IContractFunctionResult): hashgraph.proto.ContractFunctionResult;

            /**
             * Encodes the specified ContractFunctionResult message. Does not implicitly {@link hashgraph.proto.ContractFunctionResult.verify|verify} messages.
             * @param m ContractFunctionResult message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IContractFunctionResult, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ContractFunctionResult message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ContractFunctionResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ContractFunctionResult;

            /**
             * Gets the default type url for ContractFunctionResult
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ContractCallLocalQuery. */
        interface IContractCallLocalQuery {

            /** standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither). The payment must cover the fees and all of the gas offered. */
            header?: (hashgraph.proto.IQueryHeader|null);

            /** The contract to make a static call against */
            contractID?: (hashgraph.proto.IContractID|null);

            /** The amount of gas to use for the call; all of the gas offered will be used and charged a corresponding fee */
            gas?: (Long|null);

            /** which function to call, and the parameters to pass to the function */
            functionParameters?: (Uint8Array|null);

            /** max number of bytes that the result might include. The run will fail if it would have returned more than this number of bytes. */
            maxResultSize?: (Long|null);

            /**
             * The account that is the "sender." If not present it is the accountId from the transactionId.
             * Typically a different value than specified in the transactionId requires a valid signature
             * over either the hedera transaction or foreign transaction data.
             */
            senderId?: (hashgraph.proto.IAccountID|null);
        }

        /**
         * Call a function of the given smart contract instance, giving it functionParameters as its inputs.
         * This is performed locally on the particular node that the client is communicating with.
         * It cannot change the state of the contract instance (and so, cannot spend anything from the instance's cryptocurrency account).
         * It will not have a consensus timestamp. It cannot generate a record or a receipt. The response will contain the output
         * returned by the function call.  This is useful for calling getter functions, which purely read the state and don't change it.
         * It is faster and cheaper than a normal call, because it is purely local to a single  node.
         *
         * Unlike a ContractCall transaction, the node will consume the entire amount of provided gas in determining
         * the fee for this query.
         */
        class ContractCallLocalQuery implements IContractCallLocalQuery {

            /**
             * Constructs a new ContractCallLocalQuery.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IContractCallLocalQuery);

            /** standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither). The payment must cover the fees and all of the gas offered. */
            public header?: (hashgraph.proto.IQueryHeader|null);

            /** The contract to make a static call against */
            public contractID?: (hashgraph.proto.IContractID|null);

            /** The amount of gas to use for the call; all of the gas offered will be used and charged a corresponding fee */
            public gas: Long;

            /** which function to call, and the parameters to pass to the function */
            public functionParameters: Uint8Array;

            /** max number of bytes that the result might include. The run will fail if it would have returned more than this number of bytes. */
            public maxResultSize: Long;

            /**
             * The account that is the "sender." If not present it is the accountId from the transactionId.
             * Typically a different value than specified in the transactionId requires a valid signature
             * over either the hedera transaction or foreign transaction data.
             */
            public senderId?: (hashgraph.proto.IAccountID|null);

            /**
             * Creates a new ContractCallLocalQuery instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ContractCallLocalQuery instance
             */
            public static create(properties?: hashgraph.proto.IContractCallLocalQuery): hashgraph.proto.ContractCallLocalQuery;

            /**
             * Encodes the specified ContractCallLocalQuery message. Does not implicitly {@link hashgraph.proto.ContractCallLocalQuery.verify|verify} messages.
             * @param m ContractCallLocalQuery message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IContractCallLocalQuery, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ContractCallLocalQuery message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ContractCallLocalQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ContractCallLocalQuery;

            /**
             * Gets the default type url for ContractCallLocalQuery
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ContractCallLocalResponse. */
        interface IContractCallLocalResponse {

            /** standard response from node to client, including the requested fields: cost, or state proof, or both, or neither */
            header?: (hashgraph.proto.IResponseHeader|null);

            /** the value returned by the function (if it completed and didn't fail) */
            functionResult?: (hashgraph.proto.IContractFunctionResult|null);
        }

        /** Response when the client sends the node ContractCallLocalQuery */
        class ContractCallLocalResponse implements IContractCallLocalResponse {

            /**
             * Constructs a new ContractCallLocalResponse.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IContractCallLocalResponse);

            /** standard response from node to client, including the requested fields: cost, or state proof, or both, or neither */
            public header?: (hashgraph.proto.IResponseHeader|null);

            /** the value returned by the function (if it completed and didn't fail) */
            public functionResult?: (hashgraph.proto.IContractFunctionResult|null);

            /**
             * Creates a new ContractCallLocalResponse instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ContractCallLocalResponse instance
             */
            public static create(properties?: hashgraph.proto.IContractCallLocalResponse): hashgraph.proto.ContractCallLocalResponse;

            /**
             * Encodes the specified ContractCallLocalResponse message. Does not implicitly {@link hashgraph.proto.ContractCallLocalResponse.verify|verify} messages.
             * @param m ContractCallLocalResponse message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IContractCallLocalResponse, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ContractCallLocalResponse message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ContractCallLocalResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ContractCallLocalResponse;

            /**
             * Gets the default type url for ContractCallLocalResponse
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ContractGetInfoQuery. */
        interface IContractGetInfoQuery {

            /**
             * standard info sent from client to node, including the signed payment, and what kind of
             * response is requested (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IQueryHeader|null);

            /** the contract for which information is requested */
            contractID?: (hashgraph.proto.IContractID|null);
        }

        /**
         * Get information about a smart contract instance. This includes the account that it uses, the file
         * containing its initcode (if a file was used to initialize the contract), and the time when it will expire.
         */
        class ContractGetInfoQuery implements IContractGetInfoQuery {

            /**
             * Constructs a new ContractGetInfoQuery.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IContractGetInfoQuery);

            /**
             * standard info sent from client to node, including the signed payment, and what kind of
             * response is requested (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IQueryHeader|null);

            /** the contract for which information is requested */
            public contractID?: (hashgraph.proto.IContractID|null);

            /**
             * Creates a new ContractGetInfoQuery instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ContractGetInfoQuery instance
             */
            public static create(properties?: hashgraph.proto.IContractGetInfoQuery): hashgraph.proto.ContractGetInfoQuery;

            /**
             * Encodes the specified ContractGetInfoQuery message. Does not implicitly {@link hashgraph.proto.ContractGetInfoQuery.verify|verify} messages.
             * @param m ContractGetInfoQuery message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IContractGetInfoQuery, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ContractGetInfoQuery message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ContractGetInfoQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ContractGetInfoQuery;

            /**
             * Gets the default type url for ContractGetInfoQuery
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ContractGetInfoResponse. */
        interface IContractGetInfoResponse {

            /**
             * standard response from node to client, including the requested fields: cost, or state proof,
             * or both, or neither
             */
            header?: (hashgraph.proto.IResponseHeader|null);

            /** the information about this contract instance (a state proof can be generated for this) */
            contractInfo?: (hashgraph.proto.ContractGetInfoResponse.IContractInfo|null);
        }

        /** Response when the client sends the node ContractGetInfoQuery */
        class ContractGetInfoResponse implements IContractGetInfoResponse {

            /**
             * Constructs a new ContractGetInfoResponse.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IContractGetInfoResponse);

            /**
             * standard response from node to client, including the requested fields: cost, or state proof,
             * or both, or neither
             */
            public header?: (hashgraph.proto.IResponseHeader|null);

            /** the information about this contract instance (a state proof can be generated for this) */
            public contractInfo?: (hashgraph.proto.ContractGetInfoResponse.IContractInfo|null);

            /**
             * Creates a new ContractGetInfoResponse instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ContractGetInfoResponse instance
             */
            public static create(properties?: hashgraph.proto.IContractGetInfoResponse): hashgraph.proto.ContractGetInfoResponse;

            /**
             * Encodes the specified ContractGetInfoResponse message. Does not implicitly {@link hashgraph.proto.ContractGetInfoResponse.verify|verify} messages.
             * @param m ContractGetInfoResponse message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IContractGetInfoResponse, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ContractGetInfoResponse message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ContractGetInfoResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ContractGetInfoResponse;

            /**
             * Gets the default type url for ContractGetInfoResponse
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        namespace ContractGetInfoResponse {

            /** Properties of a ContractInfo. */
            interface IContractInfo {

                /** ID of the contract instance, in the format used in transactions */
                contractID?: (hashgraph.proto.IContractID|null);

                /**
                 * ID of the cryptocurrency account owned by the contract instance, in the format used in
                 * transactions
                 */
                accountID?: (hashgraph.proto.IAccountID|null);

                /**
                 * ID of both the contract instance and the cryptocurrency account owned by the contract
                 * instance, in the format used by Solidity
                 */
                contractAccountID?: (string|null);

                /**
                 * the state of the instance and its fields can be modified arbitrarily if this key signs a
                 * transaction to modify it. If this is null, then such modifications are not possible, and
                 * there is no administrator that can override the normal operation of this smart contract
                 * instance. Note that if it is created with no admin keys, then there is no administrator
                 * to authorize changing the admin keys, so there can never be any admin keys for that
                 * instance.
                 */
                adminKey?: (hashgraph.proto.IKey|null);

                /** the current time at which this contract instance (and its account) is set to expire */
                expirationTime?: (hashgraph.proto.ITimestamp|null);

                /**
                 * the expiration time will extend every this many seconds. If there are insufficient funds,
                 * then it extends as long as possible. If the account is empty when it expires, then it is
                 * deleted.
                 */
                autoRenewPeriod?: (hashgraph.proto.IDuration|null);

                /**
                 * number of bytes of storage being used by this instance (which affects the cost to extend
                 * the expiration time)
                 */
                storage?: (Long|null);

                /** the memo associated with the contract (max 100 bytes) */
                memo?: (string|null);

                /** The current balance, in tinybars */
                balance?: (Long|null);

                /** Whether the contract has been deleted */
                deleted?: (boolean|null);

                /**
                 * [DEPRECATED] The metadata of the tokens associated to the contract. This field was
                 * deprecated by <a href="https://hips.hedera.com/hip/hip-367">HIP-367</a>, which allowed
                 * an account to be associated to an unlimited number of tokens. This scale makes it more
                 * efficient for users to consult mirror nodes to review their token associations.
                 */
                tokenRelationships?: (hashgraph.proto.ITokenRelationship[]|null);

                /** The ledger ID the response was returned from; please see <a href="https://github.com/hashgraph/hedera-improvement-proposal/blob/master/HIP/hip-198.md">HIP-198</a> for the network-specific IDs. */
                ledgerId?: (Uint8Array|null);

                /**
                 * ID of the an account to charge for auto-renewal of this contract. If not set, or set to an account with zero hbar
                 * balance, the contract's own hbar balance will be used to cover auto-renewal fees.
                 */
                autoRenewAccountId?: (hashgraph.proto.IAccountID|null);

                /** The maximum number of tokens that a contract can be implicitly associated with. */
                maxAutomaticTokenAssociations?: (number|null);

                /** Staking metadata for this contract. */
                stakingInfo?: (hashgraph.proto.IStakingInfo|null);
            }

            /** Represents a ContractInfo. */
            class ContractInfo implements IContractInfo {

                /**
                 * Constructs a new ContractInfo.
                 * @param [p] Properties to set
                 */
                constructor(p?: hashgraph.proto.ContractGetInfoResponse.IContractInfo);

                /** ID of the contract instance, in the format used in transactions */
                public contractID?: (hashgraph.proto.IContractID|null);

                /**
                 * ID of the cryptocurrency account owned by the contract instance, in the format used in
                 * transactions
                 */
                public accountID?: (hashgraph.proto.IAccountID|null);

                /**
                 * ID of both the contract instance and the cryptocurrency account owned by the contract
                 * instance, in the format used by Solidity
                 */
                public contractAccountID: string;

                /**
                 * the state of the instance and its fields can be modified arbitrarily if this key signs a
                 * transaction to modify it. If this is null, then such modifications are not possible, and
                 * there is no administrator that can override the normal operation of this smart contract
                 * instance. Note that if it is created with no admin keys, then there is no administrator
                 * to authorize changing the admin keys, so there can never be any admin keys for that
                 * instance.
                 */
                public adminKey?: (hashgraph.proto.IKey|null);

                /** the current time at which this contract instance (and its account) is set to expire */
                public expirationTime?: (hashgraph.proto.ITimestamp|null);

                /**
                 * the expiration time will extend every this many seconds. If there are insufficient funds,
                 * then it extends as long as possible. If the account is empty when it expires, then it is
                 * deleted.
                 */
                public autoRenewPeriod?: (hashgraph.proto.IDuration|null);

                /**
                 * number of bytes of storage being used by this instance (which affects the cost to extend
                 * the expiration time)
                 */
                public storage: Long;

                /** the memo associated with the contract (max 100 bytes) */
                public memo: string;

                /** The current balance, in tinybars */
                public balance: Long;

                /** Whether the contract has been deleted */
                public deleted: boolean;

                /**
                 * [DEPRECATED] The metadata of the tokens associated to the contract. This field was
                 * deprecated by <a href="https://hips.hedera.com/hip/hip-367">HIP-367</a>, which allowed
                 * an account to be associated to an unlimited number of tokens. This scale makes it more
                 * efficient for users to consult mirror nodes to review their token associations.
                 */
                public tokenRelationships: hashgraph.proto.ITokenRelationship[];

                /** The ledger ID the response was returned from; please see <a href="https://github.com/hashgraph/hedera-improvement-proposal/blob/master/HIP/hip-198.md">HIP-198</a> for the network-specific IDs. */
                public ledgerId: Uint8Array;

                /**
                 * ID of the an account to charge for auto-renewal of this contract. If not set, or set to an account with zero hbar
                 * balance, the contract's own hbar balance will be used to cover auto-renewal fees.
                 */
                public autoRenewAccountId?: (hashgraph.proto.IAccountID|null);

                /** The maximum number of tokens that a contract can be implicitly associated with. */
                public maxAutomaticTokenAssociations: number;

                /** Staking metadata for this contract. */
                public stakingInfo?: (hashgraph.proto.IStakingInfo|null);

                /**
                 * Creates a new ContractInfo instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns ContractInfo instance
                 */
                public static create(properties?: hashgraph.proto.ContractGetInfoResponse.IContractInfo): hashgraph.proto.ContractGetInfoResponse.ContractInfo;

                /**
                 * Encodes the specified ContractInfo message. Does not implicitly {@link hashgraph.proto.ContractGetInfoResponse.ContractInfo.verify|verify} messages.
                 * @param m ContractInfo message or plain object to encode
                 * @param [w] Writer to encode to
                 * @returns Writer
                 */
                public static encode(m: hashgraph.proto.ContractGetInfoResponse.IContractInfo, w?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a ContractInfo message from the specified reader or buffer.
                 * @param r Reader or buffer to decode from
                 * @param [l] Message length if known beforehand
                 * @returns ContractInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ContractGetInfoResponse.ContractInfo;

                /**
                 * Gets the default type url for ContractInfo
                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns The default type url
                 */
                public static getTypeUrl(typeUrlPrefix?: string): string;
            }
        }

        /** Properties of a ContractGetBytecodeQuery. */
        interface IContractGetBytecodeQuery {

            /**
             * standard info sent from client to node, including the signed payment, and what kind of
             * response is requested (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IQueryHeader|null);

            /** the contract for which information is requested */
            contractID?: (hashgraph.proto.IContractID|null);
        }

        /** Get the runtime bytecode for a smart contract instance */
        class ContractGetBytecodeQuery implements IContractGetBytecodeQuery {

            /**
             * Constructs a new ContractGetBytecodeQuery.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IContractGetBytecodeQuery);

            /**
             * standard info sent from client to node, including the signed payment, and what kind of
             * response is requested (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IQueryHeader|null);

            /** the contract for which information is requested */
            public contractID?: (hashgraph.proto.IContractID|null);

            /**
             * Creates a new ContractGetBytecodeQuery instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ContractGetBytecodeQuery instance
             */
            public static create(properties?: hashgraph.proto.IContractGetBytecodeQuery): hashgraph.proto.ContractGetBytecodeQuery;

            /**
             * Encodes the specified ContractGetBytecodeQuery message. Does not implicitly {@link hashgraph.proto.ContractGetBytecodeQuery.verify|verify} messages.
             * @param m ContractGetBytecodeQuery message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IContractGetBytecodeQuery, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ContractGetBytecodeQuery message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ContractGetBytecodeQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ContractGetBytecodeQuery;

            /**
             * Gets the default type url for ContractGetBytecodeQuery
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ContractGetBytecodeResponse. */
        interface IContractGetBytecodeResponse {

            /**
             * standard response from node to client, including the requested fields: cost, or state proof,
             * or both, or neither
             */
            header?: (hashgraph.proto.IResponseHeader|null);

            /** the runtime bytecode of the contract */
            bytecode?: (Uint8Array|null);
        }

        /** Response when the client sends the node ContractGetBytecodeQuery */
        class ContractGetBytecodeResponse implements IContractGetBytecodeResponse {

            /**
             * Constructs a new ContractGetBytecodeResponse.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IContractGetBytecodeResponse);

            /**
             * standard response from node to client, including the requested fields: cost, or state proof,
             * or both, or neither
             */
            public header?: (hashgraph.proto.IResponseHeader|null);

            /** the runtime bytecode of the contract */
            public bytecode: Uint8Array;

            /**
             * Creates a new ContractGetBytecodeResponse instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ContractGetBytecodeResponse instance
             */
            public static create(properties?: hashgraph.proto.IContractGetBytecodeResponse): hashgraph.proto.ContractGetBytecodeResponse;

            /**
             * Encodes the specified ContractGetBytecodeResponse message. Does not implicitly {@link hashgraph.proto.ContractGetBytecodeResponse.verify|verify} messages.
             * @param m ContractGetBytecodeResponse message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IContractGetBytecodeResponse, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ContractGetBytecodeResponse message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ContractGetBytecodeResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ContractGetBytecodeResponse;

            /**
             * Gets the default type url for ContractGetBytecodeResponse
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ContractGetRecordsQuery. */
        interface IContractGetRecordsQuery {

            /** Standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither). */
            header?: (hashgraph.proto.IQueryHeader|null);

            /** The smart contract instance for which the records should be retrieved */
            contractID?: (hashgraph.proto.IContractID|null);
        }

        /** Before v0.9.0, requested records of all transactions against the given contract in the last 25 hours. */
        class ContractGetRecordsQuery implements IContractGetRecordsQuery {

            /**
             * Constructs a new ContractGetRecordsQuery.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IContractGetRecordsQuery);

            /** Standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither). */
            public header?: (hashgraph.proto.IQueryHeader|null);

            /** The smart contract instance for which the records should be retrieved */
            public contractID?: (hashgraph.proto.IContractID|null);

            /**
             * Creates a new ContractGetRecordsQuery instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ContractGetRecordsQuery instance
             */
            public static create(properties?: hashgraph.proto.IContractGetRecordsQuery): hashgraph.proto.ContractGetRecordsQuery;

            /**
             * Encodes the specified ContractGetRecordsQuery message. Does not implicitly {@link hashgraph.proto.ContractGetRecordsQuery.verify|verify} messages.
             * @param m ContractGetRecordsQuery message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IContractGetRecordsQuery, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ContractGetRecordsQuery message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ContractGetRecordsQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ContractGetRecordsQuery;

            /**
             * Gets the default type url for ContractGetRecordsQuery
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ContractGetRecordsResponse. */
        interface IContractGetRecordsResponse {

            /** Standard response from node to client, including the requested fields: cost, or state proof, or both, or neither */
            header?: (hashgraph.proto.IResponseHeader|null);

            /** The smart contract instance that this record is for */
            contractID?: (hashgraph.proto.IContractID|null);

            /** List of records, each with contractCreateResult or contractCallResult as its body */
            records?: (hashgraph.proto.ITransactionRecord[]|null);
        }

        /** Before v0.9.0, returned records of all transactions against the given contract in the last 25 hours. */
        class ContractGetRecordsResponse implements IContractGetRecordsResponse {

            /**
             * Constructs a new ContractGetRecordsResponse.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IContractGetRecordsResponse);

            /** Standard response from node to client, including the requested fields: cost, or state proof, or both, or neither */
            public header?: (hashgraph.proto.IResponseHeader|null);

            /** The smart contract instance that this record is for */
            public contractID?: (hashgraph.proto.IContractID|null);

            /** List of records, each with contractCreateResult or contractCallResult as its body */
            public records: hashgraph.proto.ITransactionRecord[];

            /**
             * Creates a new ContractGetRecordsResponse instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ContractGetRecordsResponse instance
             */
            public static create(properties?: hashgraph.proto.IContractGetRecordsResponse): hashgraph.proto.ContractGetRecordsResponse;

            /**
             * Encodes the specified ContractGetRecordsResponse message. Does not implicitly {@link hashgraph.proto.ContractGetRecordsResponse.verify|verify} messages.
             * @param m ContractGetRecordsResponse message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IContractGetRecordsResponse, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ContractGetRecordsResponse message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ContractGetRecordsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ContractGetRecordsResponse;

            /**
             * Gets the default type url for ContractGetRecordsResponse
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TransactionRecord. */
        interface ITransactionRecord {

            /**
             * The status (reach consensus, or failed, or is unknown) and the ID of any new
             * account/file/instance created.
             */
            receipt?: (hashgraph.proto.ITransactionReceipt|null);

            /**
             * The hash of the Transaction that executed (not the hash of any Transaction that failed for
             * having a duplicate TransactionID)
             */
            transactionHash?: (Uint8Array|null);

            /** The consensus timestamp (or null if didn't reach consensus yet) */
            consensusTimestamp?: (hashgraph.proto.ITimestamp|null);

            /** The ID of the transaction this record represents */
            transactionID?: (hashgraph.proto.ITransactionID|null);

            /** The memo that was submitted as part of the transaction (max 100 bytes) */
            memo?: (string|null);

            /**
             * The actual transaction fee charged, not the original transactionFee value from
             * TransactionBody
             */
            transactionFee?: (Long|null);

            /**
             * Record of the value returned by the smart contract function (if it completed and didn't
             * fail) from ContractCallTransaction
             */
            contractCallResult?: (hashgraph.proto.IContractFunctionResult|null);

            /**
             * Record of the value returned by the smart contract constructor (if it completed and
             * didn't fail) from ContractCreateTransaction
             */
            contractCreateResult?: (hashgraph.proto.IContractFunctionResult|null);

            /**
             * All hbar transfers as a result of this transaction, such as fees, or transfers performed by
             * the transaction, or by a smart contract it calls, or by the creation of threshold records
             * that it triggers.
             */
            transferList?: (hashgraph.proto.ITransferList|null);

            /** All Token transfers as a result of this transaction */
            tokenTransferLists?: (hashgraph.proto.ITokenTransferList[]|null);

            /** Reference to the scheduled transaction ID that this transaction record represent */
            scheduleRef?: (hashgraph.proto.IScheduleID|null);

            /**
             * All custom fees that were assessed during a CryptoTransfer, and must be paid if the
             * transaction status resolved to SUCCESS
             */
            assessedCustomFees?: (hashgraph.proto.IAssessedCustomFee[]|null);

            /** All token associations implicitly created while handling this transaction */
            automaticTokenAssociations?: (hashgraph.proto.ITokenAssociation[]|null);

            /**
             * In the record of an internal transaction, the consensus timestamp of the user
             * transaction that spawned it.
             */
            parentConsensusTimestamp?: (hashgraph.proto.ITimestamp|null);

            /**
             * In the record of a CryptoCreate transaction triggered by a user transaction with a
             * (previously unused) alias, the new account's alias.
             */
            alias?: (Uint8Array|null);

            /**
             * The keccak256 hash of the ethereumData. This field will only be populated for
             * EthereumTransaction.
             */
            ethereumHash?: (Uint8Array|null);

            /** List of accounts with the corresponding staking rewards paid as a result of a transaction. */
            paidStakingRewards?: (hashgraph.proto.IAccountAmount[]|null);

            /** In the record of a UtilPrng transaction with no output range, a pseudorandom 384-bit string. */
            prngBytes?: (Uint8Array|null);

            /** In the record of a PRNG transaction with an output range, the output of a PRNG whose input was a 384-bit string. */
            prngNumber?: (number|null);

            /**
             * The new default EVM address of the account created by this transaction.
             * This field is populated only when the EVM address is not specified in the related transaction body.
             */
            evmAddress?: (Uint8Array|null);
        }

        /** Response when the client sends the node TransactionGetRecordResponse */
        class TransactionRecord implements ITransactionRecord {

            /**
             * Constructs a new TransactionRecord.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITransactionRecord);

            /**
             * The status (reach consensus, or failed, or is unknown) and the ID of any new
             * account/file/instance created.
             */
            public receipt?: (hashgraph.proto.ITransactionReceipt|null);

            /**
             * The hash of the Transaction that executed (not the hash of any Transaction that failed for
             * having a duplicate TransactionID)
             */
            public transactionHash: Uint8Array;

            /** The consensus timestamp (or null if didn't reach consensus yet) */
            public consensusTimestamp?: (hashgraph.proto.ITimestamp|null);

            /** The ID of the transaction this record represents */
            public transactionID?: (hashgraph.proto.ITransactionID|null);

            /** The memo that was submitted as part of the transaction (max 100 bytes) */
            public memo: string;

            /**
             * The actual transaction fee charged, not the original transactionFee value from
             * TransactionBody
             */
            public transactionFee: Long;

            /**
             * Record of the value returned by the smart contract function (if it completed and didn't
             * fail) from ContractCallTransaction
             */
            public contractCallResult?: (hashgraph.proto.IContractFunctionResult|null);

            /**
             * Record of the value returned by the smart contract constructor (if it completed and
             * didn't fail) from ContractCreateTransaction
             */
            public contractCreateResult?: (hashgraph.proto.IContractFunctionResult|null);

            /**
             * All hbar transfers as a result of this transaction, such as fees, or transfers performed by
             * the transaction, or by a smart contract it calls, or by the creation of threshold records
             * that it triggers.
             */
            public transferList?: (hashgraph.proto.ITransferList|null);

            /** All Token transfers as a result of this transaction */
            public tokenTransferLists: hashgraph.proto.ITokenTransferList[];

            /** Reference to the scheduled transaction ID that this transaction record represent */
            public scheduleRef?: (hashgraph.proto.IScheduleID|null);

            /**
             * All custom fees that were assessed during a CryptoTransfer, and must be paid if the
             * transaction status resolved to SUCCESS
             */
            public assessedCustomFees: hashgraph.proto.IAssessedCustomFee[];

            /** All token associations implicitly created while handling this transaction */
            public automaticTokenAssociations: hashgraph.proto.ITokenAssociation[];

            /**
             * In the record of an internal transaction, the consensus timestamp of the user
             * transaction that spawned it.
             */
            public parentConsensusTimestamp?: (hashgraph.proto.ITimestamp|null);

            /**
             * In the record of a CryptoCreate transaction triggered by a user transaction with a
             * (previously unused) alias, the new account's alias.
             */
            public alias: Uint8Array;

            /**
             * The keccak256 hash of the ethereumData. This field will only be populated for
             * EthereumTransaction.
             */
            public ethereumHash: Uint8Array;

            /** List of accounts with the corresponding staking rewards paid as a result of a transaction. */
            public paidStakingRewards: hashgraph.proto.IAccountAmount[];

            /** In the record of a UtilPrng transaction with no output range, a pseudorandom 384-bit string. */
            public prngBytes?: (Uint8Array|null);

            /** In the record of a PRNG transaction with an output range, the output of a PRNG whose input was a 384-bit string. */
            public prngNumber?: (number|null);

            /**
             * The new default EVM address of the account created by this transaction.
             * This field is populated only when the EVM address is not specified in the related transaction body.
             */
            public evmAddress: Uint8Array;

            /** TransactionRecord body. */
            public body?: ("contractCallResult"|"contractCreateResult");

            /** TransactionRecord entropy. */
            public entropy?: ("prngBytes"|"prngNumber");

            /**
             * Creates a new TransactionRecord instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TransactionRecord instance
             */
            public static create(properties?: hashgraph.proto.ITransactionRecord): hashgraph.proto.TransactionRecord;

            /**
             * Encodes the specified TransactionRecord message. Does not implicitly {@link hashgraph.proto.TransactionRecord.verify|verify} messages.
             * @param m TransactionRecord message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITransactionRecord, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TransactionRecord message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TransactionRecord
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TransactionRecord;

            /**
             * Gets the default type url for TransactionRecord
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TransactionReceipt. */
        interface ITransactionReceipt {

            /**
             * The consensus status of the transaction; is UNKNOWN if consensus has not been reached, or if
             * the associated transaction did not have a valid payer signature
             */
            status?: (hashgraph.proto.ResponseCodeEnum|null);

            /** In the receipt of a CryptoCreate, the id of the newly created account */
            accountID?: (hashgraph.proto.IAccountID|null);

            /** In the receipt of a FileCreate, the id of the newly created file */
            fileID?: (hashgraph.proto.IFileID|null);

            /** In the receipt of a ContractCreate, the id of the newly created contract */
            contractID?: (hashgraph.proto.IContractID|null);

            /** The exchange rates in effect when the transaction reached consensus */
            exchangeRate?: (hashgraph.proto.IExchangeRateSet|null);

            /** In the receipt of a ConsensusCreateTopic, the id of the newly created topic. */
            topicID?: (hashgraph.proto.ITopicID|null);

            /**
             * In the receipt of a ConsensusSubmitMessage, the new sequence number of the topic that
             * received the message
             */
            topicSequenceNumber?: (Long|null);

            /**
             * In the receipt of a ConsensusSubmitMessage, the new running hash of the topic that received
             * the message.  This 48-byte field is the output of a particular SHA-384 digest whose input
             * data are determined by the value of the topicRunningHashVersion below. The bytes of each
             * uint64 or uint32 are to be in Big-Endian format.
             *
             * IF the topicRunningHashVersion is '0' or '1', then the input data to the SHA-384 digest are,
             * in order:
             * ---
             * 1. The previous running hash of the topic (48 bytes)
             * 2. The topic's shard (8 bytes)
             * 3. The topic's realm (8 bytes)
             * 4. The topic's number (8 bytes)
             * 5. The number of seconds since the epoch before the ConsensusSubmitMessage reached
             * consensus (8 bytes)
             * 6. The number of nanoseconds since 5. before the ConsensusSubmitMessage reached
             * consensus (4 bytes)
             * 7. The topicSequenceNumber from above (8 bytes)
             * 8. The message bytes from the ConsensusSubmitMessage (variable).
             *
             * IF the topicRunningHashVersion is '2', then the input data to the SHA-384 digest are, in
             * order:
             * ---
             * 1. The previous running hash of the topic (48 bytes)
             * 2. The topicRunningHashVersion below (8 bytes)
             * 3. The topic's shard (8 bytes)
             * 4. The topic's realm (8 bytes)
             * 5. The topic's number (8 bytes)
             * 6. The number of seconds since the epoch before the ConsensusSubmitMessage reached
             * consensus (8 bytes)
             * 7. The number of nanoseconds since 6. before the ConsensusSubmitMessage reached
             * consensus (4 bytes)
             * 8. The topicSequenceNumber from above (8 bytes)
             * 9. The output of the SHA-384 digest of the message bytes from the
             * consensusSubmitMessage (48 bytes)
             *
             * Otherwise, IF the topicRunningHashVersion is '3', then the input data to the SHA-384 digest
             * are, in order:
             * ---
             * 1. The previous running hash of the topic (48 bytes)
             * 2. The topicRunningHashVersion below (8 bytes)
             * 3. The payer account's shard (8 bytes)
             * 4. The payer account's realm (8 bytes)
             * 5. The payer account's number (8 bytes)
             * 6. The topic's shard (8 bytes)
             * 7. The topic's realm (8 bytes)
             * 8. The topic's number (8 bytes)
             * 9. The number of seconds since the epoch before the ConsensusSubmitMessage reached
             * consensus (8 bytes)
             * 10. The number of nanoseconds since 9. before the ConsensusSubmitMessage reached
             * consensus (4 bytes)
             * 11. The topicSequenceNumber from above (8 bytes)
             * 12. The output of the SHA-384 digest of the message bytes from the
             * consensusSubmitMessage (48 bytes)
             */
            topicRunningHash?: (Uint8Array|null);

            /**
             * In the receipt of a ConsensusSubmitMessage, the version of the SHA-384 digest used to update
             * the running hash.
             */
            topicRunningHashVersion?: (Long|null);

            /** In the receipt of a CreateToken, the id of the newly created token */
            tokenID?: (hashgraph.proto.ITokenID|null);

            /**
             * In the receipt of TokenMint, TokenWipe, TokenBurn, For fungible tokens - the current total
             * supply of this token. For non fungible tokens - the total number of NFTs issued for a given
             * tokenID
             */
            newTotalSupply?: (Long|null);

            /** In the receipt of a ScheduleCreate, the id of the newly created Scheduled Entity */
            scheduleID?: (hashgraph.proto.IScheduleID|null);

            /**
             * In the receipt of a ScheduleCreate or ScheduleSign that resolves to SUCCESS, the
             * TransactionID that should be used to query for the receipt or record of the relevant
             * scheduled transaction
             */
            scheduledTransactionID?: (hashgraph.proto.ITransactionID|null);

            /**
             * In the receipt of a TokenMint for tokens of type NON_FUNGIBLE_UNIQUE, the serial numbers of
             * the newly created NFTs
             */
            serialNumbers?: (Long[]|null);
        }

        /**
         * The summary of a transaction's result so far. If the transaction has not reached consensus, this
         * result will be necessarily incomplete.
         */
        class TransactionReceipt implements ITransactionReceipt {

            /**
             * Constructs a new TransactionReceipt.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITransactionReceipt);

            /**
             * The consensus status of the transaction; is UNKNOWN if consensus has not been reached, or if
             * the associated transaction did not have a valid payer signature
             */
            public status: hashgraph.proto.ResponseCodeEnum;

            /** In the receipt of a CryptoCreate, the id of the newly created account */
            public accountID?: (hashgraph.proto.IAccountID|null);

            /** In the receipt of a FileCreate, the id of the newly created file */
            public fileID?: (hashgraph.proto.IFileID|null);

            /** In the receipt of a ContractCreate, the id of the newly created contract */
            public contractID?: (hashgraph.proto.IContractID|null);

            /** The exchange rates in effect when the transaction reached consensus */
            public exchangeRate?: (hashgraph.proto.IExchangeRateSet|null);

            /** In the receipt of a ConsensusCreateTopic, the id of the newly created topic. */
            public topicID?: (hashgraph.proto.ITopicID|null);

            /**
             * In the receipt of a ConsensusSubmitMessage, the new sequence number of the topic that
             * received the message
             */
            public topicSequenceNumber: Long;

            /**
             * In the receipt of a ConsensusSubmitMessage, the new running hash of the topic that received
             * the message.  This 48-byte field is the output of a particular SHA-384 digest whose input
             * data are determined by the value of the topicRunningHashVersion below. The bytes of each
             * uint64 or uint32 are to be in Big-Endian format.
             *
             * IF the topicRunningHashVersion is '0' or '1', then the input data to the SHA-384 digest are,
             * in order:
             * ---
             * 1. The previous running hash of the topic (48 bytes)
             * 2. The topic's shard (8 bytes)
             * 3. The topic's realm (8 bytes)
             * 4. The topic's number (8 bytes)
             * 5. The number of seconds since the epoch before the ConsensusSubmitMessage reached
             * consensus (8 bytes)
             * 6. The number of nanoseconds since 5. before the ConsensusSubmitMessage reached
             * consensus (4 bytes)
             * 7. The topicSequenceNumber from above (8 bytes)
             * 8. The message bytes from the ConsensusSubmitMessage (variable).
             *
             * IF the topicRunningHashVersion is '2', then the input data to the SHA-384 digest are, in
             * order:
             * ---
             * 1. The previous running hash of the topic (48 bytes)
             * 2. The topicRunningHashVersion below (8 bytes)
             * 3. The topic's shard (8 bytes)
             * 4. The topic's realm (8 bytes)
             * 5. The topic's number (8 bytes)
             * 6. The number of seconds since the epoch before the ConsensusSubmitMessage reached
             * consensus (8 bytes)
             * 7. The number of nanoseconds since 6. before the ConsensusSubmitMessage reached
             * consensus (4 bytes)
             * 8. The topicSequenceNumber from above (8 bytes)
             * 9. The output of the SHA-384 digest of the message bytes from the
             * consensusSubmitMessage (48 bytes)
             *
             * Otherwise, IF the topicRunningHashVersion is '3', then the input data to the SHA-384 digest
             * are, in order:
             * ---
             * 1. The previous running hash of the topic (48 bytes)
             * 2. The topicRunningHashVersion below (8 bytes)
             * 3. The payer account's shard (8 bytes)
             * 4. The payer account's realm (8 bytes)
             * 5. The payer account's number (8 bytes)
             * 6. The topic's shard (8 bytes)
             * 7. The topic's realm (8 bytes)
             * 8. The topic's number (8 bytes)
             * 9. The number of seconds since the epoch before the ConsensusSubmitMessage reached
             * consensus (8 bytes)
             * 10. The number of nanoseconds since 9. before the ConsensusSubmitMessage reached
             * consensus (4 bytes)
             * 11. The topicSequenceNumber from above (8 bytes)
             * 12. The output of the SHA-384 digest of the message bytes from the
             * consensusSubmitMessage (48 bytes)
             */
            public topicRunningHash: Uint8Array;

            /**
             * In the receipt of a ConsensusSubmitMessage, the version of the SHA-384 digest used to update
             * the running hash.
             */
            public topicRunningHashVersion: Long;

            /** In the receipt of a CreateToken, the id of the newly created token */
            public tokenID?: (hashgraph.proto.ITokenID|null);

            /**
             * In the receipt of TokenMint, TokenWipe, TokenBurn, For fungible tokens - the current total
             * supply of this token. For non fungible tokens - the total number of NFTs issued for a given
             * tokenID
             */
            public newTotalSupply: Long;

            /** In the receipt of a ScheduleCreate, the id of the newly created Scheduled Entity */
            public scheduleID?: (hashgraph.proto.IScheduleID|null);

            /**
             * In the receipt of a ScheduleCreate or ScheduleSign that resolves to SUCCESS, the
             * TransactionID that should be used to query for the receipt or record of the relevant
             * scheduled transaction
             */
            public scheduledTransactionID?: (hashgraph.proto.ITransactionID|null);

            /**
             * In the receipt of a TokenMint for tokens of type NON_FUNGIBLE_UNIQUE, the serial numbers of
             * the newly created NFTs
             */
            public serialNumbers: Long[];

            /**
             * Creates a new TransactionReceipt instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TransactionReceipt instance
             */
            public static create(properties?: hashgraph.proto.ITransactionReceipt): hashgraph.proto.TransactionReceipt;

            /**
             * Encodes the specified TransactionReceipt message. Does not implicitly {@link hashgraph.proto.TransactionReceipt.verify|verify} messages.
             * @param m TransactionReceipt message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITransactionReceipt, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TransactionReceipt message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TransactionReceipt
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TransactionReceipt;

            /**
             * Gets the default type url for TransactionReceipt
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of an ExchangeRate. */
        interface IExchangeRate {

            /** Denominator in calculation of exchange rate between hbar and cents */
            hbarEquiv?: (number|null);

            /** Numerator in calculation of exchange rate between hbar and cents */
            centEquiv?: (number|null);

            /** Expiration time in seconds for this exchange rate */
            expirationTime?: (hashgraph.proto.ITimestampSeconds|null);
        }

        /**
         * An exchange rate between hbar and cents (USD) and the time at which the exchange rate will
         * expire, and be superseded by a new exchange rate.
         */
        class ExchangeRate implements IExchangeRate {

            /**
             * Constructs a new ExchangeRate.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IExchangeRate);

            /** Denominator in calculation of exchange rate between hbar and cents */
            public hbarEquiv: number;

            /** Numerator in calculation of exchange rate between hbar and cents */
            public centEquiv: number;

            /** Expiration time in seconds for this exchange rate */
            public expirationTime?: (hashgraph.proto.ITimestampSeconds|null);

            /**
             * Creates a new ExchangeRate instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ExchangeRate instance
             */
            public static create(properties?: hashgraph.proto.IExchangeRate): hashgraph.proto.ExchangeRate;

            /**
             * Encodes the specified ExchangeRate message. Does not implicitly {@link hashgraph.proto.ExchangeRate.verify|verify} messages.
             * @param m ExchangeRate message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IExchangeRate, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an ExchangeRate message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ExchangeRate
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ExchangeRate;

            /**
             * Gets the default type url for ExchangeRate
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of an ExchangeRateSet. */
        interface IExchangeRateSet {

            /** Current exchange rate */
            currentRate?: (hashgraph.proto.IExchangeRate|null);

            /** Next exchange rate which will take effect when current rate expires */
            nextRate?: (hashgraph.proto.IExchangeRate|null);
        }

        /** Two sets of exchange rates */
        class ExchangeRateSet implements IExchangeRateSet {

            /**
             * Constructs a new ExchangeRateSet.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IExchangeRateSet);

            /** Current exchange rate */
            public currentRate?: (hashgraph.proto.IExchangeRate|null);

            /** Next exchange rate which will take effect when current rate expires */
            public nextRate?: (hashgraph.proto.IExchangeRate|null);

            /**
             * Creates a new ExchangeRateSet instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ExchangeRateSet instance
             */
            public static create(properties?: hashgraph.proto.IExchangeRateSet): hashgraph.proto.ExchangeRateSet;

            /**
             * Encodes the specified ExchangeRateSet message. Does not implicitly {@link hashgraph.proto.ExchangeRateSet.verify|verify} messages.
             * @param m ExchangeRateSet message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IExchangeRateSet, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an ExchangeRateSet message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ExchangeRateSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ExchangeRateSet;

            /**
             * Gets the default type url for ExchangeRateSet
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a CryptoGetAccountBalanceQuery. */
        interface ICryptoGetAccountBalanceQuery {

            /**
             * Standard info sent from client to node, including the signed payment, and what kind of
             * response is requested (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IQueryHeader|null);

            /** The account ID for which information is requested */
            accountID?: (hashgraph.proto.IAccountID|null);

            /** The account ID for which information is requested */
            contractID?: (hashgraph.proto.IContractID|null);
        }

        /**
         * Get the balance of a cryptocurrency account. This returns only the balance, so it is a smaller
         * reply than CryptoGetInfo, which returns the balance plus additional information.
         */
        class CryptoGetAccountBalanceQuery implements ICryptoGetAccountBalanceQuery {

            /**
             * Constructs a new CryptoGetAccountBalanceQuery.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ICryptoGetAccountBalanceQuery);

            /**
             * Standard info sent from client to node, including the signed payment, and what kind of
             * response is requested (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IQueryHeader|null);

            /** * The account ID for which information is requested */
            public accountID?: (hashgraph.proto.IAccountID|null);

            /** * The account ID for which information is requested */
            public contractID?: (hashgraph.proto.IContractID|null);

            /** CryptoGetAccountBalanceQuery balanceSource. */
            public balanceSource?: ("accountID"|"contractID");

            /**
             * Creates a new CryptoGetAccountBalanceQuery instance using the specified properties.
             * @param [properties] Properties to set
             * @returns CryptoGetAccountBalanceQuery instance
             */
            public static create(properties?: hashgraph.proto.ICryptoGetAccountBalanceQuery): hashgraph.proto.CryptoGetAccountBalanceQuery;

            /**
             * Encodes the specified CryptoGetAccountBalanceQuery message. Does not implicitly {@link hashgraph.proto.CryptoGetAccountBalanceQuery.verify|verify} messages.
             * @param m CryptoGetAccountBalanceQuery message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ICryptoGetAccountBalanceQuery, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a CryptoGetAccountBalanceQuery message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns CryptoGetAccountBalanceQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.CryptoGetAccountBalanceQuery;

            /**
             * Gets the default type url for CryptoGetAccountBalanceQuery
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a CryptoGetAccountBalanceResponse. */
        interface ICryptoGetAccountBalanceResponse {

            /**
             * Standard response from node to client, including the requested fields: cost, or state proof,
             * or both, or neither.
             */
            header?: (hashgraph.proto.IResponseHeader|null);

            /**
             * The account ID that is being described (this is useful with state proofs, for proving to a
             * third party)
             */
            accountID?: (hashgraph.proto.IAccountID|null);

            /** The current balance, in tinybars. */
            balance?: (Long|null);

            /**
             * [DEPRECATED] The balances of the tokens associated to the account. This field was
             * deprecated by <a href="https://hips.hedera.com/hip/hip-367">HIP-367</a>, which allowed
             * an account to be associated to an unlimited number of tokens. This scale makes it more
             * efficient for users to consult mirror nodes to review their token balances.
             */
            tokenBalances?: (hashgraph.proto.ITokenBalance[]|null);
        }

        /** Response when the client sends the node CryptoGetAccountBalanceQuery */
        class CryptoGetAccountBalanceResponse implements ICryptoGetAccountBalanceResponse {

            /**
             * Constructs a new CryptoGetAccountBalanceResponse.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ICryptoGetAccountBalanceResponse);

            /**
             * Standard response from node to client, including the requested fields: cost, or state proof,
             * or both, or neither.
             */
            public header?: (hashgraph.proto.IResponseHeader|null);

            /**
             * The account ID that is being described (this is useful with state proofs, for proving to a
             * third party)
             */
            public accountID?: (hashgraph.proto.IAccountID|null);

            /** The current balance, in tinybars. */
            public balance: Long;

            /**
             * [DEPRECATED] The balances of the tokens associated to the account. This field was
             * deprecated by <a href="https://hips.hedera.com/hip/hip-367">HIP-367</a>, which allowed
             * an account to be associated to an unlimited number of tokens. This scale makes it more
             * efficient for users to consult mirror nodes to review their token balances.
             */
            public tokenBalances: hashgraph.proto.ITokenBalance[];

            /**
             * Creates a new CryptoGetAccountBalanceResponse instance using the specified properties.
             * @param [properties] Properties to set
             * @returns CryptoGetAccountBalanceResponse instance
             */
            public static create(properties?: hashgraph.proto.ICryptoGetAccountBalanceResponse): hashgraph.proto.CryptoGetAccountBalanceResponse;

            /**
             * Encodes the specified CryptoGetAccountBalanceResponse message. Does not implicitly {@link hashgraph.proto.CryptoGetAccountBalanceResponse.verify|verify} messages.
             * @param m CryptoGetAccountBalanceResponse message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ICryptoGetAccountBalanceResponse, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a CryptoGetAccountBalanceResponse message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns CryptoGetAccountBalanceResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.CryptoGetAccountBalanceResponse;

            /**
             * Gets the default type url for CryptoGetAccountBalanceResponse
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a CryptoGetAccountRecordsQuery. */
        interface ICryptoGetAccountRecordsQuery {

            /** Standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither). */
            header?: (hashgraph.proto.IQueryHeader|null);

            /** The account ID for which the records should be retrieved */
            accountID?: (hashgraph.proto.IAccountID|null);
        }

        /** Requests records of all transactions for which the given account was the effective payer in the last 3 minutes of consensus time and <tt>ledger.keepRecordsInState=true</tt> was true during <tt>handleTransaction</tt>. */
        class CryptoGetAccountRecordsQuery implements ICryptoGetAccountRecordsQuery {

            /**
             * Constructs a new CryptoGetAccountRecordsQuery.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ICryptoGetAccountRecordsQuery);

            /** Standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither). */
            public header?: (hashgraph.proto.IQueryHeader|null);

            /** The account ID for which the records should be retrieved */
            public accountID?: (hashgraph.proto.IAccountID|null);

            /**
             * Creates a new CryptoGetAccountRecordsQuery instance using the specified properties.
             * @param [properties] Properties to set
             * @returns CryptoGetAccountRecordsQuery instance
             */
            public static create(properties?: hashgraph.proto.ICryptoGetAccountRecordsQuery): hashgraph.proto.CryptoGetAccountRecordsQuery;

            /**
             * Encodes the specified CryptoGetAccountRecordsQuery message. Does not implicitly {@link hashgraph.proto.CryptoGetAccountRecordsQuery.verify|verify} messages.
             * @param m CryptoGetAccountRecordsQuery message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ICryptoGetAccountRecordsQuery, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a CryptoGetAccountRecordsQuery message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns CryptoGetAccountRecordsQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.CryptoGetAccountRecordsQuery;

            /**
             * Gets the default type url for CryptoGetAccountRecordsQuery
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a CryptoGetAccountRecordsResponse. */
        interface ICryptoGetAccountRecordsResponse {

            /** Standard response from node to client, including the requested fields: cost, or state proof, or both, or neither */
            header?: (hashgraph.proto.IResponseHeader|null);

            /** The account that this record is for */
            accountID?: (hashgraph.proto.IAccountID|null);

            /** List of records */
            records?: (hashgraph.proto.ITransactionRecord[]|null);
        }

        /** Returns records of all transactions for which the given account was the effective payer in the last 3 minutes of consensus time and <tt>ledger.keepRecordsInState=true</tt> was true during <tt>handleTransaction</tt>. */
        class CryptoGetAccountRecordsResponse implements ICryptoGetAccountRecordsResponse {

            /**
             * Constructs a new CryptoGetAccountRecordsResponse.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ICryptoGetAccountRecordsResponse);

            /** Standard response from node to client, including the requested fields: cost, or state proof, or both, or neither */
            public header?: (hashgraph.proto.IResponseHeader|null);

            /** The account that this record is for */
            public accountID?: (hashgraph.proto.IAccountID|null);

            /** List of records */
            public records: hashgraph.proto.ITransactionRecord[];

            /**
             * Creates a new CryptoGetAccountRecordsResponse instance using the specified properties.
             * @param [properties] Properties to set
             * @returns CryptoGetAccountRecordsResponse instance
             */
            public static create(properties?: hashgraph.proto.ICryptoGetAccountRecordsResponse): hashgraph.proto.CryptoGetAccountRecordsResponse;

            /**
             * Encodes the specified CryptoGetAccountRecordsResponse message. Does not implicitly {@link hashgraph.proto.CryptoGetAccountRecordsResponse.verify|verify} messages.
             * @param m CryptoGetAccountRecordsResponse message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ICryptoGetAccountRecordsResponse, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a CryptoGetAccountRecordsResponse message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns CryptoGetAccountRecordsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.CryptoGetAccountRecordsResponse;

            /**
             * Gets the default type url for CryptoGetAccountRecordsResponse
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a CryptoGetInfoQuery. */
        interface ICryptoGetInfoQuery {

            /**
             * Standard info sent from client to node, including the signed payment, and what kind of
             * response is requested (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IQueryHeader|null);

            /** The account ID for which information is requested */
            accountID?: (hashgraph.proto.IAccountID|null);
        }

        /**
         * Get all the information about an account, including the balance. This does not get the list of
         * account records.
         */
        class CryptoGetInfoQuery implements ICryptoGetInfoQuery {

            /**
             * Constructs a new CryptoGetInfoQuery.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ICryptoGetInfoQuery);

            /**
             * Standard info sent from client to node, including the signed payment, and what kind of
             * response is requested (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IQueryHeader|null);

            /** The account ID for which information is requested */
            public accountID?: (hashgraph.proto.IAccountID|null);

            /**
             * Creates a new CryptoGetInfoQuery instance using the specified properties.
             * @param [properties] Properties to set
             * @returns CryptoGetInfoQuery instance
             */
            public static create(properties?: hashgraph.proto.ICryptoGetInfoQuery): hashgraph.proto.CryptoGetInfoQuery;

            /**
             * Encodes the specified CryptoGetInfoQuery message. Does not implicitly {@link hashgraph.proto.CryptoGetInfoQuery.verify|verify} messages.
             * @param m CryptoGetInfoQuery message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ICryptoGetInfoQuery, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a CryptoGetInfoQuery message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns CryptoGetInfoQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.CryptoGetInfoQuery;

            /**
             * Gets the default type url for CryptoGetInfoQuery
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a CryptoGetInfoResponse. */
        interface ICryptoGetInfoResponse {

            /**
             * Standard response from node to client, including the requested fields: cost, or state proof,
             * or both, or neither
             */
            header?: (hashgraph.proto.IResponseHeader|null);

            /** Info about the account (a state proof can be generated for this) */
            accountInfo?: (hashgraph.proto.CryptoGetInfoResponse.IAccountInfo|null);
        }

        /** Response when the client sends the node CryptoGetInfoQuery */
        class CryptoGetInfoResponse implements ICryptoGetInfoResponse {

            /**
             * Constructs a new CryptoGetInfoResponse.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ICryptoGetInfoResponse);

            /**
             * Standard response from node to client, including the requested fields: cost, or state proof,
             * or both, or neither
             */
            public header?: (hashgraph.proto.IResponseHeader|null);

            /** Info about the account (a state proof can be generated for this) */
            public accountInfo?: (hashgraph.proto.CryptoGetInfoResponse.IAccountInfo|null);

            /**
             * Creates a new CryptoGetInfoResponse instance using the specified properties.
             * @param [properties] Properties to set
             * @returns CryptoGetInfoResponse instance
             */
            public static create(properties?: hashgraph.proto.ICryptoGetInfoResponse): hashgraph.proto.CryptoGetInfoResponse;

            /**
             * Encodes the specified CryptoGetInfoResponse message. Does not implicitly {@link hashgraph.proto.CryptoGetInfoResponse.verify|verify} messages.
             * @param m CryptoGetInfoResponse message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ICryptoGetInfoResponse, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a CryptoGetInfoResponse message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns CryptoGetInfoResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.CryptoGetInfoResponse;

            /**
             * Gets the default type url for CryptoGetInfoResponse
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        namespace CryptoGetInfoResponse {

            /** Properties of an AccountInfo. */
            interface IAccountInfo {

                /** The account ID for which this information applies */
                accountID?: (hashgraph.proto.IAccountID|null);

                /**
                 * The Contract Account ID comprising of both the contract instance and the cryptocurrency
                 * account owned by the contract instance, in the format used by Solidity
                 */
                contractAccountID?: (string|null);

                /**
                 * If true, then this account has been deleted, it will disappear when it expires, and all
                 * transactions for it will fail except the transaction to extend its expiration date
                 */
                deleted?: (boolean|null);

                /**
                 * [Deprecated] The Account ID of the account to which this is proxy staked. If proxyAccountID is null,
                 * or is an invalid account, or is an account that isn't a node, then this account is
                 * automatically proxy staked to a node chosen by the network, but without earning payments.
                 * If the proxyAccountID account refuses to accept proxy staking , or if it is not currently
                 * running a node, then it will behave as if proxyAccountID was null.
                 */
                proxyAccountID?: (hashgraph.proto.IAccountID|null);

                /** The total number of tinybars proxy staked to this account */
                proxyReceived?: (Long|null);

                /**
                 * The key for the account, which must sign in order to transfer out, or to modify the
                 * account in any way other than extending its expiration date.
                 */
                key?: (hashgraph.proto.IKey|null);

                /** The current balance of account in tinybars */
                balance?: (Long|null);

                /**
                 * [Deprecated]. The threshold amount, in tinybars, at which a record is created of any
                 * transaction that decreases the balance of this account by more than the threshold
                 */
                generateSendRecordThreshold?: (Long|null);

                /**
                 * [Deprecated]. The threshold amount, in tinybars, at which a record is created of any
                 * transaction that increases the balance of this account by more than the threshold
                 */
                generateReceiveRecordThreshold?: (Long|null);

                /** If true, no transaction can transfer to this account unless signed by this account's key */
                receiverSigRequired?: (boolean|null);

                /** The TimeStamp time at which this account is set to expire */
                expirationTime?: (hashgraph.proto.ITimestamp|null);

                /**
                 * The duration for expiration time will extend every this many seconds. If there are
                 * insufficient funds, then it extends as long as possible. If it is empty when it expires,
                 * then it is deleted.
                 */
                autoRenewPeriod?: (hashgraph.proto.IDuration|null);

                /**
                 * All of the livehashes attached to the account (each of which is a hash along with the
                 * keys that authorized it and can delete it)
                 */
                liveHashes?: (hashgraph.proto.ILiveHash[]|null);

                /**
                 * [DEPRECATED] The metadata of the tokens associated to the account. This field was
                 * deprecated by <a href="https://hips.hedera.com/hip/hip-367">HIP-367</a>, which allowed
                 * an account to be associated to an unlimited number of tokens. This scale makes it more
                 * efficient for users to consult mirror nodes to review their token associations.
                 */
                tokenRelationships?: (hashgraph.proto.ITokenRelationship[]|null);

                /** The memo associated with the account */
                memo?: (string|null);

                /** The number of NFTs owned by this account */
                ownedNfts?: (Long|null);

                /** The maximum number of tokens that an Account can be implicitly associated with. */
                maxAutomaticTokenAssociations?: (number|null);

                /** The alias of this account */
                alias?: (Uint8Array|null);

                /** The ledger ID the response was returned from; please see <a href="https://github.com/hashgraph/hedera-improvement-proposal/blob/master/HIP/hip-198.md">HIP-198</a> for the network-specific IDs. */
                ledgerId?: (Uint8Array|null);

                /** The ethereum transaction nonce associated with this account. */
                ethereumNonce?: (Long|null);

                /** Staking metadata for this account. */
                stakingInfo?: (hashgraph.proto.IStakingInfo|null);
            }

            /** Represents an AccountInfo. */
            class AccountInfo implements IAccountInfo {

                /**
                 * Constructs a new AccountInfo.
                 * @param [p] Properties to set
                 */
                constructor(p?: hashgraph.proto.CryptoGetInfoResponse.IAccountInfo);

                /** The account ID for which this information applies */
                public accountID?: (hashgraph.proto.IAccountID|null);

                /**
                 * The Contract Account ID comprising of both the contract instance and the cryptocurrency
                 * account owned by the contract instance, in the format used by Solidity
                 */
                public contractAccountID: string;

                /**
                 * If true, then this account has been deleted, it will disappear when it expires, and all
                 * transactions for it will fail except the transaction to extend its expiration date
                 */
                public deleted: boolean;

                /**
                 * [Deprecated] The Account ID of the account to which this is proxy staked. If proxyAccountID is null,
                 * or is an invalid account, or is an account that isn't a node, then this account is
                 * automatically proxy staked to a node chosen by the network, but without earning payments.
                 * If the proxyAccountID account refuses to accept proxy staking , or if it is not currently
                 * running a node, then it will behave as if proxyAccountID was null.
                 */
                public proxyAccountID?: (hashgraph.proto.IAccountID|null);

                /** The total number of tinybars proxy staked to this account */
                public proxyReceived: Long;

                /**
                 * The key for the account, which must sign in order to transfer out, or to modify the
                 * account in any way other than extending its expiration date.
                 */
                public key?: (hashgraph.proto.IKey|null);

                /** The current balance of account in tinybars */
                public balance: Long;

                /**
                 * [Deprecated]. The threshold amount, in tinybars, at which a record is created of any
                 * transaction that decreases the balance of this account by more than the threshold
                 */
                public generateSendRecordThreshold: Long;

                /**
                 * [Deprecated]. The threshold amount, in tinybars, at which a record is created of any
                 * transaction that increases the balance of this account by more than the threshold
                 */
                public generateReceiveRecordThreshold: Long;

                /** If true, no transaction can transfer to this account unless signed by this account's key */
                public receiverSigRequired: boolean;

                /** The TimeStamp time at which this account is set to expire */
                public expirationTime?: (hashgraph.proto.ITimestamp|null);

                /**
                 * The duration for expiration time will extend every this many seconds. If there are
                 * insufficient funds, then it extends as long as possible. If it is empty when it expires,
                 * then it is deleted.
                 */
                public autoRenewPeriod?: (hashgraph.proto.IDuration|null);

                /**
                 * All of the livehashes attached to the account (each of which is a hash along with the
                 * keys that authorized it and can delete it)
                 */
                public liveHashes: hashgraph.proto.ILiveHash[];

                /**
                 * [DEPRECATED] The metadata of the tokens associated to the account. This field was
                 * deprecated by <a href="https://hips.hedera.com/hip/hip-367">HIP-367</a>, which allowed
                 * an account to be associated to an unlimited number of tokens. This scale makes it more
                 * efficient for users to consult mirror nodes to review their token associations.
                 */
                public tokenRelationships: hashgraph.proto.ITokenRelationship[];

                /** The memo associated with the account */
                public memo: string;

                /** The number of NFTs owned by this account */
                public ownedNfts: Long;

                /** The maximum number of tokens that an Account can be implicitly associated with. */
                public maxAutomaticTokenAssociations: number;

                /** The alias of this account */
                public alias: Uint8Array;

                /** The ledger ID the response was returned from; please see <a href="https://github.com/hashgraph/hedera-improvement-proposal/blob/master/HIP/hip-198.md">HIP-198</a> for the network-specific IDs. */
                public ledgerId: Uint8Array;

                /** The ethereum transaction nonce associated with this account. */
                public ethereumNonce: Long;

                /** Staking metadata for this account. */
                public stakingInfo?: (hashgraph.proto.IStakingInfo|null);

                /**
                 * Creates a new AccountInfo instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns AccountInfo instance
                 */
                public static create(properties?: hashgraph.proto.CryptoGetInfoResponse.IAccountInfo): hashgraph.proto.CryptoGetInfoResponse.AccountInfo;

                /**
                 * Encodes the specified AccountInfo message. Does not implicitly {@link hashgraph.proto.CryptoGetInfoResponse.AccountInfo.verify|verify} messages.
                 * @param m AccountInfo message or plain object to encode
                 * @param [w] Writer to encode to
                 * @returns Writer
                 */
                public static encode(m: hashgraph.proto.CryptoGetInfoResponse.IAccountInfo, w?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an AccountInfo message from the specified reader or buffer.
                 * @param r Reader or buffer to decode from
                 * @param [l] Message length if known beforehand
                 * @returns AccountInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.CryptoGetInfoResponse.AccountInfo;

                /**
                 * Gets the default type url for AccountInfo
                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns The default type url
                 */
                public static getTypeUrl(typeUrlPrefix?: string): string;
            }
        }

        /** Properties of a CryptoGetLiveHashQuery. */
        interface ICryptoGetLiveHashQuery {

            /**
             * Standard info sent from client to node, including the signed payment, and what kind of
             * response is requested (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IQueryHeader|null);

            /** The account to which the livehash is associated */
            accountID?: (hashgraph.proto.IAccountID|null);

            /** The SHA-384 data in the livehash */
            hash?: (Uint8Array|null);
        }

        /** Requests a livehash associated to an account. */
        class CryptoGetLiveHashQuery implements ICryptoGetLiveHashQuery {

            /**
             * Constructs a new CryptoGetLiveHashQuery.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ICryptoGetLiveHashQuery);

            /**
             * Standard info sent from client to node, including the signed payment, and what kind of
             * response is requested (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IQueryHeader|null);

            /** The account to which the livehash is associated */
            public accountID?: (hashgraph.proto.IAccountID|null);

            /** The SHA-384 data in the livehash */
            public hash: Uint8Array;

            /**
             * Creates a new CryptoGetLiveHashQuery instance using the specified properties.
             * @param [properties] Properties to set
             * @returns CryptoGetLiveHashQuery instance
             */
            public static create(properties?: hashgraph.proto.ICryptoGetLiveHashQuery): hashgraph.proto.CryptoGetLiveHashQuery;

            /**
             * Encodes the specified CryptoGetLiveHashQuery message. Does not implicitly {@link hashgraph.proto.CryptoGetLiveHashQuery.verify|verify} messages.
             * @param m CryptoGetLiveHashQuery message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ICryptoGetLiveHashQuery, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a CryptoGetLiveHashQuery message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns CryptoGetLiveHashQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.CryptoGetLiveHashQuery;

            /**
             * Gets the default type url for CryptoGetLiveHashQuery
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a CryptoGetLiveHashResponse. */
        interface ICryptoGetLiveHashResponse {

            /**
             * Standard response from node to client, including the requested fields: cost, or state proof,
             * or both, or neither
             */
            header?: (hashgraph.proto.IResponseHeader|null);

            /** The livehash, if present */
            liveHash?: (hashgraph.proto.ILiveHash|null);
        }

        /**
         * Returns the full livehash associated to an account, if it is present. Note that the only way to
         * obtain a state proof exhibiting the absence of a livehash from an account is to retrieve a state
         * proof of the entire account with its list of livehashes.
         */
        class CryptoGetLiveHashResponse implements ICryptoGetLiveHashResponse {

            /**
             * Constructs a new CryptoGetLiveHashResponse.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ICryptoGetLiveHashResponse);

            /**
             * Standard response from node to client, including the requested fields: cost, or state proof,
             * or both, or neither
             */
            public header?: (hashgraph.proto.IResponseHeader|null);

            /** The livehash, if present */
            public liveHash?: (hashgraph.proto.ILiveHash|null);

            /**
             * Creates a new CryptoGetLiveHashResponse instance using the specified properties.
             * @param [properties] Properties to set
             * @returns CryptoGetLiveHashResponse instance
             */
            public static create(properties?: hashgraph.proto.ICryptoGetLiveHashResponse): hashgraph.proto.CryptoGetLiveHashResponse;

            /**
             * Encodes the specified CryptoGetLiveHashResponse message. Does not implicitly {@link hashgraph.proto.CryptoGetLiveHashResponse.verify|verify} messages.
             * @param m CryptoGetLiveHashResponse message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ICryptoGetLiveHashResponse, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a CryptoGetLiveHashResponse message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns CryptoGetLiveHashResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.CryptoGetLiveHashResponse;

            /**
             * Gets the default type url for CryptoGetLiveHashResponse
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a CryptoGetStakersQuery. */
        interface ICryptoGetStakersQuery {

            /**
             * Standard info sent from client to node, including the signed payment, and what kind of
             * response is requested (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IQueryHeader|null);

            /** The Account ID for which the records should be retrieved */
            accountID?: (hashgraph.proto.IAccountID|null);
        }

        /**
         * Get all the accounts that are proxy staking to this account. For each of them, give the amount
         * currently staked. This is not yet implemented, but will be in a future version of the API.
         */
        class CryptoGetStakersQuery implements ICryptoGetStakersQuery {

            /**
             * Constructs a new CryptoGetStakersQuery.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ICryptoGetStakersQuery);

            /**
             * Standard info sent from client to node, including the signed payment, and what kind of
             * response is requested (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IQueryHeader|null);

            /** The Account ID for which the records should be retrieved */
            public accountID?: (hashgraph.proto.IAccountID|null);

            /**
             * Creates a new CryptoGetStakersQuery instance using the specified properties.
             * @param [properties] Properties to set
             * @returns CryptoGetStakersQuery instance
             */
            public static create(properties?: hashgraph.proto.ICryptoGetStakersQuery): hashgraph.proto.CryptoGetStakersQuery;

            /**
             * Encodes the specified CryptoGetStakersQuery message. Does not implicitly {@link hashgraph.proto.CryptoGetStakersQuery.verify|verify} messages.
             * @param m CryptoGetStakersQuery message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ICryptoGetStakersQuery, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a CryptoGetStakersQuery message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns CryptoGetStakersQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.CryptoGetStakersQuery;

            /**
             * Gets the default type url for CryptoGetStakersQuery
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ProxyStaker. */
        interface IProxyStaker {

            /** The Account ID that is proxy staking */
            accountID?: (hashgraph.proto.IAccountID|null);

            /** The number of hbars that are currently proxy staked */
            amount?: (Long|null);
        }

        /** information about a single account that is proxy staking */
        class ProxyStaker implements IProxyStaker {

            /**
             * Constructs a new ProxyStaker.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IProxyStaker);

            /** The Account ID that is proxy staking */
            public accountID?: (hashgraph.proto.IAccountID|null);

            /** The number of hbars that are currently proxy staked */
            public amount: Long;

            /**
             * Creates a new ProxyStaker instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ProxyStaker instance
             */
            public static create(properties?: hashgraph.proto.IProxyStaker): hashgraph.proto.ProxyStaker;

            /**
             * Encodes the specified ProxyStaker message. Does not implicitly {@link hashgraph.proto.ProxyStaker.verify|verify} messages.
             * @param m ProxyStaker message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IProxyStaker, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ProxyStaker message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ProxyStaker
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ProxyStaker;

            /**
             * Gets the default type url for ProxyStaker
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of an AllProxyStakers. */
        interface IAllProxyStakers {

            /** The Account ID that is being proxy staked to */
            accountID?: (hashgraph.proto.IAccountID|null);

            /** Each of the proxy staking accounts, and the amount they are proxy staking */
            proxyStaker?: (hashgraph.proto.IProxyStaker[]|null);
        }

        /** all of the accounts proxy staking to a given account, and the amounts proxy staked */
        class AllProxyStakers implements IAllProxyStakers {

            /**
             * Constructs a new AllProxyStakers.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IAllProxyStakers);

            /** The Account ID that is being proxy staked to */
            public accountID?: (hashgraph.proto.IAccountID|null);

            /** Each of the proxy staking accounts, and the amount they are proxy staking */
            public proxyStaker: hashgraph.proto.IProxyStaker[];

            /**
             * Creates a new AllProxyStakers instance using the specified properties.
             * @param [properties] Properties to set
             * @returns AllProxyStakers instance
             */
            public static create(properties?: hashgraph.proto.IAllProxyStakers): hashgraph.proto.AllProxyStakers;

            /**
             * Encodes the specified AllProxyStakers message. Does not implicitly {@link hashgraph.proto.AllProxyStakers.verify|verify} messages.
             * @param m AllProxyStakers message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IAllProxyStakers, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an AllProxyStakers message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns AllProxyStakers
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.AllProxyStakers;

            /**
             * Gets the default type url for AllProxyStakers
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a CryptoGetStakersResponse. */
        interface ICryptoGetStakersResponse {

            /**
             * Standard response from node to client, including the requested fields: cost, or state proof,
             * or both, or neither
             */
            header?: (hashgraph.proto.IResponseHeader|null);

            /**
             * List of accounts proxy staking to this account, and the amount each is currently proxy
             * staking
             */
            stakers?: (hashgraph.proto.IAllProxyStakers|null);
        }

        /** Response when the client sends the node CryptoGetStakersQuery */
        class CryptoGetStakersResponse implements ICryptoGetStakersResponse {

            /**
             * Constructs a new CryptoGetStakersResponse.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ICryptoGetStakersResponse);

            /**
             * Standard response from node to client, including the requested fields: cost, or state proof,
             * or both, or neither
             */
            public header?: (hashgraph.proto.IResponseHeader|null);

            /**
             * List of accounts proxy staking to this account, and the amount each is currently proxy
             * staking
             */
            public stakers?: (hashgraph.proto.IAllProxyStakers|null);

            /**
             * Creates a new CryptoGetStakersResponse instance using the specified properties.
             * @param [properties] Properties to set
             * @returns CryptoGetStakersResponse instance
             */
            public static create(properties?: hashgraph.proto.ICryptoGetStakersResponse): hashgraph.proto.CryptoGetStakersResponse;

            /**
             * Encodes the specified CryptoGetStakersResponse message. Does not implicitly {@link hashgraph.proto.CryptoGetStakersResponse.verify|verify} messages.
             * @param m CryptoGetStakersResponse message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ICryptoGetStakersResponse, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a CryptoGetStakersResponse message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns CryptoGetStakersResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.CryptoGetStakersResponse;

            /**
             * Gets the default type url for CryptoGetStakersResponse
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a FileGetContentsQuery. */
        interface IFileGetContentsQuery {

            /**
             * Standard info sent from client to node, including the signed payment, and what kind of
             * response is requested (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IQueryHeader|null);

            /** The file ID of the file whose contents are requested */
            fileID?: (hashgraph.proto.IFileID|null);
        }

        /** Get the contents of a file. The content field is empty (no bytes) if the file is empty. */
        class FileGetContentsQuery implements IFileGetContentsQuery {

            /**
             * Constructs a new FileGetContentsQuery.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IFileGetContentsQuery);

            /**
             * Standard info sent from client to node, including the signed payment, and what kind of
             * response is requested (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IQueryHeader|null);

            /** The file ID of the file whose contents are requested */
            public fileID?: (hashgraph.proto.IFileID|null);

            /**
             * Creates a new FileGetContentsQuery instance using the specified properties.
             * @param [properties] Properties to set
             * @returns FileGetContentsQuery instance
             */
            public static create(properties?: hashgraph.proto.IFileGetContentsQuery): hashgraph.proto.FileGetContentsQuery;

            /**
             * Encodes the specified FileGetContentsQuery message. Does not implicitly {@link hashgraph.proto.FileGetContentsQuery.verify|verify} messages.
             * @param m FileGetContentsQuery message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IFileGetContentsQuery, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a FileGetContentsQuery message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns FileGetContentsQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.FileGetContentsQuery;

            /**
             * Gets the default type url for FileGetContentsQuery
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a FileGetContentsResponse. */
        interface IFileGetContentsResponse {

            /**
             * Standard response from node to client, including the requested fields: cost, or state proof,
             * or both, or neither
             */
            header?: (hashgraph.proto.IResponseHeader|null);

            /** the file ID and contents (a state proof can be generated for this) */
            fileContents?: (hashgraph.proto.FileGetContentsResponse.IFileContents|null);
        }

        /** Response when the client sends the node FileGetContentsQuery */
        class FileGetContentsResponse implements IFileGetContentsResponse {

            /**
             * Constructs a new FileGetContentsResponse.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IFileGetContentsResponse);

            /**
             * Standard response from node to client, including the requested fields: cost, or state proof,
             * or both, or neither
             */
            public header?: (hashgraph.proto.IResponseHeader|null);

            /** the file ID and contents (a state proof can be generated for this) */
            public fileContents?: (hashgraph.proto.FileGetContentsResponse.IFileContents|null);

            /**
             * Creates a new FileGetContentsResponse instance using the specified properties.
             * @param [properties] Properties to set
             * @returns FileGetContentsResponse instance
             */
            public static create(properties?: hashgraph.proto.IFileGetContentsResponse): hashgraph.proto.FileGetContentsResponse;

            /**
             * Encodes the specified FileGetContentsResponse message. Does not implicitly {@link hashgraph.proto.FileGetContentsResponse.verify|verify} messages.
             * @param m FileGetContentsResponse message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IFileGetContentsResponse, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a FileGetContentsResponse message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns FileGetContentsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.FileGetContentsResponse;

            /**
             * Gets the default type url for FileGetContentsResponse
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        namespace FileGetContentsResponse {

            /** Properties of a FileContents. */
            interface IFileContents {

                /** The file ID of the file whose contents are being returned */
                fileID?: (hashgraph.proto.IFileID|null);

                /** The bytes contained in the file */
                contents?: (Uint8Array|null);
            }

            /** Represents a FileContents. */
            class FileContents implements IFileContents {

                /**
                 * Constructs a new FileContents.
                 * @param [p] Properties to set
                 */
                constructor(p?: hashgraph.proto.FileGetContentsResponse.IFileContents);

                /** The file ID of the file whose contents are being returned */
                public fileID?: (hashgraph.proto.IFileID|null);

                /** The bytes contained in the file */
                public contents: Uint8Array;

                /**
                 * Creates a new FileContents instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns FileContents instance
                 */
                public static create(properties?: hashgraph.proto.FileGetContentsResponse.IFileContents): hashgraph.proto.FileGetContentsResponse.FileContents;

                /**
                 * Encodes the specified FileContents message. Does not implicitly {@link hashgraph.proto.FileGetContentsResponse.FileContents.verify|verify} messages.
                 * @param m FileContents message or plain object to encode
                 * @param [w] Writer to encode to
                 * @returns Writer
                 */
                public static encode(m: hashgraph.proto.FileGetContentsResponse.IFileContents, w?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a FileContents message from the specified reader or buffer.
                 * @param r Reader or buffer to decode from
                 * @param [l] Message length if known beforehand
                 * @returns FileContents
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.FileGetContentsResponse.FileContents;

                /**
                 * Gets the default type url for FileContents
                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns The default type url
                 */
                public static getTypeUrl(typeUrlPrefix?: string): string;
            }
        }

        /** Properties of a FileGetInfoQuery. */
        interface IFileGetInfoQuery {

            /**
             * Standard info sent from client to node, including the signed payment, and what kind of
             * response is requested (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IQueryHeader|null);

            /** The file ID of the file for which information is requested */
            fileID?: (hashgraph.proto.IFileID|null);
        }

        /**
         * Get all of the information about a file, except for its contents. When a file expires, it no
         * longer exists, and there will be no info about it, and the fileInfo field will be blank. If a
         * transaction or smart contract deletes the file, but it has not yet expired, then the fileInfo
         * field will be non-empty, the deleted field will be true, its size will be 0, and its contents
         * will be empty.
         */
        class FileGetInfoQuery implements IFileGetInfoQuery {

            /**
             * Constructs a new FileGetInfoQuery.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IFileGetInfoQuery);

            /**
             * Standard info sent from client to node, including the signed payment, and what kind of
             * response is requested (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IQueryHeader|null);

            /** The file ID of the file for which information is requested */
            public fileID?: (hashgraph.proto.IFileID|null);

            /**
             * Creates a new FileGetInfoQuery instance using the specified properties.
             * @param [properties] Properties to set
             * @returns FileGetInfoQuery instance
             */
            public static create(properties?: hashgraph.proto.IFileGetInfoQuery): hashgraph.proto.FileGetInfoQuery;

            /**
             * Encodes the specified FileGetInfoQuery message. Does not implicitly {@link hashgraph.proto.FileGetInfoQuery.verify|verify} messages.
             * @param m FileGetInfoQuery message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IFileGetInfoQuery, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a FileGetInfoQuery message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns FileGetInfoQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.FileGetInfoQuery;

            /**
             * Gets the default type url for FileGetInfoQuery
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a FileGetInfoResponse. */
        interface IFileGetInfoResponse {

            /**
             * Standard response from node to client, including the requested fields: cost, or state proof,
             * or both, or neither
             */
            header?: (hashgraph.proto.IResponseHeader|null);

            /** The information about the file */
            fileInfo?: (hashgraph.proto.FileGetInfoResponse.IFileInfo|null);
        }

        /** Response when the client sends the node FileGetInfoQuery */
        class FileGetInfoResponse implements IFileGetInfoResponse {

            /**
             * Constructs a new FileGetInfoResponse.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IFileGetInfoResponse);

            /**
             * Standard response from node to client, including the requested fields: cost, or state proof,
             * or both, or neither
             */
            public header?: (hashgraph.proto.IResponseHeader|null);

            /** The information about the file */
            public fileInfo?: (hashgraph.proto.FileGetInfoResponse.IFileInfo|null);

            /**
             * Creates a new FileGetInfoResponse instance using the specified properties.
             * @param [properties] Properties to set
             * @returns FileGetInfoResponse instance
             */
            public static create(properties?: hashgraph.proto.IFileGetInfoResponse): hashgraph.proto.FileGetInfoResponse;

            /**
             * Encodes the specified FileGetInfoResponse message. Does not implicitly {@link hashgraph.proto.FileGetInfoResponse.verify|verify} messages.
             * @param m FileGetInfoResponse message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IFileGetInfoResponse, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a FileGetInfoResponse message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns FileGetInfoResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.FileGetInfoResponse;

            /**
             * Gets the default type url for FileGetInfoResponse
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        namespace FileGetInfoResponse {

            /** Properties of a FileInfo. */
            interface IFileInfo {

                /** The file ID of the file for which information is requested */
                fileID?: (hashgraph.proto.IFileID|null);

                /** Number of bytes in contents */
                size?: (Long|null);

                /** The current time at which this account is set to expire */
                expirationTime?: (hashgraph.proto.ITimestamp|null);

                /** True if deleted but not yet expired */
                deleted?: (boolean|null);

                /** One of these keys must sign in order to modify or delete the file */
                keys?: (hashgraph.proto.IKeyList|null);

                /** The memo associated with the file */
                memo?: (string|null);

                /** The ledger ID the response was returned from; please see <a href="https://github.com/hashgraph/hedera-improvement-proposal/blob/master/HIP/hip-198.md">HIP-198</a> for the network-specific IDs. */
                ledgerId?: (Uint8Array|null);
            }

            /** Represents a FileInfo. */
            class FileInfo implements IFileInfo {

                /**
                 * Constructs a new FileInfo.
                 * @param [p] Properties to set
                 */
                constructor(p?: hashgraph.proto.FileGetInfoResponse.IFileInfo);

                /** The file ID of the file for which information is requested */
                public fileID?: (hashgraph.proto.IFileID|null);

                /** Number of bytes in contents */
                public size: Long;

                /** The current time at which this account is set to expire */
                public expirationTime?: (hashgraph.proto.ITimestamp|null);

                /** True if deleted but not yet expired */
                public deleted: boolean;

                /** One of these keys must sign in order to modify or delete the file */
                public keys?: (hashgraph.proto.IKeyList|null);

                /** The memo associated with the file */
                public memo: string;

                /** The ledger ID the response was returned from; please see <a href="https://github.com/hashgraph/hedera-improvement-proposal/blob/master/HIP/hip-198.md">HIP-198</a> for the network-specific IDs. */
                public ledgerId: Uint8Array;

                /**
                 * Creates a new FileInfo instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns FileInfo instance
                 */
                public static create(properties?: hashgraph.proto.FileGetInfoResponse.IFileInfo): hashgraph.proto.FileGetInfoResponse.FileInfo;

                /**
                 * Encodes the specified FileInfo message. Does not implicitly {@link hashgraph.proto.FileGetInfoResponse.FileInfo.verify|verify} messages.
                 * @param m FileInfo message or plain object to encode
                 * @param [w] Writer to encode to
                 * @returns Writer
                 */
                public static encode(m: hashgraph.proto.FileGetInfoResponse.IFileInfo, w?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a FileInfo message from the specified reader or buffer.
                 * @param r Reader or buffer to decode from
                 * @param [l] Message length if known beforehand
                 * @returns FileInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.FileGetInfoResponse.FileInfo;

                /**
                 * Gets the default type url for FileInfo
                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns The default type url
                 */
                public static getTypeUrl(typeUrlPrefix?: string): string;
            }
        }

        /** Properties of a TransactionGetReceiptQuery. */
        interface ITransactionGetReceiptQuery {

            /**
             * Standard info sent from client to node, including the signed payment, and what kind of
             * response is requested (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IQueryHeader|null);

            /** The ID of the transaction for which the receipt is requested. */
            transactionID?: (hashgraph.proto.ITransactionID|null);

            /**
             * Whether receipts of processing duplicate transactions should be returned along with the
             * receipt of processing the first consensus transaction with the given id whose status was
             * neither <tt>INVALID_NODE_ACCOUNT</tt> nor <tt>INVALID_PAYER_SIGNATURE</tt>; <b>or</b>, if no
             * such receipt exists, the receipt of processing the first transaction to reach consensus with
             * the given transaction id.
             */
            includeDuplicates?: (boolean|null);

            /**
             * Whether the response should include the receipts of any child transactions spawned by the
             * top-level transaction with the given transactionID.
             */
            includeChildReceipts?: (boolean|null);
        }

        /**
         * Get the receipt of a transaction, given its transaction ID. Once a transaction reaches consensus,
         * then information about whether it succeeded or failed will be available until the end of the
         * receipt period.  Before and after the receipt period, and for a transaction that was never
         * submitted, the receipt is unknown.  This query is free (the payment field is left empty). No
         * State proof is available for this response
         */
        class TransactionGetReceiptQuery implements ITransactionGetReceiptQuery {

            /**
             * Constructs a new TransactionGetReceiptQuery.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITransactionGetReceiptQuery);

            /**
             * Standard info sent from client to node, including the signed payment, and what kind of
             * response is requested (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IQueryHeader|null);

            /** The ID of the transaction for which the receipt is requested. */
            public transactionID?: (hashgraph.proto.ITransactionID|null);

            /**
             * Whether receipts of processing duplicate transactions should be returned along with the
             * receipt of processing the first consensus transaction with the given id whose status was
             * neither <tt>INVALID_NODE_ACCOUNT</tt> nor <tt>INVALID_PAYER_SIGNATURE</tt>; <b>or</b>, if no
             * such receipt exists, the receipt of processing the first transaction to reach consensus with
             * the given transaction id.
             */
            public includeDuplicates: boolean;

            /**
             * Whether the response should include the receipts of any child transactions spawned by the
             * top-level transaction with the given transactionID.
             */
            public includeChildReceipts: boolean;

            /**
             * Creates a new TransactionGetReceiptQuery instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TransactionGetReceiptQuery instance
             */
            public static create(properties?: hashgraph.proto.ITransactionGetReceiptQuery): hashgraph.proto.TransactionGetReceiptQuery;

            /**
             * Encodes the specified TransactionGetReceiptQuery message. Does not implicitly {@link hashgraph.proto.TransactionGetReceiptQuery.verify|verify} messages.
             * @param m TransactionGetReceiptQuery message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITransactionGetReceiptQuery, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TransactionGetReceiptQuery message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TransactionGetReceiptQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TransactionGetReceiptQuery;

            /**
             * Gets the default type url for TransactionGetReceiptQuery
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TransactionGetReceiptResponse. */
        interface ITransactionGetReceiptResponse {

            /**
             * Standard response from node to client, including the requested fields: cost, or state proof,
             * or both, or neither
             */
            header?: (hashgraph.proto.IResponseHeader|null);

            /**
             * Either the receipt of processing the first consensus transaction with the given id whose
             * status was neither <tt>INVALID_NODE_ACCOUNT</tt> nor <tt>INVALID_PAYER_SIGNATURE</tt>;
             * <b>or</b>, if no such receipt exists, the receipt of processing the first transaction to
             * reach consensus with the given transaction id.
             */
            receipt?: (hashgraph.proto.ITransactionReceipt|null);

            /** The receipts of processing all transactions with the given id, in consensus time order. */
            duplicateTransactionReceipts?: (hashgraph.proto.ITransactionReceipt[]|null);

            /**
             * The receipts (if any) of all child transactions spawned by the transaction with the
             * given top-level id, in consensus order. Always empty if the top-level status is UNKNOWN.
             */
            childTransactionReceipts?: (hashgraph.proto.ITransactionReceipt[]|null);
        }

        /**
         * Response when the client sends the node TransactionGetReceiptQuery. If it created a new entity
         * (account, file, or smart contract instance) then one of the three ID fields will be filled in
         * with the ID of the new entity. Sometimes a single transaction will create more than one new
         * entity, such as when a new contract instance is created, and this also creates the new account
         * that it owned by that instance. No State proof is available for this response
         */
        class TransactionGetReceiptResponse implements ITransactionGetReceiptResponse {

            /**
             * Constructs a new TransactionGetReceiptResponse.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITransactionGetReceiptResponse);

            /**
             * Standard response from node to client, including the requested fields: cost, or state proof,
             * or both, or neither
             */
            public header?: (hashgraph.proto.IResponseHeader|null);

            /**
             * Either the receipt of processing the first consensus transaction with the given id whose
             * status was neither <tt>INVALID_NODE_ACCOUNT</tt> nor <tt>INVALID_PAYER_SIGNATURE</tt>;
             * <b>or</b>, if no such receipt exists, the receipt of processing the first transaction to
             * reach consensus with the given transaction id.
             */
            public receipt?: (hashgraph.proto.ITransactionReceipt|null);

            /** The receipts of processing all transactions with the given id, in consensus time order. */
            public duplicateTransactionReceipts: hashgraph.proto.ITransactionReceipt[];

            /**
             * The receipts (if any) of all child transactions spawned by the transaction with the
             * given top-level id, in consensus order. Always empty if the top-level status is UNKNOWN.
             */
            public childTransactionReceipts: hashgraph.proto.ITransactionReceipt[];

            /**
             * Creates a new TransactionGetReceiptResponse instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TransactionGetReceiptResponse instance
             */
            public static create(properties?: hashgraph.proto.ITransactionGetReceiptResponse): hashgraph.proto.TransactionGetReceiptResponse;

            /**
             * Encodes the specified TransactionGetReceiptResponse message. Does not implicitly {@link hashgraph.proto.TransactionGetReceiptResponse.verify|verify} messages.
             * @param m TransactionGetReceiptResponse message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITransactionGetReceiptResponse, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TransactionGetReceiptResponse message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TransactionGetReceiptResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TransactionGetReceiptResponse;

            /**
             * Gets the default type url for TransactionGetReceiptResponse
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TransactionGetRecordQuery. */
        interface ITransactionGetRecordQuery {

            /**
             * Standard info sent from client to node, including the signed payment, and what kind of
             * response is requested (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IQueryHeader|null);

            /** The ID of the transaction for which the record is requested. */
            transactionID?: (hashgraph.proto.ITransactionID|null);

            /**
             * Whether records of processing duplicate transactions should be returned along with the record
             * of processing the first consensus transaction with the given id whose status was neither
             * <tt>INVALID_NODE_ACCOUNT</tt> nor <tt>INVALID_PAYER_SIGNATURE</tt>; <b>or</b>, if no such
             * record exists, the record of processing the first transaction to reach consensus with the
             * given transaction id..
             */
            includeDuplicates?: (boolean|null);

            /**
             * Whether the response should include the records of any child transactions spawned by the
             * top-level transaction with the given transactionID.
             */
            includeChildRecords?: (boolean|null);
        }

        /**
         * Get the record for a transaction. If the transaction requested a record, then the record lasts
         * for one hour, and a state proof is available for it. If the transaction created an account, file,
         * or smart contract instance, then the record will contain the ID for what it created. If the
         * transaction called a smart contract function, then the record contains the result of that call.
         * If the transaction was a cryptocurrency transfer, then the record includes the TransferList which
         * gives the details of that transfer. If the transaction didn't return anything that should be in
         * the record, then the results field will be set to nothing.
         */
        class TransactionGetRecordQuery implements ITransactionGetRecordQuery {

            /**
             * Constructs a new TransactionGetRecordQuery.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITransactionGetRecordQuery);

            /**
             * Standard info sent from client to node, including the signed payment, and what kind of
             * response is requested (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IQueryHeader|null);

            /** The ID of the transaction for which the record is requested. */
            public transactionID?: (hashgraph.proto.ITransactionID|null);

            /**
             * Whether records of processing duplicate transactions should be returned along with the record
             * of processing the first consensus transaction with the given id whose status was neither
             * <tt>INVALID_NODE_ACCOUNT</tt> nor <tt>INVALID_PAYER_SIGNATURE</tt>; <b>or</b>, if no such
             * record exists, the record of processing the first transaction to reach consensus with the
             * given transaction id..
             */
            public includeDuplicates: boolean;

            /**
             * Whether the response should include the records of any child transactions spawned by the
             * top-level transaction with the given transactionID.
             */
            public includeChildRecords: boolean;

            /**
             * Creates a new TransactionGetRecordQuery instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TransactionGetRecordQuery instance
             */
            public static create(properties?: hashgraph.proto.ITransactionGetRecordQuery): hashgraph.proto.TransactionGetRecordQuery;

            /**
             * Encodes the specified TransactionGetRecordQuery message. Does not implicitly {@link hashgraph.proto.TransactionGetRecordQuery.verify|verify} messages.
             * @param m TransactionGetRecordQuery message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITransactionGetRecordQuery, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TransactionGetRecordQuery message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TransactionGetRecordQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TransactionGetRecordQuery;

            /**
             * Gets the default type url for TransactionGetRecordQuery
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TransactionGetRecordResponse. */
        interface ITransactionGetRecordResponse {

            /**
             * Standard response from node to client, including the requested fields: cost, or state proof,
             * or both, or neither.
             */
            header?: (hashgraph.proto.IResponseHeader|null);

            /**
             * Either the record of processing the first consensus transaction with the given id whose
             * status was neither <tt>INVALID_NODE_ACCOUNT</tt> nor <tt>INVALID_PAYER_SIGNATURE</tt>;
             * <b>or</b>, if no such record exists, the record of processing the first transaction to reach
             * consensus with the given transaction id.
             */
            transactionRecord?: (hashgraph.proto.ITransactionRecord|null);

            /**
             * The records of processing all consensus transaction with the same id as the distinguished
             * record above, in chronological order.
             */
            duplicateTransactionRecords?: (hashgraph.proto.ITransactionRecord[]|null);

            /**
             * The records of processing all child transaction spawned by the transaction with the given
             * top-level id, in consensus order. Always empty if the top-level status is UNKNOWN.
             */
            childTransactionRecords?: (hashgraph.proto.ITransactionRecord[]|null);
        }

        /** Response when the client sends the node TransactionGetRecordQuery */
        class TransactionGetRecordResponse implements ITransactionGetRecordResponse {

            /**
             * Constructs a new TransactionGetRecordResponse.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITransactionGetRecordResponse);

            /**
             * Standard response from node to client, including the requested fields: cost, or state proof,
             * or both, or neither.
             */
            public header?: (hashgraph.proto.IResponseHeader|null);

            /**
             * Either the record of processing the first consensus transaction with the given id whose
             * status was neither <tt>INVALID_NODE_ACCOUNT</tt> nor <tt>INVALID_PAYER_SIGNATURE</tt>;
             * <b>or</b>, if no such record exists, the record of processing the first transaction to reach
             * consensus with the given transaction id.
             */
            public transactionRecord?: (hashgraph.proto.ITransactionRecord|null);

            /**
             * The records of processing all consensus transaction with the same id as the distinguished
             * record above, in chronological order.
             */
            public duplicateTransactionRecords: hashgraph.proto.ITransactionRecord[];

            /**
             * The records of processing all child transaction spawned by the transaction with the given
             * top-level id, in consensus order. Always empty if the top-level status is UNKNOWN.
             */
            public childTransactionRecords: hashgraph.proto.ITransactionRecord[];

            /**
             * Creates a new TransactionGetRecordResponse instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TransactionGetRecordResponse instance
             */
            public static create(properties?: hashgraph.proto.ITransactionGetRecordResponse): hashgraph.proto.TransactionGetRecordResponse;

            /**
             * Encodes the specified TransactionGetRecordResponse message. Does not implicitly {@link hashgraph.proto.TransactionGetRecordResponse.verify|verify} messages.
             * @param m TransactionGetRecordResponse message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITransactionGetRecordResponse, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TransactionGetRecordResponse message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TransactionGetRecordResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TransactionGetRecordResponse;

            /**
             * Gets the default type url for TransactionGetRecordResponse
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TransactionGetFastRecordQuery. */
        interface ITransactionGetFastRecordQuery {

            /**
             * Standard info sent from client to node, including the signed payment, and what kind of
             * response is requested (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IQueryHeader|null);

            /** The ID of the transaction for which the record is requested. */
            transactionID?: (hashgraph.proto.ITransactionID|null);
        }

        /**
         * Get the tx record of a transaction, given its transaction ID. Once a transaction reaches
         * consensus, then information about whether it succeeded or failed will be available until the end
         * of the receipt period.  Before and after the receipt period, and for a transaction that was never
         * submitted, the receipt is unknown.  This query is free (the payment field is left empty).
         */
        class TransactionGetFastRecordQuery implements ITransactionGetFastRecordQuery {

            /**
             * Constructs a new TransactionGetFastRecordQuery.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITransactionGetFastRecordQuery);

            /**
             * Standard info sent from client to node, including the signed payment, and what kind of
             * response is requested (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IQueryHeader|null);

            /** The ID of the transaction for which the record is requested. */
            public transactionID?: (hashgraph.proto.ITransactionID|null);

            /**
             * Creates a new TransactionGetFastRecordQuery instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TransactionGetFastRecordQuery instance
             */
            public static create(properties?: hashgraph.proto.ITransactionGetFastRecordQuery): hashgraph.proto.TransactionGetFastRecordQuery;

            /**
             * Encodes the specified TransactionGetFastRecordQuery message. Does not implicitly {@link hashgraph.proto.TransactionGetFastRecordQuery.verify|verify} messages.
             * @param m TransactionGetFastRecordQuery message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITransactionGetFastRecordQuery, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TransactionGetFastRecordQuery message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TransactionGetFastRecordQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TransactionGetFastRecordQuery;

            /**
             * Gets the default type url for TransactionGetFastRecordQuery
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TransactionGetFastRecordResponse. */
        interface ITransactionGetFastRecordResponse {

            /**
             * Standard response from node to client, including the requested fields: cost, or state proof,
             * or both, or neither
             */
            header?: (hashgraph.proto.IResponseHeader|null);

            /** The requested transaction records */
            transactionRecord?: (hashgraph.proto.ITransactionRecord|null);
        }

        /**
         * Response when the client sends the node TransactionGetFastRecordQuery. If it created a new entity
         * (account, file, or smart contract instance) then one of the three ID fields will be filled in
         * with the ID of the new entity. Sometimes a single transaction will create more than one new
         * entity, such as when a new contract instance is created, and this also creates the new account
         * that it owned by that instance.
         */
        class TransactionGetFastRecordResponse implements ITransactionGetFastRecordResponse {

            /**
             * Constructs a new TransactionGetFastRecordResponse.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITransactionGetFastRecordResponse);

            /**
             * Standard response from node to client, including the requested fields: cost, or state proof,
             * or both, or neither
             */
            public header?: (hashgraph.proto.IResponseHeader|null);

            /** The requested transaction records */
            public transactionRecord?: (hashgraph.proto.ITransactionRecord|null);

            /**
             * Creates a new TransactionGetFastRecordResponse instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TransactionGetFastRecordResponse instance
             */
            public static create(properties?: hashgraph.proto.ITransactionGetFastRecordResponse): hashgraph.proto.TransactionGetFastRecordResponse;

            /**
             * Encodes the specified TransactionGetFastRecordResponse message. Does not implicitly {@link hashgraph.proto.TransactionGetFastRecordResponse.verify|verify} messages.
             * @param m TransactionGetFastRecordResponse message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITransactionGetFastRecordResponse, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TransactionGetFastRecordResponse message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TransactionGetFastRecordResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TransactionGetFastRecordResponse;

            /**
             * Gets the default type url for TransactionGetFastRecordResponse
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a NetworkGetVersionInfoQuery. */
        interface INetworkGetVersionInfoQuery {

            /**
             * Standard info sent from client to node, including the signed payment, and what kind of
             * response is requested (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IQueryHeader|null);
        }

        /** Get the deployed versions of Hedera Services and the HAPI proto in semantic version format */
        class NetworkGetVersionInfoQuery implements INetworkGetVersionInfoQuery {

            /**
             * Constructs a new NetworkGetVersionInfoQuery.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.INetworkGetVersionInfoQuery);

            /**
             * Standard info sent from client to node, including the signed payment, and what kind of
             * response is requested (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IQueryHeader|null);

            /**
             * Creates a new NetworkGetVersionInfoQuery instance using the specified properties.
             * @param [properties] Properties to set
             * @returns NetworkGetVersionInfoQuery instance
             */
            public static create(properties?: hashgraph.proto.INetworkGetVersionInfoQuery): hashgraph.proto.NetworkGetVersionInfoQuery;

            /**
             * Encodes the specified NetworkGetVersionInfoQuery message. Does not implicitly {@link hashgraph.proto.NetworkGetVersionInfoQuery.verify|verify} messages.
             * @param m NetworkGetVersionInfoQuery message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.INetworkGetVersionInfoQuery, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a NetworkGetVersionInfoQuery message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns NetworkGetVersionInfoQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.NetworkGetVersionInfoQuery;

            /**
             * Gets the default type url for NetworkGetVersionInfoQuery
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a NetworkGetVersionInfoResponse. */
        interface INetworkGetVersionInfoResponse {

            /**
             * Standard response from node to client, including the requested fields: cost, or state proof,
             * or both, or neither
             */
            header?: (hashgraph.proto.IResponseHeader|null);

            /** The Hedera API (HAPI) protobuf version recognized by the responding node. */
            hapiProtoVersion?: (hashgraph.proto.ISemanticVersion|null);

            /** The version of the Hedera Services software deployed on the responding node. */
            hederaServicesVersion?: (hashgraph.proto.ISemanticVersion|null);
        }

        /** Response when the client sends the node NetworkGetVersionInfoQuery */
        class NetworkGetVersionInfoResponse implements INetworkGetVersionInfoResponse {

            /**
             * Constructs a new NetworkGetVersionInfoResponse.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.INetworkGetVersionInfoResponse);

            /**
             * Standard response from node to client, including the requested fields: cost, or state proof,
             * or both, or neither
             */
            public header?: (hashgraph.proto.IResponseHeader|null);

            /** The Hedera API (HAPI) protobuf version recognized by the responding node. */
            public hapiProtoVersion?: (hashgraph.proto.ISemanticVersion|null);

            /** The version of the Hedera Services software deployed on the responding node. */
            public hederaServicesVersion?: (hashgraph.proto.ISemanticVersion|null);

            /**
             * Creates a new NetworkGetVersionInfoResponse instance using the specified properties.
             * @param [properties] Properties to set
             * @returns NetworkGetVersionInfoResponse instance
             */
            public static create(properties?: hashgraph.proto.INetworkGetVersionInfoResponse): hashgraph.proto.NetworkGetVersionInfoResponse;

            /**
             * Encodes the specified NetworkGetVersionInfoResponse message. Does not implicitly {@link hashgraph.proto.NetworkGetVersionInfoResponse.verify|verify} messages.
             * @param m NetworkGetVersionInfoResponse message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.INetworkGetVersionInfoResponse, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a NetworkGetVersionInfoResponse message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns NetworkGetVersionInfoResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.NetworkGetVersionInfoResponse;

            /**
             * Gets the default type url for NetworkGetVersionInfoResponse
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a NetworkGetExecutionTimeQuery. */
        interface INetworkGetExecutionTimeQuery {

            /**
             * standard info sent from client to node including the signed payment, and what kind of response
             * is requested (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IQueryHeader|null);

            /** The id(s) of the transactions to get the execution time(s) of */
            transactionIds?: (hashgraph.proto.ITransactionID[]|null);
        }

        /**
         * Gets the time in nanoseconds spent in <tt>handleTransaction</tt> for one or more
         * TransactionIDs (assuming they have reached consensus "recently", since only a limited
         * number of execution times are kept in-memory, depending on the value of the node-local
         * property <tt>stats.executionTimesToTrack</tt>).
         */
        class NetworkGetExecutionTimeQuery implements INetworkGetExecutionTimeQuery {

            /**
             * Constructs a new NetworkGetExecutionTimeQuery.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.INetworkGetExecutionTimeQuery);

            /**
             * standard info sent from client to node including the signed payment, and what kind of response
             * is requested (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IQueryHeader|null);

            /** The id(s) of the transactions to get the execution time(s) of */
            public transactionIds: hashgraph.proto.ITransactionID[];

            /**
             * Creates a new NetworkGetExecutionTimeQuery instance using the specified properties.
             * @param [properties] Properties to set
             * @returns NetworkGetExecutionTimeQuery instance
             */
            public static create(properties?: hashgraph.proto.INetworkGetExecutionTimeQuery): hashgraph.proto.NetworkGetExecutionTimeQuery;

            /**
             * Encodes the specified NetworkGetExecutionTimeQuery message. Does not implicitly {@link hashgraph.proto.NetworkGetExecutionTimeQuery.verify|verify} messages.
             * @param m NetworkGetExecutionTimeQuery message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.INetworkGetExecutionTimeQuery, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a NetworkGetExecutionTimeQuery message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns NetworkGetExecutionTimeQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.NetworkGetExecutionTimeQuery;

            /**
             * Gets the default type url for NetworkGetExecutionTimeQuery
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a NetworkGetExecutionTimeResponse. */
        interface INetworkGetExecutionTimeResponse {

            /**
             * Standard response from node to client, including the requested fields: cost, or state proof,
             * or both, or neither
             */
            header?: (hashgraph.proto.IResponseHeader|null);

            /** The execution time(s) of the requested TransactionIDs, if available */
            executionTimes?: (Long[]|null);
        }

        /**
         * Response when the client sends the node NetworkGetExecutionTimeQuery; returns
         * INVALID_TRANSACTION_ID if any of the given TransactionIDs do not have available
         * execution times in the answering node.
         */
        class NetworkGetExecutionTimeResponse implements INetworkGetExecutionTimeResponse {

            /**
             * Constructs a new NetworkGetExecutionTimeResponse.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.INetworkGetExecutionTimeResponse);

            /**
             * Standard response from node to client, including the requested fields: cost, or state proof,
             * or both, or neither
             */
            public header?: (hashgraph.proto.IResponseHeader|null);

            /** The execution time(s) of the requested TransactionIDs, if available */
            public executionTimes: Long[];

            /**
             * Creates a new NetworkGetExecutionTimeResponse instance using the specified properties.
             * @param [properties] Properties to set
             * @returns NetworkGetExecutionTimeResponse instance
             */
            public static create(properties?: hashgraph.proto.INetworkGetExecutionTimeResponse): hashgraph.proto.NetworkGetExecutionTimeResponse;

            /**
             * Encodes the specified NetworkGetExecutionTimeResponse message. Does not implicitly {@link hashgraph.proto.NetworkGetExecutionTimeResponse.verify|verify} messages.
             * @param m NetworkGetExecutionTimeResponse message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.INetworkGetExecutionTimeResponse, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a NetworkGetExecutionTimeResponse message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns NetworkGetExecutionTimeResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.NetworkGetExecutionTimeResponse;

            /**
             * Gets the default type url for NetworkGetExecutionTimeResponse
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenGetInfoQuery. */
        interface ITokenGetInfoQuery {

            /**
             * Standard info sent from client to node, including the signed payment, and what kind of
             * response is requested (cost, state proof, both, or neither)
             */
            header?: (hashgraph.proto.IQueryHeader|null);

            /**
             * The token for which information is requested. If invalid token is provided, INVALID_TOKEN_ID
             * response is returned.
             */
            token?: (hashgraph.proto.ITokenID|null);
        }

        /** Gets information about Token instance */
        class TokenGetInfoQuery implements ITokenGetInfoQuery {

            /**
             * Constructs a new TokenGetInfoQuery.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenGetInfoQuery);

            /**
             * Standard info sent from client to node, including the signed payment, and what kind of
             * response is requested (cost, state proof, both, or neither)
             */
            public header?: (hashgraph.proto.IQueryHeader|null);

            /**
             * The token for which information is requested. If invalid token is provided, INVALID_TOKEN_ID
             * response is returned.
             */
            public token?: (hashgraph.proto.ITokenID|null);

            /**
             * Creates a new TokenGetInfoQuery instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenGetInfoQuery instance
             */
            public static create(properties?: hashgraph.proto.ITokenGetInfoQuery): hashgraph.proto.TokenGetInfoQuery;

            /**
             * Encodes the specified TokenGetInfoQuery message. Does not implicitly {@link hashgraph.proto.TokenGetInfoQuery.verify|verify} messages.
             * @param m TokenGetInfoQuery message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenGetInfoQuery, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenGetInfoQuery message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenGetInfoQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenGetInfoQuery;

            /**
             * Gets the default type url for TokenGetInfoQuery
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenInfo. */
        interface ITokenInfo {

            /** ID of the token instance */
            tokenId?: (hashgraph.proto.ITokenID|null);

            /** The name of the token. It is a string of ASCII only characters */
            name?: (string|null);

            /** The symbol of the token. It is a UTF-8 capitalized alphabetical string */
            symbol?: (string|null);

            /**
             * The number of decimal places a token is divisible by. Always 0 for tokens of type
             * NON_FUNGIBLE_UNIQUE
             */
            decimals?: (number|null);

            /**
             * For tokens of type FUNGIBLE_COMMON - the total supply of tokens that are currently in
             * circulation. For tokens of type NON_FUNGIBLE_UNIQUE - the number of NFTs created of this
             * token instance
             */
            totalSupply?: (Long|null);

            /** The ID of the account which is set as Treasury */
            treasury?: (hashgraph.proto.IAccountID|null);

            /**
             * The key which can perform update/delete operations on the token. If empty, the token can be
             * perceived as immutable (not being able to be updated/deleted)
             */
            adminKey?: (hashgraph.proto.IKey|null);

            /**
             * The key which can grant or revoke KYC of an account for the token's transactions. If empty,
             * KYC is not required, and KYC grant or revoke operations are not possible.
             */
            kycKey?: (hashgraph.proto.IKey|null);

            /**
             * The key which can freeze or unfreeze an account for token transactions. If empty, freezing is
             * not possible
             */
            freezeKey?: (hashgraph.proto.IKey|null);

            /** The key which can wipe token balance of an account. If empty, wipe is not possible */
            wipeKey?: (hashgraph.proto.IKey|null);

            /**
             * The key which can change the supply of a token. The key is used to sign Token Mint/Burn
             * operations
             */
            supplyKey?: (hashgraph.proto.IKey|null);

            /**
             * The default Freeze status (not applicable, frozen or unfrozen) of Hedera accounts relative to
             * this token. FreezeNotApplicable is returned if Token Freeze Key is empty. Frozen is returned
             * if Token Freeze Key is set and defaultFreeze is set to true. Unfrozen is returned if Token
             * Freeze Key is set and defaultFreeze is set to false
             */
            defaultFreezeStatus?: (hashgraph.proto.TokenFreezeStatus|null);

            /**
             * The default KYC status (KycNotApplicable or Revoked) of Hedera accounts relative to this
             * token. KycNotApplicable is returned if KYC key is not set, otherwise Revoked
             */
            defaultKycStatus?: (hashgraph.proto.TokenKycStatus|null);

            /** Specifies whether the token was deleted or not */
            deleted?: (boolean|null);

            /**
             * An account which will be automatically charged to renew the token's expiration, at
             * autoRenewPeriod interval
             */
            autoRenewAccount?: (hashgraph.proto.IAccountID|null);

            /** The interval at which the auto-renew account will be charged to extend the token's expiry */
            autoRenewPeriod?: (hashgraph.proto.IDuration|null);

            /** The epoch second at which the token will expire */
            expiry?: (hashgraph.proto.ITimestamp|null);

            /** The memo associated with the token */
            memo?: (string|null);

            /** The token type */
            tokenType?: (hashgraph.proto.TokenType|null);

            /** The token supply type */
            supplyType?: (hashgraph.proto.TokenSupplyType|null);

            /**
             * For tokens of type FUNGIBLE_COMMON - The Maximum number of fungible tokens that can be in
             * circulation. For tokens of type NON_FUNGIBLE_UNIQUE - the maximum number of NFTs (serial
             * numbers) that can be in circulation
             */
            maxSupply?: (Long|null);

            /**
             * The key which can change the custom fee schedule of the token; if not set, the fee schedule
             * is immutable
             */
            feeScheduleKey?: (hashgraph.proto.IKey|null);

            /** The custom fees to be assessed during a CryptoTransfer that transfers units of this token */
            customFees?: (hashgraph.proto.ICustomFee[]|null);

            /** The Key which can pause and unpause the Token. */
            pauseKey?: (hashgraph.proto.IKey|null);

            /** Specifies whether the token is paused or not. PauseNotApplicable is returned if pauseKey is not set. */
            pauseStatus?: (hashgraph.proto.TokenPauseStatus|null);

            /** The ledger ID the response was returned from; please see <a href="https://github.com/hashgraph/hedera-improvement-proposal/blob/master/HIP/hip-198.md">HIP-198</a> for the network-specific IDs. */
            ledgerId?: (Uint8Array|null);
        }

        /** The metadata about a Token instance */
        class TokenInfo implements ITokenInfo {

            /**
             * Constructs a new TokenInfo.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenInfo);

            /** ID of the token instance */
            public tokenId?: (hashgraph.proto.ITokenID|null);

            /** The name of the token. It is a string of ASCII only characters */
            public name: string;

            /** The symbol of the token. It is a UTF-8 capitalized alphabetical string */
            public symbol: string;

            /**
             * The number of decimal places a token is divisible by. Always 0 for tokens of type
             * NON_FUNGIBLE_UNIQUE
             */
            public decimals: number;

            /**
             * For tokens of type FUNGIBLE_COMMON - the total supply of tokens that are currently in
             * circulation. For tokens of type NON_FUNGIBLE_UNIQUE - the number of NFTs created of this
             * token instance
             */
            public totalSupply: Long;

            /** The ID of the account which is set as Treasury */
            public treasury?: (hashgraph.proto.IAccountID|null);

            /**
             * The key which can perform update/delete operations on the token. If empty, the token can be
             * perceived as immutable (not being able to be updated/deleted)
             */
            public adminKey?: (hashgraph.proto.IKey|null);

            /**
             * The key which can grant or revoke KYC of an account for the token's transactions. If empty,
             * KYC is not required, and KYC grant or revoke operations are not possible.
             */
            public kycKey?: (hashgraph.proto.IKey|null);

            /**
             * The key which can freeze or unfreeze an account for token transactions. If empty, freezing is
             * not possible
             */
            public freezeKey?: (hashgraph.proto.IKey|null);

            /** The key which can wipe token balance of an account. If empty, wipe is not possible */
            public wipeKey?: (hashgraph.proto.IKey|null);

            /**
             * The key which can change the supply of a token. The key is used to sign Token Mint/Burn
             * operations
             */
            public supplyKey?: (hashgraph.proto.IKey|null);

            /**
             * The default Freeze status (not applicable, frozen or unfrozen) of Hedera accounts relative to
             * this token. FreezeNotApplicable is returned if Token Freeze Key is empty. Frozen is returned
             * if Token Freeze Key is set and defaultFreeze is set to true. Unfrozen is returned if Token
             * Freeze Key is set and defaultFreeze is set to false
             */
            public defaultFreezeStatus: hashgraph.proto.TokenFreezeStatus;

            /**
             * The default KYC status (KycNotApplicable or Revoked) of Hedera accounts relative to this
             * token. KycNotApplicable is returned if KYC key is not set, otherwise Revoked
             */
            public defaultKycStatus: hashgraph.proto.TokenKycStatus;

            /** Specifies whether the token was deleted or not */
            public deleted: boolean;

            /**
             * An account which will be automatically charged to renew the token's expiration, at
             * autoRenewPeriod interval
             */
            public autoRenewAccount?: (hashgraph.proto.IAccountID|null);

            /** The interval at which the auto-renew account will be charged to extend the token's expiry */
            public autoRenewPeriod?: (hashgraph.proto.IDuration|null);

            /** The epoch second at which the token will expire */
            public expiry?: (hashgraph.proto.ITimestamp|null);

            /** The memo associated with the token */
            public memo: string;

            /** The token type */
            public tokenType: hashgraph.proto.TokenType;

            /** The token supply type */
            public supplyType: hashgraph.proto.TokenSupplyType;

            /**
             * For tokens of type FUNGIBLE_COMMON - The Maximum number of fungible tokens that can be in
             * circulation. For tokens of type NON_FUNGIBLE_UNIQUE - the maximum number of NFTs (serial
             * numbers) that can be in circulation
             */
            public maxSupply: Long;

            /**
             * The key which can change the custom fee schedule of the token; if not set, the fee schedule
             * is immutable
             */
            public feeScheduleKey?: (hashgraph.proto.IKey|null);

            /** The custom fees to be assessed during a CryptoTransfer that transfers units of this token */
            public customFees: hashgraph.proto.ICustomFee[];

            /** The Key which can pause and unpause the Token. */
            public pauseKey?: (hashgraph.proto.IKey|null);

            /** Specifies whether the token is paused or not. PauseNotApplicable is returned if pauseKey is not set. */
            public pauseStatus: hashgraph.proto.TokenPauseStatus;

            /** The ledger ID the response was returned from; please see <a href="https://github.com/hashgraph/hedera-improvement-proposal/blob/master/HIP/hip-198.md">HIP-198</a> for the network-specific IDs. */
            public ledgerId: Uint8Array;

            /**
             * Creates a new TokenInfo instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenInfo instance
             */
            public static create(properties?: hashgraph.proto.ITokenInfo): hashgraph.proto.TokenInfo;

            /**
             * Encodes the specified TokenInfo message. Does not implicitly {@link hashgraph.proto.TokenInfo.verify|verify} messages.
             * @param m TokenInfo message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenInfo, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenInfo message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenInfo;

            /**
             * Gets the default type url for TokenInfo
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenGetInfoResponse. */
        interface ITokenGetInfoResponse {

            /**
             * Standard response from node to client, including the requested fields: cost, or state proof,
             * or both, or neither
             */
            header?: (hashgraph.proto.IResponseHeader|null);

            /** The information requested about this token instance */
            tokenInfo?: (hashgraph.proto.ITokenInfo|null);
        }

        /** Response when the client sends the node TokenGetInfoQuery */
        class TokenGetInfoResponse implements ITokenGetInfoResponse {

            /**
             * Constructs a new TokenGetInfoResponse.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenGetInfoResponse);

            /**
             * Standard response from node to client, including the requested fields: cost, or state proof,
             * or both, or neither
             */
            public header?: (hashgraph.proto.IResponseHeader|null);

            /** The information requested about this token instance */
            public tokenInfo?: (hashgraph.proto.ITokenInfo|null);

            /**
             * Creates a new TokenGetInfoResponse instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenGetInfoResponse instance
             */
            public static create(properties?: hashgraph.proto.ITokenGetInfoResponse): hashgraph.proto.TokenGetInfoResponse;

            /**
             * Encodes the specified TokenGetInfoResponse message. Does not implicitly {@link hashgraph.proto.TokenGetInfoResponse.verify|verify} messages.
             * @param m TokenGetInfoResponse message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenGetInfoResponse, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenGetInfoResponse message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenGetInfoResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenGetInfoResponse;

            /**
             * Gets the default type url for TokenGetInfoResponse
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ScheduleGetInfoQuery. */
        interface IScheduleGetInfoQuery {

            /**
             * standard info sent from client to node including the signed payment, and what kind of response
             * is requested (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IQueryHeader|null);

            /** The id of the schedule to interrogate */
            scheduleID?: (hashgraph.proto.IScheduleID|null);
        }

        /**
         * Gets information about a schedule in the network's action queue.
         *
         * Responds with <tt>INVALID_SCHEDULE_ID</tt> if the requested schedule doesn't exist.
         */
        class ScheduleGetInfoQuery implements IScheduleGetInfoQuery {

            /**
             * Constructs a new ScheduleGetInfoQuery.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IScheduleGetInfoQuery);

            /**
             * standard info sent from client to node including the signed payment, and what kind of response
             * is requested (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IQueryHeader|null);

            /** The id of the schedule to interrogate */
            public scheduleID?: (hashgraph.proto.IScheduleID|null);

            /**
             * Creates a new ScheduleGetInfoQuery instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ScheduleGetInfoQuery instance
             */
            public static create(properties?: hashgraph.proto.IScheduleGetInfoQuery): hashgraph.proto.ScheduleGetInfoQuery;

            /**
             * Encodes the specified ScheduleGetInfoQuery message. Does not implicitly {@link hashgraph.proto.ScheduleGetInfoQuery.verify|verify} messages.
             * @param m ScheduleGetInfoQuery message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IScheduleGetInfoQuery, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ScheduleGetInfoQuery message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ScheduleGetInfoQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ScheduleGetInfoQuery;

            /**
             * Gets the default type url for ScheduleGetInfoQuery
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ScheduleInfo. */
        interface IScheduleInfo {

            /** The id of the schedule */
            scheduleID?: (hashgraph.proto.IScheduleID|null);

            /** If the schedule has been deleted, the consensus time when this occurred */
            deletionTime?: (hashgraph.proto.ITimestamp|null);

            /** If the schedule has been executed, the consensus time when this occurred */
            executionTime?: (hashgraph.proto.ITimestamp|null);

            /**
             * The time at which the schedule will be evaluated for execution and then expire.
             *
             * Note: Before Long Term Scheduled Transactions are enabled, Scheduled Transactions will _never_ execute at expiration - they
             * will _only_ execute during the initial ScheduleCreate transaction or via ScheduleSign transactions and will _always_
             * expire at expirationTime.
             */
            expirationTime?: (hashgraph.proto.ITimestamp|null);

            /** The scheduled transaction */
            scheduledTransactionBody?: (hashgraph.proto.ISchedulableTransactionBody|null);

            /** The publicly visible memo of the schedule */
            memo?: (string|null);

            /** The key used to delete the schedule from state */
            adminKey?: (hashgraph.proto.IKey|null);

            /** The Ed25519 keys the network deems to have signed the scheduled transaction */
            signers?: (hashgraph.proto.IKeyList|null);

            /** The id of the account that created the schedule */
            creatorAccountID?: (hashgraph.proto.IAccountID|null);

            /** The id of the account responsible for the service fee of the scheduled transaction */
            payerAccountID?: (hashgraph.proto.IAccountID|null);

            /**
             * The transaction id that will be used in the record of the scheduled transaction (if it
             * executes)
             */
            scheduledTransactionID?: (hashgraph.proto.ITransactionID|null);

            /** The ledger ID the response was returned from; please see <a href="https://github.com/hashgraph/hedera-improvement-proposal/blob/master/HIP/hip-198.md">HIP-198</a> for the network-specific IDs. */
            ledgerId?: (Uint8Array|null);

            /**
             * When set to true, the transaction will be evaluated for execution at expiration_time instead
             * of when all required signatures are received.
             * When set to false, the transaction will execute immediately after sufficient signatures are received
             * to sign the contained transaction. During the initial ScheduleCreate transaction or via ScheduleSign transactions.
             *
             * Note: this field is unused until Long Term Scheduled Transactions are enabled.
             */
            waitForExpiry?: (boolean|null);
        }

        /** Information summarizing schedule state */
        class ScheduleInfo implements IScheduleInfo {

            /**
             * Constructs a new ScheduleInfo.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IScheduleInfo);

            /** The id of the schedule */
            public scheduleID?: (hashgraph.proto.IScheduleID|null);

            /** If the schedule has been deleted, the consensus time when this occurred */
            public deletionTime?: (hashgraph.proto.ITimestamp|null);

            /** If the schedule has been executed, the consensus time when this occurred */
            public executionTime?: (hashgraph.proto.ITimestamp|null);

            /**
             * The time at which the schedule will be evaluated for execution and then expire.
             *
             * Note: Before Long Term Scheduled Transactions are enabled, Scheduled Transactions will _never_ execute at expiration - they
             * will _only_ execute during the initial ScheduleCreate transaction or via ScheduleSign transactions and will _always_
             * expire at expirationTime.
             */
            public expirationTime?: (hashgraph.proto.ITimestamp|null);

            /** The scheduled transaction */
            public scheduledTransactionBody?: (hashgraph.proto.ISchedulableTransactionBody|null);

            /** The publicly visible memo of the schedule */
            public memo: string;

            /** The key used to delete the schedule from state */
            public adminKey?: (hashgraph.proto.IKey|null);

            /** The Ed25519 keys the network deems to have signed the scheduled transaction */
            public signers?: (hashgraph.proto.IKeyList|null);

            /** The id of the account that created the schedule */
            public creatorAccountID?: (hashgraph.proto.IAccountID|null);

            /** The id of the account responsible for the service fee of the scheduled transaction */
            public payerAccountID?: (hashgraph.proto.IAccountID|null);

            /**
             * The transaction id that will be used in the record of the scheduled transaction (if it
             * executes)
             */
            public scheduledTransactionID?: (hashgraph.proto.ITransactionID|null);

            /** The ledger ID the response was returned from; please see <a href="https://github.com/hashgraph/hedera-improvement-proposal/blob/master/HIP/hip-198.md">HIP-198</a> for the network-specific IDs. */
            public ledgerId: Uint8Array;

            /**
             * When set to true, the transaction will be evaluated for execution at expiration_time instead
             * of when all required signatures are received.
             * When set to false, the transaction will execute immediately after sufficient signatures are received
             * to sign the contained transaction. During the initial ScheduleCreate transaction or via ScheduleSign transactions.
             *
             * Note: this field is unused until Long Term Scheduled Transactions are enabled.
             */
            public waitForExpiry: boolean;

            /** ScheduleInfo data. */
            public data?: ("deletionTime"|"executionTime");

            /**
             * Creates a new ScheduleInfo instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ScheduleInfo instance
             */
            public static create(properties?: hashgraph.proto.IScheduleInfo): hashgraph.proto.ScheduleInfo;

            /**
             * Encodes the specified ScheduleInfo message. Does not implicitly {@link hashgraph.proto.ScheduleInfo.verify|verify} messages.
             * @param m ScheduleInfo message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IScheduleInfo, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ScheduleInfo message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ScheduleInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ScheduleInfo;

            /**
             * Gets the default type url for ScheduleInfo
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ScheduleGetInfoResponse. */
        interface IScheduleGetInfoResponse {

            /**
             * Standard response from node to client, including the requested fields: cost, or state proof, or
             * both, or neither
             */
            header?: (hashgraph.proto.IResponseHeader|null);

            /** The information requested about this schedule instance */
            scheduleInfo?: (hashgraph.proto.IScheduleInfo|null);
        }

        /** Response wrapper for the <tt>ScheduleInfo</tt> */
        class ScheduleGetInfoResponse implements IScheduleGetInfoResponse {

            /**
             * Constructs a new ScheduleGetInfoResponse.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IScheduleGetInfoResponse);

            /**
             * Standard response from node to client, including the requested fields: cost, or state proof, or
             * both, or neither
             */
            public header?: (hashgraph.proto.IResponseHeader|null);

            /** The information requested about this schedule instance */
            public scheduleInfo?: (hashgraph.proto.IScheduleInfo|null);

            /**
             * Creates a new ScheduleGetInfoResponse instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ScheduleGetInfoResponse instance
             */
            public static create(properties?: hashgraph.proto.IScheduleGetInfoResponse): hashgraph.proto.ScheduleGetInfoResponse;

            /**
             * Encodes the specified ScheduleGetInfoResponse message. Does not implicitly {@link hashgraph.proto.ScheduleGetInfoResponse.verify|verify} messages.
             * @param m ScheduleGetInfoResponse message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IScheduleGetInfoResponse, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ScheduleGetInfoResponse message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ScheduleGetInfoResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ScheduleGetInfoResponse;

            /**
             * Gets the default type url for ScheduleGetInfoResponse
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenGetAccountNftInfosQuery. */
        interface ITokenGetAccountNftInfosQuery {

            /**
             * Standard info sent from client to node, including the signed payment, and what kind of
             * response is requested (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IQueryHeader|null);

            /** The Account for which information is requested */
            accountID?: (hashgraph.proto.IAccountID|null);

            /**
             * Specifies the start index (inclusive) of the range of NFTs to query for. Value must be in the
             * range [0; ownedNFTs-1]
             */
            start?: (Long|null);

            /**
             * Specifies the end index (exclusive) of the range of NFTs to query for. Value must be in the
             * range (start; ownedNFTs]
             */
            end?: (Long|null);
        }

        /**
         * Applicable only to tokens of type NON_FUNGIBLE_UNIQUE. Gets info on NFTs N through M owned by the
         * specified accountId.
         * Example: If Account A owns 5 NFTs (might be of different Token Entity), having start=0 and end=5
         * will return all of the NFTs
         *
         * INVALID_QUERY_RANGE response code will be returned if:
         * 1) Start > End
         * 2) Start and End indices are non-positive
         * 3) Start and End indices are out of boundaries for the retrieved nft list
         * 4) The range between Start and End is bigger than the global dynamic property for maximum query
         * range
         *
         * NOT_SUPPORTED response code will be returned if the queried token is of type FUNGIBLE_COMMON
         *
         * INVALID_ACCOUNT_ID response code will be returned if the queried account does not exist
         *
         * ACCOUNT_DELETED response code will be returned if the queried account has been deleted
         */
        class TokenGetAccountNftInfosQuery implements ITokenGetAccountNftInfosQuery {

            /**
             * Constructs a new TokenGetAccountNftInfosQuery.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenGetAccountNftInfosQuery);

            /**
             * Standard info sent from client to node, including the signed payment, and what kind of
             * response is requested (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IQueryHeader|null);

            /** The Account for which information is requested */
            public accountID?: (hashgraph.proto.IAccountID|null);

            /**
             * Specifies the start index (inclusive) of the range of NFTs to query for. Value must be in the
             * range [0; ownedNFTs-1]
             */
            public start: Long;

            /**
             * Specifies the end index (exclusive) of the range of NFTs to query for. Value must be in the
             * range (start; ownedNFTs]
             */
            public end: Long;

            /**
             * Creates a new TokenGetAccountNftInfosQuery instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenGetAccountNftInfosQuery instance
             */
            public static create(properties?: hashgraph.proto.ITokenGetAccountNftInfosQuery): hashgraph.proto.TokenGetAccountNftInfosQuery;

            /**
             * Encodes the specified TokenGetAccountNftInfosQuery message. Does not implicitly {@link hashgraph.proto.TokenGetAccountNftInfosQuery.verify|verify} messages.
             * @param m TokenGetAccountNftInfosQuery message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenGetAccountNftInfosQuery, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenGetAccountNftInfosQuery message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenGetAccountNftInfosQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenGetAccountNftInfosQuery;

            /**
             * Gets the default type url for TokenGetAccountNftInfosQuery
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenGetAccountNftInfosResponse. */
        interface ITokenGetAccountNftInfosResponse {

            /**
             * Standard response from node to client, including the requested fields: cost, or state proof,
             * or both, or neither
             */
            header?: (hashgraph.proto.IResponseHeader|null);

            /** List of NFTs associated to the account */
            nfts?: (hashgraph.proto.ITokenNftInfo[]|null);
        }

        /** UNDOCUMENTED */
        class TokenGetAccountNftInfosResponse implements ITokenGetAccountNftInfosResponse {

            /**
             * Constructs a new TokenGetAccountNftInfosResponse.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenGetAccountNftInfosResponse);

            /**
             * Standard response from node to client, including the requested fields: cost, or state proof,
             * or both, or neither
             */
            public header?: (hashgraph.proto.IResponseHeader|null);

            /** List of NFTs associated to the account */
            public nfts: hashgraph.proto.ITokenNftInfo[];

            /**
             * Creates a new TokenGetAccountNftInfosResponse instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenGetAccountNftInfosResponse instance
             */
            public static create(properties?: hashgraph.proto.ITokenGetAccountNftInfosResponse): hashgraph.proto.TokenGetAccountNftInfosResponse;

            /**
             * Encodes the specified TokenGetAccountNftInfosResponse message. Does not implicitly {@link hashgraph.proto.TokenGetAccountNftInfosResponse.verify|verify} messages.
             * @param m TokenGetAccountNftInfosResponse message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenGetAccountNftInfosResponse, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenGetAccountNftInfosResponse message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenGetAccountNftInfosResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenGetAccountNftInfosResponse;

            /**
             * Gets the default type url for TokenGetAccountNftInfosResponse
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a NftID. */
        interface INftID {

            /** The (non-fungible) token of which this NFT is an instance */
            tokenID?: (hashgraph.proto.ITokenID|null);

            /** The unique identifier of this instance */
            serialNumber?: (Long|null);
        }

        /** Represents an NFT on the Ledger */
        class NftID implements INftID {

            /**
             * Constructs a new NftID.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.INftID);

            /** The (non-fungible) token of which this NFT is an instance */
            public tokenID?: (hashgraph.proto.ITokenID|null);

            /** The unique identifier of this instance */
            public serialNumber: Long;

            /**
             * Creates a new NftID instance using the specified properties.
             * @param [properties] Properties to set
             * @returns NftID instance
             */
            public static create(properties?: hashgraph.proto.INftID): hashgraph.proto.NftID;

            /**
             * Encodes the specified NftID message. Does not implicitly {@link hashgraph.proto.NftID.verify|verify} messages.
             * @param m NftID message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.INftID, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a NftID message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns NftID
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.NftID;

            /**
             * Gets the default type url for NftID
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenGetNftInfoQuery. */
        interface ITokenGetNftInfoQuery {

            /**
             * Standard info sent from client to node, including the signed payment, and what kind of
             * response is requested (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IQueryHeader|null);

            /** The ID of the NFT */
            nftID?: (hashgraph.proto.INftID|null);
        }

        /**
         * Applicable only to tokens of type NON_FUNGIBLE_UNIQUE. Gets info on a NFT for a given TokenID (of
         * type NON_FUNGIBLE_UNIQUE) and serial number
         */
        class TokenGetNftInfoQuery implements ITokenGetNftInfoQuery {

            /**
             * Constructs a new TokenGetNftInfoQuery.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenGetNftInfoQuery);

            /**
             * Standard info sent from client to node, including the signed payment, and what kind of
             * response is requested (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IQueryHeader|null);

            /** The ID of the NFT */
            public nftID?: (hashgraph.proto.INftID|null);

            /**
             * Creates a new TokenGetNftInfoQuery instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenGetNftInfoQuery instance
             */
            public static create(properties?: hashgraph.proto.ITokenGetNftInfoQuery): hashgraph.proto.TokenGetNftInfoQuery;

            /**
             * Encodes the specified TokenGetNftInfoQuery message. Does not implicitly {@link hashgraph.proto.TokenGetNftInfoQuery.verify|verify} messages.
             * @param m TokenGetNftInfoQuery message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenGetNftInfoQuery, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenGetNftInfoQuery message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenGetNftInfoQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenGetNftInfoQuery;

            /**
             * Gets the default type url for TokenGetNftInfoQuery
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenNftInfo. */
        interface ITokenNftInfo {

            /** The ID of the NFT */
            nftID?: (hashgraph.proto.INftID|null);

            /** The current owner of the NFT */
            accountID?: (hashgraph.proto.IAccountID|null);

            /** The effective consensus timestamp at which the NFT was minted */
            creationTime?: (hashgraph.proto.ITimestamp|null);

            /** Represents the unique metadata of the NFT */
            metadata?: (Uint8Array|null);

            /** The ledger ID the response was returned from; please see <a href="https://github.com/hashgraph/hedera-improvement-proposal/blob/master/HIP/hip-198.md">HIP-198</a> for the network-specific IDs. */
            ledgerId?: (Uint8Array|null);

            /** If an allowance is granted for the NFT, its corresponding spender account */
            spenderId?: (hashgraph.proto.IAccountID|null);
        }

        /** UNDOCUMENTED */
        class TokenNftInfo implements ITokenNftInfo {

            /**
             * Constructs a new TokenNftInfo.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenNftInfo);

            /** The ID of the NFT */
            public nftID?: (hashgraph.proto.INftID|null);

            /** The current owner of the NFT */
            public accountID?: (hashgraph.proto.IAccountID|null);

            /** The effective consensus timestamp at which the NFT was minted */
            public creationTime?: (hashgraph.proto.ITimestamp|null);

            /** Represents the unique metadata of the NFT */
            public metadata: Uint8Array;

            /** The ledger ID the response was returned from; please see <a href="https://github.com/hashgraph/hedera-improvement-proposal/blob/master/HIP/hip-198.md">HIP-198</a> for the network-specific IDs. */
            public ledgerId: Uint8Array;

            /** If an allowance is granted for the NFT, its corresponding spender account */
            public spenderId?: (hashgraph.proto.IAccountID|null);

            /**
             * Creates a new TokenNftInfo instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenNftInfo instance
             */
            public static create(properties?: hashgraph.proto.ITokenNftInfo): hashgraph.proto.TokenNftInfo;

            /**
             * Encodes the specified TokenNftInfo message. Does not implicitly {@link hashgraph.proto.TokenNftInfo.verify|verify} messages.
             * @param m TokenNftInfo message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenNftInfo, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenNftInfo message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenNftInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenNftInfo;

            /**
             * Gets the default type url for TokenNftInfo
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenGetNftInfoResponse. */
        interface ITokenGetNftInfoResponse {

            /**
             * Standard response from node to client, including the requested fields: cost, or state proof,
             * or both, or neither
             */
            header?: (hashgraph.proto.IResponseHeader|null);

            /** The information about this NFT */
            nft?: (hashgraph.proto.ITokenNftInfo|null);
        }

        /** UNDOCUMENTED */
        class TokenGetNftInfoResponse implements ITokenGetNftInfoResponse {

            /**
             * Constructs a new TokenGetNftInfoResponse.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenGetNftInfoResponse);

            /**
             * Standard response from node to client, including the requested fields: cost, or state proof,
             * or both, or neither
             */
            public header?: (hashgraph.proto.IResponseHeader|null);

            /** The information about this NFT */
            public nft?: (hashgraph.proto.ITokenNftInfo|null);

            /**
             * Creates a new TokenGetNftInfoResponse instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenGetNftInfoResponse instance
             */
            public static create(properties?: hashgraph.proto.ITokenGetNftInfoResponse): hashgraph.proto.TokenGetNftInfoResponse;

            /**
             * Encodes the specified TokenGetNftInfoResponse message. Does not implicitly {@link hashgraph.proto.TokenGetNftInfoResponse.verify|verify} messages.
             * @param m TokenGetNftInfoResponse message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenGetNftInfoResponse, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenGetNftInfoResponse message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenGetNftInfoResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenGetNftInfoResponse;

            /**
             * Gets the default type url for TokenGetNftInfoResponse
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenGetNftInfosQuery. */
        interface ITokenGetNftInfosQuery {

            /**
             * Standard info sent from client to node, including the signed payment, and what kind of
             * response is requested (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IQueryHeader|null);

            /** The ID of the token for which information is requested */
            tokenID?: (hashgraph.proto.ITokenID|null);

            /**
             * Specifies the start index (inclusive) of the range of NFTs to query for. Value must be in the
             * range [0; ownedNFTs-1]
             */
            start?: (Long|null);

            /**
             * Specifies the end index (exclusive) of the range of NFTs to query for. Value must be in the
             * range (start; ownedNFTs]
             */
            end?: (Long|null);
        }

        /**
         * Applicable only to tokens of type NON_FUNGIBLE_UNIQUE. Gets info on NFTs N through M on the list
         * of NFTs associated with a given NON_FUNGIBLE_UNIQUE Token.
         * Example: If there are 10 NFTs issued, having start=0 and end=5 will query for the first 5 NFTs.
         * Querying +all 10 NFTs will require start=0 and end=10
         *
         * INVALID_QUERY_RANGE response code will be returned if:
         * 1) Start > End
         * 2) Start and End indices are non-positive
         * 3) Start and End indices are out of boundaries for the retrieved nft list
         * 4) The range between Start and End is bigger than the global dynamic property for maximum query
         * range
         *
         * NOT_SUPPORTED response code will be returned if the queried token is of type FUNGIBLE_COMMON
         *
         * INVALID_TOKEN_ID response code will be returned if the queried token does not exist
         */
        class TokenGetNftInfosQuery implements ITokenGetNftInfosQuery {

            /**
             * Constructs a new TokenGetNftInfosQuery.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenGetNftInfosQuery);

            /**
             * Standard info sent from client to node, including the signed payment, and what kind of
             * response is requested (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IQueryHeader|null);

            /** The ID of the token for which information is requested */
            public tokenID?: (hashgraph.proto.ITokenID|null);

            /**
             * Specifies the start index (inclusive) of the range of NFTs to query for. Value must be in the
             * range [0; ownedNFTs-1]
             */
            public start: Long;

            /**
             * Specifies the end index (exclusive) of the range of NFTs to query for. Value must be in the
             * range (start; ownedNFTs]
             */
            public end: Long;

            /**
             * Creates a new TokenGetNftInfosQuery instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenGetNftInfosQuery instance
             */
            public static create(properties?: hashgraph.proto.ITokenGetNftInfosQuery): hashgraph.proto.TokenGetNftInfosQuery;

            /**
             * Encodes the specified TokenGetNftInfosQuery message. Does not implicitly {@link hashgraph.proto.TokenGetNftInfosQuery.verify|verify} messages.
             * @param m TokenGetNftInfosQuery message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenGetNftInfosQuery, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenGetNftInfosQuery message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenGetNftInfosQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenGetNftInfosQuery;

            /**
             * Gets the default type url for TokenGetNftInfosQuery
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TokenGetNftInfosResponse. */
        interface ITokenGetNftInfosResponse {

            /**
             * Standard response from node to client, including the requested fields: cost, or state proof,
             * or both, or neither
             */
            header?: (hashgraph.proto.IResponseHeader|null);

            /** The Token with type NON_FUNGIBLE that this record is for */
            tokenID?: (hashgraph.proto.ITokenID|null);

            /** List of NFTs associated to the specified token */
            nfts?: (hashgraph.proto.ITokenNftInfo[]|null);
        }

        /** Represents a TokenGetNftInfosResponse. */
        class TokenGetNftInfosResponse implements ITokenGetNftInfosResponse {

            /**
             * Constructs a new TokenGetNftInfosResponse.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenGetNftInfosResponse);

            /**
             * Standard response from node to client, including the requested fields: cost, or state proof,
             * or both, or neither
             */
            public header?: (hashgraph.proto.IResponseHeader|null);

            /** The Token with type NON_FUNGIBLE that this record is for */
            public tokenID?: (hashgraph.proto.ITokenID|null);

            /** List of NFTs associated to the specified token */
            public nfts: hashgraph.proto.ITokenNftInfo[];

            /**
             * Creates a new TokenGetNftInfosResponse instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenGetNftInfosResponse instance
             */
            public static create(properties?: hashgraph.proto.ITokenGetNftInfosResponse): hashgraph.proto.TokenGetNftInfosResponse;

            /**
             * Encodes the specified TokenGetNftInfosResponse message. Does not implicitly {@link hashgraph.proto.TokenGetNftInfosResponse.verify|verify} messages.
             * @param m TokenGetNftInfosResponse message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenGetNftInfosResponse, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenGetNftInfosResponse message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenGetNftInfosResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenGetNftInfosResponse;

            /**
             * Gets the default type url for TokenGetNftInfosResponse
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a GetAccountDetailsQuery. */
        interface IGetAccountDetailsQuery {

            /**
             * Account details sent from client to node, including the signed payment, and what kind of
             * response is requested (cost, state proof, both, or neither).
             */
            header?: (hashgraph.proto.IQueryHeader|null);

            /** The account ID for which information is requested */
            accountId?: (hashgraph.proto.IAccountID|null);
        }

        /**
         * Gets all the information about an account, including balance and allowances. This does not get the list of
         * account records.
         */
        class GetAccountDetailsQuery implements IGetAccountDetailsQuery {

            /**
             * Constructs a new GetAccountDetailsQuery.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IGetAccountDetailsQuery);

            /**
             * Account details sent from client to node, including the signed payment, and what kind of
             * response is requested (cost, state proof, both, or neither).
             */
            public header?: (hashgraph.proto.IQueryHeader|null);

            /** The account ID for which information is requested */
            public accountId?: (hashgraph.proto.IAccountID|null);

            /**
             * Creates a new GetAccountDetailsQuery instance using the specified properties.
             * @param [properties] Properties to set
             * @returns GetAccountDetailsQuery instance
             */
            public static create(properties?: hashgraph.proto.IGetAccountDetailsQuery): hashgraph.proto.GetAccountDetailsQuery;

            /**
             * Encodes the specified GetAccountDetailsQuery message. Does not implicitly {@link hashgraph.proto.GetAccountDetailsQuery.verify|verify} messages.
             * @param m GetAccountDetailsQuery message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IGetAccountDetailsQuery, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a GetAccountDetailsQuery message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns GetAccountDetailsQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.GetAccountDetailsQuery;

            /**
             * Gets the default type url for GetAccountDetailsQuery
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a GetAccountDetailsResponse. */
        interface IGetAccountDetailsResponse {

            /**
             * Standard response from node to client, including the requested fields: cost, or state proof,
             * or both, or neither
             */
            header?: (hashgraph.proto.IResponseHeader|null);

            /** Details of the account (a state proof can be generated for this) */
            accountDetails?: (hashgraph.proto.GetAccountDetailsResponse.IAccountDetails|null);
        }

        /** Response when the client sends the node GetAccountDetailsQuery */
        class GetAccountDetailsResponse implements IGetAccountDetailsResponse {

            /**
             * Constructs a new GetAccountDetailsResponse.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IGetAccountDetailsResponse);

            /**
             * Standard response from node to client, including the requested fields: cost, or state proof,
             * or both, or neither
             */
            public header?: (hashgraph.proto.IResponseHeader|null);

            /** Details of the account (a state proof can be generated for this) */
            public accountDetails?: (hashgraph.proto.GetAccountDetailsResponse.IAccountDetails|null);

            /**
             * Creates a new GetAccountDetailsResponse instance using the specified properties.
             * @param [properties] Properties to set
             * @returns GetAccountDetailsResponse instance
             */
            public static create(properties?: hashgraph.proto.IGetAccountDetailsResponse): hashgraph.proto.GetAccountDetailsResponse;

            /**
             * Encodes the specified GetAccountDetailsResponse message. Does not implicitly {@link hashgraph.proto.GetAccountDetailsResponse.verify|verify} messages.
             * @param m GetAccountDetailsResponse message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IGetAccountDetailsResponse, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a GetAccountDetailsResponse message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns GetAccountDetailsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.GetAccountDetailsResponse;

            /**
             * Gets the default type url for GetAccountDetailsResponse
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        namespace GetAccountDetailsResponse {

            /** Properties of an AccountDetails. */
            interface IAccountDetails {

                /** The account ID for which this information applies */
                accountId?: (hashgraph.proto.IAccountID|null);

                /**
                 * The Contract Account ID comprising of both the contract instance and the cryptocurrency
                 * account owned by the contract instance, in the format used by Solidity
                 */
                contractAccountId?: (string|null);

                /**
                 * If true, then this account has been deleted, it will disappear when it expires, and all
                 * transactions for it will fail except the transaction to extend its expiration date
                 */
                deleted?: (boolean|null);

                /**
                 * [Deprecated] The Account ID of the account to which this is proxy staked. If proxyAccountID is null,
                 * or is an invalid account, or is an account that isn't a node, then this account is
                 * automatically proxy staked to a node chosen by the network, but without earning payments.
                 * If the proxyAccountID account refuses to accept proxy staking , or if it is not currently
                 * running a node, then it will behave as if proxyAccountID was null.
                 */
                proxyAccountId?: (hashgraph.proto.IAccountID|null);

                /** The total number of tinybars proxy staked to this account */
                proxyReceived?: (Long|null);

                /**
                 * The key for the account, which must sign in order to transfer out, or to modify the
                 * account in any way other than extending its expiration date.
                 */
                key?: (hashgraph.proto.IKey|null);

                /** The current balance of account in tinybars */
                balance?: (Long|null);

                /** If true, no transaction can transfer to this account unless signed by this account's key */
                receiverSigRequired?: (boolean|null);

                /** The TimeStamp time at which this account is set to expire */
                expirationTime?: (hashgraph.proto.ITimestamp|null);

                /**
                 * The duration for expiration time will extend every this many seconds. If there are
                 * insufficient funds, then it extends as long as possible. If it is empty when it expires,
                 * then it is deleted.
                 */
                autoRenewPeriod?: (hashgraph.proto.IDuration|null);

                /** All tokens related to this account */
                tokenRelationships?: (hashgraph.proto.ITokenRelationship[]|null);

                /** The memo associated with the account */
                memo?: (string|null);

                /** The number of NFTs owned by this account */
                ownedNfts?: (Long|null);

                /** The maximum number of tokens that an Account can be implicitly associated with. */
                maxAutomaticTokenAssociations?: (number|null);

                /** The alias of this account */
                alias?: (Uint8Array|null);

                /** The ledger ID the response was returned from; please see <a href="https://github.com/hashgraph/hedera-improvement-proposal/blob/master/HIP/hip-198.md">HIP-198</a> for the network-specific IDs. */
                ledgerId?: (Uint8Array|null);

                /** All of the hbar allowances approved by the account owner. */
                grantedCryptoAllowances?: (hashgraph.proto.IGrantedCryptoAllowance[]|null);

                /** All of the non-fungible token allowances approved by the account owner. */
                grantedNftAllowances?: (hashgraph.proto.IGrantedNftAllowance[]|null);

                /** All of the fungible token allowances approved by the account owner. */
                grantedTokenAllowances?: (hashgraph.proto.IGrantedTokenAllowance[]|null);
            }

            /** Represents an AccountDetails. */
            class AccountDetails implements IAccountDetails {

                /**
                 * Constructs a new AccountDetails.
                 * @param [p] Properties to set
                 */
                constructor(p?: hashgraph.proto.GetAccountDetailsResponse.IAccountDetails);

                /** The account ID for which this information applies */
                public accountId?: (hashgraph.proto.IAccountID|null);

                /**
                 * The Contract Account ID comprising of both the contract instance and the cryptocurrency
                 * account owned by the contract instance, in the format used by Solidity
                 */
                public contractAccountId: string;

                /**
                 * If true, then this account has been deleted, it will disappear when it expires, and all
                 * transactions for it will fail except the transaction to extend its expiration date
                 */
                public deleted: boolean;

                /**
                 * [Deprecated] The Account ID of the account to which this is proxy staked. If proxyAccountID is null,
                 * or is an invalid account, or is an account that isn't a node, then this account is
                 * automatically proxy staked to a node chosen by the network, but without earning payments.
                 * If the proxyAccountID account refuses to accept proxy staking , or if it is not currently
                 * running a node, then it will behave as if proxyAccountID was null.
                 */
                public proxyAccountId?: (hashgraph.proto.IAccountID|null);

                /** The total number of tinybars proxy staked to this account */
                public proxyReceived: Long;

                /**
                 * The key for the account, which must sign in order to transfer out, or to modify the
                 * account in any way other than extending its expiration date.
                 */
                public key?: (hashgraph.proto.IKey|null);

                /** The current balance of account in tinybars */
                public balance: Long;

                /** If true, no transaction can transfer to this account unless signed by this account's key */
                public receiverSigRequired: boolean;

                /** The TimeStamp time at which this account is set to expire */
                public expirationTime?: (hashgraph.proto.ITimestamp|null);

                /**
                 * The duration for expiration time will extend every this many seconds. If there are
                 * insufficient funds, then it extends as long as possible. If it is empty when it expires,
                 * then it is deleted.
                 */
                public autoRenewPeriod?: (hashgraph.proto.IDuration|null);

                /** All tokens related to this account */
                public tokenRelationships: hashgraph.proto.ITokenRelationship[];

                /** The memo associated with the account */
                public memo: string;

                /** The number of NFTs owned by this account */
                public ownedNfts: Long;

                /** The maximum number of tokens that an Account can be implicitly associated with. */
                public maxAutomaticTokenAssociations: number;

                /** The alias of this account */
                public alias: Uint8Array;

                /** The ledger ID the response was returned from; please see <a href="https://github.com/hashgraph/hedera-improvement-proposal/blob/master/HIP/hip-198.md">HIP-198</a> for the network-specific IDs. */
                public ledgerId: Uint8Array;

                /** All of the hbar allowances approved by the account owner. */
                public grantedCryptoAllowances: hashgraph.proto.IGrantedCryptoAllowance[];

                /** All of the non-fungible token allowances approved by the account owner. */
                public grantedNftAllowances: hashgraph.proto.IGrantedNftAllowance[];

                /** All of the fungible token allowances approved by the account owner. */
                public grantedTokenAllowances: hashgraph.proto.IGrantedTokenAllowance[];

                /**
                 * Creates a new AccountDetails instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns AccountDetails instance
                 */
                public static create(properties?: hashgraph.proto.GetAccountDetailsResponse.IAccountDetails): hashgraph.proto.GetAccountDetailsResponse.AccountDetails;

                /**
                 * Encodes the specified AccountDetails message. Does not implicitly {@link hashgraph.proto.GetAccountDetailsResponse.AccountDetails.verify|verify} messages.
                 * @param m AccountDetails message or plain object to encode
                 * @param [w] Writer to encode to
                 * @returns Writer
                 */
                public static encode(m: hashgraph.proto.GetAccountDetailsResponse.IAccountDetails, w?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an AccountDetails message from the specified reader or buffer.
                 * @param r Reader or buffer to decode from
                 * @param [l] Message length if known beforehand
                 * @returns AccountDetails
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.GetAccountDetailsResponse.AccountDetails;

                /**
                 * Gets the default type url for AccountDetails
                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns The default type url
                 */
                public static getTypeUrl(typeUrlPrefix?: string): string;
            }
        }

        /** Properties of a GrantedCryptoAllowance. */
        interface IGrantedCryptoAllowance {

            /** The account ID of the spender of the hbar allowance. */
            spender?: (hashgraph.proto.IAccountID|null);

            /** The amount of the spender's allowance in tinybars. */
            amount?: (Long|null);
        }

        /** A granted allowance of hbar transfers for a spender relative to the owner account. */
        class GrantedCryptoAllowance implements IGrantedCryptoAllowance {

            /**
             * Constructs a new GrantedCryptoAllowance.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IGrantedCryptoAllowance);

            /** The account ID of the spender of the hbar allowance. */
            public spender?: (hashgraph.proto.IAccountID|null);

            /** The amount of the spender's allowance in tinybars. */
            public amount: Long;

            /**
             * Creates a new GrantedCryptoAllowance instance using the specified properties.
             * @param [properties] Properties to set
             * @returns GrantedCryptoAllowance instance
             */
            public static create(properties?: hashgraph.proto.IGrantedCryptoAllowance): hashgraph.proto.GrantedCryptoAllowance;

            /**
             * Encodes the specified GrantedCryptoAllowance message. Does not implicitly {@link hashgraph.proto.GrantedCryptoAllowance.verify|verify} messages.
             * @param m GrantedCryptoAllowance message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IGrantedCryptoAllowance, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a GrantedCryptoAllowance message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns GrantedCryptoAllowance
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.GrantedCryptoAllowance;

            /**
             * Gets the default type url for GrantedCryptoAllowance
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a GrantedNftAllowance. */
        interface IGrantedNftAllowance {

            /** The token that the allowance pertains to. */
            tokenId?: (hashgraph.proto.ITokenID|null);

            /** The account ID of the spender that has been granted access to all NFTs of the owner */
            spender?: (hashgraph.proto.IAccountID|null);
        }

        /** A granted allowance for all the NFTs of a token for a spender relative to the owner account. */
        class GrantedNftAllowance implements IGrantedNftAllowance {

            /**
             * Constructs a new GrantedNftAllowance.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IGrantedNftAllowance);

            /** The token that the allowance pertains to. */
            public tokenId?: (hashgraph.proto.ITokenID|null);

            /** The account ID of the spender that has been granted access to all NFTs of the owner */
            public spender?: (hashgraph.proto.IAccountID|null);

            /**
             * Creates a new GrantedNftAllowance instance using the specified properties.
             * @param [properties] Properties to set
             * @returns GrantedNftAllowance instance
             */
            public static create(properties?: hashgraph.proto.IGrantedNftAllowance): hashgraph.proto.GrantedNftAllowance;

            /**
             * Encodes the specified GrantedNftAllowance message. Does not implicitly {@link hashgraph.proto.GrantedNftAllowance.verify|verify} messages.
             * @param m GrantedNftAllowance message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IGrantedNftAllowance, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a GrantedNftAllowance message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns GrantedNftAllowance
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.GrantedNftAllowance;

            /**
             * Gets the default type url for GrantedNftAllowance
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a GrantedTokenAllowance. */
        interface IGrantedTokenAllowance {

            /** The token that the allowance pertains to. */
            tokenId?: (hashgraph.proto.ITokenID|null);

            /** The account ID of the token allowance spender. */
            spender?: (hashgraph.proto.IAccountID|null);

            /** The amount of the spender's token allowance. */
            amount?: (Long|null);
        }

        /** A granted allowance of fungible token transfers for a spender relative to the owner account. */
        class GrantedTokenAllowance implements IGrantedTokenAllowance {

            /**
             * Constructs a new GrantedTokenAllowance.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IGrantedTokenAllowance);

            /** The token that the allowance pertains to. */
            public tokenId?: (hashgraph.proto.ITokenID|null);

            /** The account ID of the token allowance spender. */
            public spender?: (hashgraph.proto.IAccountID|null);

            /** The amount of the spender's token allowance. */
            public amount: Long;

            /**
             * Creates a new GrantedTokenAllowance instance using the specified properties.
             * @param [properties] Properties to set
             * @returns GrantedTokenAllowance instance
             */
            public static create(properties?: hashgraph.proto.IGrantedTokenAllowance): hashgraph.proto.GrantedTokenAllowance;

            /**
             * Encodes the specified GrantedTokenAllowance message. Does not implicitly {@link hashgraph.proto.GrantedTokenAllowance.verify|verify} messages.
             * @param m GrantedTokenAllowance message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IGrantedTokenAllowance, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a GrantedTokenAllowance message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns GrantedTokenAllowance
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.GrantedTokenAllowance;

            /**
             * Gets the default type url for GrantedTokenAllowance
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a Response. */
        interface IResponse {

            /** Get all entities associated with a given key */
            getByKey?: (hashgraph.proto.IGetByKeyResponse|null);

            /** Get the IDs in the format used in transactions, given the format used in Solidity */
            getBySolidityID?: (hashgraph.proto.IGetBySolidityIDResponse|null);

            /** Response to call a function of a smart contract instance */
            contractCallLocal?: (hashgraph.proto.IContractCallLocalResponse|null);

            /** Get the runtime code for a smart contract instance */
            contractGetBytecodeResponse?: (hashgraph.proto.IContractGetBytecodeResponse|null);

            /** Get information about a smart contract instance */
            contractGetInfo?: (hashgraph.proto.IContractGetInfoResponse|null);

            /** Get all existing records for a smart contract instance */
            contractGetRecordsResponse?: (hashgraph.proto.IContractGetRecordsResponse|null);

            /** Get the current balance in a cryptocurrency account */
            cryptogetAccountBalance?: (hashgraph.proto.ICryptoGetAccountBalanceResponse|null);

            /** Get all the records that currently exist for transactions involving an account */
            cryptoGetAccountRecords?: (hashgraph.proto.ICryptoGetAccountRecordsResponse|null);

            /** Get all information about an account */
            cryptoGetInfo?: (hashgraph.proto.ICryptoGetInfoResponse|null);

            /** Contains a livehash associated to an account */
            cryptoGetLiveHash?: (hashgraph.proto.ICryptoGetLiveHashResponse|null);

            /** Get all the accounts that proxy stake to a given account, and how much they proxy stake */
            cryptoGetProxyStakers?: (hashgraph.proto.ICryptoGetStakersResponse|null);

            /** Get the contents of a file (the bytes stored in it) */
            fileGetContents?: (hashgraph.proto.IFileGetContentsResponse|null);

            /** Get information about a file, such as its expiration date */
            fileGetInfo?: (hashgraph.proto.IFileGetInfoResponse|null);

            /** Get a receipt for a transaction */
            transactionGetReceipt?: (hashgraph.proto.ITransactionGetReceiptResponse|null);

            /** Get a record for a transaction */
            transactionGetRecord?: (hashgraph.proto.ITransactionGetRecordResponse|null);

            /** Get a record for a transaction (lasts 180 seconds) */
            transactionGetFastRecord?: (hashgraph.proto.ITransactionGetFastRecordResponse|null);

            /** Parameters of and state of a consensus topic.. */
            consensusGetTopicInfo?: (hashgraph.proto.IConsensusGetTopicInfoResponse|null);

            /** Semantic versions of Hedera Services and HAPI proto */
            networkGetVersionInfo?: (hashgraph.proto.INetworkGetVersionInfoResponse|null);

            /** Get all information about a token */
            tokenGetInfo?: (hashgraph.proto.ITokenGetInfoResponse|null);

            /** Get all information about a schedule entity */
            scheduleGetInfo?: (hashgraph.proto.IScheduleGetInfoResponse|null);

            /** A list of the NFTs associated with the account */
            tokenGetAccountNftInfos?: (hashgraph.proto.ITokenGetAccountNftInfosResponse|null);

            /** All information about an NFT */
            tokenGetNftInfo?: (hashgraph.proto.ITokenGetNftInfoResponse|null);

            /** A list of the NFTs for the token */
            tokenGetNftInfos?: (hashgraph.proto.ITokenGetNftInfosResponse|null);

            /** Execution times of "sufficiently recent" transactions */
            networkGetExecutionTime?: (hashgraph.proto.INetworkGetExecutionTimeResponse|null);

            /** Gets all information about an account including allowances granted by the account */
            accountDetails?: (hashgraph.proto.IGetAccountDetailsResponse|null);
        }

        /**
         * A single response, which is returned from the node to the client, after the client sent the node
         * a query. This includes all responses.
         */
        class Response implements IResponse {

            /**
             * Constructs a new Response.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IResponse);

            /** Get all entities associated with a given key */
            public getByKey?: (hashgraph.proto.IGetByKeyResponse|null);

            /** Get the IDs in the format used in transactions, given the format used in Solidity */
            public getBySolidityID?: (hashgraph.proto.IGetBySolidityIDResponse|null);

            /** Response to call a function of a smart contract instance */
            public contractCallLocal?: (hashgraph.proto.IContractCallLocalResponse|null);

            /** Get the runtime code for a smart contract instance */
            public contractGetBytecodeResponse?: (hashgraph.proto.IContractGetBytecodeResponse|null);

            /** Get information about a smart contract instance */
            public contractGetInfo?: (hashgraph.proto.IContractGetInfoResponse|null);

            /** Get all existing records for a smart contract instance */
            public contractGetRecordsResponse?: (hashgraph.proto.IContractGetRecordsResponse|null);

            /** Get the current balance in a cryptocurrency account */
            public cryptogetAccountBalance?: (hashgraph.proto.ICryptoGetAccountBalanceResponse|null);

            /** Get all the records that currently exist for transactions involving an account */
            public cryptoGetAccountRecords?: (hashgraph.proto.ICryptoGetAccountRecordsResponse|null);

            /** Get all information about an account */
            public cryptoGetInfo?: (hashgraph.proto.ICryptoGetInfoResponse|null);

            /** Contains a livehash associated to an account */
            public cryptoGetLiveHash?: (hashgraph.proto.ICryptoGetLiveHashResponse|null);

            /** Get all the accounts that proxy stake to a given account, and how much they proxy stake */
            public cryptoGetProxyStakers?: (hashgraph.proto.ICryptoGetStakersResponse|null);

            /** Get the contents of a file (the bytes stored in it) */
            public fileGetContents?: (hashgraph.proto.IFileGetContentsResponse|null);

            /** Get information about a file, such as its expiration date */
            public fileGetInfo?: (hashgraph.proto.IFileGetInfoResponse|null);

            /** Get a receipt for a transaction */
            public transactionGetReceipt?: (hashgraph.proto.ITransactionGetReceiptResponse|null);

            /** Get a record for a transaction */
            public transactionGetRecord?: (hashgraph.proto.ITransactionGetRecordResponse|null);

            /** Get a record for a transaction (lasts 180 seconds) */
            public transactionGetFastRecord?: (hashgraph.proto.ITransactionGetFastRecordResponse|null);

            /** Parameters of and state of a consensus topic.. */
            public consensusGetTopicInfo?: (hashgraph.proto.IConsensusGetTopicInfoResponse|null);

            /** Semantic versions of Hedera Services and HAPI proto */
            public networkGetVersionInfo?: (hashgraph.proto.INetworkGetVersionInfoResponse|null);

            /** Get all information about a token */
            public tokenGetInfo?: (hashgraph.proto.ITokenGetInfoResponse|null);

            /** Get all information about a schedule entity */
            public scheduleGetInfo?: (hashgraph.proto.IScheduleGetInfoResponse|null);

            /** A list of the NFTs associated with the account */
            public tokenGetAccountNftInfos?: (hashgraph.proto.ITokenGetAccountNftInfosResponse|null);

            /** All information about an NFT */
            public tokenGetNftInfo?: (hashgraph.proto.ITokenGetNftInfoResponse|null);

            /** A list of the NFTs for the token */
            public tokenGetNftInfos?: (hashgraph.proto.ITokenGetNftInfosResponse|null);

            /** Execution times of "sufficiently recent" transactions */
            public networkGetExecutionTime?: (hashgraph.proto.INetworkGetExecutionTimeResponse|null);

            /** Gets all information about an account including allowances granted by the account */
            public accountDetails?: (hashgraph.proto.IGetAccountDetailsResponse|null);

            /** Response response. */
            public response?: ("getByKey"|"getBySolidityID"|"contractCallLocal"|"contractGetBytecodeResponse"|"contractGetInfo"|"contractGetRecordsResponse"|"cryptogetAccountBalance"|"cryptoGetAccountRecords"|"cryptoGetInfo"|"cryptoGetLiveHash"|"cryptoGetProxyStakers"|"fileGetContents"|"fileGetInfo"|"transactionGetReceipt"|"transactionGetRecord"|"transactionGetFastRecord"|"consensusGetTopicInfo"|"networkGetVersionInfo"|"tokenGetInfo"|"scheduleGetInfo"|"tokenGetAccountNftInfos"|"tokenGetNftInfo"|"tokenGetNftInfos"|"networkGetExecutionTime"|"accountDetails");

            /**
             * Creates a new Response instance using the specified properties.
             * @param [properties] Properties to set
             * @returns Response instance
             */
            public static create(properties?: hashgraph.proto.IResponse): hashgraph.proto.Response;

            /**
             * Encodes the specified Response message. Does not implicitly {@link hashgraph.proto.Response.verify|verify} messages.
             * @param m Response message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IResponse, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a Response message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns Response
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.Response;

            /**
             * Gets the default type url for Response
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Transactions and queries for the Crypto Service */
        class CryptoService extends $protobuf.rpc.Service {

            /**
             * Constructs a new CryptoService service.
             * @param rpcImpl RPC implementation
             * @param [requestDelimited=false] Whether requests are length-delimited
             * @param [responseDelimited=false] Whether responses are length-delimited
             */
            constructor(rpcImpl: $protobuf.RPCImpl, requestDelimited?: boolean, responseDelimited?: boolean);

            /**
             * Creates new CryptoService service using the specified rpc implementation.
             * @param rpcImpl RPC implementation
             * @param [requestDelimited=false] Whether requests are length-delimited
             * @param [responseDelimited=false] Whether responses are length-delimited
             * @returns RPC service. Useful where requests and/or responses are streamed.
             */
            public static create(rpcImpl: $protobuf.RPCImpl, requestDelimited?: boolean, responseDelimited?: boolean): CryptoService;

            /**
             * Creates a new account by submitting the transaction
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public createAccount(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.CryptoService.createAccountCallback): void;

            /**
             * Creates a new account by submitting the transaction
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public createAccount(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Updates an account by submitting the transaction
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public updateAccount(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.CryptoService.updateAccountCallback): void;

            /**
             * Updates an account by submitting the transaction
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public updateAccount(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Initiates a transfer by submitting the transaction
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public cryptoTransfer(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.CryptoService.cryptoTransferCallback): void;

            /**
             * Initiates a transfer by submitting the transaction
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public cryptoTransfer(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Deletes and account by submitting the transaction
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public cryptoDelete(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.CryptoService.cryptoDeleteCallback): void;

            /**
             * Deletes and account by submitting the transaction
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public cryptoDelete(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Adds one or more approved allowances for spenders to transfer the paying account's hbar or tokens.
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public approveAllowances(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.CryptoService.approveAllowancesCallback): void;

            /**
             * Adds one or more approved allowances for spenders to transfer the paying account's hbar or tokens.
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public approveAllowances(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Deletes one or more of the specific approved NFT serial numbers on an owner account.
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public deleteAllowances(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.CryptoService.deleteAllowancesCallback): void;

            /**
             * Deletes one or more of the specific approved NFT serial numbers on an owner account.
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public deleteAllowances(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * (NOT CURRENTLY SUPPORTED) Adds a livehash
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public addLiveHash(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.CryptoService.addLiveHashCallback): void;

            /**
             * (NOT CURRENTLY SUPPORTED) Adds a livehash
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public addLiveHash(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * (NOT CURRENTLY SUPPORTED) Deletes a livehash
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public deleteLiveHash(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.CryptoService.deleteLiveHashCallback): void;

            /**
             * (NOT CURRENTLY SUPPORTED) Deletes a livehash
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public deleteLiveHash(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * (NOT CURRENTLY SUPPORTED) Retrieves a livehash for an account
             * @param request Query message or plain object
             * @param callback Node-style callback called with the error, if any, and Response
             */
            public getLiveHash(request: hashgraph.proto.IQuery, callback: hashgraph.proto.CryptoService.getLiveHashCallback): void;

            /**
             * (NOT CURRENTLY SUPPORTED) Retrieves a livehash for an account
             * @param request Query message or plain object
             * @returns Promise
             */
            public getLiveHash(request: hashgraph.proto.IQuery): Promise<hashgraph.proto.Response>;

            /**
             * Returns all transactions in the last 180s of consensus time for which the given account was
             * the effective payer <b>and</b> network property <tt>ledger.keepRecordsInState</tt> was
             * <tt>true</tt>.
             * @param request Query message or plain object
             * @param callback Node-style callback called with the error, if any, and Response
             */
            public getAccountRecords(request: hashgraph.proto.IQuery, callback: hashgraph.proto.CryptoService.getAccountRecordsCallback): void;

            /**
             * Returns all transactions in the last 180s of consensus time for which the given account was
             * the effective payer <b>and</b> network property <tt>ledger.keepRecordsInState</tt> was
             * <tt>true</tt>.
             * @param request Query message or plain object
             * @returns Promise
             */
            public getAccountRecords(request: hashgraph.proto.IQuery): Promise<hashgraph.proto.Response>;

            /**
             * Retrieves the balance of an account
             * @param request Query message or plain object
             * @param callback Node-style callback called with the error, if any, and Response
             */
            public cryptoGetBalance(request: hashgraph.proto.IQuery, callback: hashgraph.proto.CryptoService.cryptoGetBalanceCallback): void;

            /**
             * Retrieves the balance of an account
             * @param request Query message or plain object
             * @returns Promise
             */
            public cryptoGetBalance(request: hashgraph.proto.IQuery): Promise<hashgraph.proto.Response>;

            /**
             * Retrieves the metadata of an account
             * @param request Query message or plain object
             * @param callback Node-style callback called with the error, if any, and Response
             */
            public getAccountInfo(request: hashgraph.proto.IQuery, callback: hashgraph.proto.CryptoService.getAccountInfoCallback): void;

            /**
             * Retrieves the metadata of an account
             * @param request Query message or plain object
             * @returns Promise
             */
            public getAccountInfo(request: hashgraph.proto.IQuery): Promise<hashgraph.proto.Response>;

            /**
             * Retrieves the latest receipt for a transaction that is either awaiting consensus, or reached
             * consensus in the last 180 seconds
             * @param request Query message or plain object
             * @param callback Node-style callback called with the error, if any, and Response
             */
            public getTransactionReceipts(request: hashgraph.proto.IQuery, callback: hashgraph.proto.CryptoService.getTransactionReceiptsCallback): void;

            /**
             * Retrieves the latest receipt for a transaction that is either awaiting consensus, or reached
             * consensus in the last 180 seconds
             * @param request Query message or plain object
             * @returns Promise
             */
            public getTransactionReceipts(request: hashgraph.proto.IQuery): Promise<hashgraph.proto.Response>;

            /**
             * (NOT CURRENTLY SUPPORTED) Returns the records of transactions recently funded by an account
             * @param request Query message or plain object
             * @param callback Node-style callback called with the error, if any, and Response
             */
            public getFastTransactionRecord(request: hashgraph.proto.IQuery, callback: hashgraph.proto.CryptoService.getFastTransactionRecordCallback): void;

            /**
             * (NOT CURRENTLY SUPPORTED) Returns the records of transactions recently funded by an account
             * @param request Query message or plain object
             * @returns Promise
             */
            public getFastTransactionRecord(request: hashgraph.proto.IQuery): Promise<hashgraph.proto.Response>;

            /**
             * Retrieves the record of a transaction that is either awaiting consensus, or reached consensus
             * in the last 180 seconds
             * @param request Query message or plain object
             * @param callback Node-style callback called with the error, if any, and Response
             */
            public getTxRecordByTxID(request: hashgraph.proto.IQuery, callback: hashgraph.proto.CryptoService.getTxRecordByTxIDCallback): void;

            /**
             * Retrieves the record of a transaction that is either awaiting consensus, or reached consensus
             * in the last 180 seconds
             * @param request Query message or plain object
             * @returns Promise
             */
            public getTxRecordByTxID(request: hashgraph.proto.IQuery): Promise<hashgraph.proto.Response>;

            /**
             * (NOT CURRENTLY SUPPORTED) Retrieves the stakers for a node by account id
             * @param request Query message or plain object
             * @param callback Node-style callback called with the error, if any, and Response
             */
            public getStakersByAccountID(request: hashgraph.proto.IQuery, callback: hashgraph.proto.CryptoService.getStakersByAccountIDCallback): void;

            /**
             * (NOT CURRENTLY SUPPORTED) Retrieves the stakers for a node by account id
             * @param request Query message or plain object
             * @returns Promise
             */
            public getStakersByAccountID(request: hashgraph.proto.IQuery): Promise<hashgraph.proto.Response>;
        }

        namespace CryptoService {

            /**
             * Callback as used by {@link hashgraph.proto.CryptoService#createAccount}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type createAccountCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.CryptoService#updateAccount}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type updateAccountCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.CryptoService#cryptoTransfer}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type cryptoTransferCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.CryptoService#cryptoDelete}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type cryptoDeleteCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.CryptoService#approveAllowances}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type approveAllowancesCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.CryptoService#deleteAllowances}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type deleteAllowancesCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.CryptoService#addLiveHash}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type addLiveHashCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.CryptoService#deleteLiveHash}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type deleteLiveHashCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.CryptoService#getLiveHash}.
             * @param error Error, if any
             * @param [response] Response
             */
            type getLiveHashCallback = (error: (Error|null), response?: hashgraph.proto.Response) => void;

            /**
             * Callback as used by {@link hashgraph.proto.CryptoService#getAccountRecords}.
             * @param error Error, if any
             * @param [response] Response
             */
            type getAccountRecordsCallback = (error: (Error|null), response?: hashgraph.proto.Response) => void;

            /**
             * Callback as used by {@link hashgraph.proto.CryptoService#cryptoGetBalance}.
             * @param error Error, if any
             * @param [response] Response
             */
            type cryptoGetBalanceCallback = (error: (Error|null), response?: hashgraph.proto.Response) => void;

            /**
             * Callback as used by {@link hashgraph.proto.CryptoService#getAccountInfo}.
             * @param error Error, if any
             * @param [response] Response
             */
            type getAccountInfoCallback = (error: (Error|null), response?: hashgraph.proto.Response) => void;

            /**
             * Callback as used by {@link hashgraph.proto.CryptoService#getTransactionReceipts}.
             * @param error Error, if any
             * @param [response] Response
             */
            type getTransactionReceiptsCallback = (error: (Error|null), response?: hashgraph.proto.Response) => void;

            /**
             * Callback as used by {@link hashgraph.proto.CryptoService#getFastTransactionRecord}.
             * @param error Error, if any
             * @param [response] Response
             */
            type getFastTransactionRecordCallback = (error: (Error|null), response?: hashgraph.proto.Response) => void;

            /**
             * Callback as used by {@link hashgraph.proto.CryptoService#getTxRecordByTxID}.
             * @param error Error, if any
             * @param [response] Response
             */
            type getTxRecordByTxIDCallback = (error: (Error|null), response?: hashgraph.proto.Response) => void;

            /**
             * Callback as used by {@link hashgraph.proto.CryptoService#getStakersByAccountID}.
             * @param error Error, if any
             * @param [response] Response
             */
            type getStakersByAccountIDCallback = (error: (Error|null), response?: hashgraph.proto.Response) => void;
        }

        /** Transactions and queries for the file service. */
        class FileService extends $protobuf.rpc.Service {

            /**
             * Constructs a new FileService service.
             * @param rpcImpl RPC implementation
             * @param [requestDelimited=false] Whether requests are length-delimited
             * @param [responseDelimited=false] Whether responses are length-delimited
             */
            constructor(rpcImpl: $protobuf.RPCImpl, requestDelimited?: boolean, responseDelimited?: boolean);

            /**
             * Creates new FileService service using the specified rpc implementation.
             * @param rpcImpl RPC implementation
             * @param [requestDelimited=false] Whether requests are length-delimited
             * @param [responseDelimited=false] Whether responses are length-delimited
             * @returns RPC service. Useful where requests and/or responses are streamed.
             */
            public static create(rpcImpl: $protobuf.RPCImpl, requestDelimited?: boolean, responseDelimited?: boolean): FileService;

            /**
             * Creates a file
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public createFile(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.FileService.createFileCallback): void;

            /**
             * Creates a file
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public createFile(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Updates a file
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public updateFile(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.FileService.updateFileCallback): void;

            /**
             * Updates a file
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public updateFile(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Deletes a file
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public deleteFile(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.FileService.deleteFileCallback): void;

            /**
             * Deletes a file
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public deleteFile(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Appends to a file
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public appendContent(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.FileService.appendContentCallback): void;

            /**
             * Appends to a file
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public appendContent(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Retrieves the file contents
             * @param request Query message or plain object
             * @param callback Node-style callback called with the error, if any, and Response
             */
            public getFileContent(request: hashgraph.proto.IQuery, callback: hashgraph.proto.FileService.getFileContentCallback): void;

            /**
             * Retrieves the file contents
             * @param request Query message or plain object
             * @returns Promise
             */
            public getFileContent(request: hashgraph.proto.IQuery): Promise<hashgraph.proto.Response>;

            /**
             * Retrieves the file information
             * @param request Query message or plain object
             * @param callback Node-style callback called with the error, if any, and Response
             */
            public getFileInfo(request: hashgraph.proto.IQuery, callback: hashgraph.proto.FileService.getFileInfoCallback): void;

            /**
             * Retrieves the file information
             * @param request Query message or plain object
             * @returns Promise
             */
            public getFileInfo(request: hashgraph.proto.IQuery): Promise<hashgraph.proto.Response>;

            /**
             * Deletes a file if the submitting account has network admin privileges
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public systemDelete(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.FileService.systemDeleteCallback): void;

            /**
             * Deletes a file if the submitting account has network admin privileges
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public systemDelete(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Undeletes a file if the submitting account has network admin privileges
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public systemUndelete(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.FileService.systemUndeleteCallback): void;

            /**
             * Undeletes a file if the submitting account has network admin privileges
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public systemUndelete(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;
        }

        namespace FileService {

            /**
             * Callback as used by {@link hashgraph.proto.FileService#createFile}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type createFileCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.FileService#updateFile}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type updateFileCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.FileService#deleteFile}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type deleteFileCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.FileService#appendContent}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type appendContentCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.FileService#getFileContent}.
             * @param error Error, if any
             * @param [response] Response
             */
            type getFileContentCallback = (error: (Error|null), response?: hashgraph.proto.Response) => void;

            /**
             * Callback as used by {@link hashgraph.proto.FileService#getFileInfo}.
             * @param error Error, if any
             * @param [response] Response
             */
            type getFileInfoCallback = (error: (Error|null), response?: hashgraph.proto.Response) => void;

            /**
             * Callback as used by {@link hashgraph.proto.FileService#systemDelete}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type systemDeleteCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.FileService#systemUndelete}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type systemUndeleteCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;
        }

        /** The request and responses for freeze service. */
        class FreezeService extends $protobuf.rpc.Service {

            /**
             * Constructs a new FreezeService service.
             * @param rpcImpl RPC implementation
             * @param [requestDelimited=false] Whether requests are length-delimited
             * @param [responseDelimited=false] Whether responses are length-delimited
             */
            constructor(rpcImpl: $protobuf.RPCImpl, requestDelimited?: boolean, responseDelimited?: boolean);

            /**
             * Creates new FreezeService service using the specified rpc implementation.
             * @param rpcImpl RPC implementation
             * @param [requestDelimited=false] Whether requests are length-delimited
             * @param [responseDelimited=false] Whether responses are length-delimited
             * @returns RPC service. Useful where requests and/or responses are streamed.
             */
            public static create(rpcImpl: $protobuf.RPCImpl, requestDelimited?: boolean, responseDelimited?: boolean): FreezeService;

            /**
             * Freezes the nodes by submitting the transaction. The grpc server returns the
             * TransactionResponse
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public freeze(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.FreezeService.freezeCallback): void;

            /**
             * Freezes the nodes by submitting the transaction. The grpc server returns the
             * TransactionResponse
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public freeze(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;
        }

        namespace FreezeService {

            /**
             * Callback as used by {@link hashgraph.proto.FreezeService#freeze}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type freezeCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;
        }

        /** The requests and responses for different network services. */
        class NetworkService extends $protobuf.rpc.Service {

            /**
             * Constructs a new NetworkService service.
             * @param rpcImpl RPC implementation
             * @param [requestDelimited=false] Whether requests are length-delimited
             * @param [responseDelimited=false] Whether responses are length-delimited
             */
            constructor(rpcImpl: $protobuf.RPCImpl, requestDelimited?: boolean, responseDelimited?: boolean);

            /**
             * Creates new NetworkService service using the specified rpc implementation.
             * @param rpcImpl RPC implementation
             * @param [requestDelimited=false] Whether requests are length-delimited
             * @param [responseDelimited=false] Whether responses are length-delimited
             * @returns RPC service. Useful where requests and/or responses are streamed.
             */
            public static create(rpcImpl: $protobuf.RPCImpl, requestDelimited?: boolean, responseDelimited?: boolean): NetworkService;

            /**
             * Retrieves the active versions of Hedera Services and HAPI proto
             * @param request Query message or plain object
             * @param callback Node-style callback called with the error, if any, and Response
             */
            public getVersionInfo(request: hashgraph.proto.IQuery, callback: hashgraph.proto.NetworkService.getVersionInfoCallback): void;

            /**
             * Retrieves the active versions of Hedera Services and HAPI proto
             * @param request Query message or plain object
             * @returns Promise
             */
            public getVersionInfo(request: hashgraph.proto.IQuery): Promise<hashgraph.proto.Response>;

            /**
             * Retrieves the time in nanoseconds spent in <tt>handleTransaction</tt> for one or more
             * TransactionIDs (assuming they have reached consensus "recently", since only a limited
             * number of execution times are kept in-memory, depending on the value of the node-local
             * property <tt>stats.executionTimesToTrack</tt>).
             * @param request Query message or plain object
             * @param callback Node-style callback called with the error, if any, and Response
             */
            public getExecutionTime(request: hashgraph.proto.IQuery, callback: hashgraph.proto.NetworkService.getExecutionTimeCallback): void;

            /**
             * Retrieves the time in nanoseconds spent in <tt>handleTransaction</tt> for one or more
             * TransactionIDs (assuming they have reached consensus "recently", since only a limited
             * number of execution times are kept in-memory, depending on the value of the node-local
             * property <tt>stats.executionTimesToTrack</tt>).
             * @param request Query message or plain object
             * @returns Promise
             */
            public getExecutionTime(request: hashgraph.proto.IQuery): Promise<hashgraph.proto.Response>;

            /**
             * Submits a "wrapped" transaction to the network, skipping its standard prechecks. (Note that
             * the "wrapper" <tt>UncheckedSubmit</tt> transaction is still subject to normal prechecks,
             * including an authorization requirement that its payer be either the treasury or system admin
             * account.)
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public uncheckedSubmit(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.NetworkService.uncheckedSubmitCallback): void;

            /**
             * Submits a "wrapped" transaction to the network, skipping its standard prechecks. (Note that
             * the "wrapper" <tt>UncheckedSubmit</tt> transaction is still subject to normal prechecks,
             * including an authorization requirement that its payer be either the treasury or system admin
             * account.)
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public uncheckedSubmit(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Get all the information about an account, including balance and allowances. This does not get the list of
             * account records.
             * @param request Query message or plain object
             * @param callback Node-style callback called with the error, if any, and Response
             */
            public getAccountDetails(request: hashgraph.proto.IQuery, callback: hashgraph.proto.NetworkService.getAccountDetailsCallback): void;

            /**
             * Get all the information about an account, including balance and allowances. This does not get the list of
             * account records.
             * @param request Query message or plain object
             * @returns Promise
             */
            public getAccountDetails(request: hashgraph.proto.IQuery): Promise<hashgraph.proto.Response>;
        }

        namespace NetworkService {

            /**
             * Callback as used by {@link hashgraph.proto.NetworkService#getVersionInfo}.
             * @param error Error, if any
             * @param [response] Response
             */
            type getVersionInfoCallback = (error: (Error|null), response?: hashgraph.proto.Response) => void;

            /**
             * Callback as used by {@link hashgraph.proto.NetworkService#getExecutionTime}.
             * @param error Error, if any
             * @param [response] Response
             */
            type getExecutionTimeCallback = (error: (Error|null), response?: hashgraph.proto.Response) => void;

            /**
             * Callback as used by {@link hashgraph.proto.NetworkService#uncheckedSubmit}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type uncheckedSubmitCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.NetworkService#getAccountDetails}.
             * @param error Error, if any
             * @param [response] Response
             */
            type getAccountDetailsCallback = (error: (Error|null), response?: hashgraph.proto.Response) => void;
        }

        /**
         * Transactions and queries for the Schedule Service
         *
         * The Schedule Service allows transactions to be submitted without all the required signatures and
         * allows anyone to provide the required signatures independently after a transaction has already
         * been created. The transactions can be executed immediately when all required signatures are received
         * or at a future date if Long Term Scheduled Transactions are enabled.
         *
         * Execution:
         *
         * Scheduled Transactions are executed in two different modes.
         *
         * 1. If Long Term Scheduled Transactions are enabled and <tt>wait_for_expiry</tt> was set to <tt>true</tt> on the
         * <tt>ScheduleCreate</tt>, then the transaction will be executed at the <tt>expiration_time</tt> specified on the
         * <tt>ScheduleCreate</tt>.
         *
         * 2. Otherwise Scheduled Transactions are executed once all required signatures are collected and witnessed.
         * Every time new signature is provided, a check is performed on the "readiness" of the execution.
         * The Scheduled Transaction will be executed immediately after the transaction that triggered it.
         *
         * NOTICE:
         * A Scheduled Transaction being ready to execute, or even not ready to execute, at the time a <tt>ScheduleCreate</tt> or
         * <tt>ScheduleSign</tt> comes in does not guarantee it will stay that way. Any number of things can happen over time that
         * impact the transaction.
         *
         * For example, account keys can change, accounts can be deleted, and account balances can change.
         *
         * A particularly noteworthy case is if Long Term Scheduled Transactions are enabled and signature requirements for a Scheduled
         * Transaction change such that existing signatures become sufficient to allow the transaction to go through. In this case the transaction
         * will execute at expiration_time unless a ScheduleSign comes in to push it through.
         *
         * Transaction Record:
         *
         * If a Scheduled Transaction is executed immediately following the transaction that provided all required signatures,
         * the timestamp of the Scheduled Transaction will be equal to consensusTimestamp + 1 nano, where
         * consensusTimestamp is the timestamp of the transaction that triggered the execution.
         *
         * The Transaction ID of the Scheduled Transaction will have the scheduled property set to true and
         * inherit the <tt>transactionValidStart</tt> and <tt>accountID</tt> from the <tt>ScheduleCreate</tt> transaction.
         *
         * The <tt>scheduleRef</tt> property of the transaction record will be populated with the <tt>ScheduleID</tt> of the
         * Scheduled Transaction.
         *
         * Post execution:
         *
         * After execution, a Scheduled Transaction will remain in state and can be queried using <tt>GetScheduleInfo</tt> until expiration.
         *
         * Expiry:
         *
         * The expiration time of a schedule is controlled by it's <tt>expiration_time</tt>. If Long Term Scheduled Transactions are disabled,
         * the <tt>expiration_time</tt> is always 30 minutes in the future.
         *
         * Once a given Scheduled Transaction expires, it will be removed from the ledger and any upcoming
         * operation referring the ScheduleID will resolve to INVALID_SCHEDULE_ID.
         */
        class ScheduleService extends $protobuf.rpc.Service {

            /**
             * Constructs a new ScheduleService service.
             * @param rpcImpl RPC implementation
             * @param [requestDelimited=false] Whether requests are length-delimited
             * @param [responseDelimited=false] Whether responses are length-delimited
             */
            constructor(rpcImpl: $protobuf.RPCImpl, requestDelimited?: boolean, responseDelimited?: boolean);

            /**
             * Creates new ScheduleService service using the specified rpc implementation.
             * @param rpcImpl RPC implementation
             * @param [requestDelimited=false] Whether requests are length-delimited
             * @param [responseDelimited=false] Whether responses are length-delimited
             * @returns RPC service. Useful where requests and/or responses are streamed.
             */
            public static create(rpcImpl: $protobuf.RPCImpl, requestDelimited?: boolean, responseDelimited?: boolean): ScheduleService;

            /**
             * Creates a new Schedule by submitting the transaction
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public createSchedule(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.ScheduleService.createScheduleCallback): void;

            /**
             * Creates a new Schedule by submitting the transaction
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public createSchedule(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Signs a new Schedule by submitting the transaction
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public signSchedule(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.ScheduleService.signScheduleCallback): void;

            /**
             * Signs a new Schedule by submitting the transaction
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public signSchedule(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Deletes a new Schedule by submitting the transaction
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public deleteSchedule(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.ScheduleService.deleteScheduleCallback): void;

            /**
             * Deletes a new Schedule by submitting the transaction
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public deleteSchedule(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Retrieves the metadata of a schedule entity
             * @param request Query message or plain object
             * @param callback Node-style callback called with the error, if any, and Response
             */
            public getScheduleInfo(request: hashgraph.proto.IQuery, callback: hashgraph.proto.ScheduleService.getScheduleInfoCallback): void;

            /**
             * Retrieves the metadata of a schedule entity
             * @param request Query message or plain object
             * @returns Promise
             */
            public getScheduleInfo(request: hashgraph.proto.IQuery): Promise<hashgraph.proto.Response>;
        }

        namespace ScheduleService {

            /**
             * Callback as used by {@link hashgraph.proto.ScheduleService#createSchedule}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type createScheduleCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.ScheduleService#signSchedule}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type signScheduleCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.ScheduleService#deleteSchedule}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type deleteScheduleCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.ScheduleService#getScheduleInfo}.
             * @param error Error, if any
             * @param [response] Response
             */
            type getScheduleInfoCallback = (error: (Error|null), response?: hashgraph.proto.Response) => void;
        }

        /** Transactions and queries for the file service. */
        class SmartContractService extends $protobuf.rpc.Service {

            /**
             * Constructs a new SmartContractService service.
             * @param rpcImpl RPC implementation
             * @param [requestDelimited=false] Whether requests are length-delimited
             * @param [responseDelimited=false] Whether responses are length-delimited
             */
            constructor(rpcImpl: $protobuf.RPCImpl, requestDelimited?: boolean, responseDelimited?: boolean);

            /**
             * Creates new SmartContractService service using the specified rpc implementation.
             * @param rpcImpl RPC implementation
             * @param [requestDelimited=false] Whether requests are length-delimited
             * @param [responseDelimited=false] Whether responses are length-delimited
             * @returns RPC service. Useful where requests and/or responses are streamed.
             */
            public static create(rpcImpl: $protobuf.RPCImpl, requestDelimited?: boolean, responseDelimited?: boolean): SmartContractService;

            /**
             * Creates a contract
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public createContract(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.SmartContractService.createContractCallback): void;

            /**
             * Creates a contract
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public createContract(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Updates a contract with the content
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public updateContract(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.SmartContractService.updateContractCallback): void;

            /**
             * Updates a contract with the content
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public updateContract(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Calls a contract
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public contractCallMethod(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.SmartContractService.contractCallMethodCallback): void;

            /**
             * Calls a contract
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public contractCallMethod(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Retrieves the contract information
             * @param request Query message or plain object
             * @param callback Node-style callback called with the error, if any, and Response
             */
            public getContractInfo(request: hashgraph.proto.IQuery, callback: hashgraph.proto.SmartContractService.getContractInfoCallback): void;

            /**
             * Retrieves the contract information
             * @param request Query message or plain object
             * @returns Promise
             */
            public getContractInfo(request: hashgraph.proto.IQuery): Promise<hashgraph.proto.Response>;

            /**
             * Calls a smart contract to be run on a single node
             * @param request Query message or plain object
             * @param callback Node-style callback called with the error, if any, and Response
             */
            public contractCallLocalMethod(request: hashgraph.proto.IQuery, callback: hashgraph.proto.SmartContractService.contractCallLocalMethodCallback): void;

            /**
             * Calls a smart contract to be run on a single node
             * @param request Query message or plain object
             * @returns Promise
             */
            public contractCallLocalMethod(request: hashgraph.proto.IQuery): Promise<hashgraph.proto.Response>;

            /**
             * Retrieves the runtime code of a contract
             * @param request Query message or plain object
             * @param callback Node-style callback called with the error, if any, and Response
             */
            public contractGetBytecode(request: hashgraph.proto.IQuery, callback: hashgraph.proto.SmartContractService.ContractGetBytecodeCallback): void;

            /**
             * Retrieves the runtime code of a contract
             * @param request Query message or plain object
             * @returns Promise
             */
            public contractGetBytecode(request: hashgraph.proto.IQuery): Promise<hashgraph.proto.Response>;

            /**
             * Retrieves a contract by its Solidity address
             * @param request Query message or plain object
             * @param callback Node-style callback called with the error, if any, and Response
             */
            public getBySolidityID(request: hashgraph.proto.IQuery, callback: hashgraph.proto.SmartContractService.getBySolidityIDCallback): void;

            /**
             * Retrieves a contract by its Solidity address
             * @param request Query message or plain object
             * @returns Promise
             */
            public getBySolidityID(request: hashgraph.proto.IQuery): Promise<hashgraph.proto.Response>;

            /**
             * Always returns an empty record list, as contract accounts are never effective payers for
             * transactions
             * @param request Query message or plain object
             * @param callback Node-style callback called with the error, if any, and Response
             */
            public getTxRecordByContractID(request: hashgraph.proto.IQuery, callback: hashgraph.proto.SmartContractService.getTxRecordByContractIDCallback): void;

            /**
             * Always returns an empty record list, as contract accounts are never effective payers for
             * transactions
             * @param request Query message or plain object
             * @returns Promise
             */
            public getTxRecordByContractID(request: hashgraph.proto.IQuery): Promise<hashgraph.proto.Response>;

            /**
             * Deletes a contract instance and transfers any remaining hbars to a specified receiver
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public deleteContract(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.SmartContractService.deleteContractCallback): void;

            /**
             * Deletes a contract instance and transfers any remaining hbars to a specified receiver
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public deleteContract(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Deletes a contract if the submitting account has network admin privileges
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public systemDelete(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.SmartContractService.systemDeleteCallback): void;

            /**
             * Deletes a contract if the submitting account has network admin privileges
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public systemDelete(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Undeletes a contract if the submitting account has network admin privileges
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public systemUndelete(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.SmartContractService.systemUndeleteCallback): void;

            /**
             * Undeletes a contract if the submitting account has network admin privileges
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public systemUndelete(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Ethereum transaction
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public callEthereum(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.SmartContractService.callEthereumCallback): void;

            /**
             * Ethereum transaction
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public callEthereum(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;
        }

        namespace SmartContractService {

            /**
             * Callback as used by {@link hashgraph.proto.SmartContractService#createContract}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type createContractCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.SmartContractService#updateContract}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type updateContractCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.SmartContractService#contractCallMethod}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type contractCallMethodCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.SmartContractService#getContractInfo}.
             * @param error Error, if any
             * @param [response] Response
             */
            type getContractInfoCallback = (error: (Error|null), response?: hashgraph.proto.Response) => void;

            /**
             * Callback as used by {@link hashgraph.proto.SmartContractService#contractCallLocalMethod}.
             * @param error Error, if any
             * @param [response] Response
             */
            type contractCallLocalMethodCallback = (error: (Error|null), response?: hashgraph.proto.Response) => void;

            /**
             * Callback as used by {@link hashgraph.proto.SmartContractService#contractGetBytecode}.
             * @param error Error, if any
             * @param [response] Response
             */
            type ContractGetBytecodeCallback = (error: (Error|null), response?: hashgraph.proto.Response) => void;

            /**
             * Callback as used by {@link hashgraph.proto.SmartContractService#getBySolidityID}.
             * @param error Error, if any
             * @param [response] Response
             */
            type getBySolidityIDCallback = (error: (Error|null), response?: hashgraph.proto.Response) => void;

            /**
             * Callback as used by {@link hashgraph.proto.SmartContractService#getTxRecordByContractID}.
             * @param error Error, if any
             * @param [response] Response
             */
            type getTxRecordByContractIDCallback = (error: (Error|null), response?: hashgraph.proto.Response) => void;

            /**
             * Callback as used by {@link hashgraph.proto.SmartContractService#deleteContract}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type deleteContractCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.SmartContractService#systemDelete}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type systemDeleteCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.SmartContractService#systemUndelete}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type systemUndeleteCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.SmartContractService#callEthereum}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type callEthereumCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;
        }

        /** Properties of a ThrottleGroup. */
        interface IThrottleGroup {

            /** The operations to be throttled */
            operations?: (hashgraph.proto.HederaFunctionality[]|null);

            /**
             * The number of total operations per second across the entire network, multiplied by 1000. So, to
             * choose 3 operations per second (which on a network of 30 nodes is a tenth of an operation per
             * second for each node), set milliOpsPerSec = 3000. And to choose 3.6 ops per second, use
             * milliOpsPerSec = 3600. Minimum allowed value is 1, and maximum allowed value is 9223372.
             */
            milliOpsPerSec?: (Long|null);
        }

        /** A set of operations which should be collectively throttled at a given milli-ops-per-second limit. */
        class ThrottleGroup implements IThrottleGroup {

            /**
             * Constructs a new ThrottleGroup.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IThrottleGroup);

            /** The operations to be throttled */
            public operations: hashgraph.proto.HederaFunctionality[];

            /**
             * The number of total operations per second across the entire network, multiplied by 1000. So, to
             * choose 3 operations per second (which on a network of 30 nodes is a tenth of an operation per
             * second for each node), set milliOpsPerSec = 3000. And to choose 3.6 ops per second, use
             * milliOpsPerSec = 3600. Minimum allowed value is 1, and maximum allowed value is 9223372.
             */
            public milliOpsPerSec: Long;

            /**
             * Creates a new ThrottleGroup instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ThrottleGroup instance
             */
            public static create(properties?: hashgraph.proto.IThrottleGroup): hashgraph.proto.ThrottleGroup;

            /**
             * Encodes the specified ThrottleGroup message. Does not implicitly {@link hashgraph.proto.ThrottleGroup.verify|verify} messages.
             * @param m ThrottleGroup message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IThrottleGroup, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ThrottleGroup message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ThrottleGroup
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ThrottleGroup;

            /**
             * Gets the default type url for ThrottleGroup
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ThrottleBucket. */
        interface IThrottleBucket {

            /** A name for this bucket (primarily for use in logs) */
            name?: (string|null);

            /**
             * The number of milliseconds required for this bucket to drain completely when full. The product
             * of this number and the least common multiple of the milliOpsPerSec values in this bucket must
             * not exceed 9223372036.
             */
            burstPeriodMs?: (Long|null);

            /** The throttle groups competing for this bucket */
            throttleGroups?: (hashgraph.proto.IThrottleGroup[]|null);
        }

        /** A list of throttle groups that should all compete for the same internal bucket. */
        class ThrottleBucket implements IThrottleBucket {

            /**
             * Constructs a new ThrottleBucket.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IThrottleBucket);

            /** A name for this bucket (primarily for use in logs) */
            public name: string;

            /**
             * The number of milliseconds required for this bucket to drain completely when full. The product
             * of this number and the least common multiple of the milliOpsPerSec values in this bucket must
             * not exceed 9223372036.
             */
            public burstPeriodMs: Long;

            /** The throttle groups competing for this bucket */
            public throttleGroups: hashgraph.proto.IThrottleGroup[];

            /**
             * Creates a new ThrottleBucket instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ThrottleBucket instance
             */
            public static create(properties?: hashgraph.proto.IThrottleBucket): hashgraph.proto.ThrottleBucket;

            /**
             * Encodes the specified ThrottleBucket message. Does not implicitly {@link hashgraph.proto.ThrottleBucket.verify|verify} messages.
             * @param m ThrottleBucket message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IThrottleBucket, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ThrottleBucket message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ThrottleBucket
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ThrottleBucket;

            /**
             * Gets the default type url for ThrottleBucket
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ThrottleDefinitions. */
        interface IThrottleDefinitions {

            /** ThrottleDefinitions throttleBuckets */
            throttleBuckets?: (hashgraph.proto.IThrottleBucket[]|null);
        }

        /**
         * A list of throttle buckets which, simultaneously enforced, define the system's throttling policy.
         * <ol>
         * <li> When an operation appears in more than one throttling bucket, all its buckets must have room
         * or it will be throttled.</li>
         * <li>An operation assigned to no buckets is always throttled.</li>
         * </ol>
         */
        class ThrottleDefinitions implements IThrottleDefinitions {

            /**
             * Constructs a new ThrottleDefinitions.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IThrottleDefinitions);

            /** ThrottleDefinitions throttleBuckets. */
            public throttleBuckets: hashgraph.proto.IThrottleBucket[];

            /**
             * Creates a new ThrottleDefinitions instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ThrottleDefinitions instance
             */
            public static create(properties?: hashgraph.proto.IThrottleDefinitions): hashgraph.proto.ThrottleDefinitions;

            /**
             * Encodes the specified ThrottleDefinitions message. Does not implicitly {@link hashgraph.proto.ThrottleDefinitions.verify|verify} messages.
             * @param m ThrottleDefinitions message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IThrottleDefinitions, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ThrottleDefinitions message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ThrottleDefinitions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ThrottleDefinitions;

            /**
             * Gets the default type url for ThrottleDefinitions
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Transactions and queries for the Token Service */
        class TokenService extends $protobuf.rpc.Service {

            /**
             * Constructs a new TokenService service.
             * @param rpcImpl RPC implementation
             * @param [requestDelimited=false] Whether requests are length-delimited
             * @param [responseDelimited=false] Whether responses are length-delimited
             */
            constructor(rpcImpl: $protobuf.RPCImpl, requestDelimited?: boolean, responseDelimited?: boolean);

            /**
             * Creates new TokenService service using the specified rpc implementation.
             * @param rpcImpl RPC implementation
             * @param [requestDelimited=false] Whether requests are length-delimited
             * @param [responseDelimited=false] Whether responses are length-delimited
             * @returns RPC service. Useful where requests and/or responses are streamed.
             */
            public static create(rpcImpl: $protobuf.RPCImpl, requestDelimited?: boolean, responseDelimited?: boolean): TokenService;

            /**
             * Creates a new Token by submitting the transaction
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public createToken(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.TokenService.createTokenCallback): void;

            /**
             * Creates a new Token by submitting the transaction
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public createToken(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Updates the account by submitting the transaction
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public updateToken(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.TokenService.updateTokenCallback): void;

            /**
             * Updates the account by submitting the transaction
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public updateToken(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Mints an amount of the token to the defined treasury account
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public mintToken(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.TokenService.mintTokenCallback): void;

            /**
             * Mints an amount of the token to the defined treasury account
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public mintToken(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Burns an amount of the token from the defined treasury account
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public burnToken(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.TokenService.burnTokenCallback): void;

            /**
             * Burns an amount of the token from the defined treasury account
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public burnToken(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Deletes a Token
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public deleteToken(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.TokenService.deleteTokenCallback): void;

            /**
             * Deletes a Token
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public deleteToken(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Wipes the provided amount of tokens from the specified Account ID
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public wipeTokenAccount(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.TokenService.wipeTokenAccountCallback): void;

            /**
             * Wipes the provided amount of tokens from the specified Account ID
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public wipeTokenAccount(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Freezes the transfer of tokens to or from the specified Account ID
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public freezeTokenAccount(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.TokenService.freezeTokenAccountCallback): void;

            /**
             * Freezes the transfer of tokens to or from the specified Account ID
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public freezeTokenAccount(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Unfreezes the transfer of tokens to or from the specified Account ID
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public unfreezeTokenAccount(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.TokenService.unfreezeTokenAccountCallback): void;

            /**
             * Unfreezes the transfer of tokens to or from the specified Account ID
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public unfreezeTokenAccount(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Flags the provided Account ID as having gone through KYC
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public grantKycToTokenAccount(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.TokenService.grantKycToTokenAccountCallback): void;

            /**
             * Flags the provided Account ID as having gone through KYC
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public grantKycToTokenAccount(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Removes the KYC flag of the provided Account ID
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public revokeKycFromTokenAccount(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.TokenService.revokeKycFromTokenAccountCallback): void;

            /**
             * Removes the KYC flag of the provided Account ID
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public revokeKycFromTokenAccount(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Associates tokens to an account
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public associateTokens(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.TokenService.associateTokensCallback): void;

            /**
             * Associates tokens to an account
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public associateTokens(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Dissociates tokens from an account
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public dissociateTokens(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.TokenService.dissociateTokensCallback): void;

            /**
             * Dissociates tokens from an account
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public dissociateTokens(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Updates the custom fee schedule on a token
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public updateTokenFeeSchedule(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.TokenService.updateTokenFeeScheduleCallback): void;

            /**
             * Updates the custom fee schedule on a token
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public updateTokenFeeSchedule(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Retrieves the metadata of a token
             * @param request Query message or plain object
             * @param callback Node-style callback called with the error, if any, and Response
             */
            public getTokenInfo(request: hashgraph.proto.IQuery, callback: hashgraph.proto.TokenService.getTokenInfoCallback): void;

            /**
             * Retrieves the metadata of a token
             * @param request Query message or plain object
             * @returns Promise
             */
            public getTokenInfo(request: hashgraph.proto.IQuery): Promise<hashgraph.proto.Response>;

            /**
             * (DEPRECATED) Gets info on NFTs N through M on the list of NFTs associated with a given account
             * @param request Query message or plain object
             * @param callback Node-style callback called with the error, if any, and Response
             */
            public getAccountNftInfos(request: hashgraph.proto.IQuery, callback: hashgraph.proto.TokenService.getAccountNftInfosCallback): void;

            /**
             * (DEPRECATED) Gets info on NFTs N through M on the list of NFTs associated with a given account
             * @param request Query message or plain object
             * @returns Promise
             */
            public getAccountNftInfos(request: hashgraph.proto.IQuery): Promise<hashgraph.proto.Response>;

            /**
             * Retrieves the metadata of an NFT by TokenID and serial number
             * @param request Query message or plain object
             * @param callback Node-style callback called with the error, if any, and Response
             */
            public getTokenNftInfo(request: hashgraph.proto.IQuery, callback: hashgraph.proto.TokenService.getTokenNftInfoCallback): void;

            /**
             * Retrieves the metadata of an NFT by TokenID and serial number
             * @param request Query message or plain object
             * @returns Promise
             */
            public getTokenNftInfo(request: hashgraph.proto.IQuery): Promise<hashgraph.proto.Response>;

            /**
             * (DEPRECATED) Gets info on NFTs N through M on the list of NFTs associated with a given Token of type NON_FUNGIBLE
             * @param request Query message or plain object
             * @param callback Node-style callback called with the error, if any, and Response
             */
            public getTokenNftInfos(request: hashgraph.proto.IQuery, callback: hashgraph.proto.TokenService.getTokenNftInfosCallback): void;

            /**
             * (DEPRECATED) Gets info on NFTs N through M on the list of NFTs associated with a given Token of type NON_FUNGIBLE
             * @param request Query message or plain object
             * @returns Promise
             */
            public getTokenNftInfos(request: hashgraph.proto.IQuery): Promise<hashgraph.proto.Response>;

            /**
             * Calls pauseToken.
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public pauseToken(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.TokenService.pauseTokenCallback): void;

            /**
             * Calls pauseToken.
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public pauseToken(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;

            /**
             * Calls unpauseToken.
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public unpauseToken(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.TokenService.unpauseTokenCallback): void;

            /**
             * Calls unpauseToken.
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public unpauseToken(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;
        }

        namespace TokenService {

            /**
             * Callback as used by {@link hashgraph.proto.TokenService#createToken}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type createTokenCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.TokenService#updateToken}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type updateTokenCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.TokenService#mintToken}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type mintTokenCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.TokenService#burnToken}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type burnTokenCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.TokenService#deleteToken}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type deleteTokenCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.TokenService#wipeTokenAccount}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type wipeTokenAccountCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.TokenService#freezeTokenAccount}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type freezeTokenAccountCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.TokenService#unfreezeTokenAccount}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type unfreezeTokenAccountCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.TokenService#grantKycToTokenAccount}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type grantKycToTokenAccountCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.TokenService#revokeKycFromTokenAccount}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type revokeKycFromTokenAccountCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.TokenService#associateTokens}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type associateTokensCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.TokenService#dissociateTokens}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type dissociateTokensCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.TokenService#updateTokenFeeSchedule}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type updateTokenFeeScheduleCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.TokenService#getTokenInfo}.
             * @param error Error, if any
             * @param [response] Response
             */
            type getTokenInfoCallback = (error: (Error|null), response?: hashgraph.proto.Response) => void;

            /**
             * Callback as used by {@link hashgraph.proto.TokenService#getAccountNftInfos}.
             * @param error Error, if any
             * @param [response] Response
             */
            type getAccountNftInfosCallback = (error: (Error|null), response?: hashgraph.proto.Response) => void;

            /**
             * Callback as used by {@link hashgraph.proto.TokenService#getTokenNftInfo}.
             * @param error Error, if any
             * @param [response] Response
             */
            type getTokenNftInfoCallback = (error: (Error|null), response?: hashgraph.proto.Response) => void;

            /**
             * Callback as used by {@link hashgraph.proto.TokenService#getTokenNftInfos}.
             * @param error Error, if any
             * @param [response] Response
             */
            type getTokenNftInfosCallback = (error: (Error|null), response?: hashgraph.proto.Response) => void;

            /**
             * Callback as used by {@link hashgraph.proto.TokenService#pauseToken}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type pauseTokenCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;

            /**
             * Callback as used by {@link hashgraph.proto.TokenService#unpauseToken}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type unpauseTokenCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;
        }

        /** Properties of a SignedTransaction. */
        interface ISignedTransaction {

            /** TransactionBody serialized into bytes, which needs to be signed */
            bodyBytes?: (Uint8Array|null);

            /** The signatures on the body with the new format, to authorize the transaction */
            sigMap?: (hashgraph.proto.ISignatureMap|null);
        }

        /** Represents a SignedTransaction. */
        class SignedTransaction implements ISignedTransaction {

            /**
             * Constructs a new SignedTransaction.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ISignedTransaction);

            /** TransactionBody serialized into bytes, which needs to be signed */
            public bodyBytes: Uint8Array;

            /** The signatures on the body with the new format, to authorize the transaction */
            public sigMap?: (hashgraph.proto.ISignatureMap|null);

            /**
             * Creates a new SignedTransaction instance using the specified properties.
             * @param [properties] Properties to set
             * @returns SignedTransaction instance
             */
            public static create(properties?: hashgraph.proto.ISignedTransaction): hashgraph.proto.SignedTransaction;

            /**
             * Encodes the specified SignedTransaction message. Does not implicitly {@link hashgraph.proto.SignedTransaction.verify|verify} messages.
             * @param m SignedTransaction message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ISignedTransaction, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a SignedTransaction message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns SignedTransaction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.SignedTransaction;

            /**
             * Gets the default type url for SignedTransaction
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** The requests and responses for different utility services. */
        class UtilService extends $protobuf.rpc.Service {

            /**
             * Constructs a new UtilService service.
             * @param rpcImpl RPC implementation
             * @param [requestDelimited=false] Whether requests are length-delimited
             * @param [responseDelimited=false] Whether responses are length-delimited
             */
            constructor(rpcImpl: $protobuf.RPCImpl, requestDelimited?: boolean, responseDelimited?: boolean);

            /**
             * Creates new UtilService service using the specified rpc implementation.
             * @param rpcImpl RPC implementation
             * @param [requestDelimited=false] Whether requests are length-delimited
             * @param [responseDelimited=false] Whether responses are length-delimited
             * @returns RPC service. Useful where requests and/or responses are streamed.
             */
            public static create(rpcImpl: $protobuf.RPCImpl, requestDelimited?: boolean, responseDelimited?: boolean): UtilService;

            /**
             * Generates a pseudorandom number.
             * @param request Transaction message or plain object
             * @param callback Node-style callback called with the error, if any, and TransactionResponse
             */
            public prng(request: hashgraph.proto.ITransaction, callback: hashgraph.proto.UtilService.prngCallback): void;

            /**
             * Generates a pseudorandom number.
             * @param request Transaction message or plain object
             * @returns Promise
             */
            public prng(request: hashgraph.proto.ITransaction): Promise<hashgraph.proto.TransactionResponse>;
        }

        namespace UtilService {

            /**
             * Callback as used by {@link hashgraph.proto.UtilService#prng}.
             * @param error Error, if any
             * @param [response] TransactionResponse
             */
            type prngCallback = (error: (Error|null), response?: hashgraph.proto.TransactionResponse) => void;
        }

        /** Properties of a TokenUnitBalance. */
        interface ITokenUnitBalance {

            /** A unique token id */
            tokenId?: (hashgraph.proto.ITokenID|null);

            /**
             * Number of transferable units of the identified token. For token of type FUNGIBLE_COMMON -
             * balance in the smallest denomination. For token of type NON_FUNGIBLE_UNIQUE - the number of
             * NFTs held by the account
             */
            balance?: (Long|null);
        }

        /** Represents a TokenUnitBalance. */
        class TokenUnitBalance implements ITokenUnitBalance {

            /**
             * Constructs a new TokenUnitBalance.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITokenUnitBalance);

            /** A unique token id */
            public tokenId?: (hashgraph.proto.ITokenID|null);

            /**
             * Number of transferable units of the identified token. For token of type FUNGIBLE_COMMON -
             * balance in the smallest denomination. For token of type NON_FUNGIBLE_UNIQUE - the number of
             * NFTs held by the account
             */
            public balance: Long;

            /**
             * Creates a new TokenUnitBalance instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TokenUnitBalance instance
             */
            public static create(properties?: hashgraph.proto.ITokenUnitBalance): hashgraph.proto.TokenUnitBalance;

            /**
             * Encodes the specified TokenUnitBalance message. Does not implicitly {@link hashgraph.proto.TokenUnitBalance.verify|verify} messages.
             * @param m TokenUnitBalance message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITokenUnitBalance, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TokenUnitBalance message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TokenUnitBalance
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TokenUnitBalance;

            /**
             * Gets the default type url for TokenUnitBalance
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a SingleAccountBalances. */
        interface ISingleAccountBalances {

            /** The account */
            accountID?: (hashgraph.proto.IAccountID|null);

            /** The account's hbar balance */
            hbarBalance?: (Long|null);

            /** The list of the account's token balances */
            tokenUnitBalances?: (hashgraph.proto.ITokenUnitBalance[]|null);
        }

        /** Includes all currency balances (both hbar and token) of a single account in the ledger. */
        class SingleAccountBalances implements ISingleAccountBalances {

            /**
             * Constructs a new SingleAccountBalances.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ISingleAccountBalances);

            /** The account */
            public accountID?: (hashgraph.proto.IAccountID|null);

            /** The account's hbar balance */
            public hbarBalance: Long;

            /** The list of the account's token balances */
            public tokenUnitBalances: hashgraph.proto.ITokenUnitBalance[];

            /**
             * Creates a new SingleAccountBalances instance using the specified properties.
             * @param [properties] Properties to set
             * @returns SingleAccountBalances instance
             */
            public static create(properties?: hashgraph.proto.ISingleAccountBalances): hashgraph.proto.SingleAccountBalances;

            /**
             * Encodes the specified SingleAccountBalances message. Does not implicitly {@link hashgraph.proto.SingleAccountBalances.verify|verify} messages.
             * @param m SingleAccountBalances message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ISingleAccountBalances, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a SingleAccountBalances message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns SingleAccountBalances
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.SingleAccountBalances;

            /**
             * Gets the default type url for SingleAccountBalances
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of an AllAccountBalances. */
        interface IAllAccountBalances {

            /** An instant in consensus time */
            consensusTimestamp?: (hashgraph.proto.ITimestamp|null);

            /**
             * The list of account balances for all accounts, after handling all transactions with consensus
             * timestamp up to and including the above instant
             */
            allAccounts?: (hashgraph.proto.ISingleAccountBalances[]|null);
        }

        /** Includes all currency balances (both hbar and token) of all accounts in the ledger. */
        class AllAccountBalances implements IAllAccountBalances {

            /**
             * Constructs a new AllAccountBalances.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IAllAccountBalances);

            /** An instant in consensus time */
            public consensusTimestamp?: (hashgraph.proto.ITimestamp|null);

            /**
             * The list of account balances for all accounts, after handling all transactions with consensus
             * timestamp up to and including the above instant
             */
            public allAccounts: hashgraph.proto.ISingleAccountBalances[];

            /**
             * Creates a new AllAccountBalances instance using the specified properties.
             * @param [properties] Properties to set
             * @returns AllAccountBalances instance
             */
            public static create(properties?: hashgraph.proto.IAllAccountBalances): hashgraph.proto.AllAccountBalances;

            /**
             * Encodes the specified AllAccountBalances message. Does not implicitly {@link hashgraph.proto.AllAccountBalances.verify|verify} messages.
             * @param m AllAccountBalances message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IAllAccountBalances, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an AllAccountBalances message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns AllAccountBalances
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.AllAccountBalances;

            /**
             * Gets the default type url for AllAccountBalances
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ContractActions. */
        interface IContractActions {

            /** ContractActions contractActions */
            contractActions?: (hashgraph.proto.IContractAction[]|null);
        }

        /** Represents a ContractActions. */
        class ContractActions implements IContractActions {

            /**
             * Constructs a new ContractActions.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IContractActions);

            /** ContractActions contractActions. */
            public contractActions: hashgraph.proto.IContractAction[];

            /**
             * Creates a new ContractActions instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ContractActions instance
             */
            public static create(properties?: hashgraph.proto.IContractActions): hashgraph.proto.ContractActions;

            /**
             * Encodes the specified ContractActions message. Does not implicitly {@link hashgraph.proto.ContractActions.verify|verify} messages.
             * @param m ContractActions message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IContractActions, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ContractActions message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ContractActions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ContractActions;

            /**
             * Gets the default type url for ContractActions
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** The type of action described by the action hashgraph.proto. */
        enum ContractActionType {
            NO_ACTION = 0,
            CALL = 1,
            CREATE = 2,
            PRECOMPILE = 3,
            SYSTEM = 4
        }

        /**
         * The specific operation type of a call. The OP prefix has been added to avoid name collisions for
         * the CALL and CREATE operation types since both ContractActionType and CallOperationType enums are
         * used in ContractAction
         */
        enum CallOperationType {
            OP_UNKNOWN = 0,
            OP_CALL = 1,
            OP_CALLCODE = 2,
            OP_DELEGATECALL = 3,
            OP_STATICCALL = 4,
            OP_CREATE = 5,
            OP_CREATE2 = 6
        }

        /** Properties of a ContractAction. */
        interface IContractAction {

            /** The type of this action. */
            callType?: (hashgraph.proto.ContractActionType|null);

            /** If the caller was a regular account, the AccountID. */
            callingAccount?: (hashgraph.proto.IAccountID|null);

            /** If the caller was a smart contract account, the ContractID. */
            callingContract?: (hashgraph.proto.IContractID|null);

            /** The upper limit of gas this action can spend. */
            gas?: (Long|null);

            /** Bytes passed in as input data to this action. */
            input?: (Uint8Array|null);

            /**
             * The AccountID of the recipient if the recipient is an account. Only HBars will be transferred, no other side
             * effects should be expected.
             */
            recipientAccount?: (hashgraph.proto.IAccountID|null);

            /** The ContractID of the recipient if the recipient is a smart contract. */
            recipientContract?: (hashgraph.proto.IContractID|null);

            /**
             * The bytes of the targeted by the action address.
             * Only set on failed executions. If set, denotes that the address did not
             * correspond to any account or contract at the time of finalization of
             * this action.
             * An example would be a failed lazy create as per HIP-583.
             */
            targetedAddress?: (Uint8Array|null);

            /** The value (in tinybars) that is associated with this action. */
            value?: (Long|null);

            /** The actual gas spent by this action. */
            gasUsed?: (Long|null);

            /** If successful, the output bytes of the action. */
            output?: (Uint8Array|null);

            /** The contract itself caused the transaction to fail via the `REVERT` operation */
            revertReason?: (Uint8Array|null);

            /** The transaction itself failed without an explicit `REVERT` */
            error?: (Uint8Array|null);

            /** The nesting depth of this call. The original action is at depth=0. */
            callDepth?: (number|null);

            /** The call operation type */
            callOperationType?: (hashgraph.proto.CallOperationType|null);
        }

        /**
         * A finer grained action with a function result. Sometimes called "internal transactions." The function call itself
         * will be the first action in a list, followed by sub-action in the order they were executed.
         */
        class ContractAction implements IContractAction {

            /**
             * Constructs a new ContractAction.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IContractAction);

            /** The type of this action. */
            public callType: hashgraph.proto.ContractActionType;

            /** If the caller was a regular account, the AccountID. */
            public callingAccount?: (hashgraph.proto.IAccountID|null);

            /** If the caller was a smart contract account, the ContractID. */
            public callingContract?: (hashgraph.proto.IContractID|null);

            /** The upper limit of gas this action can spend. */
            public gas: Long;

            /** Bytes passed in as input data to this action. */
            public input: Uint8Array;

            /**
             * The AccountID of the recipient if the recipient is an account. Only HBars will be transferred, no other side
             * effects should be expected.
             */
            public recipientAccount?: (hashgraph.proto.IAccountID|null);

            /** The ContractID of the recipient if the recipient is a smart contract. */
            public recipientContract?: (hashgraph.proto.IContractID|null);

            /**
             * The bytes of the targeted by the action address.
             * Only set on failed executions. If set, denotes that the address did not
             * correspond to any account or contract at the time of finalization of
             * this action.
             * An example would be a failed lazy create as per HIP-583.
             */
            public targetedAddress?: (Uint8Array|null);

            /** The value (in tinybars) that is associated with this action. */
            public value: Long;

            /** The actual gas spent by this action. */
            public gasUsed: Long;

            /** If successful, the output bytes of the action. */
            public output?: (Uint8Array|null);

            /** The contract itself caused the transaction to fail via the `REVERT` operation */
            public revertReason?: (Uint8Array|null);

            /** The transaction itself failed without an explicit `REVERT` */
            public error?: (Uint8Array|null);

            /** The nesting depth of this call. The original action is at depth=0. */
            public callDepth: number;

            /** The call operation type */
            public callOperationType: hashgraph.proto.CallOperationType;

            /**
             * Only the first action can come from an account, the rest will come from contracts.  Because of DELEGATECALL
             * and CALLCODE the caller of actions whose parent is an account may also be an account.
             */
            public caller?: ("callingAccount"|"callingContract");

            /** Who this action is directed to. */
            public recipient?: ("recipientAccount"|"recipientContract"|"targetedAddress");

            /** The result data of the action. */
            public resultData?: ("output"|"revertReason"|"error");

            /**
             * Creates a new ContractAction instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ContractAction instance
             */
            public static create(properties?: hashgraph.proto.IContractAction): hashgraph.proto.ContractAction;

            /**
             * Encodes the specified ContractAction message. Does not implicitly {@link hashgraph.proto.ContractAction.verify|verify} messages.
             * @param m ContractAction message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IContractAction, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ContractAction message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ContractAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ContractAction;

            /**
             * Gets the default type url for ContractAction
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ContractBytecode. */
        interface IContractBytecode {

            /** The contract to which the bytecodes apply to */
            contractId?: (hashgraph.proto.IContractID|null);

            /** Contract bytecode during deployment */
            initcode?: (Uint8Array|null);

            /** Contract bytecode after deployment */
            runtimeBytecode?: (Uint8Array|null);
        }

        /** Represents a ContractBytecode. */
        class ContractBytecode implements IContractBytecode {

            /**
             * Constructs a new ContractBytecode.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IContractBytecode);

            /** The contract to which the bytecodes apply to */
            public contractId?: (hashgraph.proto.IContractID|null);

            /** Contract bytecode during deployment */
            public initcode: Uint8Array;

            /** Contract bytecode after deployment */
            public runtimeBytecode: Uint8Array;

            /**
             * Creates a new ContractBytecode instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ContractBytecode instance
             */
            public static create(properties?: hashgraph.proto.IContractBytecode): hashgraph.proto.ContractBytecode;

            /**
             * Encodes the specified ContractBytecode message. Does not implicitly {@link hashgraph.proto.ContractBytecode.verify|verify} messages.
             * @param m ContractBytecode message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IContractBytecode, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ContractBytecode message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ContractBytecode
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ContractBytecode;

            /**
             * Gets the default type url for ContractBytecode
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ContractStateChanges. */
        interface IContractStateChanges {

            /** ContractStateChanges contractStateChanges */
            contractStateChanges?: (hashgraph.proto.IContractStateChange[]|null);
        }

        /** Represents a ContractStateChanges. */
        class ContractStateChanges implements IContractStateChanges {

            /**
             * Constructs a new ContractStateChanges.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IContractStateChanges);

            /** ContractStateChanges contractStateChanges. */
            public contractStateChanges: hashgraph.proto.IContractStateChange[];

            /**
             * Creates a new ContractStateChanges instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ContractStateChanges instance
             */
            public static create(properties?: hashgraph.proto.IContractStateChanges): hashgraph.proto.ContractStateChanges;

            /**
             * Encodes the specified ContractStateChanges message. Does not implicitly {@link hashgraph.proto.ContractStateChanges.verify|verify} messages.
             * @param m ContractStateChanges message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IContractStateChanges, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ContractStateChanges message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ContractStateChanges
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ContractStateChanges;

            /**
             * Gets the default type url for ContractStateChanges
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a ContractStateChange. */
        interface IContractStateChange {

            /** The contract to which the storage changes apply to */
            contractId?: (hashgraph.proto.IContractID|null);

            /** The list of storage changes. */
            storageChanges?: (hashgraph.proto.IStorageChange[]|null);
        }

        /** The storage changes to a smart contract's storage as a side effect of the function call. */
        class ContractStateChange implements IContractStateChange {

            /**
             * Constructs a new ContractStateChange.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IContractStateChange);

            /** The contract to which the storage changes apply to */
            public contractId?: (hashgraph.proto.IContractID|null);

            /** The list of storage changes. */
            public storageChanges: hashgraph.proto.IStorageChange[];

            /**
             * Creates a new ContractStateChange instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ContractStateChange instance
             */
            public static create(properties?: hashgraph.proto.IContractStateChange): hashgraph.proto.ContractStateChange;

            /**
             * Encodes the specified ContractStateChange message. Does not implicitly {@link hashgraph.proto.ContractStateChange.verify|verify} messages.
             * @param m ContractStateChange message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IContractStateChange, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ContractStateChange message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns ContractStateChange
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.ContractStateChange;

            /**
             * Gets the default type url for ContractStateChange
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a StorageChange. */
        interface IStorageChange {

            /** The storage slot changed.  Up to 32 bytes, big-endian, zero bytes left trimmed. */
            slot?: (Uint8Array|null);

            /**
             * The value read from the storage slot.  Up to 32 bytes, big-endian, zero bytes left trimmed.
             *
             * Because of the way SSTORE operations are charged the slot is always read before being written to.
             */
            valueRead?: (Uint8Array|null);

            /**
             * The new value written to the slot.  Up to 32 bytes, big-endian, zero bytes left trimmed.
             *
             * If a value of zero is written the valueWritten will be present but the inner value will be absent.
             *
             * If a value was read and not written this value will not be present.
             */
            valueWritten?: (google.protobuf.IBytesValue|null);
        }

        /** A storage slot change description. */
        class StorageChange implements IStorageChange {

            /**
             * Constructs a new StorageChange.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IStorageChange);

            /** The storage slot changed.  Up to 32 bytes, big-endian, zero bytes left trimmed. */
            public slot: Uint8Array;

            /**
             * The value read from the storage slot.  Up to 32 bytes, big-endian, zero bytes left trimmed.
             *
             * Because of the way SSTORE operations are charged the slot is always read before being written to.
             */
            public valueRead: Uint8Array;

            /**
             * The new value written to the slot.  Up to 32 bytes, big-endian, zero bytes left trimmed.
             *
             * If a value of zero is written the valueWritten will be present but the inner value will be absent.
             *
             * If a value was read and not written this value will not be present.
             */
            public valueWritten?: (google.protobuf.IBytesValue|null);

            /**
             * Creates a new StorageChange instance using the specified properties.
             * @param [properties] Properties to set
             * @returns StorageChange instance
             */
            public static create(properties?: hashgraph.proto.IStorageChange): hashgraph.proto.StorageChange;

            /**
             * Encodes the specified StorageChange message. Does not implicitly {@link hashgraph.proto.StorageChange.verify|verify} messages.
             * @param m StorageChange message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IStorageChange, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a StorageChange message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns StorageChange
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.StorageChange;

            /**
             * Gets the default type url for StorageChange
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** List of hash algorithms */
        enum HashAlgorithm {
            HASH_ALGORITHM_UNKNOWN = 0,
            SHA_384 = 1
        }

        /** Properties of a HashObject. */
        interface IHashObject {

            /** Specifies the hashing algorithm */
            algorithm?: (hashgraph.proto.HashAlgorithm|null);

            /** Hash length */
            length?: (number|null);

            /** Specifies the result of the hashing operation in bytes */
            hash?: (Uint8Array|null);
        }

        /**
         * Encapsulates an object hash so that additional hash algorithms
         * can be added in the future without requiring a breaking change.
         */
        class HashObject implements IHashObject {

            /**
             * Constructs a new HashObject.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IHashObject);

            /** Specifies the hashing algorithm */
            public algorithm: hashgraph.proto.HashAlgorithm;

            /** Hash length */
            public length: number;

            /** Specifies the result of the hashing operation in bytes */
            public hash: Uint8Array;

            /**
             * Creates a new HashObject instance using the specified properties.
             * @param [properties] Properties to set
             * @returns HashObject instance
             */
            public static create(properties?: hashgraph.proto.IHashObject): hashgraph.proto.HashObject;

            /**
             * Encodes the specified HashObject message. Does not implicitly {@link hashgraph.proto.HashObject.verify|verify} messages.
             * @param m HashObject message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IHashObject, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a HashObject message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns HashObject
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.HashObject;

            /**
             * Gets the default type url for HashObject
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a RecordStreamFile. */
        interface IRecordStreamFile {

            /** Version of HAPI that was used to serialize the file. */
            hapiProtoVersion?: (hashgraph.proto.ISemanticVersion|null);

            /** Running Hash of all RecordStreamItems before writing this file. */
            startObjectRunningHash?: (hashgraph.proto.IHashObject|null);

            /** List of all the record stream items from that period. */
            recordStreamItems?: (hashgraph.proto.IRecordStreamItem[]|null);

            /** Running Hash of all RecordStreamItems before closing this file. */
            endObjectRunningHash?: (hashgraph.proto.IHashObject|null);

            /** The block number associated with this period. */
            blockNumber?: (Long|null);

            /**
             * List of the hashes of all the sidecar record files created for the same period.
             * Allows multiple sidecar files to be linked to this RecordStreamFile.
             */
            sidecars?: (hashgraph.proto.ISidecarMetadata[]|null);
        }

        /**
         * RecordStreamFile is used to serialize all RecordStreamItems that are part of the
         * same period into record stream files.
         * This structure represents a block in Hedera (HIP-415).
         */
        class RecordStreamFile implements IRecordStreamFile {

            /**
             * Constructs a new RecordStreamFile.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IRecordStreamFile);

            /** Version of HAPI that was used to serialize the file. */
            public hapiProtoVersion?: (hashgraph.proto.ISemanticVersion|null);

            /** Running Hash of all RecordStreamItems before writing this file. */
            public startObjectRunningHash?: (hashgraph.proto.IHashObject|null);

            /** List of all the record stream items from that period. */
            public recordStreamItems: hashgraph.proto.IRecordStreamItem[];

            /** Running Hash of all RecordStreamItems before closing this file. */
            public endObjectRunningHash?: (hashgraph.proto.IHashObject|null);

            /** The block number associated with this period. */
            public blockNumber: Long;

            /**
             * List of the hashes of all the sidecar record files created for the same period.
             * Allows multiple sidecar files to be linked to this RecordStreamFile.
             */
            public sidecars: hashgraph.proto.ISidecarMetadata[];

            /**
             * Creates a new RecordStreamFile instance using the specified properties.
             * @param [properties] Properties to set
             * @returns RecordStreamFile instance
             */
            public static create(properties?: hashgraph.proto.IRecordStreamFile): hashgraph.proto.RecordStreamFile;

            /**
             * Encodes the specified RecordStreamFile message. Does not implicitly {@link hashgraph.proto.RecordStreamFile.verify|verify} messages.
             * @param m RecordStreamFile message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IRecordStreamFile, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a RecordStreamFile message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns RecordStreamFile
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.RecordStreamFile;

            /**
             * Gets the default type url for RecordStreamFile
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a RecordStreamItem. */
        interface IRecordStreamItem {

            /** RecordStreamItem transaction */
            transaction?: (hashgraph.proto.ITransaction|null);

            /** RecordStreamItem record */
            record?: (hashgraph.proto.ITransactionRecord|null);
        }

        /**
         * A RecordStreamItem consists of a Transaction and a TransactionRecord,
         * which are already defined protobuf messages.
         */
        class RecordStreamItem implements IRecordStreamItem {

            /**
             * Constructs a new RecordStreamItem.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.IRecordStreamItem);

            /** RecordStreamItem transaction. */
            public transaction?: (hashgraph.proto.ITransaction|null);

            /** RecordStreamItem record. */
            public record?: (hashgraph.proto.ITransactionRecord|null);

            /**
             * Creates a new RecordStreamItem instance using the specified properties.
             * @param [properties] Properties to set
             * @returns RecordStreamItem instance
             */
            public static create(properties?: hashgraph.proto.IRecordStreamItem): hashgraph.proto.RecordStreamItem;

            /**
             * Encodes the specified RecordStreamItem message. Does not implicitly {@link hashgraph.proto.RecordStreamItem.verify|verify} messages.
             * @param m RecordStreamItem message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.IRecordStreamItem, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a RecordStreamItem message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns RecordStreamItem
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.RecordStreamItem;

            /**
             * Gets the default type url for RecordStreamItem
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a SidecarMetadata. */
        interface ISidecarMetadata {

            /** The hash of the entire file. */
            hash?: (hashgraph.proto.IHashObject|null);

            /** The id of the sidecar record file */
            id?: (number|null);

            /** The types of sidecar records that will be included in the file. */
            types?: (hashgraph.proto.SidecarType[]|null);
        }

        /** Information about a single sidecar file. */
        class SidecarMetadata implements ISidecarMetadata {

            /**
             * Constructs a new SidecarMetadata.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ISidecarMetadata);

            /** The hash of the entire file. */
            public hash?: (hashgraph.proto.IHashObject|null);

            /** The id of the sidecar record file */
            public id: number;

            /** The types of sidecar records that will be included in the file. */
            public types: hashgraph.proto.SidecarType[];

            /**
             * Creates a new SidecarMetadata instance using the specified properties.
             * @param [properties] Properties to set
             * @returns SidecarMetadata instance
             */
            public static create(properties?: hashgraph.proto.ISidecarMetadata): hashgraph.proto.SidecarMetadata;

            /**
             * Encodes the specified SidecarMetadata message. Does not implicitly {@link hashgraph.proto.SidecarMetadata.verify|verify} messages.
             * @param m SidecarMetadata message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ISidecarMetadata, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a SidecarMetadata message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns SidecarMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.SidecarMetadata;

            /**
             * Gets the default type url for SidecarMetadata
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** The type of sidecar records contained in the sidecar record file */
        enum SidecarType {
            SIDECAR_TYPE_UNKNOWN = 0,
            CONTRACT_STATE_CHANGE = 1,
            CONTRACT_ACTION = 2,
            CONTRACT_BYTECODE = 3
        }

        /** Properties of a SidecarFile. */
        interface ISidecarFile {

            /** List of sidecar records */
            sidecarRecords?: (hashgraph.proto.ITransactionSidecarRecord[]|null);
        }

        /**
         * A SidecarFile contains a list of TransactionSidecarRecords that are all created
         * in the same period and related to the same RecordStreamFile.
         */
        class SidecarFile implements ISidecarFile {

            /**
             * Constructs a new SidecarFile.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ISidecarFile);

            /** List of sidecar records */
            public sidecarRecords: hashgraph.proto.ITransactionSidecarRecord[];

            /**
             * Creates a new SidecarFile instance using the specified properties.
             * @param [properties] Properties to set
             * @returns SidecarFile instance
             */
            public static create(properties?: hashgraph.proto.ISidecarFile): hashgraph.proto.SidecarFile;

            /**
             * Encodes the specified SidecarFile message. Does not implicitly {@link hashgraph.proto.SidecarFile.verify|verify} messages.
             * @param m SidecarFile message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ISidecarFile, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a SidecarFile message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns SidecarFile
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.SidecarFile;

            /**
             * Gets the default type url for SidecarFile
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a TransactionSidecarRecord. */
        interface ITransactionSidecarRecord {

            /**
             * Consensus timestamp will be the same as the consensus timestamp of the
             * transaction the side car is related to. This offers a convenient
             * way to match record to sidecar.
             */
            consensusTimestamp?: (hashgraph.proto.ITimestamp|null);

            /** Whether sidecar is from migration. */
            migration?: (boolean|null);

            /** TransactionSidecarRecord stateChanges */
            stateChanges?: (hashgraph.proto.IContractStateChanges|null);

            /** TransactionSidecarRecord actions */
            actions?: (hashgraph.proto.IContractActions|null);

            /** TransactionSidecarRecord bytecode */
            bytecode?: (hashgraph.proto.IContractBytecode|null);
        }

        /**
         * TransactionSidecarRecord is used to create sidecar records complementing
         * TransactionRecord and storing additional information about a transaction's execution.
         */
        class TransactionSidecarRecord implements ITransactionSidecarRecord {

            /**
             * Constructs a new TransactionSidecarRecord.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ITransactionSidecarRecord);

            /**
             * Consensus timestamp will be the same as the consensus timestamp of the
             * transaction the side car is related to. This offers a convenient
             * way to match record to sidecar.
             */
            public consensusTimestamp?: (hashgraph.proto.ITimestamp|null);

            /** Whether sidecar is from migration. */
            public migration: boolean;

            /** TransactionSidecarRecord stateChanges. */
            public stateChanges?: (hashgraph.proto.IContractStateChanges|null);

            /** TransactionSidecarRecord actions. */
            public actions?: (hashgraph.proto.IContractActions|null);

            /** TransactionSidecarRecord bytecode. */
            public bytecode?: (hashgraph.proto.IContractBytecode|null);

            /** TransactionSidecarRecord sidecarRecords. */
            public sidecarRecords?: ("stateChanges"|"actions"|"bytecode");

            /**
             * Creates a new TransactionSidecarRecord instance using the specified properties.
             * @param [properties] Properties to set
             * @returns TransactionSidecarRecord instance
             */
            public static create(properties?: hashgraph.proto.ITransactionSidecarRecord): hashgraph.proto.TransactionSidecarRecord;

            /**
             * Encodes the specified TransactionSidecarRecord message. Does not implicitly {@link hashgraph.proto.TransactionSidecarRecord.verify|verify} messages.
             * @param m TransactionSidecarRecord message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ITransactionSidecarRecord, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TransactionSidecarRecord message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns TransactionSidecarRecord
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.TransactionSidecarRecord;

            /**
             * Gets the default type url for TransactionSidecarRecord
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a SignatureFile. */
        interface ISignatureFile {

            /** Signature for the file */
            fileSignature?: (hashgraph.proto.ISignatureObject|null);

            /** Metadata signature */
            metadataSignature?: (hashgraph.proto.ISignatureObject|null);
        }

        /**
         * The record signature file which is created for each record stream file
         * that signs the hash of the entire corresponding stream file.
         */
        class SignatureFile implements ISignatureFile {

            /**
             * Constructs a new SignatureFile.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ISignatureFile);

            /** Signature for the file */
            public fileSignature?: (hashgraph.proto.ISignatureObject|null);

            /** Metadata signature */
            public metadataSignature?: (hashgraph.proto.ISignatureObject|null);

            /**
             * Creates a new SignatureFile instance using the specified properties.
             * @param [properties] Properties to set
             * @returns SignatureFile instance
             */
            public static create(properties?: hashgraph.proto.ISignatureFile): hashgraph.proto.SignatureFile;

            /**
             * Encodes the specified SignatureFile message. Does not implicitly {@link hashgraph.proto.SignatureFile.verify|verify} messages.
             * @param m SignatureFile message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ISignatureFile, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a SignatureFile message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns SignatureFile
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.SignatureFile;

            /**
             * Gets the default type url for SignatureFile
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** Properties of a SignatureObject. */
        interface ISignatureObject {

            /** The signature type */
            type?: (hashgraph.proto.SignatureType|null);

            /** Signature length */
            length?: (number|null);

            /** Signature checksum */
            checksum?: (number|null);

            /** Signature bytes */
            signature?: (Uint8Array|null);

            /** The hash that is signed by this signature */
            hashObject?: (hashgraph.proto.IHashObject|null);
        }

        /** A Signature defined by its type, length, checksum and signature bytes and the hash that is signed */
        class SignatureObject implements ISignatureObject {

            /**
             * Constructs a new SignatureObject.
             * @param [p] Properties to set
             */
            constructor(p?: hashgraph.proto.ISignatureObject);

            /** The signature type */
            public type: hashgraph.proto.SignatureType;

            /** Signature length */
            public length: number;

            /** Signature checksum */
            public checksum: number;

            /** Signature bytes */
            public signature: Uint8Array;

            /** The hash that is signed by this signature */
            public hashObject?: (hashgraph.proto.IHashObject|null);

            /**
             * Creates a new SignatureObject instance using the specified properties.
             * @param [properties] Properties to set
             * @returns SignatureObject instance
             */
            public static create(properties?: hashgraph.proto.ISignatureObject): hashgraph.proto.SignatureObject;

            /**
             * Encodes the specified SignatureObject message. Does not implicitly {@link hashgraph.proto.SignatureObject.verify|verify} messages.
             * @param m SignatureObject message or plain object to encode
             * @param [w] Writer to encode to
             * @returns Writer
             */
            public static encode(m: hashgraph.proto.ISignatureObject, w?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a SignatureObject message from the specified reader or buffer.
             * @param r Reader or buffer to decode from
             * @param [l] Message length if known beforehand
             * @returns SignatureObject
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): hashgraph.proto.SignatureObject;

            /**
             * Gets the default type url for SignatureObject
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }

        /** The signature type */
        enum SignatureType {
            SIGNATURE_TYPE_UNKNOWN = 0,
            SHA_384_WITH_RSA = 1
        }
    }

    /** Namespace google. */
    namespace google {

        /** Namespace protobuf. */
        namespace protobuf {

            /** Properties of a DoubleValue. */
            interface IDoubleValue {

                /** DoubleValue value */
                value?: (number|null);
            }

            /** Represents a DoubleValue. */
            class DoubleValue implements IDoubleValue {

                /**
                 * Constructs a new DoubleValue.
                 * @param [p] Properties to set
                 */
                constructor(p?: google.protobuf.IDoubleValue);

                /** DoubleValue value. */
                public value: number;

                /**
                 * Creates a new DoubleValue instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns DoubleValue instance
                 */
                public static create(properties?: google.protobuf.IDoubleValue): google.protobuf.DoubleValue;

                /**
                 * Encodes the specified DoubleValue message. Does not implicitly {@link google.protobuf.DoubleValue.verify|verify} messages.
                 * @param m DoubleValue message or plain object to encode
                 * @param [w] Writer to encode to
                 * @returns Writer
                 */
                public static encode(m: google.protobuf.IDoubleValue, w?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a DoubleValue message from the specified reader or buffer.
                 * @param r Reader or buffer to decode from
                 * @param [l] Message length if known beforehand
                 * @returns DoubleValue
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): google.protobuf.DoubleValue;

                /**
                 * Gets the default type url for DoubleValue
                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns The default type url
                 */
                public static getTypeUrl(typeUrlPrefix?: string): string;
            }

            /** Properties of a FloatValue. */
            interface IFloatValue {

                /** FloatValue value */
                value?: (number|null);
            }

            /** Represents a FloatValue. */
            class FloatValue implements IFloatValue {

                /**
                 * Constructs a new FloatValue.
                 * @param [p] Properties to set
                 */
                constructor(p?: google.protobuf.IFloatValue);

                /** FloatValue value. */
                public value: number;

                /**
                 * Creates a new FloatValue instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns FloatValue instance
                 */
                public static create(properties?: google.protobuf.IFloatValue): google.protobuf.FloatValue;

                /**
                 * Encodes the specified FloatValue message. Does not implicitly {@link google.protobuf.FloatValue.verify|verify} messages.
                 * @param m FloatValue message or plain object to encode
                 * @param [w] Writer to encode to
                 * @returns Writer
                 */
                public static encode(m: google.protobuf.IFloatValue, w?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a FloatValue message from the specified reader or buffer.
                 * @param r Reader or buffer to decode from
                 * @param [l] Message length if known beforehand
                 * @returns FloatValue
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): google.protobuf.FloatValue;

                /**
                 * Gets the default type url for FloatValue
                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns The default type url
                 */
                public static getTypeUrl(typeUrlPrefix?: string): string;
            }

            /** Properties of an Int64Value. */
            interface IInt64Value {

                /** Int64Value value */
                value?: (Long|null);
            }

            /** Represents an Int64Value. */
            class Int64Value implements IInt64Value {

                /**
                 * Constructs a new Int64Value.
                 * @param [p] Properties to set
                 */
                constructor(p?: google.protobuf.IInt64Value);

                /** Int64Value value. */
                public value: Long;

                /**
                 * Creates a new Int64Value instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Int64Value instance
                 */
                public static create(properties?: google.protobuf.IInt64Value): google.protobuf.Int64Value;

                /**
                 * Encodes the specified Int64Value message. Does not implicitly {@link google.protobuf.Int64Value.verify|verify} messages.
                 * @param m Int64Value message or plain object to encode
                 * @param [w] Writer to encode to
                 * @returns Writer
                 */
                public static encode(m: google.protobuf.IInt64Value, w?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an Int64Value message from the specified reader or buffer.
                 * @param r Reader or buffer to decode from
                 * @param [l] Message length if known beforehand
                 * @returns Int64Value
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): google.protobuf.Int64Value;

                /**
                 * Gets the default type url for Int64Value
                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns The default type url
                 */
                public static getTypeUrl(typeUrlPrefix?: string): string;
            }

            /** Properties of a UInt64Value. */
            interface IUInt64Value {

                /** UInt64Value value */
                value?: (Long|null);
            }

            /** Represents a UInt64Value. */
            class UInt64Value implements IUInt64Value {

                /**
                 * Constructs a new UInt64Value.
                 * @param [p] Properties to set
                 */
                constructor(p?: google.protobuf.IUInt64Value);

                /** UInt64Value value. */
                public value: Long;

                /**
                 * Creates a new UInt64Value instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns UInt64Value instance
                 */
                public static create(properties?: google.protobuf.IUInt64Value): google.protobuf.UInt64Value;

                /**
                 * Encodes the specified UInt64Value message. Does not implicitly {@link google.protobuf.UInt64Value.verify|verify} messages.
                 * @param m UInt64Value message or plain object to encode
                 * @param [w] Writer to encode to
                 * @returns Writer
                 */
                public static encode(m: google.protobuf.IUInt64Value, w?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a UInt64Value message from the specified reader or buffer.
                 * @param r Reader or buffer to decode from
                 * @param [l] Message length if known beforehand
                 * @returns UInt64Value
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): google.protobuf.UInt64Value;

                /**
                 * Gets the default type url for UInt64Value
                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns The default type url
                 */
                public static getTypeUrl(typeUrlPrefix?: string): string;
            }

            /** Properties of an Int32Value. */
            interface IInt32Value {

                /** Int32Value value */
                value?: (number|null);
            }

            /** Represents an Int32Value. */
            class Int32Value implements IInt32Value {

                /**
                 * Constructs a new Int32Value.
                 * @param [p] Properties to set
                 */
                constructor(p?: google.protobuf.IInt32Value);

                /** Int32Value value. */
                public value: number;

                /**
                 * Creates a new Int32Value instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Int32Value instance
                 */
                public static create(properties?: google.protobuf.IInt32Value): google.protobuf.Int32Value;

                /**
                 * Encodes the specified Int32Value message. Does not implicitly {@link google.protobuf.Int32Value.verify|verify} messages.
                 * @param m Int32Value message or plain object to encode
                 * @param [w] Writer to encode to
                 * @returns Writer
                 */
                public static encode(m: google.protobuf.IInt32Value, w?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an Int32Value message from the specified reader or buffer.
                 * @param r Reader or buffer to decode from
                 * @param [l] Message length if known beforehand
                 * @returns Int32Value
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): google.protobuf.Int32Value;

                /**
                 * Gets the default type url for Int32Value
                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns The default type url
                 */
                public static getTypeUrl(typeUrlPrefix?: string): string;
            }

            /** Properties of a UInt32Value. */
            interface IUInt32Value {

                /** UInt32Value value */
                value?: (number|null);
            }

            /** Represents a UInt32Value. */
            class UInt32Value implements IUInt32Value {

                /**
                 * Constructs a new UInt32Value.
                 * @param [p] Properties to set
                 */
                constructor(p?: google.protobuf.IUInt32Value);

                /** UInt32Value value. */
                public value: number;

                /**
                 * Creates a new UInt32Value instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns UInt32Value instance
                 */
                public static create(properties?: google.protobuf.IUInt32Value): google.protobuf.UInt32Value;

                /**
                 * Encodes the specified UInt32Value message. Does not implicitly {@link google.protobuf.UInt32Value.verify|verify} messages.
                 * @param m UInt32Value message or plain object to encode
                 * @param [w] Writer to encode to
                 * @returns Writer
                 */
                public static encode(m: google.protobuf.IUInt32Value, w?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a UInt32Value message from the specified reader or buffer.
                 * @param r Reader or buffer to decode from
                 * @param [l] Message length if known beforehand
                 * @returns UInt32Value
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): google.protobuf.UInt32Value;

                /**
                 * Gets the default type url for UInt32Value
                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns The default type url
                 */
                public static getTypeUrl(typeUrlPrefix?: string): string;
            }

            /** Properties of a BoolValue. */
            interface IBoolValue {

                /** BoolValue value */
                value?: (boolean|null);
            }

            /** Represents a BoolValue. */
            class BoolValue implements IBoolValue {

                /**
                 * Constructs a new BoolValue.
                 * @param [p] Properties to set
                 */
                constructor(p?: google.protobuf.IBoolValue);

                /** BoolValue value. */
                public value: boolean;

                /**
                 * Creates a new BoolValue instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns BoolValue instance
                 */
                public static create(properties?: google.protobuf.IBoolValue): google.protobuf.BoolValue;

                /**
                 * Encodes the specified BoolValue message. Does not implicitly {@link google.protobuf.BoolValue.verify|verify} messages.
                 * @param m BoolValue message or plain object to encode
                 * @param [w] Writer to encode to
                 * @returns Writer
                 */
                public static encode(m: google.protobuf.IBoolValue, w?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a BoolValue message from the specified reader or buffer.
                 * @param r Reader or buffer to decode from
                 * @param [l] Message length if known beforehand
                 * @returns BoolValue
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): google.protobuf.BoolValue;

                /**
                 * Gets the default type url for BoolValue
                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns The default type url
                 */
                public static getTypeUrl(typeUrlPrefix?: string): string;
            }

            /** Properties of a StringValue. */
            interface IStringValue {

                /** StringValue value */
                value?: (string|null);
            }

            /** Represents a StringValue. */
            class StringValue implements IStringValue {

                /**
                 * Constructs a new StringValue.
                 * @param [p] Properties to set
                 */
                constructor(p?: google.protobuf.IStringValue);

                /** StringValue value. */
                public value: string;

                /**
                 * Creates a new StringValue instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns StringValue instance
                 */
                public static create(properties?: google.protobuf.IStringValue): google.protobuf.StringValue;

                /**
                 * Encodes the specified StringValue message. Does not implicitly {@link google.protobuf.StringValue.verify|verify} messages.
                 * @param m StringValue message or plain object to encode
                 * @param [w] Writer to encode to
                 * @returns Writer
                 */
                public static encode(m: google.protobuf.IStringValue, w?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a StringValue message from the specified reader or buffer.
                 * @param r Reader or buffer to decode from
                 * @param [l] Message length if known beforehand
                 * @returns StringValue
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): google.protobuf.StringValue;

                /**
                 * Gets the default type url for StringValue
                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns The default type url
                 */
                public static getTypeUrl(typeUrlPrefix?: string): string;
            }

            /** Properties of a BytesValue. */
            interface IBytesValue {

                /** BytesValue value */
                value?: (Uint8Array|null);
            }

            /** Represents a BytesValue. */
            class BytesValue implements IBytesValue {

                /**
                 * Constructs a new BytesValue.
                 * @param [p] Properties to set
                 */
                constructor(p?: google.protobuf.IBytesValue);

                /** BytesValue value. */
                public value: Uint8Array;

                /**
                 * Creates a new BytesValue instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns BytesValue instance
                 */
                public static create(properties?: google.protobuf.IBytesValue): google.protobuf.BytesValue;

                /**
                 * Encodes the specified BytesValue message. Does not implicitly {@link google.protobuf.BytesValue.verify|verify} messages.
                 * @param m BytesValue message or plain object to encode
                 * @param [w] Writer to encode to
                 * @returns Writer
                 */
                public static encode(m: google.protobuf.IBytesValue, w?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a BytesValue message from the specified reader or buffer.
                 * @param r Reader or buffer to decode from
                 * @param [l] Message length if known beforehand
                 * @returns BytesValue
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(r: ($protobuf.Reader|Uint8Array), l?: number): google.protobuf.BytesValue;

                /**
                 * Gets the default type url for BytesValue
                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns The default type url
                 */
                public static getTypeUrl(typeUrlPrefix?: string): string;
            }
        }
    }
}

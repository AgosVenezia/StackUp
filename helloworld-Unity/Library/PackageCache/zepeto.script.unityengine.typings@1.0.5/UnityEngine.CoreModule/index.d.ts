//# signature=UnityEngine.CoreModule#4018a7bba7ca6151785c4c9e4e167af5#0.0.4
// @ts-nocheck
declare module 'UnityEngine' {

    import * as System from 'System';
    import * as RootNamespace from 'RootNamespace';
    import * as System_Collections from 'System.Collections';
    import * as System_Collections_Generic from 'System.Collections.Generic';
    import * as UnityEngine_SceneManagement from 'UnityEngine.SceneManagement';
    import * as UnityEngine_RectTransform from 'UnityEngine.RectTransform';
    import * as UnityEngine_Random from 'UnityEngine.Random';
    import * as UnityEngine_Experimental_Rendering from 'UnityEngine.Experimental.Rendering';
    import * as UnityEngine_Rendering from 'UnityEngine.Rendering';
    import * as Unity_Collections from 'Unity.Collections';
    import * as UnityEngine_Camera from 'UnityEngine.Camera';
    import * as UnityEngine_Mesh from 'UnityEngine.Mesh';
    import * as UnityEngine_LightProbeProxyVolume from 'UnityEngine.LightProbeProxyVolume';
    import * as UnityEngine_Application from 'UnityEngine.Application';
    import * as UnityEngine_Events from 'UnityEngine.Events';
    import * as UnityEngine_CullingGroup from 'UnityEngine.CullingGroup';
    import * as UnityEngine_LightingSettings from 'UnityEngine.LightingSettings';
    import * as UnityEngine_BoundsInt from 'UnityEngine.BoundsInt';
    import * as UnityEngine_RectInt from 'UnityEngine.RectInt';
    import * as UnityEngine_Display from 'UnityEngine.Display';
    import * as UnityEngine_iOS from 'UnityEngine.iOS';
    import * as UnityEngine_Scripting from 'UnityEngine.Scripting';
    import * as UnityEngine_ShaderVariantCollection from 'UnityEngine.ShaderVariantCollection';
    import * as UnityEngine_TouchScreenKeyboard from 'UnityEngine.TouchScreenKeyboard';
    import * as UnityEngine_U2D from 'UnityEngine.U2D';
        
    /**
     * Base class for all objects Unity can reference.
     */
    class Object extends System.Object {
        /**
         * The name of the object.
         */
        public get name(): string;
        public set name(value: string);
        /**
         * Should the object be hidden, saved with the Scene or modifiable by the user?
         */
        public get hideFlags(): HideFlags;
        public set hideFlags(value: HideFlags);
        
        public constructor();
        /**
         * Returns the instance id of the object.
         */
        public GetInstanceID():number;
        
        public GetHashCode():number;
        
        public Equals($other: any):boolean;
        
        public static op_Implicit($exists: Object):boolean;
        /**
         * Clones the object original and returns the clone.
         * @param original An existing object that you want to make a copy of.
         * @param position Position for the new object.
         * @param rotation Orientation of the new object.
         * @param parent Parent that will be assigned to the new object.
         * @param instantiateInWorldSpace When you assign a parent Object, pass true to position the new object directly in world space. Pass false to set the Object’s position relative to its new parent..
         * @returns The instantiated clone.
         */
        public static Instantiate($original: Object, $position: Vector3, $rotation: Quaternion):Object;
        /**
         * Clones the object original and returns the clone.
         * @param original An existing object that you want to make a copy of.
         * @param position Position for the new object.
         * @param rotation Orientation of the new object.
         * @param parent Parent that will be assigned to the new object.
         * @param instantiateInWorldSpace When you assign a parent Object, pass true to position the new object directly in world space. Pass false to set the Object’s position relative to its new parent..
         * @returns The instantiated clone.
         */
        public static Instantiate($original: Object, $position: Vector3, $rotation: Quaternion, $parent: Transform):Object;
        /**
         * Clones the object original and returns the clone.
         * @param original An existing object that you want to make a copy of.
         * @param position Position for the new object.
         * @param rotation Orientation of the new object.
         * @param parent Parent that will be assigned to the new object.
         * @param instantiateInWorldSpace When you assign a parent Object, pass true to position the new object directly in world space. Pass false to set the Object’s position relative to its new parent..
         * @returns The instantiated clone.
         */
        public static Instantiate($original: Object):Object;
        /**
         * Clones the object original and returns the clone.
         * @param original An existing object that you want to make a copy of.
         * @param position Position for the new object.
         * @param rotation Orientation of the new object.
         * @param parent Parent that will be assigned to the new object.
         * @param instantiateInWorldSpace When you assign a parent Object, pass true to position the new object directly in world space. Pass false to set the Object’s position relative to its new parent..
         * @returns The instantiated clone.
         */
        public static Instantiate($original: Object, $parent: Transform):Object;
        /**
         * Clones the object original and returns the clone.
         * @param original An existing object that you want to make a copy of.
         * @param position Position for the new object.
         * @param rotation Orientation of the new object.
         * @param parent Parent that will be assigned to the new object.
         * @param instantiateInWorldSpace When you assign a parent Object, pass true to position the new object directly in world space. Pass false to set the Object’s position relative to its new parent..
         * @returns The instantiated clone.
         */
        public static Instantiate($original: Object, $parent: Transform, $instantiateInWorldSpace: boolean):Object;
        
        public static Instantiate<T extends Object>($original: T):T;
        
        public static Instantiate<T extends Object>($original: T, $position: Vector3, $rotation: Quaternion):T;
        
        public static Instantiate<T extends Object>($original: T, $position: Vector3, $rotation: Quaternion, $parent: Transform):T;
        
        public static Instantiate<T extends Object>($original: T, $parent: Transform):T;
        
        public static Instantiate<T extends Object>($original: T, $parent: Transform, $worldPositionStays: boolean):T;
        /**
         * Removes a GameObject, component or asset.
         * @param obj The object to destroy.
         * @param t The optional amount of time to delay before destroying the object.
         */
        public static Destroy($obj: Object, $t: number):void;
        /**
         * Removes a GameObject, component or asset.
         * @param obj The object to destroy.
         * @param t The optional amount of time to delay before destroying the object.
         */
        public static Destroy($obj: Object):void;
        /**
         * Destroys the object obj immediately. You are strongly recommended to use Destroy instead.
         * @param obj Object to be destroyed.
         * @param allowDestroyingAssets Set to true to allow assets to be destroyed.
         */
        public static DestroyImmediate($obj: Object, $allowDestroyingAssets: boolean):void;
        /**
         * Destroys the object obj immediately. You are strongly recommended to use Destroy instead.
         * @param obj Object to be destroyed.
         * @param allowDestroyingAssets Set to true to allow assets to be destroyed.
         */
        public static DestroyImmediate($obj: Object):void;
        /**
         * Gets a list of all loaded objects of Type type.
         * @param type The type of object to find.
         * @param includeInactive If true, components attached to inactive GameObjects are also included.
         * @returns The array of objects found matching the type specified.
         */
        public static FindObjectsOfType($type: System.Type):Object[];
        /**
         * Gets a list of all loaded objects of Type type.
         * @param type The type of object to find.
         * @param includeInactive If true, components attached to inactive GameObjects are also included.
         * @returns The array of objects found matching the type specified.
         */
        public static FindObjectsOfType($type: System.Type, $includeInactive: boolean):Object[];
        /**
         * Do not destroy the target Object when loading a new Scene.
         * @param target An Object not destroyed on Scene change.
         */
        public static DontDestroyOnLoad($target: Object):void;
        /**
         * Gets a list of all loaded objects of Type type.
         * @param type The type of object to find.
         * @param includeInactive If true, components attached to inactive GameObjects are also included.
         * @returns The array of objects found matching the type specified.
         */
        public static FindObjectsOfType<T extends Object>():T[];
        /**
         * Gets a list of all loaded objects of Type type.
         * @param type The type of object to find.
         * @param includeInactive If true, components attached to inactive GameObjects are also included.
         * @returns The array of objects found matching the type specified.
         */
        public static FindObjectsOfType<T extends Object>($includeInactive: boolean):T[];
        /**
         * Returns the first active loaded object of Type type.
         * @param type The type of object to find.
         * @returns Object The first active loaded object that matches the specified type. It returns null if no Object matches the type.
         */
        public static FindObjectOfType<T extends Object>():T;
        /**
         * Returns the first active loaded object of Type type.
         * @param type The type of object to find.
         * @returns Object The first active loaded object that matches the specified type. It returns null if no Object matches the type.
         */
        public static FindObjectOfType<T extends Object>($includeInactive: boolean):T;
        /**
         * Returns the first active loaded object of Type type.
         * @param type The type of object to find.
         * @returns Object The first active loaded object that matches the specified type. It returns null if no Object matches the type.
         */
        public static FindObjectOfType($type: System.Type):Object;
        /**
         * Returns the first active loaded object of Type type.
         * @param type The type of object to find.
         * @returns Object The first active loaded object that matches the specified type. It returns null if no Object matches the type.
         */
        public static FindObjectOfType($type: System.Type, $includeInactive: boolean):Object;
        /**
         * Returns the name of the object.
         * @returns The name returned by ToString.
         */
        public ToString():string;
        
        public static op_Equality($x: Object, $y: Object):boolean;
        
        public static op_Inequality($x: Object, $y: Object):boolean;
        
                    
    }
    /**
     * Representation of 3D vectors and points.
     */
    class Vector3 extends System.ValueType {
        
        public static kEpsilon: number;
        
        public static kEpsilonNormalSqrt: number;
        /**
         * X component of the vector.
         */
        public x: number;
        /**
         * Y component of the vector.
         */
        public y: number;
        /**
         * Z component of the vector.
         */
        public z: number;
        /**
         * Returns this vector with a magnitude of 1 (Read Only).
         */
        public get normalized(): Vector3;
        /**
         * Returns the length of this vector (Read Only).
         */
        public get magnitude(): number;
        /**
         * Returns the squared length of this vector (Read Only).
         */
        public get sqrMagnitude(): number;
        /**
         * Shorthand for writing Vector3(0, 0, 0).
         */
        public static get zero(): Vector3;
        /**
         * Shorthand for writing Vector3(1, 1, 1).
         */
        public static get one(): Vector3;
        /**
         * Shorthand for writing Vector3(0, 0, 1).
         */
        public static get forward(): Vector3;
        /**
         * Shorthand for writing Vector3(0, 0, -1).
         */
        public static get back(): Vector3;
        /**
         * Shorthand for writing Vector3(0, 1, 0).
         */
        public static get up(): Vector3;
        /**
         * Shorthand for writing Vector3(0, -1, 0).
         */
        public static get down(): Vector3;
        /**
         * Shorthand for writing Vector3(-1, 0, 0).
         */
        public static get left(): Vector3;
        /**
         * Shorthand for writing Vector3(1, 0, 0).
         */
        public static get right(): Vector3;
        /**
         * Shorthand for writing Vector3(float.PositiveInfinity, float.PositiveInfinity, float.PositiveInfinity).
         */
        public static get positiveInfinity(): Vector3;
        /**
         * Shorthand for writing Vector3(float.NegativeInfinity, float.NegativeInfinity, float.NegativeInfinity).
         */
        public static get negativeInfinity(): Vector3;
        /**
         * Creates a new vector with given x, y, z components.
         */
        public constructor($x: number, $y: number, $z: number);
        /**
         * Creates a new vector with given x, y components and sets z to zero.
         */
        public constructor($x: number, $y: number);
        /**
         * Spherically interpolates between two vectors.
         */
        public static Slerp($a: Vector3, $b: Vector3, $t: number):Vector3;
        /**
         * Spherically interpolates between two vectors.
         */
        public static SlerpUnclamped($a: Vector3, $b: Vector3, $t: number):Vector3;
        /**
         * Makes vectors normalized and orthogonal to each other.
         */
        public static OrthoNormalize($normal: $Ref<Vector3>, $tangent: $Ref<Vector3>):void;
        /**
         * Makes vectors normalized and orthogonal to each other.
         */
        public static OrthoNormalize($normal: $Ref<Vector3>, $tangent: $Ref<Vector3>, $binormal: $Ref<Vector3>):void;
        /**
         * Rotates a vector current towards target.
         * @param current The vector being managed.
         * @param target The vector.
         * @param maxRadiansDelta The maximum angle in radians allowed for this rotation.
         * @param maxMagnitudeDelta The maximum allowed change in vector magnitude for this rotation.
         * @returns The location that RotateTowards generates.
         */
        public static RotateTowards($current: Vector3, $target: Vector3, $maxRadiansDelta: number, $maxMagnitudeDelta: number):Vector3;
        /**
         * Linearly interpolates between two points.
         * @param a Start value, returned when t = 0.
         * @param b End value, returned when t = 1.
         * @param t Value used to interpolate between a and b.
         * @returns Interpolated value, equals to a + (b - a) * t.
         */
        public static Lerp($a: Vector3, $b: Vector3, $t: number):Vector3;
        /**
         * Linearly interpolates between two vectors.
         */
        public static LerpUnclamped($a: Vector3, $b: Vector3, $t: number):Vector3;
        /**
         * Calculate a position between the points specified by current and target, moving no farther than the distance specified by maxDistanceDelta.
         * @param current The position to move from.
         * @param target The position to move towards.
         * @param maxDistanceDelta Distance to move current per call.
         * @returns The new position.
         */
        public static MoveTowards($current: Vector3, $target: Vector3, $maxDistanceDelta: number):Vector3;
        /**
         * Gradually changes a vector towards a desired goal over time.
         * @param current The current position.
         * @param target The position we are trying to reach.
         * @param currentVelocity The current velocity, this value is modified by the function every time you call it.
         * @param smoothTime Approximately the time it will take to reach the target. A smaller value will reach the target faster.
         * @param maxSpeed Optionally allows you to clamp the maximum speed.
         * @param deltaTime The time since the last call to this function. By default Time.deltaTime.
         */
        public static SmoothDamp($current: Vector3, $target: Vector3, $currentVelocity: $Ref<Vector3>, $smoothTime: number, $maxSpeed: number):Vector3;
        /**
         * Gradually changes a vector towards a desired goal over time.
         * @param current The current position.
         * @param target The position we are trying to reach.
         * @param currentVelocity The current velocity, this value is modified by the function every time you call it.
         * @param smoothTime Approximately the time it will take to reach the target. A smaller value will reach the target faster.
         * @param maxSpeed Optionally allows you to clamp the maximum speed.
         * @param deltaTime The time since the last call to this function. By default Time.deltaTime.
         */
        public static SmoothDamp($current: Vector3, $target: Vector3, $currentVelocity: $Ref<Vector3>, $smoothTime: number):Vector3;
        /**
         * Gradually changes a vector towards a desired goal over time.
         * @param current The current position.
         * @param target The position we are trying to reach.
         * @param currentVelocity The current velocity, this value is modified by the function every time you call it.
         * @param smoothTime Approximately the time it will take to reach the target. A smaller value will reach the target faster.
         * @param maxSpeed Optionally allows you to clamp the maximum speed.
         * @param deltaTime The time since the last call to this function. By default Time.deltaTime.
         */
        public static SmoothDamp($current: Vector3, $target: Vector3, $currentVelocity: $Ref<Vector3>, $smoothTime: number, $maxSpeed: number, $deltaTime: number):Vector3;
        
        public get_Item($index: number):number;
        
        public set_Item($index: number, $value: number):void;
        /**
         * Set x, y and z components of an existing Vector3.
         */
        public Set($newX: number, $newY: number, $newZ: number):void;
        /**
         * Multiplies two vectors component-wise.
         */
        public static Scale($a: Vector3, $b: Vector3):Vector3;
        /**
         * Multiplies every component of this vector by the same component of scale.
         */
        public Scale($scale: Vector3):void;
        /**
         * Cross Product of two vectors.
         */
        public static Cross($lhs: Vector3, $rhs: Vector3):Vector3;
        
        public GetHashCode():number;
        /**
         * Returns true if the given vector is exactly equal to this vector.
         */
        public Equals($other: any):boolean;
        
        public Equals($other: Vector3):boolean;
        /**
         * Reflects a vector off the plane defined by a normal.
         */
        public static Reflect($inDirection: Vector3, $inNormal: Vector3):Vector3;
        /**
         * Makes this vector have a magnitude of 1.
         */
        public static Normalize($value: Vector3):Vector3;
        
        public Normalize():void;
        /**
         * Dot Product of two vectors.
         */
        public static Dot($lhs: Vector3, $rhs: Vector3):number;
        /**
         * Projects a vector onto another vector.
         */
        public static Project($vector: Vector3, $onNormal: Vector3):Vector3;
        /**
         * Projects a vector onto a plane defined by a normal orthogonal to the plane.
         * @param planeNormal The direction from the vector towards the plane.
         * @param vector The location of the vector above the plane.
         * @returns The location of the vector on the plane.
         */
        public static ProjectOnPlane($vector: Vector3, $planeNormal: Vector3):Vector3;
        /**
         * Returns the angle in degrees between from and to.
         * @param from The vector from which the angular difference is measured.
         * @param to The vector to which the angular difference is measured.
         * @returns The angle in degrees between the two vectors.
         */
        public static Angle($from: Vector3, $to: Vector3):number;
        /**
         * Returns the signed angle in degrees between from and to.
         * @param from The vector from which the angular difference is measured.
         * @param to The vector to which the angular difference is measured.
         * @param axis A vector around which the other vectors are rotated.
         */
        public static SignedAngle($from: Vector3, $to: Vector3, $axis: Vector3):number;
        /**
         * Returns the distance between a and b.
         */
        public static Distance($a: Vector3, $b: Vector3):number;
        /**
         * Returns a copy of vector with its magnitude clamped to maxLength.
         */
        public static ClampMagnitude($vector: Vector3, $maxLength: number):Vector3;
        
        public static Magnitude($vector: Vector3):number;
        
        public static SqrMagnitude($vector: Vector3):number;
        /**
         * Returns a vector that is made from the smallest components of two vectors.
         */
        public static Min($lhs: Vector3, $rhs: Vector3):Vector3;
        /**
         * Returns a vector that is made from the largest components of two vectors.
         */
        public static Max($lhs: Vector3, $rhs: Vector3):Vector3;
        
        public static op_Addition($a: Vector3, $b: Vector3):Vector3;
        
        public static op_Subtraction($a: Vector3, $b: Vector3):Vector3;
        
        public static op_UnaryNegation($a: Vector3):Vector3;
        /**
         * Multiplies a vector by a number.
         */
        public static op_Multiply($a: Vector3, $d: number):Vector3;
        /**
         * Multiplies a vector by a number.
         */
        public static op_Multiply($d: number, $a: Vector3):Vector3;
        
        public static op_Division($a: Vector3, $d: number):Vector3;
        
        public static op_Equality($lhs: Vector3, $rhs: Vector3):boolean;
        
        public static op_Inequality($lhs: Vector3, $rhs: Vector3):boolean;
        /**
         * Returns a formatted string for this vector.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        public ToString():string;
        /**
         * Returns a formatted string for this vector.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        public ToString($format: string):string;
        /**
         * Returns a formatted string for this vector.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        public ToString($format: string, $formatProvider: System.IFormatProvider):string;
        
        public get_Clone(): Vector3;            
    }
    /**
     * Quaternions are used to represent rotations.
     */
    class Quaternion extends System.ValueType {
        /**
         * X component of the Quaternion. Don't modify this directly unless you know quaternions inside out.
         */
        public x: number;
        /**
         * Y component of the Quaternion. Don't modify this directly unless you know quaternions inside out.
         */
        public y: number;
        /**
         * Z component of the Quaternion. Don't modify this directly unless you know quaternions inside out.
         */
        public z: number;
        /**
         * W component of the Quaternion. Do not directly modify quaternions.
         */
        public w: number;
        
        public static kEpsilon: number;
        /**
         * The identity rotation (Read Only).
         */
        public static get identity(): Quaternion;
        /**
         * Returns or sets the euler angle representation of the rotation.
         */
        public get eulerAngles(): Vector3;
        public set eulerAngles(value: Vector3);
        /**
         * Returns this quaternion with a magnitude of 1 (Read Only).
         */
        public get normalized(): Quaternion;
        /**
         * Constructs new Quaternion with given x,y,z,w components.
         */
        public constructor($x: number, $y: number, $z: number, $w: number);
        /**
         * Creates a rotation which rotates from fromDirection to toDirection.
         */
        public static FromToRotation($fromDirection: Vector3, $toDirection: Vector3):Quaternion;
        /**
         * Returns the Inverse of rotation.
         */
        public static Inverse($rotation: Quaternion):Quaternion;
        /**
         * Spherically interpolates between quaternions a and b by ratio t. The parameter t is clamped to the range [0, 1].
         * @param a Start value, returned when t = 0.
         * @param b End value, returned when t = 1.
         * @param t Interpolation ratio.
         * @returns A quaternion spherically interpolated between quaternions a and b.
         */
        public static Slerp($a: Quaternion, $b: Quaternion, $t: number):Quaternion;
        /**
         * Spherically interpolates between a and b by t. The parameter t is not clamped.
         */
        public static SlerpUnclamped($a: Quaternion, $b: Quaternion, $t: number):Quaternion;
        /**
         * Interpolates between a and b by t and normalizes the result afterwards. The parameter t is clamped to the range [0, 1].
         */
        public static Lerp($a: Quaternion, $b: Quaternion, $t: number):Quaternion;
        /**
         * Interpolates between a and b by t and normalizes the result afterwards. The parameter t is not clamped.
         */
        public static LerpUnclamped($a: Quaternion, $b: Quaternion, $t: number):Quaternion;
        /**
         * Creates a rotation which rotates angle degrees around axis.
         */
        public static AngleAxis($angle: number, $axis: Vector3):Quaternion;
        /**
         * Creates a rotation with the specified forward and upwards directions.
         * @param forward The direction to look in.
         * @param upwards The vector that defines in which direction up is.
         */
        public static LookRotation($forward: Vector3, $upwards: Vector3):Quaternion;
        /**
         * Creates a rotation with the specified forward and upwards directions.
         * @param forward The direction to look in.
         * @param upwards The vector that defines in which direction up is.
         */
        public static LookRotation($forward: Vector3):Quaternion;
        
        public get_Item($index: number):number;
        
        public set_Item($index: number, $value: number):void;
        /**
         * Set x, y, z and w components of an existing Quaternion.
         */
        public Set($newX: number, $newY: number, $newZ: number, $newW: number):void;
        /**
         * Combines rotations lhs and rhs.
         * @param lhs Left-hand side quaternion.
         * @param rhs Right-hand side quaternion.
         */
        public static op_Multiply($lhs: Quaternion, $rhs: Quaternion):Quaternion;
        /**
         * Rotates the point point with rotation.
         */
        public static op_Multiply($rotation: Quaternion, $point: Vector3):Vector3;
        
        public static op_Equality($lhs: Quaternion, $rhs: Quaternion):boolean;
        
        public static op_Inequality($lhs: Quaternion, $rhs: Quaternion):boolean;
        /**
         * The dot product between two rotations.
         */
        public static Dot($a: Quaternion, $b: Quaternion):number;
        /**
         * Creates a rotation with the specified forward and upwards directions.
         * @param view The direction to look in.
         * @param up The vector that defines in which direction up is.
         */
        public SetLookRotation($view: Vector3):void;
        /**
         * Creates a rotation with the specified forward and upwards directions.
         * @param view The direction to look in.
         * @param up The vector that defines in which direction up is.
         */
        public SetLookRotation($view: Vector3, $up: Vector3):void;
        /**
         * Returns the angle in degrees between two rotations a and b.
         */
        public static Angle($a: Quaternion, $b: Quaternion):number;
        /**
         * Returns a rotation that rotates z degrees around the z axis, x degrees around the x axis, and y degrees around the y axis; applied in that order.
         */
        public static Euler($x: number, $y: number, $z: number):Quaternion;
        /**
         * Returns a rotation that rotates z degrees around the z axis, x degrees around the x axis, and y degrees around the y axis.
         */
        public static Euler($euler: Vector3):Quaternion;
        /**
         * Converts a rotation to angle-axis representation (angles in degrees).
         */
        public ToAngleAxis($angle: $Ref<number>, $axis: $Ref<Vector3>):void;
        /**
         * Creates a rotation which rotates from fromDirection to toDirection.
         */
        public SetFromToRotation($fromDirection: Vector3, $toDirection: Vector3):void;
        /**
         * Rotates a rotation from towards to.
         */
        public static RotateTowards($from: Quaternion, $to: Quaternion, $maxDegreesDelta: number):Quaternion;
        /**
         * Converts this quaternion to one with the same orientation but with a magnitude of 1.
         */
        public static Normalize($q: Quaternion):Quaternion;
        
        public Normalize():void;
        
        public GetHashCode():number;
        
        public Equals($other: any):boolean;
        
        public Equals($other: Quaternion):boolean;
        /**
         * Returns a formatted string of the Quaternion.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        public ToString():string;
        /**
         * Returns a formatted string of the Quaternion.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        public ToString($format: string):string;
        /**
         * Returns a formatted string of the Quaternion.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        public ToString($format: string, $formatProvider: System.IFormatProvider):string;
        
        public get_Clone(): Quaternion;            
    }
    /**
     * Position, rotation and scale of an object.
     */
    class Transform extends Component {
        /**
         * The world space position of the Transform.
         */
        public get position(): Vector3;
        public set position(value: Vector3);
        /**
         * Position of the transform relative to the parent transform.
         */
        public get localPosition(): Vector3;
        public set localPosition(value: Vector3);
        /**
         * The rotation as Euler angles in degrees.
         */
        public get eulerAngles(): Vector3;
        public set eulerAngles(value: Vector3);
        /**
         * The rotation as Euler angles in degrees relative to the parent transform's rotation.
         */
        public get localEulerAngles(): Vector3;
        public set localEulerAngles(value: Vector3);
        /**
         * The red axis of the transform in world space.
         */
        public get right(): Vector3;
        public set right(value: Vector3);
        /**
         * The green axis of the transform in world space.
         */
        public get up(): Vector3;
        public set up(value: Vector3);
        /**
         * Returns a normalized vector representing the blue axis of the transform in world space.
         */
        public get forward(): Vector3;
        public set forward(value: Vector3);
        /**
         * A Quaternion that stores the rotation of the Transform in world space.
         */
        public get rotation(): Quaternion;
        public set rotation(value: Quaternion);
        /**
         * The rotation of the transform relative to the transform rotation of the parent.
         */
        public get localRotation(): Quaternion;
        public set localRotation(value: Quaternion);
        /**
         * The scale of the transform relative to the GameObjects parent.
         */
        public get localScale(): Vector3;
        public set localScale(value: Vector3);
        /**
         * The parent of the transform.
         */
        public get parent(): Transform;
        public set parent(value: Transform);
        /**
         * Matrix that transforms a point from world space into local space (Read Only).
         */
        public get worldToLocalMatrix(): Matrix4x4;
        /**
         * Matrix that transforms a point from local space into world space (Read Only).
         */
        public get localToWorldMatrix(): Matrix4x4;
        /**
         * Returns the topmost transform in the hierarchy.
         */
        public get root(): Transform;
        /**
         * The number of children the parent Transform has.
         */
        public get childCount(): number;
        /**
         * The global scale of the object (Read Only).
         */
        public get lossyScale(): Vector3;
        /**
         * Has the transform changed since the last time the flag was set to 'false'?
         */
        public get hasChanged(): boolean;
        public set hasChanged(value: boolean);
        /**
         * The transform capacity of the transform's hierarchy data structure.
         */
        public get hierarchyCapacity(): number;
        public set hierarchyCapacity(value: number);
        /**
         * The number of transforms in the transform's hierarchy data structure.
         */
        public get hierarchyCount(): number;
        /**
         * Set the parent of the transform.
         * @param parent The parent Transform to use.
         * @param worldPositionStays If true, the parent-relative position, scale and rotation are modified such that the object keeps the same world space position, rotation and scale as before.
         */
        public SetParent($p: Transform):void;
        /**
         * Set the parent of the transform.
         * @param parent The parent Transform to use.
         * @param worldPositionStays If true, the parent-relative position, scale and rotation are modified such that the object keeps the same world space position, rotation and scale as before.
         */
        public SetParent($parent: Transform, $worldPositionStays: boolean):void;
        /**
         * Sets the world space position and rotation of the Transform component.
         */
        public SetPositionAndRotation($position: Vector3, $rotation: Quaternion):void;
        /**
         * Moves the transform in the direction and distance of translation.
         */
        public Translate($translation: Vector3, $relativeTo: Space):void;
        /**
         * Moves the transform in the direction and distance of translation.
         */
        public Translate($translation: Vector3):void;
        /**
         * Moves the transform by x along the x axis, y along the y axis, and z along the z axis.
         */
        public Translate($x: number, $y: number, $z: number, $relativeTo: Space):void;
        /**
         * Moves the transform by x along the x axis, y along the y axis, and z along the z axis.
         */
        public Translate($x: number, $y: number, $z: number):void;
        /**
         * Moves the transform in the direction and distance of translation.
         */
        public Translate($translation: Vector3, $relativeTo: Transform):void;
        /**
         * Moves the transform by x along the x axis, y along the y axis, and z along the z axis.
         */
        public Translate($x: number, $y: number, $z: number, $relativeTo: Transform):void;
        /**
         * Applies a rotation of eulerAngles.z degrees around the z-axis, eulerAngles.x degrees around the x-axis, and eulerAngles.y degrees around the y-axis (in that order).
         * @param eulers The rotation to apply in euler angles.
         * @param relativeTo Determines whether to rotate the GameObject either locally to  the GameObject or relative to the Scene in world space.
         */
        public Rotate($eulers: Vector3, $relativeTo: Space):void;
        /**
         * Applies a rotation of eulerAngles.z degrees around the z-axis, eulerAngles.x degrees around the x-axis, and eulerAngles.y degrees around the y-axis (in that order).
         * @param eulers The rotation to apply in euler angles.
         */
        public Rotate($eulers: Vector3):void;
        /**
         * The implementation of this method applies a rotation of zAngle degrees around the z axis, xAngle degrees around the x axis, and yAngle degrees around the y axis (in that order).
         * @param relativeTo Determines whether to rotate the GameObject either locally to the GameObject or relative to the Scene in world space.
         * @param xAngle Degrees to rotate the GameObject around the X axis.
         * @param yAngle Degrees to rotate the GameObject around the Y axis.
         * @param zAngle Degrees to rotate the GameObject around the Z axis.
         */
        public Rotate($xAngle: number, $yAngle: number, $zAngle: number, $relativeTo: Space):void;
        /**
         * The implementation of this method applies a rotation of zAngle degrees around the z axis, xAngle degrees around the x axis, and yAngle degrees around the y axis (in that order).
         * @param xAngle Degrees to rotate the GameObject around the X axis.
         * @param yAngle Degrees to rotate the GameObject around the Y axis.
         * @param zAngle Degrees to rotate the GameObject around the Z axis.
         */
        public Rotate($xAngle: number, $yAngle: number, $zAngle: number):void;
        /**
         * Rotates the object around the given axis by the number of degrees defined by the given angle.
         * @param angle The degrees of rotation to apply.
         * @param axis The axis to apply rotation to.
         * @param relativeTo Determines whether to rotate the GameObject either locally to the GameObject or relative to the Scene in world space.
         */
        public Rotate($axis: Vector3, $angle: number, $relativeTo: Space):void;
        /**
         * Rotates the object around the given axis by the number of degrees defined by the given angle.
         * @param axis The axis to apply rotation to.
         * @param angle The degrees of rotation to apply.
         */
        public Rotate($axis: Vector3, $angle: number):void;
        /**
         * Rotates the transform about axis passing through point in world coordinates by angle degrees.
         */
        public RotateAround($point: Vector3, $axis: Vector3, $angle: number):void;
        /**
         * Rotates the transform so the forward vector points at target's current position.
         * @param target Object to point towards.
         * @param worldUp Vector specifying the upward direction.
         */
        public LookAt($target: Transform, $worldUp: Vector3):void;
        /**
         * Rotates the transform so the forward vector points at target's current position.
         * @param target Object to point towards.
         * @param worldUp Vector specifying the upward direction.
         */
        public LookAt($target: Transform):void;
        /**
         * Rotates the transform so the forward vector points at worldPosition.
         * @param worldPosition Point to look at.
         * @param worldUp Vector specifying the upward direction.
         */
        public LookAt($worldPosition: Vector3, $worldUp: Vector3):void;
        /**
         * Rotates the transform so the forward vector points at worldPosition.
         * @param worldPosition Point to look at.
         * @param worldUp Vector specifying the upward direction.
         */
        public LookAt($worldPosition: Vector3):void;
        /**
         * Transforms direction from local space to world space.
         */
        public TransformDirection($direction: Vector3):Vector3;
        /**
         * Transforms direction x, y, z from local space to world space.
         */
        public TransformDirection($x: number, $y: number, $z: number):Vector3;
        /**
         * Transforms a direction from world space to local space. The opposite of Transform.TransformDirection.
         */
        public InverseTransformDirection($direction: Vector3):Vector3;
        /**
         * Transforms the direction x, y, z from world space to local space. The opposite of Transform.TransformDirection.
         */
        public InverseTransformDirection($x: number, $y: number, $z: number):Vector3;
        /**
         * Transforms vector from local space to world space.
         */
        public TransformVector($vector: Vector3):Vector3;
        /**
         * Transforms vector x, y, z from local space to world space.
         */
        public TransformVector($x: number, $y: number, $z: number):Vector3;
        /**
         * Transforms a vector from world space to local space. The opposite of Transform.TransformVector.
         */
        public InverseTransformVector($vector: Vector3):Vector3;
        /**
         * Transforms the vector x, y, z from world space to local space. The opposite of Transform.TransformVector.
         */
        public InverseTransformVector($x: number, $y: number, $z: number):Vector3;
        /**
         * Transforms position from local space to world space.
         */
        public TransformPoint($position: Vector3):Vector3;
        /**
         * Transforms the position x, y, z from local space to world space.
         */
        public TransformPoint($x: number, $y: number, $z: number):Vector3;
        /**
         * Transforms position from world space to local space.
         */
        public InverseTransformPoint($position: Vector3):Vector3;
        /**
         * Transforms the position x, y, z from world space to local space. The opposite of Transform.TransformPoint.
         */
        public InverseTransformPoint($x: number, $y: number, $z: number):Vector3;
        /**
         * Unparents all children.
         */
        public DetachChildren():void;
        /**
         * Move the transform to the start of the local transform list.
         */
        public SetAsFirstSibling():void;
        /**
         * Move the transform to the end of the local transform list.
         */
        public SetAsLastSibling():void;
        /**
         * Sets the sibling index.
         * @param index Index to set.
         */
        public SetSiblingIndex($index: number):void;
        /**
         * Gets the sibling index.
         */
        public GetSiblingIndex():number;
        /**
         * Finds a child by n and returns it.
         * @param n Name of child to be found.
         * @returns The returned child transform or null if no child is found.
         */
        public Find($n: string):Transform;
        /**
         * Is this transform a child of parent?
         */
        public IsChildOf($parent: Transform):boolean;
        
        public GetEnumerator():System_Collections.IEnumerator;
        /**
         * Returns a transform child by index.
         * @param index Index of the child transform to return. Must be smaller than Transform.childCount.
         * @returns Transform child by index.
         */
        public GetChild($index: number):Transform;
        
                    
    }
    /**
     * Base class for everything attached to GameObjects.
     */
    class Component extends Object {
        /**
         * The Transform attached to this GameObject.
         */
        public get transform(): Transform;
        /**
         * The game object this component is attached to. A component is always attached to a game object.
         */
        public get gameObject(): GameObject;
        /**
         * The tag of this game object.
         */
        public get tag(): string;
        public set tag(value: string);
        
        public constructor();
        /**
         * Returns the component of Type type if the GameObject has one attached, null if it doesn't. Will also return disabled components.
         * @param type The type of Component to retrieve.
         */
        public GetComponent($type: System.Type):Component;
        /**
         * Generic version of this method.
         */
        public GetComponent<T>():T;
        /**
         * Gets the component of the specified type, if it exists.
         * @param type The type of the component to retrieve.
         * @param component The output argument that will contain the component or null.
         * @returns Returns true if the component is found, false otherwise.
         */
        public TryGetComponent($type: System.Type, $component: $Ref<Component>):boolean;
        
        public TryGetComponent<T>($component: $Ref<T>):boolean;
        /**
         * Returns the component with name type if the GameObject has one attached, null if it doesn't.
         */
        public GetComponent($type: string):Component;
        
        public GetComponentInChildren($t: System.Type, $includeInactive: boolean):Component;
        /**
         * Returns the component of Type type in the GameObject or any of its children using depth first search.
         * @param t The type of Component to retrieve.
         * @returns A component of the matching type, if found.
         */
        public GetComponentInChildren($t: System.Type):Component;
        
        public GetComponentInChildren<T>($includeInactive: boolean):T;
        
        public GetComponentInChildren<T>():T;
        /**
         * Returns all components of Type type in the GameObject or any of its children. Works recursively.
         * @param t The type of Component to retrieve.
         * @param includeInactive Should Components on inactive GameObjects be included in the found set? includeInactive decides which children of the GameObject will be searched.  The GameObject that you call GetComponentsInChildren on is always searched regardless. Default is false.
         */
        public GetComponentsInChildren($t: System.Type, $includeInactive: boolean):Component[];
        
        public GetComponentsInChildren($t: System.Type):Component[];
        /**
         * Generic version of this method.
         * @param includeInactive Should Components on inactive GameObjects be included in the found set? includeInactive decides which children of the GameObject will be searched.  The GameObject that you call GetComponentsInChildren on is always searched regardless.
         * @returns A list of all found components matching the specified type.
         */
        public GetComponentsInChildren<T>($includeInactive: boolean):T[];
        
        public GetComponentsInChildren<T>($includeInactive: boolean, $result: System_Collections_Generic.List$1<T>):void;
        /**
         * Generic version of this method.
         * @returns A list of all found components matching the specified type.
         */
        public GetComponentsInChildren<T>():T[];
        /**
         * Generic version of this method.
         * @returns A list of all found components matching the specified type.
         */
        public GetComponentsInChildren<T>($results: System_Collections_Generic.List$1<T>):void;
        /**
         * Returns the component of Type type in the GameObject or any of its parents.
         * @param t The type of Component to retrieve.
         * @returns A component of the matching type, if found.
         */
        public GetComponentInParent($t: System.Type):Component;
        /**
         * Generic version of this method.
         * @returns A component of the matching type, if found.
         */
        public GetComponentInParent<T>():T;
        /**
         * Returns all components of Type type in the GameObject or any of its parents.
         * @param t The type of Component to retrieve.
         * @param includeInactive Should inactive Components be included in the found set?
         */
        public GetComponentsInParent($t: System.Type, $includeInactive: boolean):Component[];
        
        public GetComponentsInParent($t: System.Type):Component[];
        /**
         * Generic version of this method.
         * @param includeInactive Should inactive Components be included in the found set?
         */
        public GetComponentsInParent<T>($includeInactive: boolean):T[];
        
        public GetComponentsInParent<T>($includeInactive: boolean, $results: System_Collections_Generic.List$1<T>):void;
        /**
         * Generic version of this method.
         * @param includeInactive Should inactive Components be included in the found set?
         */
        public GetComponentsInParent<T>():T[];
        /**
         * Returns all components of Type type in the GameObject.
         * @param type The type of Component to retrieve.
         */
        public GetComponents($type: System.Type):Component[];
        
        public GetComponents($type: System.Type, $results: System_Collections_Generic.List$1<Component>):void;
        /**
         * Generic version of this method.
         */
        public GetComponents<T>($results: System_Collections_Generic.List$1<T>):void;
        /**
         * Generic version of this method.
         */
        public GetComponents<T>():T[];
        /**
         * Is this game object tagged with tag ?
         * @param tag The tag to compare.
         */
        public CompareTag($tag: string):boolean;
        /**
         * Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour.
         * @param methodName Name of method to call.
         * @param value Optional parameter value for the method.
         * @param options Should an error be raised if the method does not exist on the target object?
         */
        public SendMessageUpwards($methodName: string, $value: any, $options: SendMessageOptions):void;
        /**
         * Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour.
         * @param methodName Name of method to call.
         * @param value Optional parameter value for the method.
         * @param options Should an error be raised if the method does not exist on the target object?
         */
        public SendMessageUpwards($methodName: string, $value: any):void;
        /**
         * Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour.
         * @param methodName Name of method to call.
         * @param value Optional parameter value for the method.
         * @param options Should an error be raised if the method does not exist on the target object?
         */
        public SendMessageUpwards($methodName: string):void;
        /**
         * Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour.
         * @param methodName Name of method to call.
         * @param value Optional parameter value for the method.
         * @param options Should an error be raised if the method does not exist on the target object?
         */
        public SendMessageUpwards($methodName: string, $options: SendMessageOptions):void;
        /**
         * Calls the method named methodName on every MonoBehaviour in this game object.
         * @param methodName Name of the method to call.
         * @param value Optional parameter for the method.
         * @param options Should an error be raised if the target object doesn't implement the method for the message?
         */
        public SendMessage($methodName: string, $value: any):void;
        /**
         * Calls the method named methodName on every MonoBehaviour in this game object.
         * @param methodName Name of the method to call.
         * @param value Optional parameter for the method.
         * @param options Should an error be raised if the target object doesn't implement the method for the message?
         */
        public SendMessage($methodName: string):void;
        /**
         * Calls the method named methodName on every MonoBehaviour in this game object.
         * @param methodName Name of the method to call.
         * @param value Optional parameter for the method.
         * @param options Should an error be raised if the target object doesn't implement the method for the message?
         */
        public SendMessage($methodName: string, $value: any, $options: SendMessageOptions):void;
        /**
         * Calls the method named methodName on every MonoBehaviour in this game object.
         * @param methodName Name of the method to call.
         * @param value Optional parameter for the method.
         * @param options Should an error be raised if the target object doesn't implement the method for the message?
         */
        public SendMessage($methodName: string, $options: SendMessageOptions):void;
        /**
         * Calls the method named methodName on every MonoBehaviour in this game object or any of its children.
         * @param methodName Name of the method to call.
         * @param parameter Optional parameter to pass to the method (can be any value).
         * @param options Should an error be raised if the method does not exist for a given target object?
         */
        public BroadcastMessage($methodName: string, $parameter: any, $options: SendMessageOptions):void;
        /**
         * Calls the method named methodName on every MonoBehaviour in this game object or any of its children.
         * @param methodName Name of the method to call.
         * @param parameter Optional parameter to pass to the method (can be any value).
         * @param options Should an error be raised if the method does not exist for a given target object?
         */
        public BroadcastMessage($methodName: string, $parameter: any):void;
        /**
         * Calls the method named methodName on every MonoBehaviour in this game object or any of its children.
         * @param methodName Name of the method to call.
         * @param parameter Optional parameter to pass to the method (can be any value).
         * @param options Should an error be raised if the method does not exist for a given target object?
         */
        public BroadcastMessage($methodName: string):void;
        /**
         * Calls the method named methodName on every MonoBehaviour in this game object or any of its children.
         * @param methodName Name of the method to call.
         * @param parameter Optional parameter to pass to the method (can be any value).
         * @param options Should an error be raised if the method does not exist for a given target object?
         */
        public BroadcastMessage($methodName: string, $options: SendMessageOptions):void;
        
                    
    }
    /**
     * Bit mask that controls object destruction, saving and visibility in inspectors.
     */
    enum HideFlags { None = 0, HideInHierarchy = 1, HideInInspector = 2, DontSaveInEditor = 4, NotEditable = 8, DontSaveInBuild = 16, DontUnloadUnusedAsset = 32, DontSave = 52, HideAndDontSave = 61 }
    /**
     * Base class for all entities in Unity Scenes.
     */
    class GameObject extends Object {
        /**
         * The Transform attached to this GameObject.
         */
        public get transform(): Transform;
        /**
         * The layer the game object is in.
         */
        public get layer(): number;
        public set layer(value: number);
        /**
         * The local active state of this GameObject. (Read Only)
         */
        public get activeSelf(): boolean;
        /**
         * Defines whether the GameObject is active in the Scene.
         */
        public get activeInHierarchy(): boolean;
        /**
         * Gets and sets the GameObject's StaticEditorFlags.
         */
        public get isStatic(): boolean;
        public set isStatic(value: boolean);
        /**
         * The tag of this game object.
         */
        public get tag(): string;
        public set tag(value: string);
        /**
         * Scene that the GameObject is part of.
         */
        public get scene(): UnityEngine_SceneManagement.Scene;
        /**
         * Scene culling mask Unity uses to determine which scene to render the GameObject in.
         */
        public get sceneCullingMask(): bigint;
        
        public get gameObject(): GameObject;
        /**
         * Creates a new game object, named name.
         * @param name The name that the GameObject is created with.
         * @param components A list of Components to add to the GameObject on creation.
         */
        public constructor($name: string);
        /**
         * Creates a new game object, named name.
         * @param name The name that the GameObject is created with.
         * @param components A list of Components to add to the GameObject on creation.
         */
        public constructor();
        /**
         * Creates a new game object, named name.
         * @param name The name that the GameObject is created with.
         * @param components A list of Components to add to the GameObject on creation.
         */
        public constructor($name: string, ...components: System.Type[]);
        /**
         * Creates a game object with a primitive mesh renderer and appropriate collider.
         * @param type The type of primitive object to create.
         */
        public static CreatePrimitive($type: PrimitiveType):GameObject;
        /**
         * Generic version of this method.
         */
        public GetComponent<T>():T;
        /**
         * Returns the component of Type type if the game object has one attached, null if it doesn't.
         * @param type The type of Component to retrieve.
         */
        public GetComponent($type: System.Type):Component;
        /**
         * Returns the component with name type if the game object has one attached, null if it doesn't.
         * @param type The type of Component to retrieve.
         */
        public GetComponent($type: string):Component;
        /**
         * Returns the component of Type type in the GameObject or any of its children using depth first search.
         * @param type The type of Component to retrieve.
         * @returns A component of the matching type, if found.
         */
        public GetComponentInChildren($type: System.Type, $includeInactive: boolean):Component;
        /**
         * Returns the component of Type type in the GameObject or any of its children using depth first search.
         * @param type The type of Component to retrieve.
         * @returns A component of the matching type, if found.
         */
        public GetComponentInChildren($type: System.Type):Component;
        
        public GetComponentInChildren<T>():T;
        /**
         * Generic version of this method.
         * @returns A component of the matching type, if found.
         */
        public GetComponentInChildren<T>($includeInactive: boolean):T;
        /**
         * Retrieves the component of Type type in the GameObject or any of its parents.
         * @param type Type of component to find.
         * @returns Returns a component if a component matching the type is found. Returns null otherwise.
         */
        public GetComponentInParent($type: System.Type, $includeInactive: boolean):Component;
        /**
         * Retrieves the component of Type type in the GameObject or any of its parents.
         * @param type Type of component to find.
         * @returns Returns a component if a component matching the type is found. Returns null otherwise.
         */
        public GetComponentInParent($type: System.Type):Component;
        
        public GetComponentInParent<T>():T;
        /**
         * Generic version of this method.
         * @returns Returns a component if a component matching the type is found. Returns null otherwise.
         */
        public GetComponentInParent<T>($includeInactive: boolean):T;
        /**
         * Returns all components of Type type in the GameObject.
         * @param type The type of component to retrieve.
         */
        public GetComponents($type: System.Type):Component[];
        /**
         * Generic version of this method.
         */
        public GetComponents<T>():T[];
        
        public GetComponents($type: System.Type, $results: System_Collections_Generic.List$1<Component>):void;
        /**
         * Generic version of this method.
         */
        public GetComponents<T>($results: System_Collections_Generic.List$1<T>):void;
        /**
         * Returns all components of Type type in the GameObject or any of its children.
         * @param type The type of Component to retrieve.
         * @param includeInactive Should Components on inactive GameObjects be included in the found set?
         */
        public GetComponentsInChildren($type: System.Type):Component[];
        /**
         * Returns all components of Type type in the GameObject or any of its children.
         * @param type The type of Component to retrieve.
         * @param includeInactive Should Components on inactive GameObjects be included in the found set?
         */
        public GetComponentsInChildren($type: System.Type, $includeInactive: boolean):Component[];
        /**
         * Generic version of this method.
         * @param includeInactive Should inactive GameObjects be included in the found set?
         * @returns A list of all found components matching the specified type.
         */
        public GetComponentsInChildren<T>($includeInactive: boolean):T[];
        
        public GetComponentsInChildren<T>($includeInactive: boolean, $results: System_Collections_Generic.List$1<T>):void;
        /**
         * Generic version of this method.
         * @param includeInactive Should inactive GameObjects be included in the found set?
         * @returns A list of all found components matching the specified type.
         */
        public GetComponentsInChildren<T>():T[];
        /**
         * Generic version of this method.
         * @param includeInactive Should inactive GameObjects be included in the found set?
         * @returns A list of all found components matching the specified type.
         */
        public GetComponentsInChildren<T>($results: System_Collections_Generic.List$1<T>):void;
        
        public GetComponentsInParent($type: System.Type):Component[];
        /**
         * Returns all components of Type type in the GameObject or any of its parents.
         * @param type The type of Component to retrieve.
         * @param includeInactive Should inactive Components be included in the found set?
         */
        public GetComponentsInParent($type: System.Type, $includeInactive: boolean):Component[];
        
        public GetComponentsInParent<T>($includeInactive: boolean, $results: System_Collections_Generic.List$1<T>):void;
        /**
         * Generic version of this method.
         * @param includeInactive Determines whether to include inactive components in the found set.
         */
        public GetComponentsInParent<T>($includeInactive: boolean):T[];
        /**
         * Generic version of this method.
         * @param includeInactive Determines whether to include inactive components in the found set.
         */
        public GetComponentsInParent<T>():T[];
        
        public TryGetComponent<T>($component: $Ref<T>):boolean;
        /**
         * Gets the component of the specified type, if it exists.
         * @param type The type of component to retrieve.
         * @param component The output argument that will contain the component or null.
         * @returns Returns true if the component is found, false otherwise.
         */
        public TryGetComponent($type: System.Type, $component: $Ref<Component>):boolean;
        /**
         * Returns one active GameObject tagged tag. Returns null if no GameObject was found.
         * @param tag The tag to search for.
         */
        public static FindWithTag($tag: string):GameObject;
        /**
         */
        public SendMessageUpwards($methodName: string, $options: SendMessageOptions):void;
        /**
         */
        public SendMessage($methodName: string, $options: SendMessageOptions):void;
        /**
         */
        public BroadcastMessage($methodName: string, $options: SendMessageOptions):void;
        /**
         * Adds a component class of type componentType to the game object. C# Users can use a generic version.
         */
        public AddComponent($componentType: System.Type):Component;
        /**
         * Generic version of this method.
         */
        public AddComponent<T extends Component>():T;
        /**
         * ActivatesDeactivates the GameObject, depending on the given true or false/ value.
         * @param value Activate or deactivate the object, where true activates the GameObject and false deactivates the GameObject.
         */
        public SetActive($value: boolean):void;
        /**
         * Is this game object tagged with tag ?
         * @param tag The tag to compare.
         */
        public CompareTag($tag: string):boolean;
        
        public static FindGameObjectWithTag($tag: string):GameObject;
        /**
         * Returns an array of active GameObjects tagged tag. Returns empty array if no GameObject was found.
         * @param tag The name of the tag to search GameObjects for.
         */
        public static FindGameObjectsWithTag($tag: string):GameObject[];
        /**
         * Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour.
         * @param methodName The name of the method to call.
         * @param value An optional parameter value to pass to the called method.
         * @param options Should an error be raised if the method doesn't exist on the target object?
         */
        public SendMessageUpwards($methodName: string, $value: any, $options: SendMessageOptions):void;
        /**
         * Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour.
         * @param methodName The name of the method to call.
         * @param value An optional parameter value to pass to the called method.
         * @param options Should an error be raised if the method doesn't exist on the target object?
         */
        public SendMessageUpwards($methodName: string, $value: any):void;
        /**
         * Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour.
         * @param methodName The name of the method to call.
         * @param value An optional parameter value to pass to the called method.
         * @param options Should an error be raised if the method doesn't exist on the target object?
         */
        public SendMessageUpwards($methodName: string):void;
        /**
         * Calls the method named methodName on every MonoBehaviour in this game object.
         * @param methodName The name of the method to call.
         * @param value An optional parameter value to pass to the called method.
         * @param options Should an error be raised if the method doesn't exist on the target object?
         */
        public SendMessage($methodName: string, $value: any, $options: SendMessageOptions):void;
        /**
         * Calls the method named methodName on every MonoBehaviour in this game object.
         * @param methodName The name of the method to call.
         * @param value An optional parameter value to pass to the called method.
         * @param options Should an error be raised if the method doesn't exist on the target object?
         */
        public SendMessage($methodName: string, $value: any):void;
        /**
         * Calls the method named methodName on every MonoBehaviour in this game object.
         * @param methodName The name of the method to call.
         * @param value An optional parameter value to pass to the called method.
         * @param options Should an error be raised if the method doesn't exist on the target object?
         */
        public SendMessage($methodName: string):void;
        /**
         * Calls the method named methodName on every MonoBehaviour in this game object or any of its children.
         */
        public BroadcastMessage($methodName: string, $parameter: any, $options: SendMessageOptions):void;
        /**
         * Calls the method named methodName on every MonoBehaviour in this game object or any of its children.
         */
        public BroadcastMessage($methodName: string, $parameter: any):void;
        /**
         * Calls the method named methodName on every MonoBehaviour in this game object or any of its children.
         */
        public BroadcastMessage($methodName: string):void;
        /**
         * Finds a GameObject by name and returns it.
         */
        public static Find($name: string):GameObject;
        
                    
    }
    /**
     * The various primitives that can be created using the GameObject.CreatePrimitive function.
     */
    enum PrimitiveType { Sphere = 0, Capsule = 1, Cylinder = 2, Cube = 3, Plane = 4, Quad = 5 }
    /**
     * Options for how to send a message.
     */
    enum SendMessageOptions { RequireReceiver = 0, DontRequireReceiver = 1 }
    /**
     * Behaviours are Components that can be enabled or disabled.
     */
    class Behaviour extends Component {
        /**
         * Enabled Behaviours are Updated, disabled Behaviours are not.
         */
        public get enabled(): boolean;
        public set enabled(value: boolean);
        /**
         * Has the Behaviour had active and enabled called?
         */
        public get isActiveAndEnabled(): boolean;
        
        public constructor();
        
                    
    }
    /**
     * MonoBehaviour is the base class from which every Unity script derives.
     */
    class MonoBehaviour extends Behaviour {
        /**
         * Disabling this lets you skip the GUI layout phase.
         */
        public get useGUILayout(): boolean;
        public set useGUILayout(value: boolean);
        /**
         * Allow a specific instance of a MonoBehaviour to run in edit mode (only available in the editor).
         */
        public get runInEditMode(): boolean;
        public set runInEditMode(value: boolean);
        
        public constructor();
        /**
         * Is any invoke pending on this MonoBehaviour?
         */
        public IsInvoking():boolean;
        /**
         * Cancels all Invoke calls on this MonoBehaviour.
         */
        public CancelInvoke():void;
        /**
         * Invokes the method methodName in time seconds.
         */
        public Invoke($methodName: string, $time: number):void;
        /**
         * Invokes the method methodName in time seconds, then repeatedly every repeatRate seconds.
         */
        public InvokeRepeating($methodName: string, $time: number, $repeatRate: number):void;
        /**
         * Cancels all Invoke calls with name methodName on this behaviour.
         */
        public CancelInvoke($methodName: string):void;
        /**
         * Is any invoke on methodName pending?
         */
        public IsInvoking($methodName: string):boolean;
        /**
         * Starts a coroutine named methodName.
         */
        public StartCoroutine($methodName: string):Coroutine;
        /**
         * Starts a coroutine named methodName.
         */
        public StartCoroutine($methodName: string, $value: any):Coroutine;
        /**
         * Starts a Coroutine.
         */
        public StartCoroutine($routine: System_Collections.IEnumerator):Coroutine;
        /**
         * Stops the first coroutine named methodName, or the coroutine stored in routine running on this behaviour.
         * @param methodName Name of coroutine.
         * @param routine Name of the function in code, including coroutines.
         */
        public StopCoroutine($routine: System_Collections.IEnumerator):void;
        /**
         * Stops the first coroutine named methodName, or the coroutine stored in routine running on this behaviour.
         * @param methodName Name of coroutine.
         * @param routine Name of the function in code, including coroutines.
         */
        public StopCoroutine($routine: Coroutine):void;
        /**
         * Stops the first coroutine named methodName, or the coroutine stored in routine running on this behaviour.
         * @param methodName Name of coroutine.
         * @param routine Name of the function in code, including coroutines.
         */
        public StopCoroutine($methodName: string):void;
        /**
         * Stops all coroutines running on this behaviour.
         */
        public StopAllCoroutines():void;
        /**
         * Logs message to the Unity Console (identical to Debug.Log).
         */
        public static print($message: any):void;
        
                    
    }
    /**
     * MonoBehaviour.StartCoroutine returns a Coroutine. Instances of this class are only used to reference these coroutines, and do not hold any exposed properties or functions.
     */
    class Coroutine extends YieldInstruction {
        
                    
    }
    /**
     * Base class for all yield instructions.
     */
    class YieldInstruction extends System.Object {
        
        public constructor();
        
                    
    }
    /**
     * Position, size, anchor and pivot information for a rectangle.
     */
    class RectTransform extends Transform {
        /**
         * The calculated rectangle in the local space of the Transform.
         */
        public get rect(): Rect;
        /**
         * The normalized position in the parent RectTransform that the lower left corner is anchored to.
         */
        public get anchorMin(): Vector2;
        public set anchorMin(value: Vector2);
        /**
         * The normalized position in the parent RectTransform that the upper right corner is anchored to.
         */
        public get anchorMax(): Vector2;
        public set anchorMax(value: Vector2);
        /**
         * The position of the pivot of this RectTransform relative to the anchor reference point.
         */
        public get anchoredPosition(): Vector2;
        public set anchoredPosition(value: Vector2);
        /**
         * The size of this RectTransform relative to the distances between the anchors.
         */
        public get sizeDelta(): Vector2;
        public set sizeDelta(value: Vector2);
        /**
         * The normalized position in this RectTransform that it rotates around.
         */
        public get pivot(): Vector2;
        public set pivot(value: Vector2);
        /**
         * The 3D position of the pivot of this RectTransform relative to the anchor reference point.
         */
        public get anchoredPosition3D(): Vector3;
        public set anchoredPosition3D(value: Vector3);
        /**
         * The offset of the lower left corner of the rectangle relative to the lower left anchor.
         */
        public get offsetMin(): Vector2;
        public set offsetMin(value: Vector2);
        /**
         * The offset of the upper right corner of the rectangle relative to the upper right anchor.
         */
        public get offsetMax(): Vector2;
        public set offsetMax(value: Vector2);
        
        public constructor();
        
        public static add_reapplyDrivenProperties($value: UnityEngine_RectTransform.ReapplyDrivenProperties):void;
        
        public static remove_reapplyDrivenProperties($value: UnityEngine_RectTransform.ReapplyDrivenProperties):void;
        /**
         * Force the recalculation of RectTransforms internal data.
         */
        public ForceUpdateRectTransforms():void;
        /**
         * Get the corners of the calculated rectangle in the local space of its Transform.
         * @param fourCornersArray The array that corners are filled into.
         */
        public GetLocalCorners($fourCornersArray: Vector3[]):void;
        /**
         * Get the corners of the calculated rectangle in world space.
         * @param fourCornersArray The array that corners are filled into.
         */
        public GetWorldCorners($fourCornersArray: Vector3[]):void;
        /**
         * Set the distance of this rectangle relative to a specified edge of the parent rectangle, while also setting its size.
         * @param edge The edge of the parent rectangle to inset from.
         * @param inset The inset distance.
         * @param size The size of the rectangle along the same direction of the inset.
         */
        public SetInsetAndSizeFromParentEdge($edge: UnityEngine_RectTransform.Edge, $inset: number, $size: number):void;
        /**
         * Makes the RectTransform calculated rect be a given size on the specified axis.
         * @param axis The axis to specify the size along.
         * @param size The desired size along the specified axis.
         */
        public SetSizeWithCurrentAnchors($axis: UnityEngine_RectTransform.Axis, $size: number):void;
        /**
         * Event that is invoked for RectTransforms that need to have their driven properties reapplied.
         */
        public static reapplyDrivenProperties;
        
                    
    }
    /**
     * A 2D Rectangle defined by X and Y position, width and height.
     */
    class Rect extends System.ValueType {
        /**
         * Shorthand for writing new Rect(0,0,0,0).
         */
        public static get zero(): Rect;
        /**
         * The X coordinate of the rectangle.
         */
        public get x(): number;
        public set x(value: number);
        /**
         * The Y coordinate of the rectangle.
         */
        public get y(): number;
        public set y(value: number);
        /**
         * The X and Y position of the rectangle.
         */
        public get position(): Vector2;
        public set position(value: Vector2);
        /**
         * The position of the center of the rectangle.
         */
        public get center(): Vector2;
        public set center(value: Vector2);
        /**
         * The position of the minimum corner of the rectangle.
         */
        public get min(): Vector2;
        public set min(value: Vector2);
        /**
         * The position of the maximum corner of the rectangle.
         */
        public get max(): Vector2;
        public set max(value: Vector2);
        /**
         * The width of the rectangle, measured from the X position.
         */
        public get width(): number;
        public set width(value: number);
        /**
         * The height of the rectangle, measured from the Y position.
         */
        public get height(): number;
        public set height(value: number);
        /**
         * The width and height of the rectangle.
         */
        public get size(): Vector2;
        public set size(value: Vector2);
        /**
         * The minimum X coordinate of the rectangle.
         */
        public get xMin(): number;
        public set xMin(value: number);
        /**
         * The minimum Y coordinate of the rectangle.
         */
        public get yMin(): number;
        public set yMin(value: number);
        /**
         * The maximum X coordinate of the rectangle.
         */
        public get xMax(): number;
        public set xMax(value: number);
        /**
         * The maximum Y coordinate of the rectangle.
         */
        public get yMax(): number;
        public set yMax(value: number);
        /**
         * Creates a new rectangle.
         * @param x The X value the rect is measured from.
         * @param y The Y value the rect is measured from.
         * @param width The width of the rectangle.
         * @param height The height of the rectangle.
         */
        public constructor($x: number, $y: number, $width: number, $height: number);
        /**
         * Creates a rectangle given a size and position.
         * @param position The position of the minimum corner of the rect.
         * @param size The width and height of the rect.
         */
        public constructor($position: Vector2, $size: Vector2);
        /**
         */
        public constructor($source: Rect);
        /**
         * Creates a rectangle from min/max coordinate values.
         * @param xmin The minimum X coordinate.
         * @param ymin The minimum Y coordinate.
         * @param xmax The maximum X coordinate.
         * @param ymax The maximum Y coordinate.
         * @returns A rectangle matching the specified coordinates.
         */
        public static MinMaxRect($xmin: number, $ymin: number, $xmax: number, $ymax: number):Rect;
        /**
         * Set components of an existing Rect.
         */
        public Set($x: number, $y: number, $width: number, $height: number):void;
        /**
         * Returns true if the x and y components of point is a point inside this rectangle. If allowInverse is present and true, the width and height of the Rect are allowed to take negative values (ie, the min value is greater than the max), and the test will still work.
         * @param point Point to test.
         * @param allowInverse Does the test allow the Rect's width and height to be negative?
         * @returns True if the point lies within the specified rectangle.
         */
        public Contains($point: Vector2):boolean;
        /**
         * Returns true if the x and y components of point is a point inside this rectangle. If allowInverse is present and true, the width and height of the Rect are allowed to take negative values (ie, the min value is greater than the max), and the test will still work.
         * @param point Point to test.
         * @param allowInverse Does the test allow the Rect's width and height to be negative?
         * @returns True if the point lies within the specified rectangle.
         */
        public Contains($point: Vector3):boolean;
        /**
         * Returns true if the x and y components of point is a point inside this rectangle. If allowInverse is present and true, the width and height of the Rect are allowed to take negative values (ie, the min value is greater than the max), and the test will still work.
         * @param point Point to test.
         * @param allowInverse Does the test allow the Rect's width and height to be negative?
         * @returns True if the point lies within the specified rectangle.
         */
        public Contains($point: Vector3, $allowInverse: boolean):boolean;
        /**
         * Returns true if the other rectangle overlaps this one. If allowInverse is present and true, the widths and heights of the Rects are allowed to take negative values (ie, the min value is greater than the max), and the test will still work.
         * @param other Other rectangle to test overlapping with.
         * @param allowInverse Does the test allow the widths and heights of the Rects to be negative?
         */
        public Overlaps($other: Rect):boolean;
        /**
         * Returns true if the other rectangle overlaps this one. If allowInverse is present and true, the widths and heights of the Rects are allowed to take negative values (ie, the min value is greater than the max), and the test will still work.
         * @param other Other rectangle to test overlapping with.
         * @param allowInverse Does the test allow the widths and heights of the Rects to be negative?
         */
        public Overlaps($other: Rect, $allowInverse: boolean):boolean;
        /**
         * Returns a point inside a rectangle, given normalized coordinates.
         * @param rectangle Rectangle to get a point inside.
         * @param normalizedRectCoordinates Normalized coordinates to get a point for.
         */
        public static NormalizedToPoint($rectangle: Rect, $normalizedRectCoordinates: Vector2):Vector2;
        /**
         * Returns the normalized coordinates cooresponding the the point.
         * @param rectangle Rectangle to get normalized coordinates inside.
         * @param point A point inside the rectangle to get normalized coordinates for.
         */
        public static PointToNormalized($rectangle: Rect, $point: Vector2):Vector2;
        
        public static op_Inequality($lhs: Rect, $rhs: Rect):boolean;
        
        public static op_Equality($lhs: Rect, $rhs: Rect):boolean;
        
        public GetHashCode():number;
        
        public Equals($other: any):boolean;
        
        public Equals($other: Rect):boolean;
        /**
         * Returns a formatted string for this Rect.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        public ToString():string;
        /**
         * Returns a formatted string for this Rect.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        public ToString($format: string):string;
        /**
         * Returns a formatted string for this Rect.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        public ToString($format: string, $formatProvider: System.IFormatProvider):string;
        
        public get_Clone(): Rect;            
    }
    /**
     * Representation of 2D vectors and points.
     */
    class Vector2 extends System.ValueType {
        /**
         * X component of the vector.
         */
        public x: number;
        /**
         * Y component of the vector.
         */
        public y: number;
        
        public static kEpsilon: number;
        
        public static kEpsilonNormalSqrt: number;
        /**
         * Returns this vector with a magnitude of 1 (Read Only).
         */
        public get normalized(): Vector2;
        /**
         * Returns the length of this vector (Read Only).
         */
        public get magnitude(): number;
        /**
         * Returns the squared length of this vector (Read Only).
         */
        public get sqrMagnitude(): number;
        /**
         * Shorthand for writing Vector2(0, 0).
         */
        public static get zero(): Vector2;
        /**
         * Shorthand for writing Vector2(1, 1).
         */
        public static get one(): Vector2;
        /**
         * Shorthand for writing Vector2(0, 1).
         */
        public static get up(): Vector2;
        /**
         * Shorthand for writing Vector2(0, -1).
         */
        public static get down(): Vector2;
        /**
         * Shorthand for writing Vector2(-1, 0).
         */
        public static get left(): Vector2;
        /**
         * Shorthand for writing Vector2(1, 0).
         */
        public static get right(): Vector2;
        /**
         * Shorthand for writing Vector2(float.PositiveInfinity, float.PositiveInfinity).
         */
        public static get positiveInfinity(): Vector2;
        /**
         * Shorthand for writing Vector2(float.NegativeInfinity, float.NegativeInfinity).
         */
        public static get negativeInfinity(): Vector2;
        /**
         * Constructs a new vector with given x, y components.
         */
        public constructor($x: number, $y: number);
        
        public get_Item($index: number):number;
        
        public set_Item($index: number, $value: number):void;
        /**
         * Set x and y components of an existing Vector2.
         */
        public Set($newX: number, $newY: number):void;
        /**
         * Linearly interpolates between vectors a and b by t.
         */
        public static Lerp($a: Vector2, $b: Vector2, $t: number):Vector2;
        /**
         * Linearly interpolates between vectors a and b by t.
         */
        public static LerpUnclamped($a: Vector2, $b: Vector2, $t: number):Vector2;
        /**
         * Moves a point current towards target.
         */
        public static MoveTowards($current: Vector2, $target: Vector2, $maxDistanceDelta: number):Vector2;
        /**
         * Multiplies two vectors component-wise.
         */
        public static Scale($a: Vector2, $b: Vector2):Vector2;
        /**
         * Multiplies every component of this vector by the same component of scale.
         */
        public Scale($scale: Vector2):void;
        /**
         * Makes this vector have a magnitude of 1.
         */
        public Normalize():void;
        /**
         * Returns a formatted string for this vector.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        public ToString():string;
        /**
         * Returns a formatted string for this vector.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        public ToString($format: string):string;
        /**
         * Returns a formatted string for this vector.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        public ToString($format: string, $formatProvider: System.IFormatProvider):string;
        
        public GetHashCode():number;
        /**
         * Returns true if the given vector is exactly equal to this vector.
         */
        public Equals($other: any):boolean;
        
        public Equals($other: Vector2):boolean;
        /**
         * Reflects a vector off the vector defined by a normal.
         */
        public static Reflect($inDirection: Vector2, $inNormal: Vector2):Vector2;
        /**
         * Returns the 2D vector perpendicular to this 2D vector. The result is always rotated 90-degrees in a counter-clockwise direction for a 2D coordinate system where the positive Y axis goes up.
         * @param inDirection The input direction.
         * @returns The perpendicular direction.
         */
        public static Perpendicular($inDirection: Vector2):Vector2;
        /**
         * Dot Product of two vectors.
         */
        public static Dot($lhs: Vector2, $rhs: Vector2):number;
        /**
         * Returns the unsigned angle in degrees between from and to.
         * @param from The vector from which the angular difference is measured.
         * @param to The vector to which the angular difference is measured.
         */
        public static Angle($from: Vector2, $to: Vector2):number;
        /**
         * Returns the signed angle in degrees between from and to.
         * @param from The vector from which the angular difference is measured.
         * @param to The vector to which the angular difference is measured.
         */
        public static SignedAngle($from: Vector2, $to: Vector2):number;
        /**
         * Returns the distance between a and b.
         */
        public static Distance($a: Vector2, $b: Vector2):number;
        /**
         * Returns a copy of vector with its magnitude clamped to maxLength.
         */
        public static ClampMagnitude($vector: Vector2, $maxLength: number):Vector2;
        
        public static SqrMagnitude($a: Vector2):number;
        
        public SqrMagnitude():number;
        /**
         * Returns a vector that is made from the smallest components of two vectors.
         */
        public static Min($lhs: Vector2, $rhs: Vector2):Vector2;
        /**
         * Returns a vector that is made from the largest components of two vectors.
         */
        public static Max($lhs: Vector2, $rhs: Vector2):Vector2;
        /**
         * Gradually changes a vector towards a desired goal over time.
         * @param current The current position.
         * @param target The position we are trying to reach.
         * @param currentVelocity The current velocity, this value is modified by the function every time you call it.
         * @param smoothTime Approximately the time it will take to reach the target. A smaller value will reach the target faster.
         * @param maxSpeed Optionally allows you to clamp the maximum speed.
         * @param deltaTime The time since the last call to this function. By default Time.deltaTime.
         */
        public static SmoothDamp($current: Vector2, $target: Vector2, $currentVelocity: $Ref<Vector2>, $smoothTime: number, $maxSpeed: number):Vector2;
        /**
         * Gradually changes a vector towards a desired goal over time.
         * @param current The current position.
         * @param target The position we are trying to reach.
         * @param currentVelocity The current velocity, this value is modified by the function every time you call it.
         * @param smoothTime Approximately the time it will take to reach the target. A smaller value will reach the target faster.
         * @param maxSpeed Optionally allows you to clamp the maximum speed.
         * @param deltaTime The time since the last call to this function. By default Time.deltaTime.
         */
        public static SmoothDamp($current: Vector2, $target: Vector2, $currentVelocity: $Ref<Vector2>, $smoothTime: number):Vector2;
        /**
         * Gradually changes a vector towards a desired goal over time.
         * @param current The current position.
         * @param target The position we are trying to reach.
         * @param currentVelocity The current velocity, this value is modified by the function every time you call it.
         * @param smoothTime Approximately the time it will take to reach the target. A smaller value will reach the target faster.
         * @param maxSpeed Optionally allows you to clamp the maximum speed.
         * @param deltaTime The time since the last call to this function. By default Time.deltaTime.
         */
        public static SmoothDamp($current: Vector2, $target: Vector2, $currentVelocity: $Ref<Vector2>, $smoothTime: number, $maxSpeed: number, $deltaTime: number):Vector2;
        
        public static op_Addition($a: Vector2, $b: Vector2):Vector2;
        
        public static op_Subtraction($a: Vector2, $b: Vector2):Vector2;
        /**
         * Multiplies a vector by another vector.
         */
        public static op_Multiply($a: Vector2, $b: Vector2):Vector2;
        
        public static op_Division($a: Vector2, $b: Vector2):Vector2;
        
        public static op_UnaryNegation($a: Vector2):Vector2;
        /**
         * Multiplies a vector by a number.
         */
        public static op_Multiply($a: Vector2, $d: number):Vector2;
        /**
         * Multiplies a vector by a number.
         */
        public static op_Multiply($d: number, $a: Vector2):Vector2;
        
        public static op_Division($a: Vector2, $d: number):Vector2;
        
        public static op_Equality($lhs: Vector2, $rhs: Vector2):boolean;
        
        public static op_Inequality($lhs: Vector2, $rhs: Vector2):boolean;
        
        public static op_Implicit($v: Vector3):Vector2;
        
        public static op_Implicit($v: Vector2):Vector3;
        
        public get_Clone(): Vector2;            
    }
    /**
     * A standard 4x4 transformation matrix.
     */
    class Matrix4x4 extends System.ValueType {
        
        public m00: number;
        
        public m10: number;
        
        public m20: number;
        
        public m30: number;
        
        public m01: number;
        
        public m11: number;
        
        public m21: number;
        
        public m31: number;
        
        public m02: number;
        
        public m12: number;
        
        public m22: number;
        
        public m32: number;
        
        public m03: number;
        
        public m13: number;
        
        public m23: number;
        
        public m33: number;
        /**
         * Attempts to get a rotation quaternion from this matrix.
         */
        public get rotation(): Quaternion;
        /**
         * Attempts to get a scale value from the matrix. (Read Only)
         */
        public get lossyScale(): Vector3;
        /**
         * Checks whether this is an identity matrix. (Read Only)
         */
        public get isIdentity(): boolean;
        /**
         * The determinant of the matrix. (Read Only)
         */
        public get determinant(): number;
        /**
         * This property takes a projection matrix and returns the six plane coordinates that define a projection frustum.
         */
        public get decomposeProjection(): FrustumPlanes;
        /**
         * The inverse of this matrix. (Read Only)
         */
        public get inverse(): Matrix4x4;
        /**
         * Returns the transpose of this matrix (Read Only).
         */
        public get transpose(): Matrix4x4;
        /**
         * Returns a matrix with all elements set to zero (Read Only).
         */
        public static get zero(): Matrix4x4;
        /**
         * Returns the identity matrix (Read Only).
         */
        public static get identity(): Matrix4x4;
        
        public constructor($column0: Vector4, $column1: Vector4, $column2: Vector4, $column3: Vector4);
        /**
         * Checks if this matrix is a valid transform matrix.
         */
        public ValidTRS():boolean;
        
        public static Determinant($m: Matrix4x4):number;
        /**
         * Creates a translation, rotation and scaling matrix.
         */
        public static TRS($pos: Vector3, $q: Quaternion, $s: Vector3):Matrix4x4;
        /**
         * Sets this matrix to a translation, rotation and scaling matrix.
         */
        public SetTRS($pos: Vector3, $q: Quaternion, $s: Vector3):void;
        /**
         * Computes the inverse of a 3D affine matrix.
         * @param input Input matrix to invert.
         * @param result The result of the inversion. Equal to the input matrix if the function fails.
         * @returns Returns true and a valid result if the function succeeds, false and a copy of the input matrix if the function fails.
         */
        public static Inverse3DAffine($input: Matrix4x4, $result: $Ref<Matrix4x4>):boolean;
        
        public static Inverse($m: Matrix4x4):Matrix4x4;
        
        public static Transpose($m: Matrix4x4):Matrix4x4;
        /**
         * Create an orthogonal projection matrix.
         * @param left Left-side x-coordinate.
         * @param right Right-side x-coordinate.
         * @param bottom Bottom y-coordinate.
         * @param top Top y-coordinate.
         * @param zNear Near depth clipping plane value.
         * @param zFar Far depth clipping plane value.
         * @returns The projection matrix.
         */
        public static Ortho($left: number, $right: number, $bottom: number, $top: number, $zNear: number, $zFar: number):Matrix4x4;
        /**
         * Create a perspective projection matrix.
         * @param fov Vertical field-of-view in degrees.
         * @param aspect Aspect ratio (width divided by height).
         * @param zNear Near depth clipping plane value.
         * @param zFar Far depth clipping plane value.
         * @returns The projection matrix.
         */
        public static Perspective($fov: number, $aspect: number, $zNear: number, $zFar: number):Matrix4x4;
        /**
         * Create a "look at" matrix.
         * @param from The source point.
         * @param to The target point.
         * @param up The vector describing the up direction (typically Vector3.up).
         * @returns The resulting transformation matrix.
         */
        public static LookAt($from: Vector3, $to: Vector3, $up: Vector3):Matrix4x4;
        /**
         * This function returns a projection matrix with viewing frustum that has a near plane defined by the coordinates that were passed in.
         * @param left The X coordinate of the left side of the near projection plane in view space.
         * @param right The X coordinate of the right side of the near projection plane in view space.
         * @param bottom The Y coordinate of the bottom side of the near projection plane in view space.
         * @param top The Y coordinate of the top side of the near projection plane in view space.
         * @param zNear Z distance to the near plane from the origin in view space.
         * @param zFar Z distance to the far plane from the origin in view space.
         * @param frustumPlanes Frustum planes struct that contains the view space coordinates of that define a viewing frustum.
         * @returns A projection matrix with a viewing frustum defined by the plane coordinates passed in.
         */
        public static Frustum($left: number, $right: number, $bottom: number, $top: number, $zNear: number, $zFar: number):Matrix4x4;
        /**
         * This function returns a projection matrix with viewing frustum that has a near plane defined by the coordinates that were passed in.
         * @param left The X coordinate of the left side of the near projection plane in view space.
         * @param right The X coordinate of the right side of the near projection plane in view space.
         * @param bottom The Y coordinate of the bottom side of the near projection plane in view space.
         * @param top The Y coordinate of the top side of the near projection plane in view space.
         * @param zNear Z distance to the near plane from the origin in view space.
         * @param zFar Z distance to the far plane from the origin in view space.
         * @param frustumPlanes Frustum planes struct that contains the view space coordinates of that define a viewing frustum.
         * @returns A projection matrix with a viewing frustum defined by the plane coordinates passed in.
         */
        public static Frustum($fp: FrustumPlanes):Matrix4x4;
        
        public get_Item($index: number):number;
        
        public set_Item($index: number, $value: number):void;
        
        public GetHashCode():number;
        
        public Equals($other: any):boolean;
        
        public Equals($other: Matrix4x4):boolean;
        /**
         * Multiplies two matrices.
         */
        public static op_Multiply($lhs: Matrix4x4, $rhs: Matrix4x4):Matrix4x4;
        /**
         * Transforms a Vector4 by a matrix.
         */
        public static op_Multiply($lhs: Matrix4x4, $vector: Vector4):Vector4;
        
        public static op_Equality($lhs: Matrix4x4, $rhs: Matrix4x4):boolean;
        
        public static op_Inequality($lhs: Matrix4x4, $rhs: Matrix4x4):boolean;
        /**
         * Get a column of the matrix.
         */
        public GetColumn($index: number):Vector4;
        /**
         * Returns a row of the matrix.
         */
        public GetRow($index: number):Vector4;
        /**
         * Sets a column of the matrix.
         */
        public SetColumn($index: number, $column: Vector4):void;
        /**
         * Sets a row of the matrix.
         */
        public SetRow($index: number, $row: Vector4):void;
        /**
         * Transforms a position by this matrix (generic).
         */
        public MultiplyPoint($point: Vector3):Vector3;
        /**
         * Transforms a position by this matrix (fast).
         */
        public MultiplyPoint3x4($point: Vector3):Vector3;
        /**
         * Transforms a direction by this matrix.
         */
        public MultiplyVector($vector: Vector3):Vector3;
        /**
         * Returns a plane that is transformed in space.
         */
        public TransformPlane($plane: Plane):Plane;
        /**
         * Creates a scaling matrix.
         */
        public static Scale($vector: Vector3):Matrix4x4;
        /**
         * Creates a translation matrix.
         */
        public static Translate($vector: Vector3):Matrix4x4;
        /**
         * Creates a rotation matrix.
         */
        public static Rotate($q: Quaternion):Matrix4x4;
        /**
         * Returns a formatted string for this matrix.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        public ToString():string;
        /**
         * Returns a formatted string for this matrix.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        public ToString($format: string):string;
        /**
         * Returns a formatted string for this matrix.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        public ToString($format: string, $formatProvider: System.IFormatProvider):string;
        
        public get_Clone(): Matrix4x4;            
    }
    /**
     * The coordinate space in which to operate.
     */
    enum Space { World = 0, Self = 1 }
    /**
     * Representation of four-dimensional vectors.
     */
    class Vector4 extends System.ValueType {
        
        public static kEpsilon: number;
        /**
         * X component of the vector.
         */
        public x: number;
        /**
         * Y component of the vector.
         */
        public y: number;
        /**
         * Z component of the vector.
         */
        public z: number;
        /**
         * W component of the vector.
         */
        public w: number;
        /**
         * Returns this vector with a magnitude of 1 (Read Only).
         */
        public get normalized(): Vector4;
        /**
         * Returns the length of this vector (Read Only).
         */
        public get magnitude(): number;
        /**
         * Returns the squared length of this vector (Read Only).
         */
        public get sqrMagnitude(): number;
        /**
         * Shorthand for writing Vector4(0,0,0,0).
         */
        public static get zero(): Vector4;
        /**
         * Shorthand for writing Vector4(1,1,1,1).
         */
        public static get one(): Vector4;
        /**
         * Shorthand for writing Vector4(float.PositiveInfinity, float.PositiveInfinity, float.PositiveInfinity, float.PositiveInfinity).
         */
        public static get positiveInfinity(): Vector4;
        /**
         * Shorthand for writing Vector4(float.NegativeInfinity, float.NegativeInfinity, float.NegativeInfinity, float.NegativeInfinity).
         */
        public static get negativeInfinity(): Vector4;
        /**
         * Creates a new vector with given x, y, z, w components.
         */
        public constructor($x: number, $y: number, $z: number, $w: number);
        /**
         * Creates a new vector with given x, y, z components and sets w to zero.
         */
        public constructor($x: number, $y: number, $z: number);
        /**
         * Creates a new vector with given x, y components and sets z and w to zero.
         */
        public constructor($x: number, $y: number);
        
        public get_Item($index: number):number;
        
        public set_Item($index: number, $value: number):void;
        /**
         * Set x, y, z and w components of an existing Vector4.
         */
        public Set($newX: number, $newY: number, $newZ: number, $newW: number):void;
        /**
         * Linearly interpolates between two vectors.
         */
        public static Lerp($a: Vector4, $b: Vector4, $t: number):Vector4;
        /**
         * Linearly interpolates between two vectors.
         */
        public static LerpUnclamped($a: Vector4, $b: Vector4, $t: number):Vector4;
        /**
         * Moves a point current towards target.
         */
        public static MoveTowards($current: Vector4, $target: Vector4, $maxDistanceDelta: number):Vector4;
        /**
         * Multiplies two vectors component-wise.
         */
        public static Scale($a: Vector4, $b: Vector4):Vector4;
        /**
         * Multiplies every component of this vector by the same component of scale.
         */
        public Scale($scale: Vector4):void;
        
        public GetHashCode():number;
        /**
         * Returns true if the given vector is exactly equal to this vector.
         */
        public Equals($other: any):boolean;
        
        public Equals($other: Vector4):boolean;
        /**
         */
        public static Normalize($a: Vector4):Vector4;
        /**
         * Makes this vector have a magnitude of 1.
         */
        public Normalize():void;
        /**
         * Dot Product of two vectors.
         */
        public static Dot($a: Vector4, $b: Vector4):number;
        /**
         * Projects a vector onto another vector.
         */
        public static Project($a: Vector4, $b: Vector4):Vector4;
        /**
         * Returns the distance between a and b.
         */
        public static Distance($a: Vector4, $b: Vector4):number;
        
        public static Magnitude($a: Vector4):number;
        /**
         * Returns a vector that is made from the smallest components of two vectors.
         */
        public static Min($lhs: Vector4, $rhs: Vector4):Vector4;
        /**
         * Returns a vector that is made from the largest components of two vectors.
         */
        public static Max($lhs: Vector4, $rhs: Vector4):Vector4;
        
        public static op_Addition($a: Vector4, $b: Vector4):Vector4;
        
        public static op_Subtraction($a: Vector4, $b: Vector4):Vector4;
        
        public static op_UnaryNegation($a: Vector4):Vector4;
        /**
         * Multiplies a vector by a number.
         */
        public static op_Multiply($a: Vector4, $d: number):Vector4;
        /**
         * Multiplies a vector by a number.
         */
        public static op_Multiply($d: number, $a: Vector4):Vector4;
        
        public static op_Division($a: Vector4, $d: number):Vector4;
        
        public static op_Equality($lhs: Vector4, $rhs: Vector4):boolean;
        
        public static op_Inequality($lhs: Vector4, $rhs: Vector4):boolean;
        
        public static op_Implicit($v: Vector3):Vector4;
        
        public static op_Implicit($v: Vector4):Vector3;
        
        public static op_Implicit($v: Vector2):Vector4;
        
        public static op_Implicit($v: Vector4):Vector2;
        /**
         * Returns a formatted string for this vector.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        public ToString():string;
        /**
         * Returns a formatted string for this vector.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        public ToString($format: string):string;
        /**
         * Returns a formatted string for this vector.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        public ToString($format: string, $formatProvider: System.IFormatProvider):string;
        
        public static SqrMagnitude($a: Vector4):number;
        
        public SqrMagnitude():number;
        
        public get_Clone(): Vector4;            
    }
    /**
     * A collection of common math functions.
     */
    class Mathf extends System.ValueType {
        /**
         * The well-known 3.14159265358979... value (Read Only).
         */
        public static PI: number;
        /**
         * A representation of positive infinity (Read Only).
         */
        public static Infinity: number;
        /**
         * A representation of negative infinity (Read Only).
         */
        public static NegativeInfinity: number;
        /**
         * Degrees-to-radians conversion constant (Read Only).
         */
        public static Deg2Rad: number;
        /**
         * Radians-to-degrees conversion constant (Read Only).
         */
        public static Rad2Deg: number;
        /**
         * A tiny floating point value (Read Only).
         */
        public static Epsilon: number;
        /**
         * Returns the closest power of two value.
         */
        public static ClosestPowerOfTwo($value: number):number;
        /**
         * Returns true if the value is power of two.
         */
        public static IsPowerOfTwo($value: number):boolean;
        /**
         * Returns the next power of two that is equal to, or greater than, the argument.
         */
        public static NextPowerOfTwo($value: number):number;
        /**
         * Converts the given value from gamma (sRGB) to linear color space.
         */
        public static GammaToLinearSpace($value: number):number;
        /**
         * Converts the given value from linear to gamma (sRGB) color space.
         */
        public static LinearToGammaSpace($value: number):number;
        /**
         * Convert a color temperature in Kelvin to RGB color.
         * @param kelvin Temperature in Kelvin. Range 1000 to 40000 Kelvin.
         * @returns Correlated Color Temperature as floating point RGB color.
         */
        public static CorrelatedColorTemperatureToRGB($kelvin: number):Color;
        /**
         * Encode a floating point value into a 16-bit representation.
         * @param val The floating point value to convert.
         * @returns The converted half-precision float, stored in a 16-bit unsigned integer.
         */
        public static FloatToHalf($val: number):number;
        /**
         * Convert a half precision float to a 32-bit floating point value.
         * @param val The half precision value to convert.
         * @returns The decoded 32-bit float.
         */
        public static HalfToFloat($val: number):number;
        /**
         * Generate 2D Perlin noise.
         * @param x X-coordinate of sample point.
         * @param y Y-coordinate of sample point.
         * @returns Value between 0.0 and 1.0. (Return value might be slightly below 0.0 or beyond 1.0.)
         */
        public static PerlinNoise($x: number, $y: number):number;
        /**
         * Returns the sine of angle f.
         * @param f The input angle, in radians.
         * @returns The return value between -1 and +1.
         */
        public static Sin($f: number):number;
        /**
         * Returns the cosine of angle f.
         * @param f The input angle, in radians.
         * @returns The return value between -1 and 1.
         */
        public static Cos($f: number):number;
        /**
         * Returns the tangent of angle f in radians.
         */
        public static Tan($f: number):number;
        /**
         * Returns the arc-sine of f - the angle in radians whose sine is f.
         */
        public static Asin($f: number):number;
        /**
         * Returns the arc-cosine of f - the angle in radians whose cosine is f.
         */
        public static Acos($f: number):number;
        /**
         * Returns the arc-tangent of f - the angle in radians whose tangent is f.
         */
        public static Atan($f: number):number;
        /**
         * Returns the angle in radians whose Tan is y/x.
         */
        public static Atan2($y: number, $x: number):number;
        /**
         * Returns square root of f.
         */
        public static Sqrt($f: number):number;
        /**
         * Returns the absolute value of f.
         */
        public static Abs($f: number):number;
        /**
         * Returns the absolute value of value.
         */
        public static Abs($value: number):number;
        /**
         * Returns the smallest of two or more values.
         */
        public static Min($a: number, $b: number):number;
        /**
         * Returns the smallest of two or more values.
         */
        public static Min(...values: number[]):number;
        /**
         * Returns the smallest of two or more values.
         */
        public static Min($a: number, $b: number):number;
        /**
         * Returns the smallest of two or more values.
         */
        public static Min(...values: number[]):number;
        /**
         * Returns largest of two or more values.
         */
        public static Max($a: number, $b: number):number;
        /**
         * Returns largest of two or more values.
         */
        public static Max(...values: number[]):number;
        /**
         * Returns the largest of two or more values.
         */
        public static Max($a: number, $b: number):number;
        /**
         * Returns the largest of two or more values.
         */
        public static Max(...values: number[]):number;
        /**
         * Returns f raised to power p.
         */
        public static Pow($f: number, $p: number):number;
        /**
         * Returns e raised to the specified power.
         */
        public static Exp($power: number):number;
        /**
         * Returns the logarithm of a specified number in a specified base.
         */
        public static Log($f: number, $p: number):number;
        /**
         * Returns the natural (base e) logarithm of a specified number.
         */
        public static Log($f: number):number;
        /**
         * Returns the base 10 logarithm of a specified number.
         */
        public static Log10($f: number):number;
        /**
         * Returns the smallest integer greater to or equal to f.
         */
        public static Ceil($f: number):number;
        /**
         * Returns the largest integer smaller than or equal to f.
         */
        public static Floor($f: number):number;
        /**
         * Returns f rounded to the nearest integer.
         */
        public static Round($f: number):number;
        /**
         * Returns the smallest integer greater to or equal to f.
         */
        public static CeilToInt($f: number):number;
        /**
         * Returns the largest integer smaller to or equal to f.
         */
        public static FloorToInt($f: number):number;
        /**
         * Returns f rounded to the nearest integer.
         */
        public static RoundToInt($f: number):number;
        /**
         * Returns the sign of f.
         */
        public static Sign($f: number):number;
        /**
         * Clamps the given value between the given minimum float and maximum float values.  Returns the given value if it is within the min and max range.
         * @param value The floating point value to restrict inside the range defined by the min and max values.
         * @param min The minimum floating point value to compare against.
         * @param max The maximum floating point value to compare against.
         * @returns The float result between the min and max values.
         */
        public static Clamp($value: number, $min: number, $max: number):number;
        /**
         * Clamps the given value between a range defined by the given minimum integer and maximum integer values. Returns the given value if it is within min and max.
         * @param value The integer point value to restrict inside the min-to-max range
         * @param min The minimum integer point value to compare against.
         * @param max The maximum  integer point value to compare against.
         * @returns The int result between min and max values.
         */
        public static Clamp($value: number, $min: number, $max: number):number;
        /**
         * Clamps value between 0 and 1 and returns value.
         */
        public static Clamp01($value: number):number;
        /**
         * Linearly interpolates between a and b by t.
         * @param a The start value.
         * @param b The end value.
         * @param t The interpolation value between the two floats.
         * @returns The interpolated float result between the two float values.
         */
        public static Lerp($a: number, $b: number, $t: number):number;
        /**
         * Linearly interpolates between a and b by t with no limit to t.
         * @param a The start value.
         * @param b The end value.
         * @param t The interpolation between the two floats.
         * @returns The float value as a result from the linear interpolation.
         */
        public static LerpUnclamped($a: number, $b: number, $t: number):number;
        /**
         * Same as Lerp but makes sure the values interpolate correctly when they wrap around 360 degrees.
         */
        public static LerpAngle($a: number, $b: number, $t: number):number;
        /**
         * Moves a value current towards target.
         * @param current The current value.
         * @param target The value to move towards.
         * @param maxDelta The maximum change that should be applied to the value.
         */
        public static MoveTowards($current: number, $target: number, $maxDelta: number):number;
        /**
         * Same as MoveTowards but makes sure the values interpolate correctly when they wrap around 360 degrees.
         */
        public static MoveTowardsAngle($current: number, $target: number, $maxDelta: number):number;
        /**
         * Interpolates between min and max with smoothing at the limits.
         */
        public static SmoothStep($from: number, $to: number, $t: number):number;
        
        public static Gamma($value: number, $absmax: number, $gamma: number):number;
        /**
         * Compares two floating point values and returns true if they are similar.
         */
        public static Approximately($a: number, $b: number):boolean;
        /**
         * Gradually changes a value towards a desired goal over time.
         * @param current The current position.
         * @param target The position we are trying to reach.
         * @param currentVelocity The current velocity, this value is modified by the function every time you call it.
         * @param smoothTime Approximately the time it will take to reach the target. A smaller value will reach the target faster.
         * @param maxSpeed Optionally allows you to clamp the maximum speed.
         * @param deltaTime The time since the last call to this function. By default Time.deltaTime.
         */
        public static SmoothDamp($current: number, $target: number, $currentVelocity: $Ref<number>, $smoothTime: number, $maxSpeed: number):number;
        /**
         * Gradually changes a value towards a desired goal over time.
         * @param current The current position.
         * @param target The position we are trying to reach.
         * @param currentVelocity The current velocity, this value is modified by the function every time you call it.
         * @param smoothTime Approximately the time it will take to reach the target. A smaller value will reach the target faster.
         * @param maxSpeed Optionally allows you to clamp the maximum speed.
         * @param deltaTime The time since the last call to this function. By default Time.deltaTime.
         */
        public static SmoothDamp($current: number, $target: number, $currentVelocity: $Ref<number>, $smoothTime: number):number;
        /**
         * Gradually changes a value towards a desired goal over time.
         * @param current The current position.
         * @param target The position we are trying to reach.
         * @param currentVelocity The current velocity, this value is modified by the function every time you call it.
         * @param smoothTime Approximately the time it will take to reach the target. A smaller value will reach the target faster.
         * @param maxSpeed Optionally allows you to clamp the maximum speed.
         * @param deltaTime The time since the last call to this function. By default Time.deltaTime.
         */
        public static SmoothDamp($current: number, $target: number, $currentVelocity: $Ref<number>, $smoothTime: number, $maxSpeed: number, $deltaTime: number):number;
        /**
         * Gradually changes an angle given in degrees towards a desired goal angle over time.
         * @param current The current position.
         * @param target The position we are trying to reach.
         * @param currentVelocity The current velocity, this value is modified by the function every time you call it.
         * @param smoothTime Approximately the time it will take to reach the target. A smaller value will reach the target faster.
         * @param maxSpeed Optionally allows you to clamp the maximum speed.
         * @param deltaTime The time since the last call to this function. By default Time.deltaTime.
         */
        public static SmoothDampAngle($current: number, $target: number, $currentVelocity: $Ref<number>, $smoothTime: number, $maxSpeed: number):number;
        /**
         * Gradually changes an angle given in degrees towards a desired goal angle over time.
         * @param current The current position.
         * @param target The position we are trying to reach.
         * @param currentVelocity The current velocity, this value is modified by the function every time you call it.
         * @param smoothTime Approximately the time it will take to reach the target. A smaller value will reach the target faster.
         * @param maxSpeed Optionally allows you to clamp the maximum speed.
         * @param deltaTime The time since the last call to this function. By default Time.deltaTime.
         */
        public static SmoothDampAngle($current: number, $target: number, $currentVelocity: $Ref<number>, $smoothTime: number):number;
        /**
         * Gradually changes an angle given in degrees towards a desired goal angle over time.
         * @param current The current position.
         * @param target The position we are trying to reach.
         * @param currentVelocity The current velocity, this value is modified by the function every time you call it.
         * @param smoothTime Approximately the time it will take to reach the target. A smaller value will reach the target faster.
         * @param maxSpeed Optionally allows you to clamp the maximum speed.
         * @param deltaTime The time since the last call to this function. By default Time.deltaTime.
         */
        public static SmoothDampAngle($current: number, $target: number, $currentVelocity: $Ref<number>, $smoothTime: number, $maxSpeed: number, $deltaTime: number):number;
        /**
         * Loops the value t, so that it is never larger than length and never smaller than 0.
         */
        public static Repeat($t: number, $length: number):number;
        /**
         * PingPong returns a value that will increment and decrement between the value 0 and length.
         */
        public static PingPong($t: number, $length: number):number;
        /**
         * Calculates the linear parameter t that produces the interpolant value within the range [a, b].
         * @param a Start value.
         * @param b End value.
         * @param value Value between start and end.
         * @returns Percentage of value between start and end.
         */
        public static InverseLerp($a: number, $b: number, $value: number):number;
        /**
         * Calculates the shortest difference between two given angles given in degrees.
         */
        public static DeltaAngle($current: number, $target: number):number;
        
        public get_Clone(): Mathf;            
    }
    /**
     * Representation of RGBA colors.
     */
    class Color extends System.ValueType {
        /**
         * Red component of the color.
         */
        public r: number;
        /**
         * Green component of the color.
         */
        public g: number;
        /**
         * Blue component of the color.
         */
        public b: number;
        /**
         * Alpha component of the color (0 is transparent, 1 is opaque).
         */
        public a: number;
        /**
         * Solid red. RGBA is (1, 0, 0, 1).
         */
        public static get red(): Color;
        /**
         * Solid green. RGBA is (0, 1, 0, 1).
         */
        public static get green(): Color;
        /**
         * Solid blue. RGBA is (0, 0, 1, 1).
         */
        public static get blue(): Color;
        /**
         * Solid white. RGBA is (1, 1, 1, 1).
         */
        public static get white(): Color;
        /**
         * Solid black. RGBA is (0, 0, 0, 1).
         */
        public static get black(): Color;
        /**
         * Yellow. RGBA is (1, 0.92, 0.016, 1), but the color is nice to look at!
         */
        public static get yellow(): Color;
        /**
         * Cyan. RGBA is (0, 1, 1, 1).
         */
        public static get cyan(): Color;
        /**
         * Magenta. RGBA is (1, 0, 1, 1).
         */
        public static get magenta(): Color;
        /**
         * Gray. RGBA is (0.5, 0.5, 0.5, 1).
         */
        public static get gray(): Color;
        /**
         * English spelling for gray. RGBA is the same (0.5, 0.5, 0.5, 1).
         */
        public static get grey(): Color;
        /**
         * Completely transparent. RGBA is (0, 0, 0, 0).
         */
        public static get clear(): Color;
        /**
         * The grayscale value of the color. (Read Only)
         */
        public get grayscale(): number;
        /**
         * A linear value of an sRGB color.
         */
        public get linear(): Color;
        /**
         * A version of the color that has had the gamma curve applied.
         */
        public get gamma(): Color;
        /**
         * Returns the maximum color component value: Max(r,g,b).
         */
        public get maxColorComponent(): number;
        /**
         * Constructs a new Color with given r,g,b,a components.
         * @param r Red component.
         * @param g Green component.
         * @param b Blue component.
         * @param a Alpha component.
         */
        public constructor($r: number, $g: number, $b: number, $a: number);
        /**
         * Constructs a new Color with given r,g,b components and sets a to 1.
         * @param r Red component.
         * @param g Green component.
         * @param b Blue component.
         */
        public constructor($r: number, $g: number, $b: number);
        /**
         * Returns a formatted string of this color.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        public ToString():string;
        /**
         * Returns a formatted string of this color.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        public ToString($format: string):string;
        /**
         * Returns a formatted string of this color.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        public ToString($format: string, $formatProvider: System.IFormatProvider):string;
        
        public GetHashCode():number;
        
        public Equals($other: any):boolean;
        
        public Equals($other: Color):boolean;
        
        public static op_Addition($a: Color, $b: Color):Color;
        
        public static op_Subtraction($a: Color, $b: Color):Color;
        /**
         * Multiplies two colors together. Each component is multiplied separately.
         */
        public static op_Multiply($a: Color, $b: Color):Color;
        /**
         * Multiplies color a by the float b. Each color component is scaled separately.
         */
        public static op_Multiply($a: Color, $b: number):Color;
        /**
         * Multiplies color a by the float b. Each color component is scaled separately.
         */
        public static op_Multiply($b: number, $a: Color):Color;
        
        public static op_Division($a: Color, $b: number):Color;
        
        public static op_Equality($lhs: Color, $rhs: Color):boolean;
        
        public static op_Inequality($lhs: Color, $rhs: Color):boolean;
        /**
         * Linearly interpolates between colors a and b by t.
         * @param a Color a.
         * @param b Color b.
         * @param t Float for combining a and b.
         */
        public static Lerp($a: Color, $b: Color, $t: number):Color;
        /**
         * Linearly interpolates between colors a and b by t.
         */
        public static LerpUnclamped($a: Color, $b: Color, $t: number):Color;
        
        public static op_Implicit($c: Color):Vector4;
        
        public static op_Implicit($v: Vector4):Color;
        
        public get_Item($index: number):number;
        
        public set_Item($index: number, $value: number):void;
        /**
         * Calculates the hue, saturation and value of an RGB input color.
         * @param rgbColor An input color.
         * @param H Output variable for hue.
         * @param S Output variable for saturation.
         * @param V Output variable for value.
         */
        public static RGBToHSV($rgbColor: Color, $H: $Ref<number>, $S: $Ref<number>, $V: $Ref<number>):void;
        /**
         * Creates an RGB colour from HSV input.
         * @param H Hue [0..1].
         * @param S Saturation [0..1].
         * @param V Brightness value [0..1].
         * @param hdr Output HDR colours. If true, the returned colour will not be clamped to [0..1].
         * @returns An opaque colour with HSV matching the input.
         */
        public static HSVToRGB($H: number, $S: number, $V: number):Color;
        /**
         * Creates an RGB colour from HSV input.
         * @param H Hue [0..1].
         * @param S Saturation [0..1].
         * @param V Brightness value [0..1].
         * @param hdr Output HDR colours. If true, the returned colour will not be clamped to [0..1].
         * @returns An opaque colour with HSV matching the input.
         */
        public static HSVToRGB($H: number, $S: number, $V: number, $hdr: boolean):Color;
        
        public get_Clone(): Color;            
    }
    /**
     * Easily generate random data for games.
     */
    class Random extends System.Object {
        /**
         * Gets or sets the full internal state of the random number generator.
         */
        public static get state(): UnityEngine_Random.State;
        public static set state(value: UnityEngine_Random.State);
        /**
         * Returns a random float within [0.0..1.0] (range is inclusive) (Read Only).
         */
        public static get value(): number;
        /**
         * Returns a random point inside or on a sphere with radius 1.0 (Read Only).
         */
        public static get insideUnitSphere(): Vector3;
        /**
         * Returns a random point inside or on a circle with radius 1.0 (Read Only).
         */
        public static get insideUnitCircle(): Vector2;
        /**
         * Returns a random point on the surface of a sphere with radius 1.0 (Read Only).
         */
        public static get onUnitSphere(): Vector3;
        /**
         * Returns a random rotation (Read Only).
         */
        public static get rotation(): Quaternion;
        /**
         * Returns a random rotation with uniform distribution (Read Only).
         */
        public static get rotationUniform(): Quaternion;
        /**
         * Initializes the random number generator state with a seed.
         * @param seed Seed used to initialize the random number generator.
         */
        public static InitState($seed: number):void;
        /**
         * Returns a random float within [minInclusive..maxInclusive] (range is inclusive).
         */
        public static Range($minInclusive: number, $maxInclusive: number):number;
        /**
         * Return a random int within [minInclusive..maxExclusive) (Read Only).
         */
        public static Range($minInclusive: number, $maxExclusive: number):number;
        /**
         * Generates a random color from HSV and alpha ranges.
         * @param hueMin Minimum hue [0..1].
         * @param hueMax Maximum hue [0..1].
         * @param saturationMin Minimum saturation [0..1].
         * @param saturationMax Maximum saturation [0..1].
         * @param valueMin Minimum value [0..1].
         * @param valueMax Maximum value [0..1].
         * @param alphaMin Minimum alpha [0..1].
         * @param alphaMax Maximum alpha [0..1].
         * @returns A random color with HSV and alpha values in the (inclusive) input ranges. Values for each component are derived via linear interpolation of value.
         */
        public static ColorHSV():Color;
        /**
         * Generates a random color from HSV and alpha ranges.
         * @param hueMin Minimum hue [0..1].
         * @param hueMax Maximum hue [0..1].
         * @param saturationMin Minimum saturation [0..1].
         * @param saturationMax Maximum saturation [0..1].
         * @param valueMin Minimum value [0..1].
         * @param valueMax Maximum value [0..1].
         * @param alphaMin Minimum alpha [0..1].
         * @param alphaMax Maximum alpha [0..1].
         * @returns A random color with HSV and alpha values in the (inclusive) input ranges. Values for each component are derived via linear interpolation of value.
         */
        public static ColorHSV($hueMin: number, $hueMax: number):Color;
        /**
         * Generates a random color from HSV and alpha ranges.
         * @param hueMin Minimum hue [0..1].
         * @param hueMax Maximum hue [0..1].
         * @param saturationMin Minimum saturation [0..1].
         * @param saturationMax Maximum saturation [0..1].
         * @param valueMin Minimum value [0..1].
         * @param valueMax Maximum value [0..1].
         * @param alphaMin Minimum alpha [0..1].
         * @param alphaMax Maximum alpha [0..1].
         * @returns A random color with HSV and alpha values in the (inclusive) input ranges. Values for each component are derived via linear interpolation of value.
         */
        public static ColorHSV($hueMin: number, $hueMax: number, $saturationMin: number, $saturationMax: number):Color;
        /**
         * Generates a random color from HSV and alpha ranges.
         * @param hueMin Minimum hue [0..1].
         * @param hueMax Maximum hue [0..1].
         * @param saturationMin Minimum saturation [0..1].
         * @param saturationMax Maximum saturation [0..1].
         * @param valueMin Minimum value [0..1].
         * @param valueMax Maximum value [0..1].
         * @param alphaMin Minimum alpha [0..1].
         * @param alphaMax Maximum alpha [0..1].
         * @returns A random color with HSV and alpha values in the (inclusive) input ranges. Values for each component are derived via linear interpolation of value.
         */
        public static ColorHSV($hueMin: number, $hueMax: number, $saturationMin: number, $saturationMax: number, $valueMin: number, $valueMax: number):Color;
        /**
         * Generates a random color from HSV and alpha ranges.
         * @param hueMin Minimum hue [0..1].
         * @param hueMax Maximum hue [0..1].
         * @param saturationMin Minimum saturation [0..1].
         * @param saturationMax Maximum saturation [0..1].
         * @param valueMin Minimum value [0..1].
         * @param valueMax Maximum value [0..1].
         * @param alphaMin Minimum alpha [0..1].
         * @param alphaMax Maximum alpha [0..1].
         * @returns A random color with HSV and alpha values in the (inclusive) input ranges. Values for each component are derived via linear interpolation of value.
         */
        public static ColorHSV($hueMin: number, $hueMax: number, $saturationMin: number, $saturationMax: number, $valueMin: number, $valueMax: number, $alphaMin: number, $alphaMax: number):Color;
        
                    
    }
    /**
     * Provides an interface to get time information from Unity.
     */
    class Time extends System.Object {
        /**
         * The time at the beginning of this frame (Read Only).
         */
        public static get time(): number;
        /**
         * The double precision time at the beginning of this frame (Read Only). This is the time in seconds since the start of the game.
         */
        public static get timeAsDouble(): number;
        /**
         * The time since this frame started (Read Only). This is the time in seconds since the last non-additive scene has finished loading.
         */
        public static get timeSinceLevelLoad(): number;
        /**
         * The double precision time since this frame started (Read Only). This is the time in seconds since the last non-additive scene has finished loading.
         */
        public static get timeSinceLevelLoadAsDouble(): number;
        /**
         * The interval in seconds from the last frame to the current one (Read Only).
         */
        public static get deltaTime(): number;
        /**
         * The time since the last MonoBehaviour.FixedUpdate started (Read Only). This is the time in seconds since the start of the game.
         */
        public static get fixedTime(): number;
        /**
         * The double precision time since the last MonoBehaviour.FixedUpdate started (Read Only). This is the time in seconds since the start of the game.
         */
        public static get fixedTimeAsDouble(): number;
        /**
         * The timeScale-independent time for this frame (Read Only). This is the time in seconds since the start of the game.
         */
        public static get unscaledTime(): number;
        /**
         * The double precision timeScale-independent time for this frame (Read Only). This is the time in seconds since the start of the game.
         */
        public static get unscaledTimeAsDouble(): number;
        /**
         * The timeScale-independent time at the beginning of the last MonoBehaviour.FixedUpdate phase (Read Only). This is the time in seconds since the start of the game.
         */
        public static get fixedUnscaledTime(): number;
        /**
         * The double precision timeScale-independent time at the beginning of the last MonoBehaviour.FixedUpdate (Read Only). This is the time in seconds since the start of the game.
         */
        public static get fixedUnscaledTimeAsDouble(): number;
        /**
         * The timeScale-independent interval in seconds from the last frame to the current one (Read Only).
         */
        public static get unscaledDeltaTime(): number;
        /**
         * The timeScale-independent interval in seconds from the last MonoBehaviour.FixedUpdate phase to the current one (Read Only).
         */
        public static get fixedUnscaledDeltaTime(): number;
        /**
         * The interval in seconds at which physics and other fixed frame rate updates (like MonoBehaviour's MonoBehaviour.FixedUpdate) are performed.
         */
        public static get fixedDeltaTime(): number;
        public static set fixedDeltaTime(value: number);
        /**
         * The maximum value of Time.deltaTime in any given frame. This is a time in seconds that limits the increase of Time.time between two frames.
         */
        public static get maximumDeltaTime(): number;
        public static set maximumDeltaTime(value: number);
        /**
         * A smoothed out Time.deltaTime (Read Only).
         */
        public static get smoothDeltaTime(): number;
        /**
         * The maximum time a frame can spend on particle updates. If the frame takes longer than this, then updates are split into multiple smaller updates.
         */
        public static get maximumParticleDeltaTime(): number;
        public static set maximumParticleDeltaTime(value: number);
        /**
         * The scale at which time passes.
         */
        public static get timeScale(): number;
        public static set timeScale(value: number);
        /**
         * The total number of frames since the start of the game (Read Only).
         */
        public static get frameCount(): number;
        
        public static get renderedFrameCount(): number;
        /**
         * The real time in seconds since the game started (Read Only).
         */
        public static get realtimeSinceStartup(): number;
        /**
         * The real time in seconds since the game started (Read Only). Double precision version of Time.realtimeSinceStartup.
         */
        public static get realtimeSinceStartupAsDouble(): number;
        /**
         * Slows your application’s playback time to allow Unity to save screenshots in between frames.
         */
        public static get captureDeltaTime(): number;
        public static set captureDeltaTime(value: number);
        /**
         * The reciprocal of Time.captureDeltaTime.
         */
        public static get captureFramerate(): number;
        public static set captureFramerate(value: number);
        /**
         * Returns true if called inside a fixed time step callback (like MonoBehaviour's MonoBehaviour.FixedUpdate), otherwise returns false.
         */
        public static get inFixedTimeStep(): boolean;
        
        public constructor();
        
                    
    }
    /**
     * Base class for Texture handling.
     */
    class Texture extends Object {
        /**
         * Can be used with Texture constructors that take a mip count to indicate that all mips should be generated.  The value of this field is -1.
         */
        public static GenerateAllMips: number;
        
        public static get masterTextureLimit(): number;
        public static set masterTextureLimit(value: number);
        /**
         * How many mipmap levels are in this Texture (Read Only).
         */
        public get mipmapCount(): number;
        
        public static get anisotropicFiltering(): AnisotropicFiltering;
        public static set anisotropicFiltering(value: AnisotropicFiltering);
        /**
         * Returns the GraphicsFormat format or color format of a Texture object.
         */
        public get graphicsFormat(): UnityEngine_Experimental_Rendering.GraphicsFormat;
        /**
         * Width of the Texture in pixels. (Read Only)
         */
        public get width(): number;
        public set width(value: number);
        /**
         * Height of the Texture in pixels. (Read Only)
         */
        public get height(): number;
        public set height(value: number);
        /**
         * Dimensionality (type) of the Texture (Read Only).
         */
        public get dimension(): UnityEngine_Rendering.TextureDimension;
        public set dimension(value: UnityEngine_Rendering.TextureDimension);
        /**
         * Returns true if the Read/Write Enabled checkbox was checked when the Texture was imported; otherwise returns false. For a dynamic Texture created from script, always returns true. For additional information, see TextureImporter.isReadable.
         */
        public get isReadable(): boolean;
        /**
         * Texture coordinate wrapping mode.
         */
        public get wrapMode(): TextureWrapMode;
        public set wrapMode(value: TextureWrapMode);
        /**
         * Texture U coordinate wrapping mode.
         */
        public get wrapModeU(): TextureWrapMode;
        public set wrapModeU(value: TextureWrapMode);
        /**
         * Texture V coordinate wrapping mode.
         */
        public get wrapModeV(): TextureWrapMode;
        public set wrapModeV(value: TextureWrapMode);
        /**
         * Texture W coordinate wrapping mode for Texture3D.
         */
        public get wrapModeW(): TextureWrapMode;
        public set wrapModeW(value: TextureWrapMode);
        /**
         * Filtering mode of the Texture.
         */
        public get filterMode(): FilterMode;
        public set filterMode(value: FilterMode);
        /**
         * Defines the anisotropic filtering level of the Texture.
         */
        public get anisoLevel(): number;
        public set anisoLevel(value: number);
        /**
         * The mipmap bias of the Texture.
         */
        public get mipMapBias(): number;
        public set mipMapBias(value: number);
        
        public get texelSize(): Vector2;
        /**
         * This counter is incremented when the Texture is updated.
         */
        public get updateCount(): number;
        /**
         * The hash value of the Texture.
         */
        public get imageContentsHash(): Hash128;
        public set imageContentsHash(value: Hash128);
        /**
         * The total amount of Texture memory that Unity would use if it loads all Textures at mipmap level 0.
         * This is a theoretical value that does not take into account any input from the streaming system or any other input, for example when you set the`Texture2D.requestedMipmapLevel` manually.
         * To see a Texture memory value that takes inputs into account, use `desiredTextureMemory`.
         * `totalTextureMemory` only includes instances of Texture2D and CubeMap Textures. It does not include any other Texture types, or 2D and CubeMap Textures that Unity creates internally.
         */
        public static get totalTextureMemory(): bigint;
        /**
         * The total size of the Textures, in bytes, that Unity loads if there were no other constraints. Before Unity loads any Textures, it applies the which reduces the loaded Texture resolution if the Texture sizes exceed its value. The `desiredTextureMemory` value takes into account the mipmap levels that Unity has requested or that you have set manually.
         * For example, if Unity does not load a Texture at full resolution because it is far away or its requested mipmap level is greater than 0,  Unity reduces the `desiredTextureMemory` value to match the total memory needed.
         * The `desiredTextureMemory` value can be greater than the `targetTextureMemory` value.
         */
        public static get desiredTextureMemory(): bigint;
        /**
         * The total amount of Texture memory that Unity allocates to the Textures in the scene after it applies the and finishes loading Textures. `targetTextureMemory`also takes mipmap streaming settings into account. This value only includes instances of Texture2D and CubeMap Textures. It does not include any other Texture types, or 2D and CubeMap Textures that Unity creates internally.
         */
        public static get targetTextureMemory(): bigint;
        /**
         * The amount of memory that all Textures in the scene use.
         */
        public static get currentTextureMemory(): bigint;
        /**
         * The amount of memory Unity allocates for non-streaming Textures in the scene. This only includes instances of Texture2D and CubeMap Textures. This does not include any other Texture types, or 2D and CubeMap Textures that Unity creates internally.
         */
        public static get nonStreamingTextureMemory(): bigint;
        /**
         * How many times has a Texture been uploaded due to Texture mipmap streaming.
         */
        public static get streamingMipmapUploadCount(): bigint;
        /**
         * Number of renderers registered with the Texture streaming system.
         */
        public static get streamingRendererCount(): bigint;
        /**
         * Number of streaming Textures.
         */
        public static get streamingTextureCount(): bigint;
        /**
         * The number of non-streaming Textures in the scene. This includes instances of Texture2D and CubeMap Textures. This does not include any other Texture types, or 2D and CubeMap Textures that Unity creates internally.
         */
        public static get nonStreamingTextureCount(): bigint;
        /**
         * Number of streaming Textures with outstanding mipmaps to be loaded.
         */
        public static get streamingTexturePendingLoadCount(): bigint;
        /**
         * Number of streaming Textures with mipmaps currently loading.
         */
        public static get streamingTextureLoadingCount(): bigint;
        /**
         * Force streaming Textures to load all mipmap levels.
         */
        public static get streamingTextureForceLoadAll(): boolean;
        public static set streamingTextureForceLoadAll(value: boolean);
        /**
         * This property forces the streaming Texture system to discard all unused mipmaps instead of caching them until the Texture is exceeded. This is useful when you profile or write tests to keep a predictable set of Textures in memory.
         */
        public static get streamingTextureDiscardUnusedMips(): boolean;
        public static set streamingTextureDiscardUnusedMips(value: boolean);
        /**
         * Allow Unity internals to perform Texture creation on any thread (rather than the dedicated render thread).
         */
        public static get allowThreadedTextureCreation(): boolean;
        public static set allowThreadedTextureCreation(value: boolean);
        /**
         * Sets Anisotropic limits.
         */
        public static SetGlobalAnisotropicFilteringLimits($forcedMin: number, $globalMax: number):void;
        /**
         * Retrieve a native (underlying graphics API) pointer to the Texture resource.
         * @returns Pointer to an underlying graphics API Texture resource.
         */
        public GetNativeTexturePtr():System.IntPtr;
        /**
         * Increment the update counter.
         */
        public IncrementUpdateCount():void;
        /**
         * This function sets mipmap streaming debug properties on any materials that use this Texture through the mipmap streaming system.
         */
        public static SetStreamingTextureMaterialDebugProperties():void;
        
                    
    }
    /**
     * Anisotropic filtering mode.
     */
    enum AnisotropicFiltering { Disable = 0, Enable = 1, ForceEnable = 2 }
    /**
     * Wrap mode for textures.
     */
    enum TextureWrapMode { Repeat = 0, Clamp = 1, Mirror = 2, MirrorOnce = 3 }
    /**
     * Filtering mode for textures. Corresponds to the settings in a.
     */
    enum FilterMode { Point = 0, Bilinear = 1, Trilinear = 2 }
    /**
     * Represents  a 128-bit hash value.
     */
    class Hash128 extends System.ValueType {
        /**
         * Returns true is the hash value is valid. (Read Only)
         */
        public get isValid(): boolean;
        /**
         * Directly initialize a Hash128 with a 128-bit value.
         * @param u32_0 First 32 bits of hash value.
         * @param u32_1 Second 32 bits of hash value.
         * @param u32_2 Third 32 bits of hash value.
         * @param u32_3 Fourth 32 bits of hash value.
         * @param u64_0 First 64 bits of hash value.
         * @param u64_1 Second 64 bits of hash value.
         */
        public constructor($u32_0: number, $u32_1: number, $u32_2: number, $u32_3: number);
        /**
         * Directly initialize a Hash128 with a 128-bit value.
         * @param u32_0 First 32 bits of hash value.
         * @param u32_1 Second 32 bits of hash value.
         * @param u32_2 Third 32 bits of hash value.
         * @param u32_3 Fourth 32 bits of hash value.
         * @param u64_0 First 64 bits of hash value.
         * @param u64_1 Second 64 bits of hash value.
         */
        public constructor($u64_0: bigint, $u64_1: bigint);
        
        public CompareTo($rhs: Hash128):number;
        /**
         * Convert a Hash128 to string.
         */
        public ToString():string;
        /**
         * Convert a hex-encoded string into Hash128 value.
         * @param hashString A hexadecimal-encoded hash string.
         * @returns The 128-bit hash.
         */
        public static Parse($hashString: string):Hash128;
        /**
         * Compute a hash of input data string.
         * @param data Input data string. Note that Unity interprets the string as UTF-8 data, even if internally in C# strings are UTF-16.
         * @returns The 128-bit hash.
         */
        public static Compute($data: string):Hash128;
        
        public static Compute<T>($data: Unity_Collections.NativeArray$1<T>):Hash128;
        
        public static Compute<T>($data: Unity_Collections.NativeArray$1<T>, $start: number, $count: number):Hash128;
        /**
         * Compute a hash of input data.
         * @param data Input data array.
         * @returns The 128-bit hash.
         */
        public static Compute<T>($data: T[]):Hash128;
        /**
         * Compute a hash of a slice of input data.
         * @param data Input data array.
         * @param start The first element in the data to start hashing from.
         * @param count Number of array elements to hash.
         * @returns The 128-bit hash.
         */
        public static Compute<T>($data: T[], $start: number, $count: number):Hash128;
        
        public static Compute<T>($data: System_Collections_Generic.List$1<T>):Hash128;
        
        public static Compute<T>($data: System_Collections_Generic.List$1<T>, $start: number, $count: number):Hash128;
        
        public static Compute<T>($val: $Ref<T>):Hash128;
        /**
         * Compute a hash of input data.
         * @param val Input value.
         * @returns The 128-bit hash.
         */
        public static Compute($val: number):Hash128;
        /**
         * Compute a hash of input data.
         * @param val Input value.
         * @returns The 128-bit hash.
         */
        public static Compute($val: number):Hash128;
        /**
         * Hash new input string and combine with the current hash value.
         * @param data Input data string. Note that Unity interprets the string as UTF-8 data, even if internally in C# strings are UTF-16.
         */
        public Append($data: string):void;
        
        public Append<T>($data: Unity_Collections.NativeArray$1<T>):void;
        
        public Append<T>($data: Unity_Collections.NativeArray$1<T>, $start: number, $count: number):void;
        /**
         * Hash new input data array and combine with the current hash value.
         * @param data Input data array.
         */
        public Append<T>($data: T[]):void;
        /**
         * Hash a slice of new input data array and combine with the current hash value.
         * @param data Input data array.
         * @param start The first element in the data to start hashing from.
         * @param count Number of array elements to hash.
         */
        public Append<T>($data: T[], $start: number, $count: number):void;
        
        public Append<T>($data: System_Collections_Generic.List$1<T>):void;
        
        public Append<T>($data: System_Collections_Generic.List$1<T>, $start: number, $count: number):void;
        
        public Append<T>($val: $Ref<T>):void;
        /**
         * Hash new input data and combine with the current hash value.
         * @param val Input value.
         */
        public Append($val: number):void;
        /**
         * Hash new input data and combine with the current hash value.
         * @param val Input value.
         */
        public Append($val: number):void;
        
        public Equals($obj: any):boolean;
        
        public Equals($obj: Hash128):boolean;
        
        public GetHashCode():number;
        
        public CompareTo($obj: any):number;
        
        public static op_Equality($hash1: Hash128, $hash2: Hash128):boolean;
        
        public static op_Inequality($hash1: Hash128, $hash2: Hash128):boolean;
        
        public static op_LessThan($x: Hash128, $y: Hash128):boolean;
        
        public static op_GreaterThan($x: Hash128, $y: Hash128):boolean;
        
        public get_Clone(): Hash128;            
    }
    /**
     * Represents a Sprite object for use in 2D gameplay.
     */
    class Sprite extends Object {
        /**
         * Bounds of the Sprite, specified by its center and extents in world space units.
         */
        public get bounds(): Bounds;
        /**
         * Location of the Sprite on the original Texture, specified in pixels.
         */
        public get rect(): Rect;
        /**
         * Returns the border sizes of the sprite.
         */
        public get border(): Vector4;
        /**
         * Get the reference to the used texture. If packed this will point to the atlas, if not packed will point to the source sprite.
         */
        public get texture(): Texture2D;
        /**
         * The number of pixels in the sprite that correspond to one unit in world space. (Read Only)
         */
        public get pixelsPerUnit(): number;
        /**
         * The Variant scale of texture used by the Sprite. This is useful to check when a Variant SpriteAtlas is being used by Sprites.
         */
        public get spriteAtlasTextureScale(): number;
        /**
         * Returns the texture that contains the alpha channel from the source texture. Unity generates this texture under the hood for sprites that have alpha in the source, and need to be compressed using techniques like ETC1.
         * Returns NULL if there is no associated alpha texture for the source sprite. This is the case if the sprite has not been setup to use ETC1 compression.
         */
        public get associatedAlphaSplitTexture(): Texture2D;
        /**
         * Location of the Sprite's center point in the Rect on the original Texture, specified in pixels.
         */
        public get pivot(): Vector2;
        /**
         * Returns true if this Sprite is packed in an atlas.
         */
        public get packed(): boolean;
        /**
         * If Sprite is packed (see Sprite.packed), returns its SpritePackingMode.
         */
        public get packingMode(): SpritePackingMode;
        /**
         * If Sprite is packed (see Sprite.packed), returns its SpritePackingRotation.
         */
        public get packingRotation(): SpritePackingRotation;
        /**
         * Get the rectangle this sprite uses on its texture. Raises an exception if this sprite is tightly packed in an atlas.
         */
        public get textureRect(): Rect;
        /**
         * Gets the offset of the rectangle this sprite uses on its texture to the original sprite bounds. If sprite mesh type is FullRect, offset is zero.
         */
        public get textureRectOffset(): Vector2;
        /**
         * Returns a copy of the array containing sprite mesh vertex positions.
         */
        public get vertices(): Vector2[];
        /**
         * Returns a copy of the array containing sprite mesh triangles.
         */
        public get triangles(): number[];
        /**
         * The base texture coordinates of the sprite mesh.
         */
        public get uv(): Vector2[];
        /**
         * The number of physics shapes for the Sprite.
         * @returns The number of physics shapes for the Sprite.
         */
        public GetPhysicsShapeCount():number;
        /**
         * The number of points in the selected physics shape for the Sprite.
         * @param shapeIdx The index of the physics shape to retrieve the number of points from.
         * @returns The number of points in the selected physics shape for the Sprite.
         */
        public GetPhysicsShapePointCount($shapeIdx: number):number;
        
        public GetPhysicsShape($shapeIdx: number, $physicsShape: System_Collections_Generic.List$1<Vector2>):number;
        
        public OverridePhysicsShape($physicsShapes: System_Collections_Generic.IList$1<Vector2[]>):void;
        /**
         * Sets up new Sprite geometry.
         * @param vertices Array of vertex positions in Sprite Rect space.
         * @param triangles Array of sprite mesh triangle indices.
         */
        public OverrideGeometry($vertices: Vector2[], $triangles: number[]):void;
        /**
         * Create a new Sprite object.
         * @param texture Texture from which to obtain the sprite graphic.
         * @param rect Rectangular section of the texture to use for the sprite.
         * @param pivot Sprite's pivot point relative to its graphic rectangle.
         * @param pixelsPerUnit The number of pixels in the sprite that correspond to one unit in world space.
         * @param extrude Amount by which the sprite mesh should be expanded outwards.
         * @param meshType Controls the type of mesh generated for the sprite.
         * @param border The border sizes of the sprite (X=left, Y=bottom, Z=right, W=top).
         * @param generateFallbackPhysicsShape Generates a default physics shape for the sprite.
         */
        public static Create($texture: Texture2D, $rect: Rect, $pivot: Vector2, $pixelsPerUnit: number, $extrude: number, $meshType: SpriteMeshType, $border: Vector4, $generateFallbackPhysicsShape: boolean):Sprite;
        /**
         * Create a new Sprite object.
         * @param texture Texture from which to obtain the sprite graphic.
         * @param rect Rectangular section of the texture to use for the sprite.
         * @param pivot Sprite's pivot point relative to its graphic rectangle.
         * @param pixelsPerUnit The number of pixels in the sprite that correspond to one unit in world space.
         * @param extrude Amount by which the sprite mesh should be expanded outwards.
         * @param meshType Controls the type of mesh generated for the sprite.
         * @param border The border sizes of the sprite (X=left, Y=bottom, Z=right, W=top).
         * @param generateFallbackPhysicsShape Generates a default physics shape for the sprite.
         */
        public static Create($texture: Texture2D, $rect: Rect, $pivot: Vector2, $pixelsPerUnit: number, $extrude: number, $meshType: SpriteMeshType, $border: Vector4):Sprite;
        /**
         * Create a new Sprite object.
         * @param texture Texture from which to obtain the sprite graphic.
         * @param rect Rectangular section of the texture to use for the sprite.
         * @param pivot Sprite's pivot point relative to its graphic rectangle.
         * @param pixelsPerUnit The number of pixels in the sprite that correspond to one unit in world space.
         * @param extrude Amount by which the sprite mesh should be expanded outwards.
         * @param meshType Controls the type of mesh generated for the sprite.
         * @param border The border sizes of the sprite (X=left, Y=bottom, Z=right, W=top).
         * @param generateFallbackPhysicsShape Generates a default physics shape for the sprite.
         */
        public static Create($texture: Texture2D, $rect: Rect, $pivot: Vector2, $pixelsPerUnit: number, $extrude: number, $meshType: SpriteMeshType):Sprite;
        /**
         * Create a new Sprite object.
         * @param texture Texture from which to obtain the sprite graphic.
         * @param rect Rectangular section of the texture to use for the sprite.
         * @param pivot Sprite's pivot point relative to its graphic rectangle.
         * @param pixelsPerUnit The number of pixels in the sprite that correspond to one unit in world space.
         * @param extrude Amount by which the sprite mesh should be expanded outwards.
         * @param meshType Controls the type of mesh generated for the sprite.
         * @param border The border sizes of the sprite (X=left, Y=bottom, Z=right, W=top).
         * @param generateFallbackPhysicsShape Generates a default physics shape for the sprite.
         */
        public static Create($texture: Texture2D, $rect: Rect, $pivot: Vector2, $pixelsPerUnit: number, $extrude: number):Sprite;
        /**
         * Create a new Sprite object.
         * @param texture Texture from which to obtain the sprite graphic.
         * @param rect Rectangular section of the texture to use for the sprite.
         * @param pivot Sprite's pivot point relative to its graphic rectangle.
         * @param pixelsPerUnit The number of pixels in the sprite that correspond to one unit in world space.
         * @param extrude Amount by which the sprite mesh should be expanded outwards.
         * @param meshType Controls the type of mesh generated for the sprite.
         * @param border The border sizes of the sprite (X=left, Y=bottom, Z=right, W=top).
         * @param generateFallbackPhysicsShape Generates a default physics shape for the sprite.
         */
        public static Create($texture: Texture2D, $rect: Rect, $pivot: Vector2, $pixelsPerUnit: number):Sprite;
        /**
         * Create a new Sprite object.
         * @param texture Texture from which to obtain the sprite graphic.
         * @param rect Rectangular section of the texture to use for the sprite.
         * @param pivot Sprite's pivot point relative to its graphic rectangle.
         * @param pixelsPerUnit The number of pixels in the sprite that correspond to one unit in world space.
         * @param extrude Amount by which the sprite mesh should be expanded outwards.
         * @param meshType Controls the type of mesh generated for the sprite.
         * @param border The border sizes of the sprite (X=left, Y=bottom, Z=right, W=top).
         * @param generateFallbackPhysicsShape Generates a default physics shape for the sprite.
         */
        public static Create($texture: Texture2D, $rect: Rect, $pivot: Vector2):Sprite;
        
                    
    }
    /**
     * Represents an axis aligned bounding box.
     */
    class Bounds extends System.ValueType {
        /**
         * The center of the bounding box.
         */
        public get center(): Vector3;
        public set center(value: Vector3);
        /**
         * The total size of the box. This is always twice as large as the extents.
         */
        public get size(): Vector3;
        public set size(value: Vector3);
        /**
         * The extents of the Bounding Box. This is always half of the size of the Bounds.
         */
        public get extents(): Vector3;
        public set extents(value: Vector3);
        /**
         * The minimal point of the box. This is always equal to center-extents.
         */
        public get min(): Vector3;
        public set min(value: Vector3);
        /**
         * The maximal point of the box. This is always equal to center+extents.
         */
        public get max(): Vector3;
        public set max(value: Vector3);
        /**
         * Creates a new Bounds.
         * @param center The location of the origin of the Bounds.
         * @param size The dimensions of the Bounds.
         */
        public constructor($center: Vector3, $size: Vector3);
        
        public GetHashCode():number;
        
        public Equals($other: any):boolean;
        
        public Equals($other: Bounds):boolean;
        
        public static op_Equality($lhs: Bounds, $rhs: Bounds):boolean;
        
        public static op_Inequality($lhs: Bounds, $rhs: Bounds):boolean;
        /**
         * Sets the bounds to the min and max value of the box.
         */
        public SetMinMax($min: Vector3, $max: Vector3):void;
        /**
         * Grows the Bounds to include the point.
         */
        public Encapsulate($point: Vector3):void;
        /**
         * Grow the bounds to encapsulate the bounds.
         */
        public Encapsulate($bounds: Bounds):void;
        /**
         * Expand the bounds by increasing its size by amount along each side.
         */
        public Expand($amount: number):void;
        /**
         * Expand the bounds by increasing its size by amount along each side.
         */
        public Expand($amount: Vector3):void;
        /**
         * Does another bounding box intersect with this bounding box?
         */
        public Intersects($bounds: Bounds):boolean;
        /**
         * Does ray intersect this bounding box?
         */
        public IntersectRay($ray: Ray):boolean;
        /**
         * Does ray intersect this bounding box?
         */
        public IntersectRay($ray: Ray, $distance: $Ref<number>):boolean;
        /**
         * Returns a formatted string for the bounds.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        public ToString():string;
        /**
         * Returns a formatted string for the bounds.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        public ToString($format: string):string;
        /**
         * Returns a formatted string for the bounds.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        public ToString($format: string, $formatProvider: System.IFormatProvider):string;
        /**
         * Is point contained in the bounding box?
         */
        public Contains($point: Vector3):boolean;
        /**
         * The smallest squared distance between the point and this bounding box.
         */
        public SqrDistance($point: Vector3):number;
        /**
         * The closest point on the bounding box.
         * @param point Arbitrary point.
         * @returns The point on the bounding box or inside the bounding box.
         */
        public ClosestPoint($point: Vector3):Vector3;
        
        public get_Clone(): Bounds;            
    }
    /**
     * Class that represents textures in C# code.
     */
    class Texture2D extends Texture {
        /**
         * The format of the pixel data in the texture (Read Only).
         */
        public get format(): TextureFormat;
        /**
         * Gets a small Texture with all white pixels.
         */
        public static get whiteTexture(): Texture2D;
        /**
         * Gets a small Texture with all black pixels.
         */
        public static get blackTexture(): Texture2D;
        /**
         * Gets a small Texture with all red pixels.
         */
        public static get redTexture(): Texture2D;
        /**
         * Gets a small Texture with all gray pixels.
         */
        public static get grayTexture(): Texture2D;
        /**
         * Gets a small Texture with all gray pixels.
         */
        public static get linearGrayTexture(): Texture2D;
        /**
         * Gets a small Texture with pixels that represent surface normal vectors at a neutral position.
         */
        public static get normalTexture(): Texture2D;
        /**
         * Returns true if the Read/Write Enabled checkbox was checked when the texture was imported; otherwise returns false. For a dynamic Texture created from script, always returns true. For additional information, see TextureImporter.isReadable.
         */
        public get isReadable(): boolean;
        /**
         * Returns true if the VTOnly checkbox was checked when the texture was imported; otherwise returns false. For additional information, see TextureImporter.vtOnly.
         */
        public get vtOnly(): boolean;
        /**
         * Determines whether mipmap streaming is enabled for this Texture.
         */
        public get streamingMipmaps(): boolean;
        /**
         * Sets the relative priority for this Texture when reducing memory size to fit within the memory budget.
         */
        public get streamingMipmapsPriority(): number;
        /**
         * The mipmap level to load.
         */
        public get requestedMipmapLevel(): number;
        public set requestedMipmapLevel(value: number);
        /**
         * Restricts the mipmap streaming system to a minimum mip level for this Texture.
         */
        public get minimumMipmapLevel(): number;
        public set minimumMipmapLevel(value: number);
        /**
         * The mipmap level calculated by the streaming system, which takes into account the streaming Cameras and the location of the objects containing this Texture. This is unaffected by requestedMipmapLevel or minimumMipmapLevel.
         */
        public get calculatedMipmapLevel(): number;
        /**
         * The mipmap level that the streaming system would load before memory budgets are applied.
         */
        public get desiredMipmapLevel(): number;
        /**
         * The mipmap level that the mipmap streaming system is in the process of loading.
         */
        public get loadingMipmapLevel(): number;
        /**
         * The mipmap level that is currently loaded by the streaming system.
         */
        public get loadedMipmapLevel(): number;
        /**
         * Indicates whether this texture was imported with TextureImporter.alphaIsTransparency enabled. This setting is available only in the Editor scripts. Note that changing this setting will have no effect; it must be enabled in TextureImporter instead.
         */
        public get alphaIsTransparency(): boolean;
        public set alphaIsTransparency(value: boolean);
        
        public constructor($width: number, $height: number, $format: UnityEngine_Experimental_Rendering.DefaultFormat, $flags: UnityEngine_Experimental_Rendering.TextureCreationFlags);
        
        public constructor($width: number, $height: number, $format: UnityEngine_Experimental_Rendering.GraphicsFormat, $flags: UnityEngine_Experimental_Rendering.TextureCreationFlags);
        
        public constructor($width: number, $height: number, $format: UnityEngine_Experimental_Rendering.GraphicsFormat, $mipCount: number, $flags: UnityEngine_Experimental_Rendering.TextureCreationFlags);
        
        public constructor($width: number, $height: number, $textureFormat: TextureFormat, $mipCount: number, $linear: boolean);
        /**
         * Create a new empty texture.
         */
        public constructor($width: number, $height: number, $textureFormat: TextureFormat, $mipChain: boolean, $linear: boolean);
        /**
         * Create a new empty texture.
         */
        public constructor($width: number, $height: number, $textureFormat: TextureFormat, $mipChain: boolean);
        /**
         * Create a new empty texture.
         */
        public constructor($width: number, $height: number);
        /**
         * Compress texture into DXT format.
         */
        public Compress($highQuality: boolean):void;
        /**
         * Resets the requestedMipmapLevel field.
         */
        public ClearRequestedMipmapLevel():void;
        /**
         * Checks to see whether the mipmap level set by requestedMipmapLevel has finished loading.
         * @returns True if the mipmap level requested by requestedMipmapLevel has finished loading.
         */
        public IsRequestedMipmapLevelLoaded():boolean;
        /**
         * Resets the minimumMipmapLevel field.
         */
        public ClearMinimumMipmapLevel():void;
        /**
         * Updates Unity texture to use different native texture object.
         * @param nativeTex Native 2D texture object.
         */
        public UpdateExternalTexture($nativeTex: System.IntPtr):void;
        /**
         * Get raw data from a texture.
         * @returns Raw texture data as a byte array.
         */
        public GetRawTextureData():number[];
        /**
         * Get a block of pixel colors.
         * @param x The x position of the pixel array to fetch.
         * @param y The y position of the pixel array to fetch.
         * @param blockWidth The width length of the pixel array to fetch.
         * @param blockHeight The height length of the pixel array to fetch.
         * @param miplevel The mipmap level to fetch the pixels. Defaults to zero, and is
                optional.
         * @returns The array of pixels in the texture that have been selected.
         */
        public GetPixels($x: number, $y: number, $blockWidth: number, $blockHeight: number, $miplevel: number):Color[];
        
        public GetPixels($x: number, $y: number, $blockWidth: number, $blockHeight: number):Color[];
        /**
         * Get a block of pixel colors in Color32 format.
         */
        public GetPixels32($miplevel: number):Color32[];
        
        public GetPixels32():Color32[];
        /**
         * Packs multiple Textures into a texture atlas.
         * @param textures Array of textures to pack into the atlas.
         * @param padding Padding in pixels between the packed textures.
         * @param maximumAtlasSize Maximum size of the resulting texture.
         * @param makeNoLongerReadable Should the texture be marked as no longer readable?
         * @returns An array of rectangles containing the UV coordinates in the atlas for each input texture, or null if packing fails.
         */
        public PackTextures($textures: Texture2D[], $padding: number, $maximumAtlasSize: number, $makeNoLongerReadable: boolean):Rect[];
        
        public PackTextures($textures: Texture2D[], $padding: number, $maximumAtlasSize: number):Rect[];
        
        public PackTextures($textures: Texture2D[], $padding: number):Rect[];
        /**
         * Creates a Unity Texture out of an externally created native texture object.
         * @param nativeTex Native 2D texture object.
         * @param width Width of texture in pixels.
         * @param height Height of texture in pixels.
         * @param format Format of underlying texture object.
         * @param mipmap Does the texture have mipmaps?
         * @param linear Is texture using linear color space?
         */
        public static CreateExternalTexture($width: number, $height: number, $format: TextureFormat, $mipChain: boolean, $linear: boolean, $nativeTex: System.IntPtr):Texture2D;
        /**
         * Sets pixel color at coordinates (x,y).
         */
        public SetPixel($x: number, $y: number, $color: Color):void;
        
        public SetPixel($x: number, $y: number, $color: Color, $mipLevel: number):void;
        /**
         * Set a block of pixel colors.
         */
        public SetPixels($x: number, $y: number, $blockWidth: number, $blockHeight: number, $colors: Color[], $miplevel: number):void;
        
        public SetPixels($x: number, $y: number, $blockWidth: number, $blockHeight: number, $colors: Color[]):void;
        /**
         * Set a block of pixel colors.
         * @param colors The array of pixel colours to assign (a 2D image flattened to a 1D array).
         * @param miplevel The mip level of the texture to write to.
         */
        public SetPixels($colors: Color[], $miplevel: number):void;
        
        public SetPixels($colors: Color[]):void;
        /**
         * Returns pixel color at coordinates (x, y).
         */
        public GetPixel($x: number, $y: number):Color;
        
        public GetPixel($x: number, $y: number, $mipLevel: number):Color;
        /**
         * Returns filtered pixel color at normalized coordinates (u, v).
         */
        public GetPixelBilinear($u: number, $v: number):Color;
        
        public GetPixelBilinear($u: number, $v: number, $mipLevel: number):Color;
        /**
         * Fills texture pixels with raw preformatted data.
         * @param data Raw data array to initialize texture pixels with.
         * @param size Size of data in bytes.
         */
        public LoadRawTextureData($data: System.IntPtr, $size: number):void;
        /**
         * Fills texture pixels with raw preformatted data.
         * @param data Raw data array to initialize texture pixels with.
         * @param size Size of data in bytes.
         */
        public LoadRawTextureData($data: number[]):void;
        
        public LoadRawTextureData<T>($data: Unity_Collections.NativeArray$1<T>):void;
        /**
         * Set pixel values from raw preformatted data.
         * @param data Data array to initialize texture pixels with.
         * @param mipLevel Mip level to fill.
         * @param sourceDataStartIndex Index in the source array to start copying from (default 0).
         */
        public SetPixelData<T>($data: T[], $mipLevel: number, $sourceDataStartIndex?: number):void;
        
        public SetPixelData<T>($data: Unity_Collections.NativeArray$1<T>, $mipLevel: number, $sourceDataStartIndex?: number):void;
        /**
         * Gets raw data from a Texture for reading or writing.
         * @param mipLevel The mip level to reference.
         */
        public GetPixelData<T>($mipLevel: number):Unity_Collections.NativeArray$1<T>;
        /**
         * Get raw data from a texture.
         * @returns Raw texture data as a byte array.
         */
        public GetRawTextureData<T>():Unity_Collections.NativeArray$1<T>;
        /**
         * Actually apply all previous SetPixel and SetPixels changes.
         * @param updateMipmaps When set to true, mipmap levels are recalculated.
         * @param makeNoLongerReadable When set to true, system memory copy of a texture is released.
         */
        public Apply($updateMipmaps: boolean, $makeNoLongerReadable: boolean):void;
        
        public Apply($updateMipmaps: boolean):void;
        
        public Apply():void;
        /**
         * Resizes the texture.
         */
        public Resize($width: number, $height: number):boolean;
        /**
         * Resizes the texture.
         */
        public Resize($width: number, $height: number, $format: TextureFormat, $hasMipMap: boolean):boolean;
        
        public Resize($width: number, $height: number, $format: UnityEngine_Experimental_Rendering.GraphicsFormat, $hasMipMap: boolean):boolean;
        /**
         * Read pixels from screen into the saved texture data.
         * @param source Rectangular region of the view to read from. Pixels are read from current render target.
         * @param destX Horizontal pixel position in the texture to place the pixels that are read.
         * @param destY Vertical pixel position in the texture to place the pixels that are read.
         * @param recalculateMipMaps Should the texture's mipmaps be recalculated after reading?
         */
        public ReadPixels($source: Rect, $destX: number, $destY: number, $recalculateMipMaps: boolean):void;
        
        public ReadPixels($source: Rect, $destX: number, $destY: number):void;
        
        public static GenerateAtlas($sizes: Vector2[], $padding: number, $atlasSize: number, $results: System_Collections_Generic.List$1<Rect>):boolean;
        /**
         * Set a block of pixel colors.
         */
        public SetPixels32($colors: Color32[], $miplevel: number):void;
        
        public SetPixels32($colors: Color32[]):void;
        /**
         * Set a block of pixel colors.
         */
        public SetPixels32($x: number, $y: number, $blockWidth: number, $blockHeight: number, $colors: Color32[], $miplevel: number):void;
        
        public SetPixels32($x: number, $y: number, $blockWidth: number, $blockHeight: number, $colors: Color32[]):void;
        /**
         * Get the pixel colors from the texture.
         * @param miplevel The mipmap level to fetch the pixels from. Defaults to zero.
         * @returns The array of all pixels in the mipmap level of the texture.
         */
        public GetPixels($miplevel: number):Color[];
        
        public GetPixels():Color[];
        
        public constructor();
        
                    
    }
    /**
     * Sprite packing modes for the Sprite Packer.
     */
    enum SpritePackingMode { Tight = 0, Rectangle = 1 }
    /**
     * Sprite rotation modes for the Sprite Packer.
     */
    enum SpritePackingRotation { None = 0, FlipHorizontal = 1, FlipVertical = 2, Rotate180 = 3, Any = 15 }
    /**
     * Defines the type of mesh generated for a sprite.
     */
    enum SpriteMeshType { FullRect = 0, Tight = 1 }
    /**
     * Suspends the coroutine execution for the given amount of seconds using scaled time.
     */
    class WaitForSeconds extends YieldInstruction {
        /**
         * Suspends the coroutine execution for the given amount of seconds using scaled time.
         * @param seconds Delay execution by the amount of time in seconds.
         */
        public constructor($seconds: number);
        
        public constructor();
        
                    
    }
    /**
     * Class containing methods to ease debugging while developing a game.
     */
    class Debug extends System.Object {
        /**
         * Get default debug logger.
         */
        public static get unityLogger(): ILogger;
        /**
         * Reports whether the development console is visible. The development console cannot be made to appear using:
         */
        public static get developerConsoleVisible(): boolean;
        public static set developerConsoleVisible(value: boolean);
        /**
         * In the Build Settings dialog there is a check box called "Development Build".
         */
        public static get isDebugBuild(): boolean;
        
        public constructor();
        /**
         * Draws a line between specified start and end points.
         * @param start Point in world space where the line should start.
         * @param end Point in world space where the line should end.
         * @param color Color of the line.
         * @param duration How long the line should be visible for.
         * @param depthTest Should the line be obscured by objects closer to the camera?
         */
        public static DrawLine($start: Vector3, $end: Vector3, $color: Color, $duration: number):void;
        /**
         * Draws a line between specified start and end points.
         * @param start Point in world space where the line should start.
         * @param end Point in world space where the line should end.
         * @param color Color of the line.
         * @param duration How long the line should be visible for.
         * @param depthTest Should the line be obscured by objects closer to the camera?
         */
        public static DrawLine($start: Vector3, $end: Vector3, $color: Color):void;
        /**
         * Draws a line between specified start and end points.
         * @param start Point in world space where the line should start.
         * @param end Point in world space where the line should end.
         * @param color Color of the line.
         * @param duration How long the line should be visible for.
         * @param depthTest Should the line be obscured by objects closer to the camera?
         */
        public static DrawLine($start: Vector3, $end: Vector3):void;
        /**
         * Draws a line between specified start and end points.
         * @param start Point in world space where the line should start.
         * @param end Point in world space where the line should end.
         * @param color Color of the line.
         * @param duration How long the line should be visible for.
         * @param depthTest Should the line be obscured by objects closer to the camera?
         */
        public static DrawLine($start: Vector3, $end: Vector3, $color: Color, $duration: number, $depthTest: boolean):void;
        /**
         * Draws a line from start to start + dir in world coordinates.
         * @param start Point in world space where the ray should start.
         * @param dir Direction and length of the ray.
         * @param color Color of the drawn line.
         * @param duration How long the line will be visible for (in seconds).
         * @param depthTest Should the line be obscured by other objects closer to the camera?
         */
        public static DrawRay($start: Vector3, $dir: Vector3, $color: Color, $duration: number):void;
        /**
         * Draws a line from start to start + dir in world coordinates.
         * @param start Point in world space where the ray should start.
         * @param dir Direction and length of the ray.
         * @param color Color of the drawn line.
         * @param duration How long the line will be visible for (in seconds).
         * @param depthTest Should the line be obscured by other objects closer to the camera?
         */
        public static DrawRay($start: Vector3, $dir: Vector3, $color: Color):void;
        /**
         * Draws a line from start to start + dir in world coordinates.
         * @param start Point in world space where the ray should start.
         * @param dir Direction and length of the ray.
         * @param color Color of the drawn line.
         * @param duration How long the line will be visible for (in seconds).
         * @param depthTest Should the line be obscured by other objects closer to the camera?
         */
        public static DrawRay($start: Vector3, $dir: Vector3):void;
        /**
         * Draws a line from start to start + dir in world coordinates.
         * @param start Point in world space where the ray should start.
         * @param dir Direction and length of the ray.
         * @param color Color of the drawn line.
         * @param duration How long the line will be visible for (in seconds).
         * @param depthTest Should the line be obscured by other objects closer to the camera?
         */
        public static DrawRay($start: Vector3, $dir: Vector3, $color: Color, $duration: number, $depthTest: boolean):void;
        /**
         * Pauses the editor.
         */
        public static Break():void;
        
        public static DebugBreak():void;
        /**
         * Logs a message to the Unity Console.
         * @param message String or object to be converted to string representation for display.
         * @param context Object to which the message applies.
         */
        public static Log($message: any):void;
        /**
         * Logs a message to the Unity Console.
         * @param message String or object to be converted to string representation for display.
         * @param context Object to which the message applies.
         */
        public static Log($message: any, $context: Object):void;
        /**
         * Logs a formatted message to the Unity Console.
         * @param format A composite format string.
         * @param args Format arguments.
         * @param context Object to which the message applies.
         * @param logType Type of message e.g. warn or error etc.
         * @param logOptions Option flags to treat the log message special.
         */
        public static LogFormat($format: string, ...args: any[]):void;
        /**
         * Logs a formatted message to the Unity Console.
         * @param format A composite format string.
         * @param args Format arguments.
         * @param context Object to which the message applies.
         * @param logType Type of message e.g. warn or error etc.
         * @param logOptions Option flags to treat the log message special.
         */
        public static LogFormat($context: Object, $format: string, ...args: any[]):void;
        /**
         * Logs a formatted message to the Unity Console.
         * @param format A composite format string.
         * @param args Format arguments.
         * @param context Object to which the message applies.
         * @param logType Type of message e.g. warn or error etc.
         * @param logOptions Option flags to treat the log message special.
         */
        public static LogFormat($logType: LogType, $logOptions: LogOption, $context: Object, $format: string, ...args: any[]):void;
        /**
         * A variant of Debug.Log that logs an error message to the console.
         * @param message String or object to be converted to string representation for display.
         * @param context Object to which the message applies.
         */
        public static LogError($message: any):void;
        /**
         * A variant of Debug.Log that logs an error message to the console.
         * @param message String or object to be converted to string representation for display.
         * @param context Object to which the message applies.
         */
        public static LogError($message: any, $context: Object):void;
        /**
         * Logs a formatted error message to the Unity console.
         * @param format A composite format string.
         * @param args Format arguments.
         * @param context Object to which the message applies.
         */
        public static LogErrorFormat($format: string, ...args: any[]):void;
        /**
         * Logs a formatted error message to the Unity console.
         * @param format A composite format string.
         * @param args Format arguments.
         * @param context Object to which the message applies.
         */
        public static LogErrorFormat($context: Object, $format: string, ...args: any[]):void;
        /**
         * Clears errors from the developer console.
         */
        public static ClearDeveloperConsole():void;
        /**
         * A variant of Debug.Log that logs an error message to the console.
         * @param context Object to which the message applies.
         * @param exception Runtime Exception.
         */
        public static LogException($exception: System.Exception):void;
        /**
         * A variant of Debug.Log that logs an error message to the console.
         * @param context Object to which the message applies.
         * @param exception Runtime Exception.
         */
        public static LogException($exception: System.Exception, $context: Object):void;
        /**
         * A variant of Debug.Log that logs a warning message to the console.
         * @param message String or object to be converted to string representation for display.
         * @param context Object to which the message applies.
         */
        public static LogWarning($message: any):void;
        /**
         * A variant of Debug.Log that logs a warning message to the console.
         * @param message String or object to be converted to string representation for display.
         * @param context Object to which the message applies.
         */
        public static LogWarning($message: any, $context: Object):void;
        /**
         * Logs a formatted warning message to the Unity Console.
         * @param format A composite format string.
         * @param args Format arguments.
         * @param context Object to which the message applies.
         */
        public static LogWarningFormat($format: string, ...args: any[]):void;
        /**
         * Logs a formatted warning message to the Unity Console.
         * @param format A composite format string.
         * @param args Format arguments.
         * @param context Object to which the message applies.
         */
        public static LogWarningFormat($context: Object, $format: string, ...args: any[]):void;
        /**
         * Assert a condition and logs an error message to the Unity console on failure.
         * @param condition Condition you expect to be true.
         * @param context Object to which the message applies.
         * @param message String or object to be converted to string representation for display.
         */
        public static Assert($condition: boolean):void;
        /**
         * Assert a condition and logs an error message to the Unity console on failure.
         * @param condition Condition you expect to be true.
         * @param context Object to which the message applies.
         * @param message String or object to be converted to string representation for display.
         */
        public static Assert($condition: boolean, $context: Object):void;
        /**
         * Assert a condition and logs an error message to the Unity console on failure.
         * @param condition Condition you expect to be true.
         * @param context Object to which the message applies.
         * @param message String or object to be converted to string representation for display.
         */
        public static Assert($condition: boolean, $message: any):void;
        
        public static Assert($condition: boolean, $message: string):void;
        /**
         * Assert a condition and logs an error message to the Unity console on failure.
         * @param condition Condition you expect to be true.
         * @param context Object to which the message applies.
         * @param message String or object to be converted to string representation for display.
         */
        public static Assert($condition: boolean, $message: any, $context: Object):void;
        
        public static Assert($condition: boolean, $message: string, $context: Object):void;
        /**
         * Assert a condition and logs a formatted error message to the Unity console on failure.
         * @param condition Condition you expect to be true.
         * @param format A composite format string.
         * @param args Format arguments.
         * @param context Object to which the message applies.
         */
        public static AssertFormat($condition: boolean, $format: string, ...args: any[]):void;
        /**
         * Assert a condition and logs a formatted error message to the Unity console on failure.
         * @param condition Condition you expect to be true.
         * @param format A composite format string.
         * @param args Format arguments.
         * @param context Object to which the message applies.
         */
        public static AssertFormat($condition: boolean, $context: Object, $format: string, ...args: any[]):void;
        /**
         * A variant of Debug.Log that logs an assertion message to the console.
         * @param message String or object to be converted to string representation for display.
         * @param context Object to which the message applies.
         */
        public static LogAssertion($message: any):void;
        /**
         * A variant of Debug.Log that logs an assertion message to the console.
         * @param message String or object to be converted to string representation for display.
         * @param context Object to which the message applies.
         */
        public static LogAssertion($message: any, $context: Object):void;
        /**
         * Logs a formatted assertion message to the Unity console.
         * @param format A composite format string.
         * @param args Format arguments.
         * @param context Object to which the message applies.
         */
        public static LogAssertionFormat($format: string, ...args: any[]):void;
        /**
         * Logs a formatted assertion message to the Unity console.
         * @param format A composite format string.
         * @param args Format arguments.
         * @param context Object to which the message applies.
         */
        public static LogAssertionFormat($context: Object, $format: string, ...args: any[]):void;
        
                    
    }
    /**
     * Interface for custom logger implementation.
     */
    interface ILogger {
        /**
         * Set Logger.ILogHandler.
         */
        logHandler: ILogHandler;
        /**
         * To runtime toggle debug logging [ON/OFF].
         */
        logEnabled: boolean;
        /**
         * To selective enable debug log message.
         */
        filterLogType: LogType;
        /**
         * Check logging is enabled based on the LogType.
         * @returns Retrun true in case logs of LogType will be logged otherwise returns false.
         */
        IsLogTypeAllowed($logType: LogType):boolean;
        /**
         * Logs message to the Unity Console using default logger.
         */
        Log($logType: LogType, $message: any):void;
        /**
         * Logs message to the Unity Console using default logger.
         */
        Log($logType: LogType, $message: any, $context: Object):void;
        /**
         * Logs message to the Unity Console using default logger.
         */
        Log($logType: LogType, $tag: string, $message: any):void;
        /**
         * Logs message to the Unity Console using default logger.
         */
        Log($logType: LogType, $tag: string, $message: any, $context: Object):void;
        /**
         * Logs message to the Unity Console using default logger.
         */
        Log($message: any):void;
        /**
         * Logs message to the Unity Console using default logger.
         */
        Log($tag: string, $message: any):void;
        /**
         * Logs message to the Unity Console using default logger.
         */
        Log($tag: string, $message: any, $context: Object):void;
        /**
         * A variant of Logger.Log that logs an warning message.
         */
        LogWarning($tag: string, $message: any):void;
        /**
         * A variant of Logger.Log that logs an warning message.
         */
        LogWarning($tag: string, $message: any, $context: Object):void;
        /**
         * A variant of ILogger.Log that logs an error message.
         */
        LogError($tag: string, $message: any):void;
        /**
         * A variant of ILogger.Log that logs an error message.
         */
        LogError($tag: string, $message: any, $context: Object):void;
        /**
         * Logs a formatted message.
         */
        LogFormat($logType: LogType, $format: string, ...args: any[]):void;
        /**
         * A variant of ILogger.Log that logs an exception message.
         */
        LogException($exception: System.Exception):void;
        
                    
    }
    /**
     * The type of the log message in Debug.unityLogger.Log or delegate registered with Application.RegisterLogCallback.
     */
    enum LogType { Error = 0, Assert = 1, Warning = 2, Log = 3, Exception = 4 }
    /**
     * Option flags for specifying special treatment of a log message.
     */
    enum LogOption { None = 0, NoStacktrace = 1 }
    /**
     * Specifies Layers to use in a Physics.Raycast.
     */
    class LayerMask extends System.ValueType {
        /**
         * Converts a layer mask value to an integer value.
         */
        public get value(): number;
        public set value(value: number);
        
        public static op_Implicit($mask: LayerMask):number;
        
        public static op_Implicit($intVal: number):LayerMask;
        /**
         * Given a layer number, returns the name of the layer as defined in either a Builtin or a User Layer in the.
         */
        public static LayerToName($layer: number):string;
        /**
         * Given a layer name, returns the layer index as defined by either a Builtin or a User Layer in the.
         */
        public static NameToLayer($layerName: string):number;
        /**
         * Given a set of layer names as defined by either a Builtin or a User Layer in the, returns the equivalent layer mask for all of them.
         * @param layerNames List of layer names to convert to a layer mask.
         * @returns The layer mask created from the layerNames.
         */
        public static GetMask(...layerNames: string[]):number;
        
        public get_Clone(): LayerMask;            
    }
    /**
     * The Resources class allows you to find and access Objects including assets.
     */
    class Resources extends System.Object {
        
        public constructor();
        /**
         * Returns a list of all objects of Type type.
         */
        public static FindObjectsOfTypeAll($type: System.Type):Object[];
        /**
         * Returns a list of all objects of Type T.
         */
        public static FindObjectsOfTypeAll<T extends Object>():T[];
        /**
         * Loads an asset stored at path in a Resources folder using an optional systemTypeInstance filter.
         * @param path Path to the target resource to load.
         * @param systemTypeInstance Type filter for objects returned.
         * @returns The requested asset returned as an Object.
         */
        public static Load($path: string):Object;
        /**
         * Loads an asset stored at path in a Resources folder using an optional systemTypeInstance filter.
         * @param path Path to the target resource to load.
         * @param systemTypeInstance Type filter for objects returned.
         * @returns The requested asset returned as an Object.
         */
        public static Load<T extends Object>($path: string):T;
        /**
         * Loads an asset stored at path in a Resources folder using an optional systemTypeInstance filter.
         * @param path Path to the target resource to load.
         * @param systemTypeInstance Type filter for objects returned.
         * @returns The requested asset returned as an Object.
         */
        public static Load($path: string, $systemTypeInstance: System.Type):Object;
        /**
         * Asynchronously loads an asset stored at path in a Resources folder.
         * @param path Pathname of the target folder. When using the empty string (i.e., ""), the function will load the entire contents of the Resources folder.
         */
        public static LoadAsync($path: string):ResourceRequest;
        /**
         * Asynchronously loads an asset stored at path in a Resources folder.
         * @param path Pathname of the target folder. When using the empty string (i.e., ""), the function will load the entire contents of the Resources folder.
         */
        public static LoadAsync<T extends Object>($path: string):ResourceRequest;
        /**
         * Asynchronously loads an asset stored at path in a Resources folder.
         * @param path Pathname of the target folder. When using the empty string (i.e., ""), the function will load the entire contents of the Resources folder.
         * @param systemTypeInstance Type filter for objects returned.
         */
        public static LoadAsync($path: string, $type: System.Type):ResourceRequest;
        /**
         * Loads all assets in a folder or file at path in a Resources folder.
         * @param path Pathname of the target folder. When using the empty string (i.e., ""), the function will load the entire contents of the Resources folder.
         * @param systemTypeInstance Type filter for objects returned.
         */
        public static LoadAll($path: string, $systemTypeInstance: System.Type):Object[];
        /**
         * Loads all assets in a folder or file at path in a Resources folder.
         * @param path Pathname of the target folder. When using the empty string (i.e., ""), the function will load the entire contents of the Resources folder.
         */
        public static LoadAll($path: string):Object[];
        /**
         * Loads all assets in a folder or file at path in a Resources folder.
         * @param path Pathname of the target folder. When using the empty string (i.e., ""), the function will load the entire contents of the Resources folder.
         */
        public static LoadAll<T extends Object>($path: string):T[];
        
        public static GetBuiltinResource($type: System.Type, $path: string):Object;
        
        public static GetBuiltinResource<T extends Object>($path: string):T;
        /**
         * Unloads assetToUnload from memory.
         */
        public static UnloadAsset($assetToUnload: Object):void;
        /**
         * Unloads assets that are not used.
         * @returns Object on which you can yield to wait until the operation completes.
         */
        public static UnloadUnusedAssets():AsyncOperation;
        /**
         * Translates an instance ID to an object reference.
         * @param instanceID Instance ID of an Object.
         * @returns Resolved reference or null if the instance ID didn't match anything.
         */
        public static InstanceIDToObject($instanceID: number):Object;
        
        public static InstanceIDToObjectList($instanceIDs: Unity_Collections.NativeArray$1<number>, $objects: System_Collections_Generic.List$1<Object>):void;
        
                    
    }
    /**
     * Asynchronous load request from the Resources bundle.
     */
    class ResourceRequest extends AsyncOperation {
        /**
         * Asset object being loaded (Read Only).
         */
        public get asset(): Object;
        
        public constructor();
        
                    
    }
    /**
     * Asynchronous operation coroutine.
     */
    class AsyncOperation extends YieldInstruction {
        /**
         * Has the operation finished? (Read Only)
         */
        public get isDone(): boolean;
        /**
         * What's the operation's progress. (Read Only)
         */
        public get progress(): number;
        /**
         * Priority lets you tweak in which order async operation calls will be performed.
         */
        public get priority(): number;
        public set priority(value: number);
        /**
         * Allow Scenes to be activated as soon as it is ready.
         */
        public get allowSceneActivation(): boolean;
        public set allowSceneActivation(value: boolean);
        
        public constructor();
        
        public add_completed($value: System.Action$1<AsyncOperation>):void;
        
        public remove_completed($value: System.Action$1<AsyncOperation>):void;
        
        public completed;
        
                    
    }
    /**
     * Suspends the coroutine execution until the supplied delegate evaluates to true.
     */
    class WaitUntil extends CustomYieldInstruction {
        
        public get keepWaiting(): boolean;
        
        public constructor($predicate: System.Func$1<boolean>);
        
                    
    }
    /**
     * Base class for custom yield instructions to suspend coroutines.
     */
    class CustomYieldInstruction extends System.Object {
        /**
         * Indicates if coroutine should be kept suspended.
         */
        public get keepWaiting(): boolean;
        
        public get Current(): any;
        
        public MoveNext():boolean;
        
        public Reset():void;
        
                    
    }
    /**
     * Suspends the coroutine execution until the supplied delegate evaluates to false.
     */
    class WaitWhile extends CustomYieldInstruction {
        
        public get keepWaiting(): boolean;
        
        public constructor($predicate: System.Func$1<boolean>);
        
                    
    }
    /**
     * Raw interface to Unity's drawing functions.
     */
    class Graphics extends System.Object {
        /**
         * Returns the currently active color gamut.
         */
        public static get activeColorGamut(): ColorGamut;
        /**
         * The GraphicsTier classification for the current device.
         * Changing this value affects any subsequently loaded shaders. Initially Unity auto-detects this value from the hardware in use. Graphics Tiers are only available in the Built-in Render Pipeline.
         */
        public static get activeTier(): UnityEngine_Rendering.GraphicsTier;
        public static set activeTier(value: UnityEngine_Rendering.GraphicsTier);
        /**
         * True when rendering over native UI is enabled in Player Settings (readonly).
         */
        public static get preserveFramebufferAlpha(): boolean;
        /**
         * The minimum OpenGL ES version. The value is specified in PlayerSettings.
         */
        public static get minOpenGLESVersion(): UnityEngine_Rendering.OpenGLESVersion;
        /**
         * Currently active color buffer (Read Only).
         */
        public static get activeColorBuffer(): RenderBuffer;
        /**
         * Currently active depth/stencil buffer (Read Only).
         */
        public static get activeDepthBuffer(): RenderBuffer;
        
        public constructor();
        /**
         * Clear random write targets for level pixel shaders.
         */
        public static ClearRandomWriteTargets():void;
        /**
         * Execute a command buffer.
         * @param buffer The buffer to execute.
         */
        public static ExecuteCommandBuffer($buffer: UnityEngine_Rendering.CommandBuffer):void;
        /**
         * Executes a command buffer on an async compute queue with the queue selected based on the ComputeQueueType parameter passed.
         * @param buffer The CommandBuffer to be executed.
         * @param queueType Describes the desired async compute queue the supplied CommandBuffer should be executed on.
         */
        public static ExecuteCommandBufferAsync($buffer: UnityEngine_Rendering.CommandBuffer, $queueType: UnityEngine_Rendering.ComputeQueueType):void;
        /**
         * Sets current render target.
         * @param rt RenderTexture to set as active render target.
         * @param mipLevel Mipmap level to render into (use 0 if not mipmapped).
         * @param face Cubemap face to render into (use Unknown if not a cubemap).
         * @param depthSlice Depth slice to render into (use 0 if not a 3D or 2DArray render target).
         * @param colorBuffer Color buffer to render into.
         * @param depthBuffer Depth buffer to render into.
         * @param colorBuffers Color buffers to render into (for multiple render target effects).
         * @param setup Full render target setup information.
         */
        public static SetRenderTarget($rt: RenderTexture, $mipLevel: number, $face: CubemapFace, $depthSlice: number):void;
        /**
         * Sets current render target.
         * @param rt RenderTexture to set as active render target.
         * @param mipLevel Mipmap level to render into (use 0 if not mipmapped).
         * @param face Cubemap face to render into (use Unknown if not a cubemap).
         * @param depthSlice Depth slice to render into (use 0 if not a 3D or 2DArray render target).
         * @param colorBuffer Color buffer to render into.
         * @param depthBuffer Depth buffer to render into.
         * @param colorBuffers Color buffers to render into (for multiple render target effects).
         * @param setup Full render target setup information.
         */
        public static SetRenderTarget($colorBuffer: RenderBuffer, $depthBuffer: RenderBuffer, $mipLevel: number, $face: CubemapFace, $depthSlice: number):void;
        /**
         * Sets current render target.
         * @param rt RenderTexture to set as active render target.
         * @param mipLevel Mipmap level to render into (use 0 if not mipmapped).
         * @param face Cubemap face to render into (use Unknown if not a cubemap).
         * @param depthSlice Depth slice to render into (use 0 if not a 3D or 2DArray render target).
         * @param colorBuffer Color buffer to render into.
         * @param depthBuffer Depth buffer to render into.
         * @param colorBuffers Color buffers to render into (for multiple render target effects).
         * @param setup Full render target setup information.
         */
        public static SetRenderTarget($colorBuffers: RenderBuffer[], $depthBuffer: RenderBuffer):void;
        /**
         * Sets current render target.
         * @param rt RenderTexture to set as active render target.
         * @param mipLevel Mipmap level to render into (use 0 if not mipmapped).
         * @param face Cubemap face to render into (use Unknown if not a cubemap).
         * @param depthSlice Depth slice to render into (use 0 if not a 3D or 2DArray render target).
         * @param colorBuffer Color buffer to render into.
         * @param depthBuffer Depth buffer to render into.
         * @param colorBuffers Color buffers to render into (for multiple render target effects).
         * @param setup Full render target setup information.
         */
        public static SetRenderTarget($setup: RenderTargetSetup):void;
        /**
         * Set random write target for level pixel shaders.
         * @param index Index of the random write target in the shader.
         * @param uav Buffer or texture to set as the write target.
         * @param preserveCounterValue Whether to leave the append/consume counter value unchanged.
         */
        public static SetRandomWriteTarget($index: number, $uav: RenderTexture):void;
        /**
         * Set random write target for level pixel shaders.
         * @param index Index of the random write target in the shader.
         * @param uav Buffer or texture to set as the write target.
         * @param preserveCounterValue Whether to leave the append/consume counter value unchanged.
         */
        public static SetRandomWriteTarget($index: number, $uav: ComputeBuffer, $preserveCounterValue: boolean):void;
        /**
         * Set random write target for level pixel shaders.
         * @param index Index of the random write target in the shader.
         * @param uav Buffer or texture to set as the write target.
         * @param preserveCounterValue Whether to leave the append/consume counter value unchanged.
         */
        public static SetRandomWriteTarget($index: number, $uav: GraphicsBuffer, $preserveCounterValue: boolean):void;
        /**
         * Copy texture contents.
         * @param src Source texture.
         * @param dst Destination texture.
         * @param srcElement Source texture element (cubemap face, texture array layer or 3D texture depth slice).
         * @param srcMip Source texture mipmap level.
         * @param dstElement Destination texture element (cubemap face, texture array layer or 3D texture depth slice).
         * @param dstMip Destination texture mipmap level.
         * @param srcX X coordinate of source texture region to copy (left side is zero).
         * @param srcY Y coordinate of source texture region to copy (bottom is zero).
         * @param srcWidth Width of source texture region to copy.
         * @param srcHeight Height of source texture region to copy.
         * @param dstX X coordinate of where to copy region in destination texture (left side is zero).
         * @param dstY Y coordinate of where to copy region in destination texture (bottom is zero).
         */
        public static CopyTexture($src: Texture, $dst: Texture):void;
        
        public static CopyTexture($src: Texture, $srcElement: number, $dst: Texture, $dstElement: number):void;
        /**
         * Copy texture contents.
         * @param src Source texture.
         * @param dst Destination texture.
         * @param srcElement Source texture element (cubemap face, texture array layer or 3D texture depth slice).
         * @param srcMip Source texture mipmap level.
         * @param dstElement Destination texture element (cubemap face, texture array layer or 3D texture depth slice).
         * @param dstMip Destination texture mipmap level.
         * @param srcX X coordinate of source texture region to copy (left side is zero).
         * @param srcY Y coordinate of source texture region to copy (bottom is zero).
         * @param srcWidth Width of source texture region to copy.
         * @param srcHeight Height of source texture region to copy.
         * @param dstX X coordinate of where to copy region in destination texture (left side is zero).
         * @param dstY Y coordinate of where to copy region in destination texture (bottom is zero).
         */
        public static CopyTexture($src: Texture, $srcElement: number, $srcMip: number, $dst: Texture, $dstElement: number, $dstMip: number):void;
        /**
         * Copy texture contents.
         * @param src Source texture.
         * @param dst Destination texture.
         * @param srcElement Source texture element (cubemap face, texture array layer or 3D texture depth slice).
         * @param srcMip Source texture mipmap level.
         * @param dstElement Destination texture element (cubemap face, texture array layer or 3D texture depth slice).
         * @param dstMip Destination texture mipmap level.
         * @param srcX X coordinate of source texture region to copy (left side is zero).
         * @param srcY Y coordinate of source texture region to copy (bottom is zero).
         * @param srcWidth Width of source texture region to copy.
         * @param srcHeight Height of source texture region to copy.
         * @param dstX X coordinate of where to copy region in destination texture (left side is zero).
         * @param dstY Y coordinate of where to copy region in destination texture (bottom is zero).
         */
        public static CopyTexture($src: Texture, $srcElement: number, $srcMip: number, $srcX: number, $srcY: number, $srcWidth: number, $srcHeight: number, $dst: Texture, $dstElement: number, $dstMip: number, $dstX: number, $dstY: number):void;
        /**
         * This function provides an efficient way to convert between textures of different formats and dimensions.
         * The destination texture format should be uncompressed and correspond to a supported RenderTextureFormat.
         * @param src Source texture.
         * @param dst Destination texture.
         * @param srcElement Source element (e.g. cubemap face).  Set this to 0 for 2D source textures.
         * @param dstElement Destination element (e.g. cubemap face or texture array element).
         * @returns True if the call succeeded.
         */
        public static ConvertTexture($src: Texture, $dst: Texture):boolean;
        /**
         * This function provides an efficient way to convert between textures of different formats and dimensions.
         * The destination texture format should be uncompressed and correspond to a supported RenderTextureFormat.
         * @param src Source texture.
         * @param dst Destination texture.
         * @param srcElement Source element (e.g. cubemap face).  Set this to 0 for 2D source textures.
         * @param dstElement Destination element (e.g. cubemap face or texture array element).
         * @returns True if the call succeeded.
         */
        public static ConvertTexture($src: Texture, $srcElement: number, $dst: Texture, $dstElement: number):boolean;
        /**
         * Shortcut for calling Graphics.CreateGraphicsFence with GraphicsFenceType.AsyncQueueSynchronization as the first parameter.
         * @param stage The synchronization stage. See Graphics.CreateGraphicsFence.
         * @returns Returns a new GraphicsFence.
         */
        public static CreateAsyncGraphicsFence($stage: UnityEngine_Rendering.SynchronisationStage):UnityEngine_Rendering.GraphicsFence;
        /**
         * Shortcut for calling Graphics.CreateGraphicsFence with GraphicsFenceType.AsyncQueueSynchronization as the first parameter.
         * @param stage The synchronization stage. See Graphics.CreateGraphicsFence.
         * @returns Returns a new GraphicsFence.
         */
        public static CreateAsyncGraphicsFence():UnityEngine_Rendering.GraphicsFence;
        
        public static CreateGraphicsFence($fenceType: UnityEngine_Rendering.GraphicsFenceType, $stage: UnityEngine_Rendering.SynchronisationStageFlags):UnityEngine_Rendering.GraphicsFence;
        /**
         * Instructs the GPU's processing of the graphics queue to wait until the given GraphicsFence is passed.
         * @param fence The GraphicsFence that the GPU will be instructed to wait upon before proceeding with its processing of the graphics queue.
         * @param stage On some platforms there is a significant gap between the vertex processing completing and the pixel processing begining for a given draw call. This parameter allows for requested wait to be before the next items vertex or pixel processing begins. If a compute shader dispatch is the next item to be submitted then this parameter is ignored.
         */
        public static WaitOnAsyncGraphicsFence($fence: UnityEngine_Rendering.GraphicsFence):void;
        /**
         * Instructs the GPU's processing of the graphics queue to wait until the given GraphicsFence is passed.
         * @param fence The GraphicsFence that the GPU will be instructed to wait upon before proceeding with its processing of the graphics queue.
         * @param stage On some platforms there is a significant gap between the vertex processing completing and the pixel processing begining for a given draw call. This parameter allows for requested wait to be before the next items vertex or pixel processing begins. If a compute shader dispatch is the next item to be submitted then this parameter is ignored.
         */
        public static WaitOnAsyncGraphicsFence($fence: UnityEngine_Rendering.GraphicsFence, $stage: UnityEngine_Rendering.SynchronisationStage):void;
        /**
         * Draw a texture in screen coordinates.
         * @param screenRect Rectangle on the screen to use for the texture. In pixel coordinates with (0,0) in the upper-left corner.
         * @param texture Texture to draw.
         * @param sourceRect Region of the texture to use. In normalized coordinates with (0,0) in the bottom-left corner.
         * @param leftBorder Number of pixels from the left that are not affected by scale.
         * @param rightBorder Number of pixels from the right that are not affected by scale.
         * @param topBorder Number of pixels from the top that are not affected by scale.
         * @param bottomBorder Number of pixels from the bottom that are not affected by scale.
         * @param color Color that modulates the output. The neutral value is (0.5, 0.5, 0.5, 0.5). Set as vertex color for the shader.
         * @param mat Custom Material that can be used to draw the texture. If null is passed, a default material with the Internal-GUITexture.shader is used.
         * @param pass If -1 (default), draws all passes in the material. Otherwise, draws given pass only.
         */
        public static DrawTexture($screenRect: Rect, $texture: Texture, $sourceRect: Rect, $leftBorder: number, $rightBorder: number, $topBorder: number, $bottomBorder: number, $color: Color, $mat: Material, $pass: number):void;
        /**
         * Draw a texture in screen coordinates.
         * @param screenRect Rectangle on the screen to use for the texture. In pixel coordinates with (0,0) in the upper-left corner.
         * @param texture Texture to draw.
         * @param sourceRect Region of the texture to use. In normalized coordinates with (0,0) in the bottom-left corner.
         * @param leftBorder Number of pixels from the left that are not affected by scale.
         * @param rightBorder Number of pixels from the right that are not affected by scale.
         * @param topBorder Number of pixels from the top that are not affected by scale.
         * @param bottomBorder Number of pixels from the bottom that are not affected by scale.
         * @param color Color that modulates the output. The neutral value is (0.5, 0.5, 0.5, 0.5). Set as vertex color for the shader.
         * @param mat Custom Material that can be used to draw the texture. If null is passed, a default material with the Internal-GUITexture.shader is used.
         * @param pass If -1 (default), draws all passes in the material. Otherwise, draws given pass only.
         */
        public static DrawTexture($screenRect: Rect, $texture: Texture, $sourceRect: Rect, $leftBorder: number, $rightBorder: number, $topBorder: number, $bottomBorder: number, $mat: Material, $pass: number):void;
        /**
         * Draw a texture in screen coordinates.
         * @param screenRect Rectangle on the screen to use for the texture. In pixel coordinates with (0,0) in the upper-left corner.
         * @param texture Texture to draw.
         * @param sourceRect Region of the texture to use. In normalized coordinates with (0,0) in the bottom-left corner.
         * @param leftBorder Number of pixels from the left that are not affected by scale.
         * @param rightBorder Number of pixels from the right that are not affected by scale.
         * @param topBorder Number of pixels from the top that are not affected by scale.
         * @param bottomBorder Number of pixels from the bottom that are not affected by scale.
         * @param color Color that modulates the output. The neutral value is (0.5, 0.5, 0.5, 0.5). Set as vertex color for the shader.
         * @param mat Custom Material that can be used to draw the texture. If null is passed, a default material with the Internal-GUITexture.shader is used.
         * @param pass If -1 (default), draws all passes in the material. Otherwise, draws given pass only.
         */
        public static DrawTexture($screenRect: Rect, $texture: Texture, $leftBorder: number, $rightBorder: number, $topBorder: number, $bottomBorder: number, $mat: Material, $pass: number):void;
        /**
         * Draw a texture in screen coordinates.
         * @param screenRect Rectangle on the screen to use for the texture. In pixel coordinates with (0,0) in the upper-left corner.
         * @param texture Texture to draw.
         * @param sourceRect Region of the texture to use. In normalized coordinates with (0,0) in the bottom-left corner.
         * @param leftBorder Number of pixels from the left that are not affected by scale.
         * @param rightBorder Number of pixels from the right that are not affected by scale.
         * @param topBorder Number of pixels from the top that are not affected by scale.
         * @param bottomBorder Number of pixels from the bottom that are not affected by scale.
         * @param color Color that modulates the output. The neutral value is (0.5, 0.5, 0.5, 0.5). Set as vertex color for the shader.
         * @param mat Custom Material that can be used to draw the texture. If null is passed, a default material with the Internal-GUITexture.shader is used.
         * @param pass If -1 (default), draws all passes in the material. Otherwise, draws given pass only.
         */
        public static DrawTexture($screenRect: Rect, $texture: Texture, $mat: Material, $pass: number):void;
        /**
         * Draw a mesh immediately.
         * @param mesh The Mesh to draw.
         * @param position Position of the mesh.
         * @param rotation Rotation of the mesh.
         * @param matrix The transformation matrix of the mesh (combines position, rotation and other transformations).
         * @param materialIndex Subset of the mesh to draw.
         */
        public static DrawMeshNow($mesh: Mesh, $position: Vector3, $rotation: Quaternion, $materialIndex: number):void;
        /**
         * Draw a mesh immediately.
         * @param mesh The Mesh to draw.
         * @param position Position of the mesh.
         * @param rotation Rotation of the mesh.
         * @param matrix The transformation matrix of the mesh (combines position, rotation and other transformations).
         * @param materialIndex Subset of the mesh to draw.
         */
        public static DrawMeshNow($mesh: Mesh, $matrix: Matrix4x4, $materialIndex: number):void;
        /**
         * Draw a mesh immediately.
         * @param mesh The Mesh to draw.
         * @param position Position of the mesh.
         * @param rotation Rotation of the mesh.
         * @param matrix The transformation matrix of the mesh (combines position, rotation and other transformations).
         * @param materialIndex Subset of the mesh to draw.
         */
        public static DrawMeshNow($mesh: Mesh, $position: Vector3, $rotation: Quaternion):void;
        /**
         * Draw a mesh immediately.
         * @param mesh The Mesh to draw.
         * @param position Position of the mesh.
         * @param rotation Rotation of the mesh.
         * @param matrix The transformation matrix of the mesh (combines position, rotation and other transformations).
         * @param materialIndex Subset of the mesh to draw.
         */
        public static DrawMeshNow($mesh: Mesh, $matrix: Matrix4x4):void;
        /**
         * Draw a mesh.
         * @param mesh The Mesh to draw.
         * @param position Position of the mesh.
         * @param rotation Rotation of the mesh.
         * @param matrix Transformation matrix of the mesh (combines position, rotation and other transformations).
         * @param material Material to use.
         * @param layer  to use.
         * @param camera If null (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given Camera only.
         * @param submeshIndex Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.
         * @param properties Additional material properties to apply onto material just before this mesh will be drawn. See MaterialPropertyBlock.
         * @param castShadows Determines whether the mesh can cast shadows.
         * @param receiveShadows Determines whether the mesh can receive shadows.
         * @param useLightProbes Should the mesh use light probes?
         * @param probeAnchor If used, the mesh will use this Transform's position to sample light probes and find the matching reflection probe.
         * @param lightProbeUsage LightProbeUsage for the mesh.
         */
        public static DrawMesh($mesh: Mesh, $position: Vector3, $rotation: Quaternion, $material: Material, $layer: number, $camera: Camera, $submeshIndex: number, $properties: MaterialPropertyBlock, $castShadows: boolean, $receiveShadows: boolean, $useLightProbes: boolean):void;
        /**
         * Draw a mesh.
         * @param mesh The Mesh to draw.
         * @param position Position of the mesh.
         * @param rotation Rotation of the mesh.
         * @param matrix Transformation matrix of the mesh (combines position, rotation and other transformations).
         * @param material Material to use.
         * @param layer  to use.
         * @param camera If null (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given Camera only.
         * @param submeshIndex Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.
         * @param properties Additional material properties to apply onto material just before this mesh will be drawn. See MaterialPropertyBlock.
         * @param castShadows Determines whether the mesh can cast shadows.
         * @param receiveShadows Determines whether the mesh can receive shadows.
         * @param useLightProbes Should the mesh use light probes?
         * @param probeAnchor If used, the mesh will use this Transform's position to sample light probes and find the matching reflection probe.
         * @param lightProbeUsage LightProbeUsage for the mesh.
         */
        public static DrawMesh($mesh: Mesh, $position: Vector3, $rotation: Quaternion, $material: Material, $layer: number, $camera: Camera, $submeshIndex: number, $properties: MaterialPropertyBlock, $castShadows: UnityEngine_Rendering.ShadowCastingMode, $receiveShadows: boolean, $probeAnchor: Transform, $useLightProbes: boolean):void;
        /**
         * Draw a mesh.
         * @param mesh The Mesh to draw.
         * @param position Position of the mesh.
         * @param rotation Rotation of the mesh.
         * @param matrix Transformation matrix of the mesh (combines position, rotation and other transformations).
         * @param material Material to use.
         * @param layer  to use.
         * @param camera If null (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given Camera only.
         * @param submeshIndex Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.
         * @param properties Additional material properties to apply onto material just before this mesh will be drawn. See MaterialPropertyBlock.
         * @param castShadows Determines whether the mesh can cast shadows.
         * @param receiveShadows Determines whether the mesh can receive shadows.
         * @param useLightProbes Should the mesh use light probes?
         * @param probeAnchor If used, the mesh will use this Transform's position to sample light probes and find the matching reflection probe.
         * @param lightProbeUsage LightProbeUsage for the mesh.
         */
        public static DrawMesh($mesh: Mesh, $matrix: Matrix4x4, $material: Material, $layer: number, $camera: Camera, $submeshIndex: number, $properties: MaterialPropertyBlock, $castShadows: boolean, $receiveShadows: boolean, $useLightProbes: boolean):void;
        /**
         * Draw a mesh.
         * @param mesh The Mesh to draw.
         * @param position Position of the mesh.
         * @param rotation Rotation of the mesh.
         * @param matrix Transformation matrix of the mesh (combines position, rotation and other transformations).
         * @param material Material to use.
         * @param layer  to use.
         * @param camera If null (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given Camera only.
         * @param submeshIndex Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.
         * @param properties Additional material properties to apply onto material just before this mesh will be drawn. See MaterialPropertyBlock.
         * @param castShadows Determines whether the mesh can cast shadows.
         * @param receiveShadows Determines whether the mesh can receive shadows.
         * @param useLightProbes Should the mesh use light probes?
         * @param probeAnchor If used, the mesh will use this Transform's position to sample light probes and find the matching reflection probe.
         * @param lightProbeUsage LightProbeUsage for the mesh.
         */
        public static DrawMesh($mesh: Mesh, $matrix: Matrix4x4, $material: Material, $layer: number, $camera: Camera, $submeshIndex: number, $properties: MaterialPropertyBlock, $castShadows: UnityEngine_Rendering.ShadowCastingMode, $receiveShadows: boolean, $probeAnchor: Transform, $lightProbeUsage: UnityEngine_Rendering.LightProbeUsage, $lightProbeProxyVolume: LightProbeProxyVolume):void;
        /**
         * Draws the same mesh multiple times using GPU instancing.
         * @param mesh The Mesh to draw.
         * @param submeshIndex Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.
         * @param material Material to use.
         * @param matrices The array of object transformation matrices.
         * @param count The number of instances to be drawn.
         * @param properties Additional material properties to apply. See MaterialPropertyBlock.
         * @param castShadows Determines whether the Meshes should cast shadows.
         * @param receiveShadows Determines whether the Meshes should receive shadows.
         * @param layer  to use.
         * @param camera If null (default), the mesh will be drawn in all cameras. Otherwise it will be drawn in the given Camera only.
         * @param lightProbeUsage LightProbeUsage for the instances.
         */
        public static DrawMeshInstanced($mesh: Mesh, $submeshIndex: number, $material: Material, $matrices: Matrix4x4[], $count: number, $properties: MaterialPropertyBlock, $castShadows: UnityEngine_Rendering.ShadowCastingMode, $receiveShadows: boolean, $layer: number, $camera: Camera, $lightProbeUsage: UnityEngine_Rendering.LightProbeUsage, $lightProbeProxyVolume: LightProbeProxyVolume):void;
        
        public static DrawMeshInstanced($mesh: Mesh, $submeshIndex: number, $material: Material, $matrices: System_Collections_Generic.List$1<Matrix4x4>, $properties: MaterialPropertyBlock, $castShadows: UnityEngine_Rendering.ShadowCastingMode, $receiveShadows: boolean, $layer: number, $camera: Camera, $lightProbeUsage: UnityEngine_Rendering.LightProbeUsage, $lightProbeProxyVolume: LightProbeProxyVolume):void;
        /**
         * Draws the same mesh multiple times using GPU instancing.
         * This is similar to Graphics.DrawMeshInstancedIndirect, except that when the instance count is known from script, it can be supplied directly using this method, rather than via a ComputeBuffer.
         * @param mesh The Mesh to draw.
         * @param submeshIndex Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.
         * @param material Material to use.
         * @param bounds The bounding volume surrounding the instances you intend to draw.
         * @param count The number of instances to be drawn.
         * @param properties Additional material properties to apply. See MaterialPropertyBlock.
         * @param castShadows Determines whether the Meshes should cast shadows.
         * @param receiveShadows Determines whether the Meshes should receive shadows.
         * @param layer  to use.
         * @param camera If null (default), the mesh will be drawn in all cameras. Otherwise it will be drawn in the given Camera only.
         * @param lightProbeUsage LightProbeUsage for the instances.
         */
        public static DrawMeshInstancedProcedural($mesh: Mesh, $submeshIndex: number, $material: Material, $bounds: Bounds, $count: number, $properties?: MaterialPropertyBlock, $castShadows?: UnityEngine_Rendering.ShadowCastingMode, $receiveShadows?: boolean, $layer?: number, $camera?: Camera, $lightProbeUsage?: UnityEngine_Rendering.LightProbeUsage, $lightProbeProxyVolume?: LightProbeProxyVolume):void;
        /**
         * Draws the same mesh multiple times using GPU instancing.
         * @param mesh The Mesh to draw.
         * @param submeshIndex Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.
         * @param material Material to use.
         * @param bounds The bounding volume surrounding the instances you intend to draw.
         * @param bufferWithArgs The GPU buffer containing the arguments for how many instances of this mesh to draw.
         * @param argsOffset The byte offset into the buffer, where the draw arguments start.
         * @param properties Additional material properties to apply. See MaterialPropertyBlock.
         * @param castShadows Determines whether the mesh can cast shadows.
         * @param receiveShadows Determines whether the mesh can receive shadows.
         * @param layer  to use.
         * @param camera If null (default), the mesh will be drawn in all cameras. Otherwise it will be drawn in the given Camera only.
         * @param lightProbeUsage LightProbeUsage for the instances.
         */
        public static DrawMeshInstancedIndirect($mesh: Mesh, $submeshIndex: number, $material: Material, $bounds: Bounds, $bufferWithArgs: ComputeBuffer, $argsOffset: number, $properties: MaterialPropertyBlock, $castShadows: UnityEngine_Rendering.ShadowCastingMode, $receiveShadows: boolean, $layer: number, $camera: Camera, $lightProbeUsage: UnityEngine_Rendering.LightProbeUsage, $lightProbeProxyVolume: LightProbeProxyVolume):void;
        /**
         * Draws the same mesh multiple times using GPU instancing.
         * @param mesh The Mesh to draw.
         * @param submeshIndex Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.
         * @param material Material to use.
         * @param bounds The bounding volume surrounding the instances you intend to draw.
         * @param bufferWithArgs The GPU buffer containing the arguments for how many instances of this mesh to draw.
         * @param argsOffset The byte offset into the buffer, where the draw arguments start.
         * @param properties Additional material properties to apply. See MaterialPropertyBlock.
         * @param castShadows Determines whether the mesh can cast shadows.
         * @param receiveShadows Determines whether the mesh can receive shadows.
         * @param layer  to use.
         * @param camera If null (default), the mesh will be drawn in all cameras. Otherwise it will be drawn in the given Camera only.
         * @param lightProbeUsage LightProbeUsage for the instances.
         */
        public static DrawMeshInstancedIndirect($mesh: Mesh, $submeshIndex: number, $material: Material, $bounds: Bounds, $bufferWithArgs: GraphicsBuffer, $argsOffset: number, $properties: MaterialPropertyBlock, $castShadows: UnityEngine_Rendering.ShadowCastingMode, $receiveShadows: boolean, $layer: number, $camera: Camera, $lightProbeUsage: UnityEngine_Rendering.LightProbeUsage, $lightProbeProxyVolume: LightProbeProxyVolume):void;
        /**
         * Draws procedural geometry on the GPU.
         * @param topology Topology of the procedural geometry.
         * @param vertexCount Vertex count to render.
         * @param instanceCount Instance count to render.
         */
        public static DrawProceduralNow($topology: MeshTopology, $vertexCount: number, $instanceCount?: number):void;
        /**
         * Draws procedural geometry on the GPU.
         * @param topology Topology of the procedural geometry.
         * @param indexCount Index count to render.
         * @param instanceCount Instance count to render.
         * @param indexBuffer Index buffer used to submit vertices to the GPU.
         */
        public static DrawProceduralNow($topology: MeshTopology, $indexBuffer: GraphicsBuffer, $indexCount: number, $instanceCount?: number):void;
        /**
         * Draws procedural geometry on the GPU.
         * @param topology Topology of the procedural geometry.
         * @param bufferWithArgs Buffer with draw arguments.
         * @param argsOffset Byte offset where in the buffer the draw arguments are.
         */
        public static DrawProceduralIndirectNow($topology: MeshTopology, $bufferWithArgs: ComputeBuffer, $argsOffset?: number):void;
        /**
         * Draws procedural geometry on the GPU.
         * @param topology Topology of the procedural geometry.
         * @param indexBuffer Index buffer used to submit vertices to the GPU.
         * @param bufferWithArgs Buffer with draw arguments.
         * @param argsOffset Byte offset where in the buffer the draw arguments are.
         */
        public static DrawProceduralIndirectNow($topology: MeshTopology, $indexBuffer: GraphicsBuffer, $bufferWithArgs: ComputeBuffer, $argsOffset?: number):void;
        /**
         * Draws procedural geometry on the GPU.
         * @param topology Topology of the procedural geometry.
         * @param bufferWithArgs Buffer with draw arguments.
         * @param argsOffset Byte offset where in the buffer the draw arguments are.
         */
        public static DrawProceduralIndirectNow($topology: MeshTopology, $bufferWithArgs: GraphicsBuffer, $argsOffset?: number):void;
        /**
         * Draws procedural geometry on the GPU.
         * @param topology Topology of the procedural geometry.
         * @param indexBuffer Index buffer used to submit vertices to the GPU.
         * @param bufferWithArgs Buffer with draw arguments.
         * @param argsOffset Byte offset where in the buffer the draw arguments are.
         */
        public static DrawProceduralIndirectNow($topology: MeshTopology, $indexBuffer: GraphicsBuffer, $bufferWithArgs: GraphicsBuffer, $argsOffset?: number):void;
        /**
         * Draws procedural geometry on the GPU.
         * @param material Material to use.
         * @param bounds The bounding volume surrounding the instances you intend to draw.
         * @param topology Topology of the procedural geometry.
         * @param instanceCount Instance count to render.
         * @param vertexCount Vertex count to render.
         * @param camera If null (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given Camera only.
         * @param properties Additional material properties to apply onto material just before this mesh will be drawn. See MaterialPropertyBlock.
         * @param castShadows Determines whether the mesh can cast shadows.
         * @param receiveShadows Determines whether the mesh can receive shadows.
         * @param layer  to use.
         */
        public static DrawProcedural($material: Material, $bounds: Bounds, $topology: MeshTopology, $vertexCount: number, $instanceCount?: number, $camera?: Camera, $properties?: MaterialPropertyBlock, $castShadows?: UnityEngine_Rendering.ShadowCastingMode, $receiveShadows?: boolean, $layer?: number):void;
        /**
         * Draws procedural geometry on the GPU.
         * @param material Material to use.
         * @param bounds The bounding volume surrounding the instances you intend to draw.
         * @param topology Topology of the procedural geometry.
         * @param indexBuffer Index buffer used to submit vertices to the GPU.
         * @param instanceCount Instance count to render.
         * @param indexCount Index count to render.
         * @param camera If null (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given Camera only.
         * @param properties Additional material properties to apply onto material just before this mesh will be drawn. See MaterialPropertyBlock.
         * @param castShadows Determines whether the mesh can cast shadows.
         * @param receiveShadows Determines whether the mesh can receive shadows.
         * @param layer  to use.
         */
        public static DrawProcedural($material: Material, $bounds: Bounds, $topology: MeshTopology, $indexBuffer: GraphicsBuffer, $indexCount: number, $instanceCount?: number, $camera?: Camera, $properties?: MaterialPropertyBlock, $castShadows?: UnityEngine_Rendering.ShadowCastingMode, $receiveShadows?: boolean, $layer?: number):void;
        /**
         * Draws procedural geometry on the GPU.
         * @param material Material to use.
         * @param bounds The bounding volume surrounding the instances you intend to draw.
         * @param topology Topology of the procedural geometry.
         * @param camera If null (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given Camera only.
         * @param bufferWithArgs Buffer with draw arguments.
         * @param argsOffset Byte offset where in the buffer the draw arguments are.
         * @param properties Additional material properties to apply onto material just before this mesh will be drawn. See MaterialPropertyBlock.
         * @param castShadows Determines whether the mesh can cast shadows.
         * @param receiveShadows Determines whether the mesh can receive shadows.
         * @param layer  to use.
         */
        public static DrawProceduralIndirect($material: Material, $bounds: Bounds, $topology: MeshTopology, $bufferWithArgs: ComputeBuffer, $argsOffset?: number, $camera?: Camera, $properties?: MaterialPropertyBlock, $castShadows?: UnityEngine_Rendering.ShadowCastingMode, $receiveShadows?: boolean, $layer?: number):void;
        /**
         * Draws procedural geometry on the GPU.
         * @param material Material to use.
         * @param bounds The bounding volume surrounding the instances you intend to draw.
         * @param topology Topology of the procedural geometry.
         * @param indexBuffer Index buffer used to submit vertices to the GPU.
         * @param camera If null (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given Camera only.
         * @param bufferWithArgs Buffer with draw arguments.
         * @param argsOffset Byte offset where in the buffer the draw arguments are.
         * @param properties Additional material properties to apply onto material just before this mesh will be drawn. See MaterialPropertyBlock.
         * @param castShadows Determines whether the mesh can cast shadows.
         * @param receiveShadows Determines whether the mesh can receive shadows.
         * @param layer  to use.
         */
        public static DrawProceduralIndirect($material: Material, $bounds: Bounds, $topology: MeshTopology, $indexBuffer: GraphicsBuffer, $bufferWithArgs: ComputeBuffer, $argsOffset?: number, $camera?: Camera, $properties?: MaterialPropertyBlock, $castShadows?: UnityEngine_Rendering.ShadowCastingMode, $receiveShadows?: boolean, $layer?: number):void;
        /**
         * Copies source texture into destination render texture with a shader.
         * @param source Source texture.
         * @param dest The destination RenderTexture. Set this to null to blit directly to screen. See description for more information.
         * @param mat Material to use. Material's shader could do some post-processing effect, for example.
         * @param pass If -1 (default), draws all passes in the material. Otherwise, draws given pass only.
         * @param offset Offset applied to the source texture coordinate.
         * @param scale Scale applied to the source texture coordinate.
         * @param sourceDepthSlice The texture array source slice to perform the blit from.
         * @param destDepthSlice The texture array destination slice to perform the blit to.
         */
        public static Blit($source: Texture, $dest: RenderTexture):void;
        /**
         * Copies source texture into destination render texture with a shader.
         * @param source Source texture.
         * @param dest The destination RenderTexture. Set this to null to blit directly to screen. See description for more information.
         * @param mat Material to use. Material's shader could do some post-processing effect, for example.
         * @param pass If -1 (default), draws all passes in the material. Otherwise, draws given pass only.
         * @param offset Offset applied to the source texture coordinate.
         * @param scale Scale applied to the source texture coordinate.
         * @param sourceDepthSlice The texture array source slice to perform the blit from.
         * @param destDepthSlice The texture array destination slice to perform the blit to.
         */
        public static Blit($source: Texture, $dest: RenderTexture, $sourceDepthSlice: number, $destDepthSlice: number):void;
        /**
         * Copies source texture into destination render texture with a shader.
         * @param source Source texture.
         * @param dest The destination RenderTexture. Set this to null to blit directly to screen. See description for more information.
         * @param mat Material to use. Material's shader could do some post-processing effect, for example.
         * @param pass If -1 (default), draws all passes in the material. Otherwise, draws given pass only.
         * @param offset Offset applied to the source texture coordinate.
         * @param scale Scale applied to the source texture coordinate.
         * @param sourceDepthSlice The texture array source slice to perform the blit from.
         * @param destDepthSlice The texture array destination slice to perform the blit to.
         */
        public static Blit($source: Texture, $dest: RenderTexture, $scale: Vector2, $offset: Vector2):void;
        /**
         * Copies source texture into destination render texture with a shader.
         * @param source Source texture.
         * @param dest The destination RenderTexture. Set this to null to blit directly to screen. See description for more information.
         * @param mat Material to use. Material's shader could do some post-processing effect, for example.
         * @param pass If -1 (default), draws all passes in the material. Otherwise, draws given pass only.
         * @param offset Offset applied to the source texture coordinate.
         * @param scale Scale applied to the source texture coordinate.
         * @param sourceDepthSlice The texture array source slice to perform the blit from.
         * @param destDepthSlice The texture array destination slice to perform the blit to.
         */
        public static Blit($source: Texture, $dest: RenderTexture, $scale: Vector2, $offset: Vector2, $sourceDepthSlice: number, $destDepthSlice: number):void;
        /**
         * Copies source texture into destination render texture with a shader.
         * @param source Source texture.
         * @param dest The destination RenderTexture. Set this to null to blit directly to screen. See description for more information.
         * @param mat Material to use. Material's shader could do some post-processing effect, for example.
         * @param pass If -1 (default), draws all passes in the material. Otherwise, draws given pass only.
         * @param offset Offset applied to the source texture coordinate.
         * @param scale Scale applied to the source texture coordinate.
         * @param sourceDepthSlice The texture array source slice to perform the blit from.
         * @param destDepthSlice The texture array destination slice to perform the blit to.
         */
        public static Blit($source: Texture, $dest: RenderTexture, $mat: Material, $pass: number):void;
        
        public static Blit($source: Texture, $dest: RenderTexture, $mat: Material, $pass: number, $destDepthSlice: number):void;
        
        public static Blit($source: Texture, $dest: RenderTexture, $mat: Material):void;
        /**
         * Copies source texture into destination render texture with a shader.
         * @param source Source texture.
         * @param dest The destination RenderTexture. Set this to null to blit directly to screen. See description for more information.
         * @param mat Material to use. Material's shader could do some post-processing effect, for example.
         * @param pass If -1 (default), draws all passes in the material. Otherwise, draws given pass only.
         * @param offset Offset applied to the source texture coordinate.
         * @param scale Scale applied to the source texture coordinate.
         * @param sourceDepthSlice The texture array source slice to perform the blit from.
         * @param destDepthSlice The texture array destination slice to perform the blit to.
         */
        public static Blit($source: Texture, $mat: Material, $pass: number):void;
        /**
         * Copies source texture into destination render texture with a shader.
         * @param source Source texture.
         * @param dest The destination RenderTexture. Set this to null to blit directly to screen. See description for more information.
         * @param mat Material to use. Material's shader could do some post-processing effect, for example.
         * @param pass If -1 (default), draws all passes in the material. Otherwise, draws given pass only.
         * @param offset Offset applied to the source texture coordinate.
         * @param scale Scale applied to the source texture coordinate.
         * @param sourceDepthSlice The texture array source slice to perform the blit from.
         * @param destDepthSlice The texture array destination slice to perform the blit to.
         */
        public static Blit($source: Texture, $mat: Material, $pass: number, $destDepthSlice: number):void;
        
        public static Blit($source: Texture, $mat: Material):void;
        /**
         * Copies source texture into destination, for multi-tap shader.
         * @param source Source texture.
         * @param dest Destination RenderTexture, or null to blit directly to screen.
         * @param mat Material to use for copying. Material's shader should do some post-processing effect.
         * @param offsets Variable number of filtering offsets. Offsets are given in pixels.
         * @param destDepthSlice The texture array destination slice to blit to.
         */
        public static BlitMultiTap($source: Texture, $dest: RenderTexture, $mat: Material, ...offsets: Vector2[]):void;
        /**
         * Copies source texture into destination, for multi-tap shader.
         * @param source Source texture.
         * @param dest Destination RenderTexture, or null to blit directly to screen.
         * @param mat Material to use for copying. Material's shader should do some post-processing effect.
         * @param offsets Variable number of filtering offsets. Offsets are given in pixels.
         * @param destDepthSlice The texture array destination slice to blit to.
         */
        public static BlitMultiTap($source: Texture, $dest: RenderTexture, $mat: Material, $destDepthSlice: number, ...offsets: Vector2[]):void;
        
        public static DrawMesh($mesh: Mesh, $position: Vector3, $rotation: Quaternion, $material: Material, $layer: number):void;
        
        public static DrawMesh($mesh: Mesh, $position: Vector3, $rotation: Quaternion, $material: Material, $layer: number, $camera: Camera):void;
        
        public static DrawMesh($mesh: Mesh, $position: Vector3, $rotation: Quaternion, $material: Material, $layer: number, $camera: Camera, $submeshIndex: number):void;
        
        public static DrawMesh($mesh: Mesh, $position: Vector3, $rotation: Quaternion, $material: Material, $layer: number, $camera: Camera, $submeshIndex: number, $properties: MaterialPropertyBlock):void;
        
        public static DrawMesh($mesh: Mesh, $position: Vector3, $rotation: Quaternion, $material: Material, $layer: number, $camera: Camera, $submeshIndex: number, $properties: MaterialPropertyBlock, $castShadows: boolean):void;
        
        public static DrawMesh($mesh: Mesh, $position: Vector3, $rotation: Quaternion, $material: Material, $layer: number, $camera: Camera, $submeshIndex: number, $properties: MaterialPropertyBlock, $castShadows: boolean, $receiveShadows: boolean):void;
        
        public static DrawMesh($mesh: Mesh, $position: Vector3, $rotation: Quaternion, $material: Material, $layer: number, $camera: Camera, $submeshIndex: number, $properties: MaterialPropertyBlock, $castShadows: UnityEngine_Rendering.ShadowCastingMode):void;
        
        public static DrawMesh($mesh: Mesh, $position: Vector3, $rotation: Quaternion, $material: Material, $layer: number, $camera: Camera, $submeshIndex: number, $properties: MaterialPropertyBlock, $castShadows: UnityEngine_Rendering.ShadowCastingMode, $receiveShadows: boolean):void;
        
        public static DrawMesh($mesh: Mesh, $position: Vector3, $rotation: Quaternion, $material: Material, $layer: number, $camera: Camera, $submeshIndex: number, $properties: MaterialPropertyBlock, $castShadows: UnityEngine_Rendering.ShadowCastingMode, $receiveShadows: boolean, $probeAnchor: Transform):void;
        
        public static DrawMesh($mesh: Mesh, $matrix: Matrix4x4, $material: Material, $layer: number):void;
        
        public static DrawMesh($mesh: Mesh, $matrix: Matrix4x4, $material: Material, $layer: number, $camera: Camera):void;
        
        public static DrawMesh($mesh: Mesh, $matrix: Matrix4x4, $material: Material, $layer: number, $camera: Camera, $submeshIndex: number):void;
        
        public static DrawMesh($mesh: Mesh, $matrix: Matrix4x4, $material: Material, $layer: number, $camera: Camera, $submeshIndex: number, $properties: MaterialPropertyBlock):void;
        
        public static DrawMesh($mesh: Mesh, $matrix: Matrix4x4, $material: Material, $layer: number, $camera: Camera, $submeshIndex: number, $properties: MaterialPropertyBlock, $castShadows: boolean):void;
        
        public static DrawMesh($mesh: Mesh, $matrix: Matrix4x4, $material: Material, $layer: number, $camera: Camera, $submeshIndex: number, $properties: MaterialPropertyBlock, $castShadows: boolean, $receiveShadows: boolean):void;
        
        public static DrawMesh($mesh: Mesh, $matrix: Matrix4x4, $material: Material, $layer: number, $camera: Camera, $submeshIndex: number, $properties: MaterialPropertyBlock, $castShadows: UnityEngine_Rendering.ShadowCastingMode):void;
        
        public static DrawMesh($mesh: Mesh, $matrix: Matrix4x4, $material: Material, $layer: number, $camera: Camera, $submeshIndex: number, $properties: MaterialPropertyBlock, $castShadows: UnityEngine_Rendering.ShadowCastingMode, $receiveShadows: boolean):void;
        
        public static DrawMesh($mesh: Mesh, $matrix: Matrix4x4, $material: Material, $layer: number, $camera: Camera, $submeshIndex: number, $properties: MaterialPropertyBlock, $castShadows: UnityEngine_Rendering.ShadowCastingMode, $receiveShadows: boolean, $probeAnchor: Transform):void;
        /**
         * Draw a mesh.
         * @param mesh The Mesh to draw.
         * @param position Position of the mesh.
         * @param rotation Rotation of the mesh.
         * @param matrix Transformation matrix of the mesh (combines position, rotation and other transformations).
         * @param material Material to use.
         * @param layer  to use.
         * @param camera If null (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given Camera only.
         * @param submeshIndex Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.
         * @param properties Additional material properties to apply onto material just before this mesh will be drawn. See MaterialPropertyBlock.
         * @param castShadows Determines whether the mesh can cast shadows.
         * @param receiveShadows Determines whether the mesh can receive shadows.
         * @param useLightProbes Should the mesh use light probes?
         * @param probeAnchor If used, the mesh will use this Transform's position to sample light probes and find the matching reflection probe.
         * @param lightProbeUsage LightProbeUsage for the mesh.
         */
        public static DrawMesh($mesh: Mesh, $matrix: Matrix4x4, $material: Material, $layer: number, $camera: Camera, $submeshIndex: number, $properties: MaterialPropertyBlock, $castShadows: UnityEngine_Rendering.ShadowCastingMode, $receiveShadows: boolean, $probeAnchor: Transform, $useLightProbes: boolean):void;
        /**
         * Draw a mesh.
         * @param mesh The Mesh to draw.
         * @param position Position of the mesh.
         * @param rotation Rotation of the mesh.
         * @param matrix Transformation matrix of the mesh (combines position, rotation and other transformations).
         * @param material Material to use.
         * @param layer  to use.
         * @param camera If null (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given Camera only.
         * @param submeshIndex Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.
         * @param properties Additional material properties to apply onto material just before this mesh will be drawn. See MaterialPropertyBlock.
         * @param castShadows Determines whether the mesh can cast shadows.
         * @param receiveShadows Determines whether the mesh can receive shadows.
         * @param useLightProbes Should the mesh use light probes?
         * @param probeAnchor If used, the mesh will use this Transform's position to sample light probes and find the matching reflection probe.
         * @param lightProbeUsage LightProbeUsage for the mesh.
         */
        public static DrawMesh($mesh: Mesh, $matrix: Matrix4x4, $material: Material, $layer: number, $camera: Camera, $submeshIndex: number, $properties: MaterialPropertyBlock, $castShadows: UnityEngine_Rendering.ShadowCastingMode, $receiveShadows: boolean, $probeAnchor: Transform, $lightProbeUsage: UnityEngine_Rendering.LightProbeUsage):void;
        
        public static DrawMeshInstanced($mesh: Mesh, $submeshIndex: number, $material: Material, $matrices: Matrix4x4[]):void;
        
        public static DrawMeshInstanced($mesh: Mesh, $submeshIndex: number, $material: Material, $matrices: Matrix4x4[], $count: number):void;
        
        public static DrawMeshInstanced($mesh: Mesh, $submeshIndex: number, $material: Material, $matrices: Matrix4x4[], $count: number, $properties: MaterialPropertyBlock):void;
        
        public static DrawMeshInstanced($mesh: Mesh, $submeshIndex: number, $material: Material, $matrices: Matrix4x4[], $count: number, $properties: MaterialPropertyBlock, $castShadows: UnityEngine_Rendering.ShadowCastingMode):void;
        
        public static DrawMeshInstanced($mesh: Mesh, $submeshIndex: number, $material: Material, $matrices: Matrix4x4[], $count: number, $properties: MaterialPropertyBlock, $castShadows: UnityEngine_Rendering.ShadowCastingMode, $receiveShadows: boolean):void;
        
        public static DrawMeshInstanced($mesh: Mesh, $submeshIndex: number, $material: Material, $matrices: Matrix4x4[], $count: number, $properties: MaterialPropertyBlock, $castShadows: UnityEngine_Rendering.ShadowCastingMode, $receiveShadows: boolean, $layer: number):void;
        
        public static DrawMeshInstanced($mesh: Mesh, $submeshIndex: number, $material: Material, $matrices: Matrix4x4[], $count: number, $properties: MaterialPropertyBlock, $castShadows: UnityEngine_Rendering.ShadowCastingMode, $receiveShadows: boolean, $layer: number, $camera: Camera):void;
        
        public static DrawMeshInstanced($mesh: Mesh, $submeshIndex: number, $material: Material, $matrices: Matrix4x4[], $count: number, $properties: MaterialPropertyBlock, $castShadows: UnityEngine_Rendering.ShadowCastingMode, $receiveShadows: boolean, $layer: number, $camera: Camera, $lightProbeUsage: UnityEngine_Rendering.LightProbeUsage):void;
        
        public static DrawMeshInstanced($mesh: Mesh, $submeshIndex: number, $material: Material, $matrices: System_Collections_Generic.List$1<Matrix4x4>):void;
        
        public static DrawMeshInstanced($mesh: Mesh, $submeshIndex: number, $material: Material, $matrices: System_Collections_Generic.List$1<Matrix4x4>, $properties: MaterialPropertyBlock):void;
        
        public static DrawMeshInstanced($mesh: Mesh, $submeshIndex: number, $material: Material, $matrices: System_Collections_Generic.List$1<Matrix4x4>, $properties: MaterialPropertyBlock, $castShadows: UnityEngine_Rendering.ShadowCastingMode):void;
        
        public static DrawMeshInstanced($mesh: Mesh, $submeshIndex: number, $material: Material, $matrices: System_Collections_Generic.List$1<Matrix4x4>, $properties: MaterialPropertyBlock, $castShadows: UnityEngine_Rendering.ShadowCastingMode, $receiveShadows: boolean):void;
        
        public static DrawMeshInstanced($mesh: Mesh, $submeshIndex: number, $material: Material, $matrices: System_Collections_Generic.List$1<Matrix4x4>, $properties: MaterialPropertyBlock, $castShadows: UnityEngine_Rendering.ShadowCastingMode, $receiveShadows: boolean, $layer: number):void;
        
        public static DrawMeshInstanced($mesh: Mesh, $submeshIndex: number, $material: Material, $matrices: System_Collections_Generic.List$1<Matrix4x4>, $properties: MaterialPropertyBlock, $castShadows: UnityEngine_Rendering.ShadowCastingMode, $receiveShadows: boolean, $layer: number, $camera: Camera):void;
        
        public static DrawMeshInstanced($mesh: Mesh, $submeshIndex: number, $material: Material, $matrices: System_Collections_Generic.List$1<Matrix4x4>, $properties: MaterialPropertyBlock, $castShadows: UnityEngine_Rendering.ShadowCastingMode, $receiveShadows: boolean, $layer: number, $camera: Camera, $lightProbeUsage: UnityEngine_Rendering.LightProbeUsage):void;
        
        public static DrawMeshInstancedIndirect($mesh: Mesh, $submeshIndex: number, $material: Material, $bounds: Bounds, $bufferWithArgs: ComputeBuffer, $argsOffset?: number, $properties?: MaterialPropertyBlock, $castShadows?: UnityEngine_Rendering.ShadowCastingMode, $receiveShadows?: boolean, $layer?: number, $camera?: Camera, $lightProbeUsage?: UnityEngine_Rendering.LightProbeUsage):void;
        
        public static DrawMeshInstancedIndirect($mesh: Mesh, $submeshIndex: number, $material: Material, $bounds: Bounds, $bufferWithArgs: GraphicsBuffer, $argsOffset?: number, $properties?: MaterialPropertyBlock, $castShadows?: UnityEngine_Rendering.ShadowCastingMode, $receiveShadows?: boolean, $layer?: number, $camera?: Camera, $lightProbeUsage?: UnityEngine_Rendering.LightProbeUsage):void;
        /**
         * Draw a texture in screen coordinates.
         * @param screenRect Rectangle on the screen to use for the texture. In pixel coordinates with (0,0) in the upper-left corner.
         * @param texture Texture to draw.
         * @param sourceRect Region of the texture to use. In normalized coordinates with (0,0) in the bottom-left corner.
         * @param leftBorder Number of pixels from the left that are not affected by scale.
         * @param rightBorder Number of pixels from the right that are not affected by scale.
         * @param topBorder Number of pixels from the top that are not affected by scale.
         * @param bottomBorder Number of pixels from the bottom that are not affected by scale.
         * @param color Color that modulates the output. The neutral value is (0.5, 0.5, 0.5, 0.5). Set as vertex color for the shader.
         * @param mat Custom Material that can be used to draw the texture. If null is passed, a default material with the Internal-GUITexture.shader is used.
         * @param pass If -1 (default), draws all passes in the material. Otherwise, draws given pass only.
         */
        public static DrawTexture($screenRect: Rect, $texture: Texture, $sourceRect: Rect, $leftBorder: number, $rightBorder: number, $topBorder: number, $bottomBorder: number, $color: Color, $mat: Material):void;
        
        public static DrawTexture($screenRect: Rect, $texture: Texture, $sourceRect: Rect, $leftBorder: number, $rightBorder: number, $topBorder: number, $bottomBorder: number, $color: Color):void;
        /**
         * Draw a texture in screen coordinates.
         * @param screenRect Rectangle on the screen to use for the texture. In pixel coordinates with (0,0) in the upper-left corner.
         * @param texture Texture to draw.
         * @param sourceRect Region of the texture to use. In normalized coordinates with (0,0) in the bottom-left corner.
         * @param leftBorder Number of pixels from the left that are not affected by scale.
         * @param rightBorder Number of pixels from the right that are not affected by scale.
         * @param topBorder Number of pixels from the top that are not affected by scale.
         * @param bottomBorder Number of pixels from the bottom that are not affected by scale.
         * @param color Color that modulates the output. The neutral value is (0.5, 0.5, 0.5, 0.5). Set as vertex color for the shader.
         * @param mat Custom Material that can be used to draw the texture. If null is passed, a default material with the Internal-GUITexture.shader is used.
         * @param pass If -1 (default), draws all passes in the material. Otherwise, draws given pass only.
         */
        public static DrawTexture($screenRect: Rect, $texture: Texture, $sourceRect: Rect, $leftBorder: number, $rightBorder: number, $topBorder: number, $bottomBorder: number, $mat: Material):void;
        
        public static DrawTexture($screenRect: Rect, $texture: Texture, $sourceRect: Rect, $leftBorder: number, $rightBorder: number, $topBorder: number, $bottomBorder: number):void;
        /**
         * Draw a texture in screen coordinates.
         * @param screenRect Rectangle on the screen to use for the texture. In pixel coordinates with (0,0) in the upper-left corner.
         * @param texture Texture to draw.
         * @param sourceRect Region of the texture to use. In normalized coordinates with (0,0) in the bottom-left corner.
         * @param leftBorder Number of pixels from the left that are not affected by scale.
         * @param rightBorder Number of pixels from the right that are not affected by scale.
         * @param topBorder Number of pixels from the top that are not affected by scale.
         * @param bottomBorder Number of pixels from the bottom that are not affected by scale.
         * @param color Color that modulates the output. The neutral value is (0.5, 0.5, 0.5, 0.5). Set as vertex color for the shader.
         * @param mat Custom Material that can be used to draw the texture. If null is passed, a default material with the Internal-GUITexture.shader is used.
         * @param pass If -1 (default), draws all passes in the material. Otherwise, draws given pass only.
         */
        public static DrawTexture($screenRect: Rect, $texture: Texture, $leftBorder: number, $rightBorder: number, $topBorder: number, $bottomBorder: number, $mat: Material):void;
        
        public static DrawTexture($screenRect: Rect, $texture: Texture, $leftBorder: number, $rightBorder: number, $topBorder: number, $bottomBorder: number):void;
        /**
         * Draw a texture in screen coordinates.
         * @param screenRect Rectangle on the screen to use for the texture. In pixel coordinates with (0,0) in the upper-left corner.
         * @param texture Texture to draw.
         * @param sourceRect Region of the texture to use. In normalized coordinates with (0,0) in the bottom-left corner.
         * @param leftBorder Number of pixels from the left that are not affected by scale.
         * @param rightBorder Number of pixels from the right that are not affected by scale.
         * @param topBorder Number of pixels from the top that are not affected by scale.
         * @param bottomBorder Number of pixels from the bottom that are not affected by scale.
         * @param color Color that modulates the output. The neutral value is (0.5, 0.5, 0.5, 0.5). Set as vertex color for the shader.
         * @param mat Custom Material that can be used to draw the texture. If null is passed, a default material with the Internal-GUITexture.shader is used.
         * @param pass If -1 (default), draws all passes in the material. Otherwise, draws given pass only.
         */
        public static DrawTexture($screenRect: Rect, $texture: Texture, $mat: Material):void;
        
        public static DrawTexture($screenRect: Rect, $texture: Texture):void;
        
        public static SetRenderTarget($rt: RenderTexture):void;
        
        public static SetRenderTarget($rt: RenderTexture, $mipLevel: number):void;
        
        public static SetRenderTarget($rt: RenderTexture, $mipLevel: number, $face: CubemapFace):void;
        
        public static SetRenderTarget($colorBuffer: RenderBuffer, $depthBuffer: RenderBuffer):void;
        
        public static SetRenderTarget($colorBuffer: RenderBuffer, $depthBuffer: RenderBuffer, $mipLevel: number):void;
        
        public static SetRenderTarget($colorBuffer: RenderBuffer, $depthBuffer: RenderBuffer, $mipLevel: number, $face: CubemapFace):void;
        
        public static SetRandomWriteTarget($index: number, $uav: ComputeBuffer):void;
        
        public static SetRandomWriteTarget($index: number, $uav: GraphicsBuffer):void;
        
                    
    }
    /**
     * Represents a color gamut.
     */
    enum ColorGamut { sRGB = 0, Rec709 = 1, Rec2020 = 2, DisplayP3 = 3, HDR10 = 4, DolbyHDR = 5 }
    /**
     * Render textures are textures that can be rendered to.
     */
    class RenderTexture extends Texture {
        /**
         * The width of the render texture in pixels.
         */
        public get width(): number;
        public set width(value: number);
        /**
         * The height of the render texture in pixels.
         */
        public get height(): number;
        public set height(value: number);
        /**
         * Dimensionality (type) of the render texture.
         */
        public get dimension(): UnityEngine_Rendering.TextureDimension;
        public set dimension(value: UnityEngine_Rendering.TextureDimension);
        /**
         * The color format of the render texture.
         */
        public get graphicsFormat(): UnityEngine_Experimental_Rendering.GraphicsFormat;
        public set graphicsFormat(value: UnityEngine_Experimental_Rendering.GraphicsFormat);
        /**
         * Render texture has mipmaps when this flag is set.
         */
        public get useMipMap(): boolean;
        public set useMipMap(value: boolean);
        /**
         * Does this render texture use sRGB read/write conversions? (Read Only).
         */
        public get sRGB(): boolean;
        /**
         * If this RenderTexture is a VR eye texture used in stereoscopic rendering, this property decides what special rendering occurs, if any.
         */
        public get vrUsage(): VRTextureUsage;
        public set vrUsage(value: VRTextureUsage);
        /**
         * The render texture memoryless mode property.
         */
        public get memorylessMode(): RenderTextureMemoryless;
        public set memorylessMode(value: RenderTextureMemoryless);
        
        public get format(): RenderTextureFormat;
        public set format(value: RenderTextureFormat);
        /**
         * The format of the stencil data that you can encapsulate within a RenderTexture.
         * Specifying this property creates a stencil element for the RenderTexture and sets its format.
         * This allows for stencil data to be bound as a Texture to all shader types for the platforms that support it.
         * This property does not specify the format of the stencil buffer, which is constrained by the depth buffer format specified in RenderTexture.depth.
         * Currently, most platforms only support R8_UInt (DirectX11, DirectX12), while PS4 also supports R8_UNorm.
         */
        public get stencilFormat(): UnityEngine_Experimental_Rendering.GraphicsFormat;
        public set stencilFormat(value: UnityEngine_Experimental_Rendering.GraphicsFormat);
        /**
         * Mipmap levels are generated automatically when this flag is set.
         */
        public get autoGenerateMips(): boolean;
        public set autoGenerateMips(value: boolean);
        /**
         * Volume extent of a 3D render texture or number of slices of array texture.
         */
        public get volumeDepth(): number;
        public set volumeDepth(value: number);
        /**
         * The antialiasing level for the RenderTexture.
         */
        public get antiAliasing(): number;
        public set antiAliasing(value: number);
        /**
         * If true and antiAliasing is greater than 1, the render texture will not be resolved by default.  Use this if the render texture needs to be bound as a multisampled texture in a shader.
         */
        public get bindTextureMS(): boolean;
        public set bindTextureMS(value: boolean);
        /**
         * Enable random access write into this render texture on Shader Model 5.0 level shaders.
         */
        public get enableRandomWrite(): boolean;
        public set enableRandomWrite(value: boolean);
        /**
         * Is the render texture marked to be scaled by the Dynamic Resolution system.
         */
        public get useDynamicScale(): boolean;
        public set useDynamicScale(value: boolean);
        
        public get isPowerOfTwo(): boolean;
        public set isPowerOfTwo(value: boolean);
        /**
         * Currently active render texture.
         */
        public static get active(): RenderTexture;
        public static set active(value: RenderTexture);
        /**
         * Color buffer of the render texture (Read Only).
         */
        public get colorBuffer(): RenderBuffer;
        /**
         * Depth/stencil buffer of the render texture (Read Only).
         */
        public get depthBuffer(): RenderBuffer;
        /**
         * The precision of the render texture's depth buffer in bits (0, 16, 24/32 are supported).
         */
        public get depth(): number;
        public set depth(value: number);
        /**
         * This struct contains all the information required to create a RenderTexture. It can be copied, cached, and reused to easily create RenderTextures that all share the same properties.
         */
        public get descriptor(): RenderTextureDescriptor;
        public set descriptor(value: RenderTextureDescriptor);
        /**
         * Creates a new RenderTexture object.
         * @param width Texture width in pixels.
         * @param height Texture height in pixels.
         * @param depth Number of bits in depth buffer (0, 16 or 24). Note that only 24 bit depth has stencil buffer.
         * @param format Texture color format.
         * @param readWrite How or if color space conversions should be done on texture read/write.
         * @param desc Create the RenderTexture with the settings in the RenderTextureDescriptor.
         * @param textureToCopy Copy the settings from another RenderTexture.
         */
        public constructor($desc: RenderTextureDescriptor);
        /**
         * Creates a new RenderTexture object.
         * @param width Texture width in pixels.
         * @param height Texture height in pixels.
         * @param depth Number of bits in depth buffer (0, 16 or 24). Note that only 24 bit depth has stencil buffer.
         * @param format Texture color format.
         * @param readWrite How or if color space conversions should be done on texture read/write.
         * @param desc Create the RenderTexture with the settings in the RenderTextureDescriptor.
         * @param textureToCopy Copy the settings from another RenderTexture.
         */
        public constructor($textureToCopy: RenderTexture);
        
        public constructor($width: number, $height: number, $depth: number, $format: UnityEngine_Experimental_Rendering.DefaultFormat);
        
        public constructor($width: number, $height: number, $depth: number, $format: UnityEngine_Experimental_Rendering.GraphicsFormat);
        
        public constructor($width: number, $height: number, $depth: number, $format: UnityEngine_Experimental_Rendering.GraphicsFormat, $mipCount: number);
        /**
         * Creates a new RenderTexture object.
         * @param width Texture width in pixels.
         * @param height Texture height in pixels.
         * @param depth Number of bits in depth buffer (0, 16 or 24). Note that only 24 bit depth has stencil buffer.
         * @param format Texture color format.
         * @param readWrite How or if color space conversions should be done on texture read/write.
         * @param desc Create the RenderTexture with the settings in the RenderTextureDescriptor.
         * @param textureToCopy Copy the settings from another RenderTexture.
         */
        public constructor($width: number, $height: number, $depth: number, $format: RenderTextureFormat, $readWrite: RenderTextureReadWrite);
        
        public constructor($width: number, $height: number, $depth: number, $format: RenderTextureFormat);
        
        public constructor($width: number, $height: number, $depth: number);
        
        public constructor($width: number, $height: number, $depth: number, $format: RenderTextureFormat, $mipCount: number);
        /**
         * Retrieve a native (underlying graphics API) pointer to the depth buffer resource.
         * @returns Pointer to an underlying graphics API depth buffer resource.
         */
        public GetNativeDepthBufferPtr():System.IntPtr;
        /**
         * Hint the GPU driver that the contents of the RenderTexture will not be used.
         * @param discardColor Should the colour buffer be discarded?
         * @param discardDepth Should the depth buffer be discarded?
         */
        public DiscardContents($discardColor: boolean, $discardDepth: boolean):void;
        /**
         * Indicate that there's a RenderTexture restore operation expected.
         */
        public MarkRestoreExpected():void;
        /**
         * Hint the GPU driver that the contents of the RenderTexture will not be used.
         * @param discardColor Should the colour buffer be discarded?
         * @param discardDepth Should the depth buffer be discarded?
         */
        public DiscardContents():void;
        /**
         * Force an antialiased render texture to be resolved.
         * @param target The render texture to resolve into.  If set, the target render texture must have the same dimensions and format as the source.
         */
        public ResolveAntiAliasedSurface():void;
        /**
         * Force an antialiased render texture to be resolved.
         * @param target The render texture to resolve into.  If set, the target render texture must have the same dimensions and format as the source.
         */
        public ResolveAntiAliasedSurface($target: RenderTexture):void;
        /**
         * Assigns this RenderTexture as a global shader property named propertyName.
         */
        public SetGlobalShaderProperty($propertyName: string):void;
        /**
         * Actually creates the RenderTexture.
         * @returns True if the texture is created, else false.
         */
        public Create():boolean;
        /**
         * Releases the RenderTexture.
         */
        public Release():void;
        /**
         * Is the render texture actually created?
         */
        public IsCreated():boolean;
        /**
         * Generate mipmap levels of a render texture.
         */
        public GenerateMips():void;
        /**
         * Converts the render texture to equirectangular format (both stereoscopic or monoscopic equirect).
         * The left eye will occupy the top half and the right eye will occupy the bottom. The monoscopic version will occupy the whole texture.
         * Texture dimension must be of type TextureDimension.Cube.
         * @param equirect RenderTexture to render the equirect format to.
         * @param eye A Camera eye corresponding to the left or right eye for stereoscopic rendering, or neither for monoscopic rendering.
         */
        public ConvertToEquirect($equirect: RenderTexture, $eye?: UnityEngine_Camera.MonoOrStereoscopicEye):void;
        /**
         * Does a RenderTexture have stencil buffer?
         * @param rt Render texture, or null for main screen.
         */
        public static SupportsStencil($rt: RenderTexture):boolean;
        /**
         * Release a temporary texture allocated with GetTemporary.
         */
        public static ReleaseTemporary($temp: RenderTexture):void;
        /**
         * Allocate a temporary render texture.
         * @param width Width in pixels.
         * @param height Height in pixels.
         * @param depthBuffer Depth buffer bits (0, 16 or 24). Note that only 24 bit depth has stencil buffer.
         * @param format Render texture format.
         * @param readWrite Color space conversion mode.
         * @param antiAliasing Number of antialiasing samples to store in the texture. Valid values are 1, 2, 4, and 8. Throws an exception if any other value is passed.
         * @param memorylessMode Render texture memoryless mode.
         * @param desc Use this RenderTextureDesc for the settings when creating the temporary RenderTexture.
         */
        public static GetTemporary($desc: RenderTextureDescriptor):RenderTexture;
        
        public static GetTemporary($width: number, $height: number, $depthBuffer: number, $format: UnityEngine_Experimental_Rendering.GraphicsFormat, $antiAliasing: number, $memorylessMode: RenderTextureMemoryless, $vrUsage: VRTextureUsage, $useDynamicScale: boolean):RenderTexture;
        
        public static GetTemporary($width: number, $height: number, $depthBuffer: number, $format: UnityEngine_Experimental_Rendering.GraphicsFormat, $antiAliasing: number, $memorylessMode: RenderTextureMemoryless, $vrUsage: VRTextureUsage):RenderTexture;
        
        public static GetTemporary($width: number, $height: number, $depthBuffer: number, $format: UnityEngine_Experimental_Rendering.GraphicsFormat, $antiAliasing: number, $memorylessMode: RenderTextureMemoryless):RenderTexture;
        
        public static GetTemporary($width: number, $height: number, $depthBuffer: number, $format: UnityEngine_Experimental_Rendering.GraphicsFormat, $antiAliasing: number):RenderTexture;
        
        public static GetTemporary($width: number, $height: number, $depthBuffer: number, $format: UnityEngine_Experimental_Rendering.GraphicsFormat):RenderTexture;
        /**
         * Allocate a temporary render texture.
         * @param width Width in pixels.
         * @param height Height in pixels.
         * @param depthBuffer Depth buffer bits (0, 16 or 24). Note that only 24 bit depth has stencil buffer.
         * @param format Render texture format.
         * @param readWrite Color space conversion mode.
         * @param antiAliasing Number of antialiasing samples to store in the texture. Valid values are 1, 2, 4, and 8. Throws an exception if any other value is passed.
         * @param memorylessMode Render texture memoryless mode.
         * @param desc Use this RenderTextureDesc for the settings when creating the temporary RenderTexture.
         */
        public static GetTemporary($width: number, $height: number, $depthBuffer: number, $format: RenderTextureFormat, $readWrite: RenderTextureReadWrite, $antiAliasing: number, $memorylessMode: RenderTextureMemoryless, $vrUsage: VRTextureUsage, $useDynamicScale: boolean):RenderTexture;
        
        public static GetTemporary($width: number, $height: number, $depthBuffer: number, $format: RenderTextureFormat, $readWrite: RenderTextureReadWrite, $antiAliasing: number, $memorylessMode: RenderTextureMemoryless, $vrUsage: VRTextureUsage):RenderTexture;
        
        public static GetTemporary($width: number, $height: number, $depthBuffer: number, $format: RenderTextureFormat, $readWrite: RenderTextureReadWrite, $antiAliasing: number, $memorylessMode: RenderTextureMemoryless):RenderTexture;
        
        public static GetTemporary($width: number, $height: number, $depthBuffer: number, $format: RenderTextureFormat, $readWrite: RenderTextureReadWrite, $antiAliasing: number):RenderTexture;
        
        public static GetTemporary($width: number, $height: number, $depthBuffer: number, $format: RenderTextureFormat, $readWrite: RenderTextureReadWrite):RenderTexture;
        
        public static GetTemporary($width: number, $height: number, $depthBuffer: number, $format: RenderTextureFormat):RenderTexture;
        
        public static GetTemporary($width: number, $height: number, $depthBuffer: number):RenderTexture;
        
        public static GetTemporary($width: number, $height: number):RenderTexture;
        
        public constructor();
        
                    
    }
    /**
     * Cubemap face.
     */
    enum CubemapFace { Unknown = -1, PositiveX = 0, NegativeX = 1, PositiveY = 2, NegativeY = 3, PositiveZ = 4, NegativeZ = 5 }
    /**
     * Color or depth buffer part of a RenderTexture.
     */
    class RenderBuffer extends System.ValueType {
        /**
         * Returns native RenderBuffer. Be warned this is not native Texture, but rather pointer to unity struct that can be used with native unity API. Currently such API exists only on iOS.
         */
        public GetNativeRenderBufferPtr():System.IntPtr;
        
        public get_Clone(): RenderBuffer;            
    }
    /**
     * Fully describes setup of RenderTarget.
     */
    class RenderTargetSetup extends System.ValueType {
        /**
         * Color Buffers to set.
         */
        public color: RenderBuffer[];
        /**
         * Depth Buffer to set.
         */
        public depth: RenderBuffer;
        /**
         * Mip Level to render to.
         */
        public mipLevel: number;
        /**
         * Cubemap face to render to.
         */
        public cubemapFace: CubemapFace;
        /**
         * Slice of a Texture3D or Texture2DArray to set as a render target.
         */
        public depthSlice: number;
        /**
         * Load Actions for Color Buffers. It will override any actions set on RenderBuffers themselves.
         */
        public colorLoad: UnityEngine_Rendering.RenderBufferLoadAction[];
        /**
         * Store Actions for Color Buffers. It will override any actions set on RenderBuffers themselves.
         */
        public colorStore: UnityEngine_Rendering.RenderBufferStoreAction[];
        /**
         * Load Action for Depth Buffer. It will override any actions set on RenderBuffer itself.
         */
        public depthLoad: UnityEngine_Rendering.RenderBufferLoadAction;
        /**
         * Store Actions for Depth Buffer. It will override any actions set on RenderBuffer itself.
         */
        public depthStore: UnityEngine_Rendering.RenderBufferStoreAction;
        
        public constructor($color: RenderBuffer[], $depth: RenderBuffer, $mip: number, $face: CubemapFace, $colorLoad: UnityEngine_Rendering.RenderBufferLoadAction[], $colorStore: UnityEngine_Rendering.RenderBufferStoreAction[], $depthLoad: UnityEngine_Rendering.RenderBufferLoadAction, $depthStore: UnityEngine_Rendering.RenderBufferStoreAction);
        /**
         * Constructs RenderTargetSetup.
         * @param color Color Buffer(s) to set.
         * @param depth Depth Buffer to set.
         * @param mipLevel Mip Level to render to.
         * @param face Cubemap face to render to.
         */
        public constructor($color: RenderBuffer, $depth: RenderBuffer);
        /**
         * Constructs RenderTargetSetup.
         * @param color Color Buffer(s) to set.
         * @param depth Depth Buffer to set.
         * @param mipLevel Mip Level to render to.
         * @param face Cubemap face to render to.
         */
        public constructor($color: RenderBuffer, $depth: RenderBuffer, $mipLevel: number);
        /**
         * Constructs RenderTargetSetup.
         * @param color Color Buffer(s) to set.
         * @param depth Depth Buffer to set.
         * @param mipLevel Mip Level to render to.
         * @param face Cubemap face to render to.
         */
        public constructor($color: RenderBuffer, $depth: RenderBuffer, $mipLevel: number, $face: CubemapFace);
        
        public constructor($color: RenderBuffer, $depth: RenderBuffer, $mipLevel: number, $face: CubemapFace, $depthSlice: number);
        /**
         * Constructs RenderTargetSetup.
         * @param color Color Buffer(s) to set.
         * @param depth Depth Buffer to set.
         * @param mipLevel Mip Level to render to.
         * @param face Cubemap face to render to.
         */
        public constructor($color: RenderBuffer[], $depth: RenderBuffer);
        /**
         * Constructs RenderTargetSetup.
         * @param color Color Buffer(s) to set.
         * @param depth Depth Buffer to set.
         * @param mipLevel Mip Level to render to.
         * @param face Cubemap face to render to.
         */
        public constructor($color: RenderBuffer[], $depth: RenderBuffer, $mipLevel: number);
        /**
         * Constructs RenderTargetSetup.
         * @param color Color Buffer(s) to set.
         * @param depth Depth Buffer to set.
         * @param mipLevel Mip Level to render to.
         * @param face Cubemap face to render to.
         */
        public constructor($color: RenderBuffer[], $depth: RenderBuffer, $mip: number, $face: CubemapFace);
        
                    
    }
    /**
     * GPU data buffer, mostly for use with compute shaders.
     */
    class ComputeBuffer extends System.Object {
        /**
         * Number of elements in the buffer (Read Only).
         */
        public get count(): number;
        /**
         * Size of one element in the buffer (Read Only).
         */
        public get stride(): number;
        /**
         * The debug label for the ComputeBuffer. This name shows up in profiling and frame debugger tools, wherever supported.
         */
        public set name(value: string);
        /**
         * Create a Compute Buffer.
         * @param count Number of elements in the buffer.
         * @param stride Size of one element in the buffer. Has to match size of buffer type in the shader. See for cross-platform compatibility information.
         * @param type Type of the buffer, default is ComputeBufferType.Default (structured buffer).
         */
        public constructor($count: number, $stride: number);
        /**
         * Create a Compute Buffer.
         * @param count Number of elements in the buffer.
         * @param stride Size of one element in the buffer. Has to match size of buffer type in the shader. See for cross-platform compatibility information.
         * @param type Type of the buffer, default is ComputeBufferType.Default (structured buffer).
         */
        public constructor($count: number, $stride: number, $type: ComputeBufferType);
        
        public constructor($count: number, $stride: number, $type: ComputeBufferType, $usage: ComputeBufferMode);
        
        public Dispose():void;
        /**
         * Release a Compute Buffer.
         */
        public Release():void;
        /**
         * Returns true if this compute buffer is valid and false otherwise.
         */
        public IsValid():boolean;
        /**
         * Set the buffer with values from an array.
         * @param data Array of values to fill the buffer.
         */
        public SetData($data: System.Array):void;
        
        public SetData<T>($data: System_Collections_Generic.List$1<T>):void;
        
        public SetData<T>($data: Unity_Collections.NativeArray$1<T>):void;
        /**
         * Partial copy of data values from an array into the buffer.
         * @param data Array of values to fill the buffer.
         * @param managedBufferStartIndex The first element index in data to copy to the compute buffer.
         * @param computeBufferStartIndex The first element index in compute buffer to receive the data.
         * @param count The number of elements to copy.
         */
        public SetData($data: System.Array, $managedBufferStartIndex: number, $computeBufferStartIndex: number, $count: number):void;
        
        public SetData<T>($data: System_Collections_Generic.List$1<T>, $managedBufferStartIndex: number, $computeBufferStartIndex: number, $count: number):void;
        
        public SetData<T>($data: Unity_Collections.NativeArray$1<T>, $nativeBufferStartIndex: number, $computeBufferStartIndex: number, $count: number):void;
        /**
         * Read data values from the buffer into an array. The array can only use <a href="https:docs.microsoft.comen-usdotnetframeworkinteropblittable-and-non-blittable-types">blittable<a> types.
         * @param data An array to receive the data.
         */
        public GetData($data: System.Array):void;
        /**
         * Partial read of data values from the buffer into an array.
         * @param data An array to receive the data.
         * @param managedBufferStartIndex The first element index in data where retrieved elements are copied.
         * @param computeBufferStartIndex The first element index of the compute buffer from which elements are read.
         * @param count The number of elements to retrieve.
         */
        public GetData($data: System.Array, $managedBufferStartIndex: number, $computeBufferStartIndex: number, $count: number):void;
        /**
         * Begins a write operation to the buffer
         * @param computeBufferStartIndex Offset in number of elements to which the write operation will occur
         * @param count Maximum number of elements which will be written
         * @returns A NativeArray of size count
         */
        public BeginWrite<T>($computeBufferStartIndex: number, $count: number):Unity_Collections.NativeArray$1<T>;
        /**
         * Ends a write operation to the buffer
         * @param countWritten Number of elements written to the buffer. Counted from the first element.
         */
        public EndWrite<T>($countWritten: number):void;
        /**
         * Sets counter value of append/consume buffer.
         * @param counterValue Value of the append/consume counter.
         */
        public SetCounterValue($counterValue: number):void;
        /**
         * Copy counter value of append/consume buffer into another buffer.
         * @param src Append/consume buffer to copy the counter from.
         * @param dst A buffer to copy the counter to.
         * @param dstOffsetBytes Target byte offset in dst.
         */
        public static CopyCount($src: ComputeBuffer, $dst: ComputeBuffer, $dstOffsetBytes: number):void;
        /**
         * Retrieve a native (underlying graphics API) pointer to the buffer.
         * @returns Pointer to the underlying graphics API buffer.
         */
        public GetNativeBufferPtr():System.IntPtr;
        
                    
    }
    /**
     * GPU graphics data buffer, for working with data such as vertex and index buffers.
     */
    class GraphicsBuffer extends System.Object {
        /**
         * Number of elements in the buffer (Read Only).
         */
        public get count(): number;
        /**
         * Size of one element in the buffer (Read Only).
         */
        public get stride(): number;
        /**
         * Create a Graphics Buffer.
         * @param target Select whether this buffer can be used as a vertex or index buffer.
         * @param count Number of elements in the buffer.
         * @param stride Size of one element in the buffer. For index buffers, this must be either 2 or 4 bytes.
         */
        public constructor($target: UnityEngine_GraphicsBuffer.Target, $count: number, $stride: number);
        
        public Dispose():void;
        /**
         * Release a Graphics Buffer.
         */
        public Release():void;
        /**
         * Returns true if this graphics buffer is valid, or false otherwise.
         */
        public IsValid():boolean;
        /**
         * Set the buffer with values from an array.
         * @param data Array of values to fill the buffer.
         */
        public SetData($data: System.Array):void;
        
        public SetData<T>($data: System_Collections_Generic.List$1<T>):void;
        
        public SetData<T>($data: Unity_Collections.NativeArray$1<T>):void;
        /**
         * Partial copy of data values from an array into the buffer.
         * @param data Array of values to fill the buffer.
         * @param managedBufferStartIndex The first element index in data to copy to the graphics buffer.
         * @param count The number of elements to copy.
         * @param graphicsBufferStartIndex The first element index in the graphics buffer to receive the data.
         */
        public SetData($data: System.Array, $managedBufferStartIndex: number, $graphicsBufferStartIndex: number, $count: number):void;
        
        public SetData<T>($data: System_Collections_Generic.List$1<T>, $managedBufferStartIndex: number, $graphicsBufferStartIndex: number, $count: number):void;
        
        public SetData<T>($data: Unity_Collections.NativeArray$1<T>, $nativeBufferStartIndex: number, $graphicsBufferStartIndex: number, $count: number):void;
        /**
         * Read data values from the buffer into an array. The array can only use <a href="https:docs.microsoft.comen-usdotnetframeworkinteropblittable-and-non-blittable-types">blittable<a> types.
         * @param data An array to receive the data.
         * @param managedBufferStartIndex The first element index in data where retrieved elements are copied.
         * @param computeBufferStartIndex The first element index of the buffer from which elements are read.
         * @param count The number of elements to retrieve.
         */
        public GetData($data: System.Array):void;
        /**
         * Read data values from the buffer into an array. The array can only use <a href="https:docs.microsoft.comen-usdotnetframeworkinteropblittable-and-non-blittable-types">blittable<a> types.
         * @param data An array to receive the data.
         * @param managedBufferStartIndex The first element index in data where retrieved elements are copied.
         * @param computeBufferStartIndex The first element index of the buffer from which elements are read.
         * @param count The number of elements to retrieve.
         */
        public GetData($data: System.Array, $managedBufferStartIndex: number, $computeBufferStartIndex: number, $count: number):void;
        /**
         * Retrieve a native (underlying graphics API) pointer to the buffer.
         * @returns Pointer to the underlying graphics API buffer.
         */
        public GetNativeBufferPtr():System.IntPtr;
        /**
         * Sets counter value of append/consume buffer.
         * @param counterValue Value of the append/consume counter.
         */
        public SetCounterValue($counterValue: number):void;
        /**
         * Copy counter value of append/consume buffer into another buffer.
         */
        public static CopyCount($src: ComputeBuffer, $dst: ComputeBuffer, $dstOffsetBytes: number):void;
        /**
         * Copy counter value of append/consume buffer into another buffer.
         */
        public static CopyCount($src: GraphicsBuffer, $dst: ComputeBuffer, $dstOffsetBytes: number):void;
        /**
         * Copy counter value of append/consume buffer into another buffer.
         */
        public static CopyCount($src: ComputeBuffer, $dst: GraphicsBuffer, $dstOffsetBytes: number):void;
        /**
         * Copy counter value of append/consume buffer into another buffer.
         */
        public static CopyCount($src: GraphicsBuffer, $dst: GraphicsBuffer, $dstOffsetBytes: number):void;
        
                    
    }
    /**
     * The material class.
     */
    class Material extends Object {
        /**
         * The shader used by the material.
         */
        public get shader(): Shader;
        public set shader(value: Shader);
        /**
         * The main color of the Material.
         */
        public get color(): Color;
        public set color(value: Color);
        /**
         * The main texture.
         */
        public get mainTexture(): Texture;
        public set mainTexture(value: Texture);
        /**
         * The offset of the main texture.
         */
        public get mainTextureOffset(): Vector2;
        public set mainTextureOffset(value: Vector2);
        /**
         * The scale of the main texture.
         */
        public get mainTextureScale(): Vector2;
        public set mainTextureScale(value: Vector2);
        /**
         * Render queue of this material.
         */
        public get renderQueue(): number;
        public set renderQueue(value: number);
        /**
         * Defines how the material should interact with lightmaps and lightprobes.
         */
        public get globalIlluminationFlags(): MaterialGlobalIlluminationFlags;
        public set globalIlluminationFlags(value: MaterialGlobalIlluminationFlags);
        /**
         * Gets and sets whether the Double Sided Global Illumination setting is enabled for this material.
         */
        public get doubleSidedGI(): boolean;
        public set doubleSidedGI(value: boolean);
        /**
         * Gets and sets whether GPU instancing is enabled for this material.
         */
        public get enableInstancing(): boolean;
        public set enableInstancing(value: boolean);
        /**
         * How many passes are in this material (Read Only).
         */
        public get passCount(): number;
        /**
         * Additional shader keywords set by this material.
         */
        public get shaderKeywords(): string[];
        public set shaderKeywords(value: string[]);
        /**
         * Create a temporary Material.
         * @param shader Create a material with a given Shader.
         * @param source Create a material by copying all properties from another material.
         */
        public constructor($shader: Shader);
        /**
         * Create a temporary Material.
         * @param shader Create a material with a given Shader.
         * @param source Create a material by copying all properties from another material.
         */
        public constructor($source: Material);
        /**
         * Checks if material's shader has a property of a given name.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public HasProperty($nameID: number):boolean;
        /**
         * Checks if material's shader has a property of a given name.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public HasProperty($name: string):boolean;
        /**
         * Sets a shader keyword that is enabled by this material.
         */
        public EnableKeyword($keyword: string):void;
        /**
         * Unset a shader keyword.
         */
        public DisableKeyword($keyword: string):void;
        /**
         * Is the shader keyword enabled on this material?
         */
        public IsKeywordEnabled($keyword: string):boolean;
        /**
         * Enables or disables a Shader pass on a per-Material level.
         * @param passName Shader pass name (case insensitive).
         * @param enabled Flag indicating whether this Shader pass should be enabled.
         */
        public SetShaderPassEnabled($passName: string, $enabled: boolean):void;
        /**
         * Checks whether a given Shader pass is enabled on this Material.
         * @param passName Shader pass name (case insensitive).
         * @returns True if the Shader pass is enabled.
         */
        public GetShaderPassEnabled($passName: string):boolean;
        /**
         * Returns the name of the shader pass at index pass.
         */
        public GetPassName($pass: number):string;
        /**
         * Returns the index of the pass passName.
         */
        public FindPass($passName: string):number;
        /**
         * Sets an override tag/value on the material.
         * @param tag Name of the tag to set.
         * @param val Name of the value to set. Empty string to clear the override flag.
         */
        public SetOverrideTag($tag: string, $val: string):void;
        /**
         * Get the value of material's shader tag.
         */
        public GetTag($tag: string, $searchFallbacks: boolean, $defaultValue: string):string;
        /**
         * Get the value of material's shader tag.
         */
        public GetTag($tag: string, $searchFallbacks: boolean):string;
        /**
         * Interpolate properties between two materials.
         */
        public Lerp($start: Material, $end: Material, $t: number):void;
        /**
         * Activate the given pass for rendering.
         * @param pass Shader pass number to setup.
         * @returns If false is returned, no rendering should be done.
         */
        public SetPass($pass: number):boolean;
        /**
         * Copy properties from other material into this material.
         */
        public CopyPropertiesFromMaterial($mat: Material):void;
        /**
         * Computes a CRC hash value from the content of the material.
         */
        public ComputeCRC():number;
        /**
         * Returns the names of all texture properties exposed on this material.
         * @param outNames Names of all texture properties exposed on this material.
         * @returns Names of all texture properties exposed on this material.
         */
        public GetTexturePropertyNames():string[];
        /**
         * Return the name IDs of all texture properties exposed on this material.
         * @param outNames IDs of all texture properties exposed on this material.
         * @returns IDs of all texture properties exposed on this material.
         */
        public GetTexturePropertyNameIDs():number[];
        
        public GetTexturePropertyNames($outNames: System_Collections_Generic.List$1<string>):void;
        
        public GetTexturePropertyNameIDs($outNames: System_Collections_Generic.List$1<number>):void;
        /**
         * Sets a named float value.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param value Float value to set.
         * @param name Property name, e.g. "_Glossiness".
         */
        public SetFloat($name: string, $value: number):void;
        /**
         * Sets a named float value.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param value Float value to set.
         * @param name Property name, e.g. "_Glossiness".
         */
        public SetFloat($nameID: number, $value: number):void;
        /**
         * Sets a named integer value.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param value Integer value to set.
         * @param name Property name, e.g. "_SrcBlend".
         */
        public SetInt($name: string, $value: number):void;
        /**
         * Sets a named integer value.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param value Integer value to set.
         * @param name Property name, e.g. "_SrcBlend".
         */
        public SetInt($nameID: number, $value: number):void;
        /**
         * Sets a named color value.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param name Property name, e.g. "_Color".
         * @param value Color value to set.
         */
        public SetColor($name: string, $value: Color):void;
        /**
         * Sets a named color value.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param name Property name, e.g. "_Color".
         * @param value Color value to set.
         */
        public SetColor($nameID: number, $value: Color):void;
        /**
         * Sets a named vector value.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param name Property name, e.g. "_WaveAndDistance".
         * @param value Vector value to set.
         */
        public SetVector($name: string, $value: Vector4):void;
        /**
         * Sets a named vector value.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param name Property name, e.g. "_WaveAndDistance".
         * @param value Vector value to set.
         */
        public SetVector($nameID: number, $value: Vector4):void;
        /**
         * Sets a named matrix for the shader.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param name Property name, e.g. "_CubemapRotation".
         * @param value Matrix value to set.
         */
        public SetMatrix($name: string, $value: Matrix4x4):void;
        /**
         * Sets a named matrix for the shader.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param name Property name, e.g. "_CubemapRotation".
         * @param value Matrix value to set.
         */
        public SetMatrix($nameID: number, $value: Matrix4x4):void;
        /**
         * Sets a named texture.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param name Property name, e.g. "_MainTex".
         * @param value Texture to set.
         * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
         */
        public SetTexture($name: string, $value: Texture):void;
        /**
         * Sets a named texture.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param name Property name, e.g. "_MainTex".
         * @param value Texture to set.
         * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
         */
        public SetTexture($nameID: number, $value: Texture):void;
        /**
         * Sets a named texture.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param name Property name, e.g. "_MainTex".
         * @param value Texture to set.
         * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
         */
        public SetTexture($name: string, $value: RenderTexture, $element: UnityEngine_Rendering.RenderTextureSubElement):void;
        /**
         * Sets a named texture.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param name Property name, e.g. "_MainTex".
         * @param value Texture to set.
         * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
         */
        public SetTexture($nameID: number, $value: RenderTexture, $element: UnityEngine_Rendering.RenderTextureSubElement):void;
        /**
         * Sets a named buffer value.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param name Property name.
         * @param value The ComputeBuffer or GraphicsBuffer value to set.
         */
        public SetBuffer($name: string, $value: ComputeBuffer):void;
        /**
         * Sets a named buffer value.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param name Property name.
         * @param value The ComputeBuffer or GraphicsBuffer value to set.
         */
        public SetBuffer($nameID: number, $value: ComputeBuffer):void;
        /**
         * Sets a named buffer value.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param name Property name.
         * @param value The ComputeBuffer or GraphicsBuffer value to set.
         */
        public SetBuffer($name: string, $value: GraphicsBuffer):void;
        /**
         * Sets a named buffer value.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param name Property name.
         * @param value The ComputeBuffer or GraphicsBuffer value to set.
         */
        public SetBuffer($nameID: number, $value: GraphicsBuffer):void;
        /**
         * Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for the material.
         * @param name The name of the constant buffer to override.
         * @param value The ComputeBuffer to override the constant buffer values with, or null to remove binding.
         * @param offset Offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
         * @param size The number of bytes to bind.
         * @param nameID The shader property ID of the constant buffer to override.
         */
        public SetConstantBuffer($name: string, $value: ComputeBuffer, $offset: number, $size: number):void;
        /**
         * Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for the material.
         * @param name The name of the constant buffer to override.
         * @param value The ComputeBuffer to override the constant buffer values with, or null to remove binding.
         * @param offset Offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
         * @param size The number of bytes to bind.
         * @param nameID The shader property ID of the constant buffer to override.
         */
        public SetConstantBuffer($nameID: number, $value: ComputeBuffer, $offset: number, $size: number):void;
        /**
         * Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for the material.
         * @param name The name of the constant buffer to override.
         * @param value The ComputeBuffer to override the constant buffer values with, or null to remove binding.
         * @param offset Offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
         * @param size The number of bytes to bind.
         * @param nameID The shader property ID of the constant buffer to override.
         */
        public SetConstantBuffer($name: string, $value: GraphicsBuffer, $offset: number, $size: number):void;
        /**
         * Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for the material.
         * @param name The name of the constant buffer to override.
         * @param value The ComputeBuffer to override the constant buffer values with, or null to remove binding.
         * @param offset Offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
         * @param size The number of bytes to bind.
         * @param nameID The shader property ID of the constant buffer to override.
         */
        public SetConstantBuffer($nameID: number, $value: GraphicsBuffer, $offset: number, $size: number):void;
        
        public SetFloatArray($name: string, $values: System_Collections_Generic.List$1<number>):void;
        
        public SetFloatArray($nameID: number, $values: System_Collections_Generic.List$1<number>):void;
        /**
         * Sets a float array property.
         * @param name Property name.
         * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
         * @param values Array of values to set.
         */
        public SetFloatArray($name: string, $values: number[]):void;
        /**
         * Sets a float array property.
         * @param name Property name.
         * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
         * @param values Array of values to set.
         */
        public SetFloatArray($nameID: number, $values: number[]):void;
        
        public SetColorArray($name: string, $values: System_Collections_Generic.List$1<Color>):void;
        
        public SetColorArray($nameID: number, $values: System_Collections_Generic.List$1<Color>):void;
        /**
         * Sets a color array property.
         * @param name Property name.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param values Array of values to set.
         */
        public SetColorArray($name: string, $values: Color[]):void;
        /**
         * Sets a color array property.
         * @param name Property name.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param values Array of values to set.
         */
        public SetColorArray($nameID: number, $values: Color[]):void;
        
        public SetVectorArray($name: string, $values: System_Collections_Generic.List$1<Vector4>):void;
        
        public SetVectorArray($nameID: number, $values: System_Collections_Generic.List$1<Vector4>):void;
        /**
         * Sets a vector array property.
         * @param name Property name.
         * @param values Array of values to set.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         */
        public SetVectorArray($name: string, $values: Vector4[]):void;
        /**
         * Sets a vector array property.
         * @param name Property name.
         * @param values Array of values to set.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         */
        public SetVectorArray($nameID: number, $values: Vector4[]):void;
        
        public SetMatrixArray($name: string, $values: System_Collections_Generic.List$1<Matrix4x4>):void;
        
        public SetMatrixArray($nameID: number, $values: System_Collections_Generic.List$1<Matrix4x4>):void;
        /**
         * Sets a matrix array property.
         * @param name Property name.
         * @param values Array of values to set.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         */
        public SetMatrixArray($name: string, $values: Matrix4x4[]):void;
        /**
         * Sets a matrix array property.
         * @param name Property name.
         * @param values Array of values to set.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         */
        public SetMatrixArray($nameID: number, $values: Matrix4x4[]):void;
        /**
         * Get a named float value.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public GetFloat($name: string):number;
        /**
         * Get a named float value.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public GetFloat($nameID: number):number;
        /**
         * Get a named integer value.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public GetInt($name: string):number;
        /**
         * Get a named integer value.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public GetInt($nameID: number):number;
        /**
         * Get a named color value.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public GetColor($name: string):Color;
        /**
         * Get a named color value.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public GetColor($nameID: number):Color;
        /**
         * Get a named vector value.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public GetVector($name: string):Vector4;
        /**
         * Get a named vector value.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public GetVector($nameID: number):Vector4;
        /**
         * Get a named matrix value from the shader.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public GetMatrix($name: string):Matrix4x4;
        /**
         * Get a named matrix value from the shader.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public GetMatrix($nameID: number):Matrix4x4;
        /**
         * Get a named texture.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public GetTexture($name: string):Texture;
        /**
         * Get a named texture.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public GetTexture($nameID: number):Texture;
        /**
         * Get a named float array.
         * @param name The name of the property.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         */
        public GetFloatArray($name: string):number[];
        /**
         * Get a named float array.
         * @param name The name of the property.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         */
        public GetFloatArray($nameID: number):number[];
        /**
         * Get a named color array.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public GetColorArray($name: string):Color[];
        /**
         * Get a named color array.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public GetColorArray($nameID: number):Color[];
        /**
         * Get a named vector array.
         * @param name The name of the property.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         */
        public GetVectorArray($name: string):Vector4[];
        /**
         * Get a named vector array.
         * @param name The name of the property.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         */
        public GetVectorArray($nameID: number):Vector4[];
        /**
         * Get a named matrix array.
         * @param name The name of the property.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         */
        public GetMatrixArray($name: string):Matrix4x4[];
        /**
         * Get a named matrix array.
         * @param name The name of the property.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         */
        public GetMatrixArray($nameID: number):Matrix4x4[];
        
        public GetFloatArray($name: string, $values: System_Collections_Generic.List$1<number>):void;
        
        public GetFloatArray($nameID: number, $values: System_Collections_Generic.List$1<number>):void;
        
        public GetColorArray($name: string, $values: System_Collections_Generic.List$1<Color>):void;
        
        public GetColorArray($nameID: number, $values: System_Collections_Generic.List$1<Color>):void;
        
        public GetVectorArray($name: string, $values: System_Collections_Generic.List$1<Vector4>):void;
        
        public GetVectorArray($nameID: number, $values: System_Collections_Generic.List$1<Vector4>):void;
        
        public GetMatrixArray($name: string, $values: System_Collections_Generic.List$1<Matrix4x4>):void;
        
        public GetMatrixArray($nameID: number, $values: System_Collections_Generic.List$1<Matrix4x4>):void;
        /**
         * Sets the placement offset of texture propertyName.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param name Property name, for example: "_MainTex".
         * @param value Texture placement offset.
         */
        public SetTextureOffset($name: string, $value: Vector2):void;
        /**
         * Sets the placement offset of texture propertyName.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param name Property name, for example: "_MainTex".
         * @param value Texture placement offset.
         */
        public SetTextureOffset($nameID: number, $value: Vector2):void;
        /**
         * Sets the placement scale of texture propertyName.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param name Property name, e.g. "_MainTex".
         * @param value Texture placement scale.
         */
        public SetTextureScale($name: string, $value: Vector2):void;
        /**
         * Sets the placement scale of texture propertyName.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param name Property name, e.g. "_MainTex".
         * @param value Texture placement scale.
         */
        public SetTextureScale($nameID: number, $value: Vector2):void;
        /**
         * Gets the placement offset of texture propertyName.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public GetTextureOffset($name: string):Vector2;
        /**
         * Gets the placement offset of texture propertyName.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public GetTextureOffset($nameID: number):Vector2;
        /**
         * Gets the placement scale of texture propertyName.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public GetTextureScale($name: string):Vector2;
        /**
         * Gets the placement scale of texture propertyName.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public GetTextureScale($nameID: number):Vector2;
        
        public constructor();
        
                    
    }
    /**
     * A class that allows you to create or modify meshes.
     */
    class Mesh extends Object {
        /**
         * Format of the mesh index buffer data.
         */
        public get indexFormat(): UnityEngine_Rendering.IndexFormat;
        public set indexFormat(value: UnityEngine_Rendering.IndexFormat);
        /**
         * Gets the number of vertex buffers present in the Mesh. (Read Only)
         */
        public get vertexBufferCount(): number;
        /**
         * Returns BlendShape count on this mesh.
         */
        public get blendShapeCount(): number;
        /**
         * The bind poses. The bind pose at each index refers to the bone with the same index.
         */
        public get bindposes(): Matrix4x4[];
        public set bindposes(value: Matrix4x4[]);
        /**
         * Returns true if the Mesh is read/write enabled, or false if it is not.
         */
        public get isReadable(): boolean;
        /**
         * Returns the number of vertices in the Mesh (Read Only).
         */
        public get vertexCount(): number;
        /**
         * The number of sub-meshes inside the Mesh object.
         */
        public get subMeshCount(): number;
        public set subMeshCount(value: number);
        /**
         * The bounding volume of the Mesh.
         */
        public get bounds(): Bounds;
        public set bounds(value: Bounds);
        /**
         * Returns a copy of the vertex positions or assigns a new vertex positions array.
         */
        public get vertices(): Vector3[];
        public set vertices(value: Vector3[]);
        /**
         * The normals of the Mesh.
         */
        public get normals(): Vector3[];
        public set normals(value: Vector3[]);
        /**
         * The tangents of the Mesh.
         */
        public get tangents(): Vector4[];
        public set tangents(value: Vector4[]);
        /**
         * The base texture coordinates of the Mesh.
         */
        public get uv(): Vector2[];
        public set uv(value: Vector2[]);
        /**
         * The second texture coordinate set of the mesh, if present.
         */
        public get uv2(): Vector2[];
        public set uv2(value: Vector2[]);
        /**
         * The third texture coordinate set of the mesh, if present.
         */
        public get uv3(): Vector2[];
        public set uv3(value: Vector2[]);
        /**
         * The fourth texture coordinate set of the mesh, if present.
         */
        public get uv4(): Vector2[];
        public set uv4(value: Vector2[]);
        /**
         * The fifth texture coordinate set of the mesh, if present.
         */
        public get uv5(): Vector2[];
        public set uv5(value: Vector2[]);
        /**
         * The sixth texture coordinate set of the mesh, if present.
         */
        public get uv6(): Vector2[];
        public set uv6(value: Vector2[]);
        /**
         * The seventh texture coordinate set of the mesh, if present.
         */
        public get uv7(): Vector2[];
        public set uv7(value: Vector2[]);
        /**
         * The eighth texture coordinate set of the mesh, if present.
         */
        public get uv8(): Vector2[];
        public set uv8(value: Vector2[]);
        /**
         * Vertex colors of the Mesh.
         */
        public get colors(): Color[];
        public set colors(value: Color[]);
        /**
         * Vertex colors of the Mesh.
         */
        public get colors32(): Color32[];
        public set colors32(value: Color32[]);
        /**
         * Returns the number of vertex attributes that the mesh has. (Read Only)
         */
        public get vertexAttributeCount(): number;
        /**
         * An array containing all triangles in the Mesh.
         */
        public get triangles(): number[];
        public set triangles(value: number[]);
        /**
         * The BoneWeight for each vertex in the Mesh, which represents 4 bones per vertex.
         */
        public get boneWeights(): BoneWeight[];
        public set boneWeights(value: BoneWeight[]);
        /**
         * Creates an empty Mesh.
         */
        public constructor();
        /**
         * Sets the index buffer size and format.
         * @param indexCount Size of index buffer.
         * @param format Format of the indices.
         */
        public SetIndexBufferParams($indexCount: number, $format: UnityEngine_Rendering.IndexFormat):void;
        /**
         * Returns information about a vertex attribute based on its index.
         * @param index The vertex attribute index (0 to vertexAttributeCount-1).
         * @returns Information about the vertex attribute.
         */
        public GetVertexAttribute($index: number):UnityEngine_Rendering.VertexAttributeDescriptor;
        /**
         * Checks if a specific vertex data attribute exists on this Mesh.
         * @param attr Vertex data attribute to check for.
         * @returns Returns true if the data attribute is present in the mesh.
         */
        public HasVertexAttribute($attr: UnityEngine_Rendering.VertexAttribute):boolean;
        /**
         * Get dimension of a specific vertex data attribute on this Mesh.
         * @param attr Vertex data attribute to check for.
         * @returns Dimensionality of the data attribute, or zero if it is not present.
         */
        public GetVertexAttributeDimension($attr: UnityEngine_Rendering.VertexAttribute):number;
        /**
         * Get format of a specific vertex data attribute on this Mesh.
         * @param attr Vertex data attribute to check for.
         * @returns Format of the data attribute.
         */
        public GetVertexAttributeFormat($attr: UnityEngine_Rendering.VertexAttribute):UnityEngine_Rendering.VertexAttributeFormat;
        /**
         * Retrieves a native (underlying graphics API) pointer to the vertex buffer.
         * @param bufferIndex Which vertex buffer to get (some Meshes might have more than one). See vertexBufferCount.
         * @returns Pointer to the underlying graphics API vertex buffer.
         */
        public GetNativeVertexBufferPtr($index: number):System.IntPtr;
        /**
         * Retrieves a native (underlying graphics API) pointer to the index buffer.
         * @returns Pointer to the underlying graphics API index buffer.
         */
        public GetNativeIndexBufferPtr():System.IntPtr;
        /**
         * Clears all blend shapes from Mesh.
         */
        public ClearBlendShapes():void;
        /**
         * Returns name of BlendShape by given index.
         */
        public GetBlendShapeName($shapeIndex: number):string;
        /**
         * Returns index of BlendShape by given name.
         */
        public GetBlendShapeIndex($blendShapeName: string):number;
        /**
         * Returns the frame count for a blend shape.
         * @param shapeIndex The shape index to get frame count from.
         */
        public GetBlendShapeFrameCount($shapeIndex: number):number;
        /**
         * Returns the weight of a blend shape frame.
         * @param shapeIndex The shape index of the frame.
         * @param frameIndex The frame index to get the weight from.
         */
        public GetBlendShapeFrameWeight($shapeIndex: number, $frameIndex: number):number;
        /**
         * Retreives deltaVertices, deltaNormals and deltaTangents of a blend shape frame.
         * @param shapeIndex The shape index of the frame.
         * @param frameIndex The frame index to get the weight from.
         * @param deltaVertices Delta vertices output array for the frame being retreived.
         * @param deltaNormals Delta normals output array for the frame being retreived.
         * @param deltaTangents Delta tangents output array for the frame being retreived.
         */
        public GetBlendShapeFrameVertices($shapeIndex: number, $frameIndex: number, $deltaVertices: Vector3[], $deltaNormals: Vector3[], $deltaTangents: Vector3[]):void;
        /**
         * Adds a new blend shape frame.
         * @param shapeName Name of the blend shape to add a frame to.
         * @param frameWeight Weight for the frame being added.
         * @param deltaVertices Delta vertices for the frame being added.
         * @param deltaNormals Delta normals for the frame being added.
         * @param deltaTangents Delta tangents for the frame being added.
         */
        public AddBlendShapeFrame($shapeName: string, $frameWeight: number, $deltaVertices: Vector3[], $deltaNormals: Vector3[], $deltaTangents: Vector3[]):void;
        
        public SetBoneWeights($bonesPerVertex: Unity_Collections.NativeArray$1<number>, $weights: Unity_Collections.NativeArray$1<BoneWeight1>):void;
        /**
         * Gets the bone weights for the Mesh.
         * @returns Returns all non-zero bone weights for the Mesh, in vertex index order.
         */
        public GetAllBoneWeights():Unity_Collections.NativeArray$1<BoneWeight1>;
        /**
         * The number of non-zero bone weights for each vertex.
         * @returns Returns the number of non-zero bone weights for each vertex.
         */
        public GetBonesPerVertex():Unity_Collections.NativeArray$1<number>;
        /**
         * Sets the information about a sub-mesh of the Mesh.
         * @param index Sub-mesh index. See subMeshCount. Out of range indices throw an exception.
         * @param desc Sub-mesh data.
         * @param flags Flags controlling the function behavior, see MeshUpdateFlags.
         */
        public SetSubMesh($index: number, $desc: UnityEngine_Rendering.SubMeshDescriptor, $flags?: UnityEngine_Rendering.MeshUpdateFlags):void;
        /**
         * Get information about a sub-mesh of the Mesh.
         * @param index Sub-mesh index. See subMeshCount. Out of range indices throw an exception.
         * @returns Sub-mesh data.
         */
        public GetSubMesh($index: number):UnityEngine_Rendering.SubMeshDescriptor;
        /**
         * Notify Renderer components of mesh geometry change.
         */
        public MarkModified():void;
        /**
         * The UV distribution metric can be used to calculate the desired mipmap level based on the position of the camera.
         * @param uvSetIndex UV set index to return the UV distibution metric for. 0 for first.
         * @returns Average of triangle area / uv area.
         */
        public GetUVDistributionMetric($uvSetIndex: number):number;
        
        public GetVertices($vertices: System_Collections_Generic.List$1<Vector3>):void;
        
        public SetVertices($inVertices: System_Collections_Generic.List$1<Vector3>):void;
        
        public SetVertices($inVertices: System_Collections_Generic.List$1<Vector3>, $start: number, $length: number):void;
        
        public SetVertices($inVertices: System_Collections_Generic.List$1<Vector3>, $start: number, $length: number, $flags: UnityEngine_Rendering.MeshUpdateFlags):void;
        /**
         * Assigns a new vertex positions array.
         * @param inVertices Per-vertex positions.
         */
        public SetVertices($inVertices: Vector3[]):void;
        /**
         * Sets the vertex positions of the Mesh, using a part of the input array.
         * @param inVertices Per-vertex positions.
         * @param start Index of the first element to take from the input array.
         * @param length Number of elements to take from the input array.
         * @param flags Flags controlling the function behavior, see MeshUpdateFlags.
         */
        public SetVertices($inVertices: Vector3[], $start: number, $length: number):void;
        /**
         * Sets the vertex positions of the Mesh, using a part of the input array.
         * @param inVertices Per-vertex positions.
         * @param start Index of the first element to take from the input array.
         * @param length Number of elements to take from the input array.
         * @param flags Flags controlling the function behavior, see MeshUpdateFlags.
         */
        public SetVertices($inVertices: Vector3[], $start: number, $length: number, $flags: UnityEngine_Rendering.MeshUpdateFlags):void;
        
        public SetVertices<T>($inVertices: Unity_Collections.NativeArray$1<T>):void;
        
        public SetVertices<T>($inVertices: Unity_Collections.NativeArray$1<T>, $start: number, $length: number):void;
        
        public SetVertices<T>($inVertices: Unity_Collections.NativeArray$1<T>, $start: number, $length: number, $flags: UnityEngine_Rendering.MeshUpdateFlags):void;
        
        public GetNormals($normals: System_Collections_Generic.List$1<Vector3>):void;
        
        public SetNormals($inNormals: System_Collections_Generic.List$1<Vector3>):void;
        
        public SetNormals($inNormals: System_Collections_Generic.List$1<Vector3>, $start: number, $length: number):void;
        
        public SetNormals($inNormals: System_Collections_Generic.List$1<Vector3>, $start: number, $length: number, $flags: UnityEngine_Rendering.MeshUpdateFlags):void;
        /**
         * Set the normals of the Mesh.
         * @param inNormals Per-vertex normals.
         */
        public SetNormals($inNormals: Vector3[]):void;
        /**
         * Sets the vertex normals of the Mesh, using a part of the input array.
         * @param inNormals Per-vertex normals.
         * @param start Index of the first element to take from the input array.
         * @param length Number of elements to take from the input array.
         * @param flags Flags controlling the function behavior, see MeshUpdateFlags.
         */
        public SetNormals($inNormals: Vector3[], $start: number, $length: number):void;
        /**
         * Sets the vertex normals of the Mesh, using a part of the input array.
         * @param inNormals Per-vertex normals.
         * @param start Index of the first element to take from the input array.
         * @param length Number of elements to take from the input array.
         * @param flags Flags controlling the function behavior, see MeshUpdateFlags.
         */
        public SetNormals($inNormals: Vector3[], $start: number, $length: number, $flags: UnityEngine_Rendering.MeshUpdateFlags):void;
        
        public SetNormals<T>($inNormals: Unity_Collections.NativeArray$1<T>):void;
        
        public SetNormals<T>($inNormals: Unity_Collections.NativeArray$1<T>, $start: number, $length: number):void;
        
        public SetNormals<T>($inNormals: Unity_Collections.NativeArray$1<T>, $start: number, $length: number, $flags: UnityEngine_Rendering.MeshUpdateFlags):void;
        
        public GetTangents($tangents: System_Collections_Generic.List$1<Vector4>):void;
        
        public SetTangents($inTangents: System_Collections_Generic.List$1<Vector4>):void;
        
        public SetTangents($inTangents: System_Collections_Generic.List$1<Vector4>, $start: number, $length: number):void;
        
        public SetTangents($inTangents: System_Collections_Generic.List$1<Vector4>, $start: number, $length: number, $flags: UnityEngine_Rendering.MeshUpdateFlags):void;
        /**
         * Set the tangents of the Mesh.
         * @param inTangents Per-vertex tangents.
         */
        public SetTangents($inTangents: Vector4[]):void;
        /**
         * Sets the tangents of the Mesh, using a part of the input array.
         * @param inTangents Per-vertex tangents.
         * @param start Index of the first element to take from the input array.
         * @param length Number of elements to take from the input array.
         * @param flags Flags controlling the function behavior, see MeshUpdateFlags.
         */
        public SetTangents($inTangents: Vector4[], $start: number, $length: number):void;
        /**
         * Sets the tangents of the Mesh, using a part of the input array.
         * @param inTangents Per-vertex tangents.
         * @param start Index of the first element to take from the input array.
         * @param length Number of elements to take from the input array.
         * @param flags Flags controlling the function behavior, see MeshUpdateFlags.
         */
        public SetTangents($inTangents: Vector4[], $start: number, $length: number, $flags: UnityEngine_Rendering.MeshUpdateFlags):void;
        
        public SetTangents<T>($inTangents: Unity_Collections.NativeArray$1<T>):void;
        
        public SetTangents<T>($inTangents: Unity_Collections.NativeArray$1<T>, $start: number, $length: number):void;
        
        public SetTangents<T>($inTangents: Unity_Collections.NativeArray$1<T>, $start: number, $length: number, $flags: UnityEngine_Rendering.MeshUpdateFlags):void;
        
        public GetColors($colors: System_Collections_Generic.List$1<Color>):void;
        
        public SetColors($inColors: System_Collections_Generic.List$1<Color>):void;
        
        public SetColors($inColors: System_Collections_Generic.List$1<Color>, $start: number, $length: number):void;
        
        public SetColors($inColors: System_Collections_Generic.List$1<Color>, $start: number, $length: number, $flags: UnityEngine_Rendering.MeshUpdateFlags):void;
        /**
         * Set the per-vertex colors of the Mesh.
         * @param inColors Per-vertex colors.
         */
        public SetColors($inColors: Color[]):void;
        /**
         * Sets the per-vertex colors of the Mesh, using a part of the input array.
         * @param inColors Per-vertex colors.
         * @param start Index of the first element to take from the input array.
         * @param length Number of elements to take from the input array.
         * @param flags Flags controlling the function behavior, see MeshUpdateFlags.
         */
        public SetColors($inColors: Color[], $start: number, $length: number):void;
        /**
         * Sets the per-vertex colors of the Mesh, using a part of the input array.
         * @param inColors Per-vertex colors.
         * @param start Index of the first element to take from the input array.
         * @param length Number of elements to take from the input array.
         * @param flags Flags controlling the function behavior, see MeshUpdateFlags.
         */
        public SetColors($inColors: Color[], $start: number, $length: number, $flags: UnityEngine_Rendering.MeshUpdateFlags):void;
        
        public GetColors($colors: System_Collections_Generic.List$1<Color32>):void;
        
        public SetColors($inColors: System_Collections_Generic.List$1<Color32>):void;
        
        public SetColors($inColors: System_Collections_Generic.List$1<Color32>, $start: number, $length: number):void;
        
        public SetColors($inColors: System_Collections_Generic.List$1<Color32>, $start: number, $length: number, $flags: UnityEngine_Rendering.MeshUpdateFlags):void;
        /**
         * Set the per-vertex colors of the Mesh.
         * @param inColors Per-vertex colors.
         */
        public SetColors($inColors: Color32[]):void;
        /**
         * Sets the per-vertex colors of the Mesh, using a part of the input array.
         * @param inColors Per-vertex colors.
         * @param start Index of the first element to take from the input array.
         * @param length Number of elements to take from the input array.
         * @param flags Flags controlling the function behavior, see MeshUpdateFlags.
         */
        public SetColors($inColors: Color32[], $start: number, $length: number):void;
        /**
         * Sets the per-vertex colors of the Mesh, using a part of the input array.
         * @param inColors Per-vertex colors.
         * @param start Index of the first element to take from the input array.
         * @param length Number of elements to take from the input array.
         * @param flags Flags controlling the function behavior, see MeshUpdateFlags.
         */
        public SetColors($inColors: Color32[], $start: number, $length: number, $flags: UnityEngine_Rendering.MeshUpdateFlags):void;
        
        public SetColors<T>($inColors: Unity_Collections.NativeArray$1<T>):void;
        
        public SetColors<T>($inColors: Unity_Collections.NativeArray$1<T>, $start: number, $length: number):void;
        
        public SetColors<T>($inColors: Unity_Collections.NativeArray$1<T>, $start: number, $length: number, $flags: UnityEngine_Rendering.MeshUpdateFlags):void;
        
        public SetUVs($channel: number, $uvs: System_Collections_Generic.List$1<Vector2>):void;
        
        public SetUVs($channel: number, $uvs: System_Collections_Generic.List$1<Vector3>):void;
        
        public SetUVs($channel: number, $uvs: System_Collections_Generic.List$1<Vector4>):void;
        
        public SetUVs($channel: number, $uvs: System_Collections_Generic.List$1<Vector2>, $start: number, $length: number):void;
        
        public SetUVs($channel: number, $uvs: System_Collections_Generic.List$1<Vector2>, $start: number, $length: number, $flags: UnityEngine_Rendering.MeshUpdateFlags):void;
        
        public SetUVs($channel: number, $uvs: System_Collections_Generic.List$1<Vector3>, $start: number, $length: number):void;
        
        public SetUVs($channel: number, $uvs: System_Collections_Generic.List$1<Vector3>, $start: number, $length: number, $flags: UnityEngine_Rendering.MeshUpdateFlags):void;
        
        public SetUVs($channel: number, $uvs: System_Collections_Generic.List$1<Vector4>, $start: number, $length: number):void;
        
        public SetUVs($channel: number, $uvs: System_Collections_Generic.List$1<Vector4>, $start: number, $length: number, $flags: UnityEngine_Rendering.MeshUpdateFlags):void;
        /**
         * Sets the UVs of the Mesh.
         * @param channel The UV channel, in [0..7] range. Indices start at 0, which corresponds to uv. Note that 1 corresponds to uv2.
         * @param uvs UVs to set for the given index.
         */
        public SetUVs($channel: number, $uvs: Vector2[]):void;
        /**
         * Sets the UVs of the Mesh.
         * @param channel The UV channel, in [0..7] range. Indices start at 0, which corresponds to uv. Note that 1 corresponds to uv2.
         * @param uvs UVs to set for the given index.
         */
        public SetUVs($channel: number, $uvs: Vector3[]):void;
        /**
         * Sets the UVs of the Mesh.
         * @param channel The UV channel, in [0..7] range. Indices start at 0, which corresponds to uv. Note that 1 corresponds to uv2.
         * @param uvs UVs to set for the given index.
         */
        public SetUVs($channel: number, $uvs: Vector4[]):void;
        /**
         * Sets the UVs of the Mesh, using a part of the input array.
         * @param channel The UV channel, in [0..7] range.
         * @param uvs UVs to set for the given index.
         * @param start Index of the first element to take from the input array.
         * @param length Number of elements to take from the input array.
         * @param flags Flags controlling the function behavior, see MeshUpdateFlags.
         */
        public SetUVs($channel: number, $uvs: Vector2[], $start: number, $length: number):void;
        /**
         * Sets the UVs of the Mesh, using a part of the input array.
         * @param channel The UV channel, in [0..7] range.
         * @param uvs UVs to set for the given index.
         * @param start Index of the first element to take from the input array.
         * @param length Number of elements to take from the input array.
         * @param flags Flags controlling the function behavior, see MeshUpdateFlags.
         */
        public SetUVs($channel: number, $uvs: Vector2[], $start: number, $length: number, $flags: UnityEngine_Rendering.MeshUpdateFlags):void;
        /**
         * Sets the UVs of the Mesh, using a part of the input array.
         * @param channel The UV channel, in [0..7] range.
         * @param uvs UVs to set for the given index.
         * @param start Index of the first element to take from the input array.
         * @param length Number of elements to take from the input array.
         * @param flags Flags controlling the function behavior, see MeshUpdateFlags.
         */
        public SetUVs($channel: number, $uvs: Vector3[], $start: number, $length: number):void;
        /**
         * Sets the UVs of the Mesh, using a part of the input array.
         * @param channel The UV channel, in [0..7] range.
         * @param uvs UVs to set for the given index.
         * @param start Index of the first element to take from the input array.
         * @param length Number of elements to take from the input array.
         * @param flags Flags controlling the function behavior, see MeshUpdateFlags.
         */
        public SetUVs($channel: number, $uvs: Vector3[], $start: number, $length: number, $flags: UnityEngine_Rendering.MeshUpdateFlags):void;
        /**
         * Sets the UVs of the Mesh, using a part of the input array.
         * @param channel The UV channel, in [0..7] range.
         * @param uvs UVs to set for the given index.
         * @param start Index of the first element to take from the input array.
         * @param length Number of elements to take from the input array.
         * @param flags Flags controlling the function behavior, see MeshUpdateFlags.
         */
        public SetUVs($channel: number, $uvs: Vector4[], $start: number, $length: number):void;
        /**
         * Sets the UVs of the Mesh, using a part of the input array.
         * @param channel The UV channel, in [0..7] range.
         * @param uvs UVs to set for the given index.
         * @param start Index of the first element to take from the input array.
         * @param length Number of elements to take from the input array.
         * @param flags Flags controlling the function behavior, see MeshUpdateFlags.
         */
        public SetUVs($channel: number, $uvs: Vector4[], $start: number, $length: number, $flags: UnityEngine_Rendering.MeshUpdateFlags):void;
        
        public SetUVs<T>($channel: number, $uvs: Unity_Collections.NativeArray$1<T>):void;
        
        public SetUVs<T>($channel: number, $uvs: Unity_Collections.NativeArray$1<T>, $start: number, $length: number):void;
        
        public SetUVs<T>($channel: number, $uvs: Unity_Collections.NativeArray$1<T>, $start: number, $length: number, $flags: UnityEngine_Rendering.MeshUpdateFlags):void;
        
        public GetUVs($channel: number, $uvs: System_Collections_Generic.List$1<Vector2>):void;
        
        public GetUVs($channel: number, $uvs: System_Collections_Generic.List$1<Vector3>):void;
        
        public GetUVs($channel: number, $uvs: System_Collections_Generic.List$1<Vector4>):void;
        /**
         * Get information about vertex attributes of a Mesh.
         * @returns Array of vertex attribute information.
         */
        public GetVertexAttributes():UnityEngine_Rendering.VertexAttributeDescriptor[];
        /**
         * Get information about vertex attributes of a Mesh, without memory allocations.
         * @param attributes Collection of vertex attributes to receive the results.
         * @returns The number of vertex attributes returned in the attributes container.
         */
        public GetVertexAttributes($attributes: UnityEngine_Rendering.VertexAttributeDescriptor[]):number;
        
        public GetVertexAttributes($attributes: System_Collections_Generic.List$1<UnityEngine_Rendering.VertexAttributeDescriptor>):number;
        /**
         * Sets the vertex buffer size and layout.
         * @param vertexCount The number of vertices in the Mesh.
         * @param attributes Layout of the vertex data -- which attributes are present, their data types and so on.
         */
        public SetVertexBufferParams($vertexCount: number, ...attributes: UnityEngine_Rendering.VertexAttributeDescriptor[]):void;
        
        public SetVertexBufferParams($vertexCount: number, $attributes: Unity_Collections.NativeArray$1<UnityEngine_Rendering.VertexAttributeDescriptor>):void;
        
        public SetVertexBufferData<T>($data: Unity_Collections.NativeArray$1<T>, $dataStart: number, $meshBufferStart: number, $count: number, $stream?: number, $flags?: UnityEngine_Rendering.MeshUpdateFlags):void;
        /**
         * Sets the data of the vertex buffer of the Mesh.
         * @param data Vertex data array.
         * @param dataStart The first element in the data to copy from.
         * @param meshBufferStart The first element in mesh vertex buffer to receive the data.
         * @param count Number of vertices to copy.
         * @param stream Vertex buffer stream to set data for (default 0).
         * @param flags Flags controlling the function behavior, see MeshUpdateFlags.
         */
        public SetVertexBufferData<T>($data: T[], $dataStart: number, $meshBufferStart: number, $count: number, $stream?: number, $flags?: UnityEngine_Rendering.MeshUpdateFlags):void;
        
        public SetVertexBufferData<T>($data: System_Collections_Generic.List$1<T>, $dataStart: number, $meshBufferStart: number, $count: number, $stream?: number, $flags?: UnityEngine_Rendering.MeshUpdateFlags):void;
        /**
         * Gets a snapshot of Mesh data for read-only access.
         * @param mesh The input mesh.
         * @param meshes The input meshes.
         * @returns Returns a MeshDataArray containing read-only MeshData structs. See Mesh.MeshDataArray and Mesh.MeshData.
         */
        public static AcquireReadOnlyMeshData($mesh: Mesh):UnityEngine_Mesh.MeshDataArray;
        /**
         * Gets a snapshot of Mesh data for read-only access.
         * @param mesh The input mesh.
         * @param meshes The input meshes.
         * @returns Returns a MeshDataArray containing read-only MeshData structs. See Mesh.MeshDataArray and Mesh.MeshData.
         */
        public static AcquireReadOnlyMeshData($meshes: Mesh[]):UnityEngine_Mesh.MeshDataArray;
        
        public static AcquireReadOnlyMeshData($meshes: System_Collections_Generic.List$1<Mesh>):UnityEngine_Mesh.MeshDataArray;
        /**
         * Allocates data structures for Mesh creation using C# Jobs.
         * @param meshCount The amount of meshes that will be created.
         * @returns Returns a MeshDataArray containing writeable MeshData structs. See Mesh.MeshDataArray and Mesh.MeshData.
         */
        public static AllocateWritableMeshData($meshCount: number):UnityEngine_Mesh.MeshDataArray;
        /**
         * Applies data defined in MeshData structs to Mesh objects.
         * @param data The mesh data array, see Mesh.MeshDataArray.
         * @param mesh The destination Mesh. Mesh data array must be of size 1.
         * @param meshes The destination Meshes. Must match the size of mesh data array.
         * @param flags The mesh data update flags, see MeshUpdateFlags.
         */
        public static ApplyAndDisposeWritableMeshData($data: UnityEngine_Mesh.MeshDataArray, $mesh: Mesh, $flags?: UnityEngine_Rendering.MeshUpdateFlags):void;
        /**
         * Applies data defined in MeshData structs to Mesh objects.
         * @param data The mesh data array, see Mesh.MeshDataArray.
         * @param mesh The destination Mesh. Mesh data array must be of size 1.
         * @param meshes The destination Meshes. Must match the size of mesh data array.
         * @param flags The mesh data update flags, see MeshUpdateFlags.
         */
        public static ApplyAndDisposeWritableMeshData($data: UnityEngine_Mesh.MeshDataArray, $meshes: Mesh[], $flags?: UnityEngine_Rendering.MeshUpdateFlags):void;
        
        public static ApplyAndDisposeWritableMeshData($data: UnityEngine_Mesh.MeshDataArray, $meshes: System_Collections_Generic.List$1<Mesh>, $flags?: UnityEngine_Rendering.MeshUpdateFlags):void;
        /**
         * Fetches the triangle list for the specified sub-mesh on this object.
         * @param triangles A list of vertex indices to populate.
         * @param submesh The sub-mesh index. See subMeshCount.
         * @param applyBaseVertex True (default value) will apply base vertex offset to returned indices.
         */
        public GetTriangles($submesh: number):number[];
        /**
         * Fetches the triangle list for the specified sub-mesh on this object.
         * @param triangles A list of vertex indices to populate.
         * @param submesh The sub-mesh index. See subMeshCount.
         * @param applyBaseVertex True (default value) will apply base vertex offset to returned indices.
         */
        public GetTriangles($submesh: number, $applyBaseVertex: boolean):number[];
        
        public GetTriangles($triangles: System_Collections_Generic.List$1<number>, $submesh: number):void;
        
        public GetTriangles($triangles: System_Collections_Generic.List$1<number>, $submesh: number, $applyBaseVertex: boolean):void;
        
        public GetTriangles($triangles: System_Collections_Generic.List$1<number>, $submesh: number, $applyBaseVertex?: boolean):void;
        /**
         * Fetches the index list for the specified sub-mesh.
         * @param submesh The sub-mesh index. See subMeshCount.
         * @param applyBaseVertex True (default value) will apply base vertex offset to returned indices.
         * @returns Array with face indices.
         */
        public GetIndices($submesh: number):number[];
        /**
         * Fetches the index list for the specified sub-mesh.
         * @param submesh The sub-mesh index. See subMeshCount.
         * @param applyBaseVertex True (default value) will apply base vertex offset to returned indices.
         * @returns Array with face indices.
         */
        public GetIndices($submesh: number, $applyBaseVertex: boolean):number[];
        
        public GetIndices($indices: System_Collections_Generic.List$1<number>, $submesh: number):void;
        
        public GetIndices($indices: System_Collections_Generic.List$1<number>, $submesh: number, $applyBaseVertex: boolean):void;
        
        public GetIndices($indices: System_Collections_Generic.List$1<number>, $submesh: number, $applyBaseVertex?: boolean):void;
        
        public SetIndexBufferData<T>($data: Unity_Collections.NativeArray$1<T>, $dataStart: number, $meshBufferStart: number, $count: number, $flags?: UnityEngine_Rendering.MeshUpdateFlags):void;
        /**
         * Sets the data of the index buffer of the Mesh.
         * @param data Index buffer data array.
         * @param dataStart The first element in the data to copy from.
         * @param meshBufferStart The first element in the mesh index buffer to receive the data.
         * @param count Count of indices to copy.
         * @param flags Flags controlling the function behavior, see MeshUpdateFlags.
         */
        public SetIndexBufferData<T>($data: T[], $dataStart: number, $meshBufferStart: number, $count: number, $flags?: UnityEngine_Rendering.MeshUpdateFlags):void;
        
        public SetIndexBufferData<T>($data: System_Collections_Generic.List$1<T>, $dataStart: number, $meshBufferStart: number, $count: number, $flags?: UnityEngine_Rendering.MeshUpdateFlags):void;
        /**
         * Gets the starting index location within the Mesh's index buffer, for the given sub-mesh.
         */
        public GetIndexStart($submesh: number):number;
        /**
         * Gets the index count of the given sub-mesh.
         */
        public GetIndexCount($submesh: number):number;
        /**
         * Gets the base vertex index of the given sub-mesh.
         * @param submesh The sub-mesh index. See subMeshCount.
         * @returns The offset applied to all vertex indices of this sub-mesh.
         */
        public GetBaseVertex($submesh: number):number;
        /**
         * Sets the triangle list for the sub-mesh.
         * @param triangles The list of indices that define the triangles.
         * @param submesh The sub-mesh to modify.
         * @param calculateBounds Calculate the bounding box of the Mesh after setting the triangles. This is done by default.
        Use false when you want to use the existing bounding box and reduce the CPU cost of setting the triangles.
         * @param baseVertex Optional vertex offset that is added to all triangle vertex indices.
         */
        public SetTriangles($triangles: number[], $submesh: number):void;
        /**
         * Sets the triangle list for the sub-mesh.
         * @param triangles The list of indices that define the triangles.
         * @param submesh The sub-mesh to modify.
         * @param calculateBounds Calculate the bounding box of the Mesh after setting the triangles. This is done by default.
        Use false when you want to use the existing bounding box and reduce the CPU cost of setting the triangles.
         * @param baseVertex Optional vertex offset that is added to all triangle vertex indices.
         */
        public SetTriangles($triangles: number[], $submesh: number, $calculateBounds: boolean):void;
        /**
         * Sets the triangle list for the sub-mesh.
         * @param triangles The list of indices that define the triangles.
         * @param submesh The sub-mesh to modify.
         * @param calculateBounds Calculate the bounding box of the Mesh after setting the triangles. This is done by default.
        Use false when you want to use the existing bounding box and reduce the CPU cost of setting the triangles.
         * @param baseVertex Optional vertex offset that is added to all triangle vertex indices.
         */
        public SetTriangles($triangles: number[], $submesh: number, $calculateBounds: boolean, $baseVertex: number):void;
        /**
         * Sets the triangle list of the Mesh, using a part of the input array.
         * @param triangles The list of indices that define the triangles.
         * @param trianglesStart Index of the first element to take from the input array.
         * @param trianglesLength Number of elements to take from the input array.
         * @param submesh The sub-mesh to modify.
         * @param calculateBounds Calculate the bounding box of the Mesh after setting the triangles. This is done by default.
        Use false when you want to use the existing bounding box and reduce the CPU cost of setting the triangles.
         * @param baseVertex Optional vertex offset that is added to all triangle vertex indices.
         */
        public SetTriangles($triangles: number[], $trianglesStart: number, $trianglesLength: number, $submesh: number, $calculateBounds?: boolean, $baseVertex?: number):void;
        /**
         * Sets the triangle list for the sub-mesh.
         * @param triangles The list of indices that define the triangles.
         * @param submesh The sub-mesh to modify.
         * @param calculateBounds Calculate the bounding box of the Mesh after setting the triangles. This is done by default.
        Use false when you want to use the existing bounding box and reduce the CPU cost of setting the triangles.
         * @param baseVertex Optional vertex offset that is added to all triangle vertex indices.
         */
        public SetTriangles($triangles: number[], $submesh: number, $calculateBounds?: boolean, $baseVertex?: number):void;
        /**
         * Sets the triangle list of the Mesh, using a part of the input array.
         * @param triangles The list of indices that define the triangles.
         * @param trianglesStart Index of the first element to take from the input array.
         * @param trianglesLength Number of elements to take from the input array.
         * @param submesh The sub-mesh to modify.
         * @param calculateBounds Calculate the bounding box of the Mesh after setting the triangles. This is done by default.
        Use false when you want to use the existing bounding box and reduce the CPU cost of setting the triangles.
         * @param baseVertex Optional vertex offset that is added to all triangle vertex indices.
         */
        public SetTriangles($triangles: number[], $trianglesStart: number, $trianglesLength: number, $submesh: number, $calculateBounds?: boolean, $baseVertex?: number):void;
        
        public SetTriangles($triangles: System_Collections_Generic.List$1<number>, $submesh: number):void;
        
        public SetTriangles($triangles: System_Collections_Generic.List$1<number>, $submesh: number, $calculateBounds: boolean):void;
        
        public SetTriangles($triangles: System_Collections_Generic.List$1<number>, $submesh: number, $calculateBounds: boolean, $baseVertex: number):void;
        
        public SetTriangles($triangles: System_Collections_Generic.List$1<number>, $trianglesStart: number, $trianglesLength: number, $submesh: number, $calculateBounds?: boolean, $baseVertex?: number):void;
        
        public SetTriangles($triangles: System_Collections_Generic.List$1<number>, $submesh: number, $calculateBounds?: boolean, $baseVertex?: number):void;
        
        public SetTriangles($triangles: System_Collections_Generic.List$1<number>, $trianglesStart: number, $trianglesLength: number, $submesh: number, $calculateBounds?: boolean, $baseVertex?: number):void;
        /**
         * Sets the index buffer for the sub-mesh.
         * @param indices The array of indices that define the mesh faces.
         * @param topology The topology of the Mesh, e.g: Triangles, Lines, Quads, Points, etc. See MeshTopology.
         * @param submesh The sub-mesh to modify.
         * @param calculateBounds Calculate the bounding box of the Mesh after setting the indices. This is done by default.
        Use false when you want to use the existing bounding box and reduce the CPU cost of setting the indices.
         * @param baseVertex Optional vertex offset that is added to all vertex indices.
         */
        public SetIndices($indices: number[], $topology: MeshTopology, $submesh: number):void;
        /**
         * Sets the index buffer for the sub-mesh.
         * @param indices The array of indices that define the mesh faces.
         * @param topology The topology of the Mesh, e.g: Triangles, Lines, Quads, Points, etc. See MeshTopology.
         * @param submesh The sub-mesh to modify.
         * @param calculateBounds Calculate the bounding box of the Mesh after setting the indices. This is done by default.
        Use false when you want to use the existing bounding box and reduce the CPU cost of setting the indices.
         * @param baseVertex Optional vertex offset that is added to all vertex indices.
         */
        public SetIndices($indices: number[], $topology: MeshTopology, $submesh: number, $calculateBounds: boolean):void;
        /**
         * Sets the index buffer for the sub-mesh.
         * @param indices The array of indices that define the mesh faces.
         * @param topology The topology of the Mesh, e.g: Triangles, Lines, Quads, Points, etc. See MeshTopology.
         * @param submesh The sub-mesh to modify.
         * @param calculateBounds Calculate the bounding box of the Mesh after setting the indices. This is done by default.
        Use false when you want to use the existing bounding box and reduce the CPU cost of setting the indices.
         * @param baseVertex Optional vertex offset that is added to all vertex indices.
         */
        public SetIndices($indices: number[], $topology: MeshTopology, $submesh: number, $calculateBounds: boolean, $baseVertex: number):void;
        /**
         * Sets the index buffer of a sub-mesh, using a part of the input array.
         * @param indices The array of indices that define the mesh faces.
         * @param indicesStart Index of the first element to take from the input array.
         * @param indicesLength Number of elements to take from the input array.
         * @param topology The topology of the Mesh, e.g: Triangles, Lines, Quads, Points, etc. See MeshTopology.
         * @param submesh The sub-mesh to modify.
         * @param calculateBounds Calculate the bounding box of the Mesh after setting the indices. This is done by default.
        Use false when you want to use the existing bounding box and reduce the CPU cost of setting the indices.
         * @param baseVertex Optional vertex offset that is added to all vertex indices.
         */
        public SetIndices($indices: number[], $indicesStart: number, $indicesLength: number, $topology: MeshTopology, $submesh: number, $calculateBounds?: boolean, $baseVertex?: number):void;
        /**
         * Sets the index buffer for the sub-mesh.
         * @param indices The array of indices that define the mesh faces.
         * @param topology The topology of the Mesh, e.g: Triangles, Lines, Quads, Points, etc. See MeshTopology.
         * @param submesh The sub-mesh to modify.
         * @param calculateBounds Calculate the bounding box of the Mesh after setting the indices. This is done by default.
        Use false when you want to use the existing bounding box and reduce the CPU cost of setting the indices.
         * @param baseVertex Optional vertex offset that is added to all vertex indices.
         */
        public SetIndices($indices: number[], $topology: MeshTopology, $submesh: number, $calculateBounds?: boolean, $baseVertex?: number):void;
        /**
         * Sets the index buffer of a sub-mesh, using a part of the input array.
         * @param indices The array of indices that define the mesh faces.
         * @param indicesStart Index of the first element to take from the input array.
         * @param indicesLength Number of elements to take from the input array.
         * @param topology The topology of the Mesh, e.g: Triangles, Lines, Quads, Points, etc. See MeshTopology.
         * @param submesh The sub-mesh to modify.
         * @param calculateBounds Calculate the bounding box of the Mesh after setting the indices. This is done by default.
        Use false when you want to use the existing bounding box and reduce the CPU cost of setting the indices.
         * @param baseVertex Optional vertex offset that is added to all vertex indices.
         */
        public SetIndices($indices: number[], $indicesStart: number, $indicesLength: number, $topology: MeshTopology, $submesh: number, $calculateBounds?: boolean, $baseVertex?: number):void;
        
        public SetIndices<T>($indices: Unity_Collections.NativeArray$1<T>, $topology: MeshTopology, $submesh: number, $calculateBounds?: boolean, $baseVertex?: number):void;
        
        public SetIndices<T>($indices: Unity_Collections.NativeArray$1<T>, $indicesStart: number, $indicesLength: number, $topology: MeshTopology, $submesh: number, $calculateBounds?: boolean, $baseVertex?: number):void;
        
        public SetIndices($indices: System_Collections_Generic.List$1<number>, $topology: MeshTopology, $submesh: number, $calculateBounds?: boolean, $baseVertex?: number):void;
        
        public SetIndices($indices: System_Collections_Generic.List$1<number>, $indicesStart: number, $indicesLength: number, $topology: MeshTopology, $submesh: number, $calculateBounds?: boolean, $baseVertex?: number):void;
        
        public SetIndices($indices: System_Collections_Generic.List$1<number>, $topology: MeshTopology, $submesh: number, $calculateBounds?: boolean, $baseVertex?: number):void;
        
        public SetIndices($indices: System_Collections_Generic.List$1<number>, $indicesStart: number, $indicesLength: number, $topology: MeshTopology, $submesh: number, $calculateBounds?: boolean, $baseVertex?: number):void;
        /**
         * Sets information defining all sub-meshes in this Mesh, replacing any existing sub-meshes.
         * @param desc An array or list of sub-mesh data descriptors.
         * @param start Index of the first element to take from the array or list in desc.
         * @param count Number of elements to take from the array or list in desc.
         * @param flags (Optional) Flags controlling the function behavior, see MeshUpdateFlags.
         */
        public SetSubMeshes($desc: UnityEngine_Rendering.SubMeshDescriptor[], $start: number, $count: number, $flags?: UnityEngine_Rendering.MeshUpdateFlags):void;
        /**
         * Sets information defining all sub-meshes in this Mesh, replacing any existing sub-meshes.
         * @param desc An array or list of sub-mesh data descriptors.
         * @param start Index of the first element to take from the array or list in desc.
         * @param count Number of elements to take from the array or list in desc.
         * @param flags (Optional) Flags controlling the function behavior, see MeshUpdateFlags.
         */
        public SetSubMeshes($desc: UnityEngine_Rendering.SubMeshDescriptor[], $flags?: UnityEngine_Rendering.MeshUpdateFlags):void;
        
        public SetSubMeshes($desc: System_Collections_Generic.List$1<UnityEngine_Rendering.SubMeshDescriptor>, $start: number, $count: number, $flags?: UnityEngine_Rendering.MeshUpdateFlags):void;
        
        public SetSubMeshes($desc: System_Collections_Generic.List$1<UnityEngine_Rendering.SubMeshDescriptor>, $flags?: UnityEngine_Rendering.MeshUpdateFlags):void;
        
        public SetSubMeshes<T>($desc: Unity_Collections.NativeArray$1<T>, $start: number, $count: number, $flags?: UnityEngine_Rendering.MeshUpdateFlags):void;
        
        public SetSubMeshes<T>($desc: Unity_Collections.NativeArray$1<T>, $flags?: UnityEngine_Rendering.MeshUpdateFlags):void;
        
        public GetBindposes($bindposes: System_Collections_Generic.List$1<Matrix4x4>):void;
        
        public GetBoneWeights($boneWeights: System_Collections_Generic.List$1<BoneWeight>):void;
        /**
         * Clears all vertex data and all triangle indices.
         * @param keepVertexLayout True if the existing Mesh data layout should be preserved.
         */
        public Clear($keepVertexLayout: boolean):void;
        
        public Clear():void;
        
        public RecalculateBounds():void;
        
        public RecalculateNormals():void;
        
        public RecalculateTangents():void;
        /**
         * Recalculate the bounding volume of the Mesh from the vertices.
         * @param flags Flags controlling the function behavior, see MeshUpdateFlags.
         */
        public RecalculateBounds($flags: UnityEngine_Rendering.MeshUpdateFlags):void;
        /**
         * Recalculates the normals of the Mesh from the triangles and vertices.
         * @param flags Flags controlling the function behavior, see MeshUpdateFlags.
         */
        public RecalculateNormals($flags: UnityEngine_Rendering.MeshUpdateFlags):void;
        /**
         * Recalculates the tangents of the Mesh from the normals and texture coordinates.
         * @param flags Flags controlling the function behavior, see MeshUpdateFlags.
         */
        public RecalculateTangents($flags: UnityEngine_Rendering.MeshUpdateFlags):void;
        /**
         * Recalculates the UV distribution metric of the Mesh from the vertices and uv coordinates.
         * @param uvSetIndex The UV set index to set the UV distibution metric for. Use 0 for first index.
         * @param uvAreaThreshold The minimum UV area to consider. The default value is 1e-9f.
         */
        public RecalculateUVDistributionMetric($uvSetIndex: number, $uvAreaThreshold?: number):void;
        /**
         * Recalculates the UV distribution metrics of the Mesh from the vertices and uv coordinates.
         * @param uvAreaThreshold The minimum UV area to consider. The default value is 1e-9f.
         */
        public RecalculateUVDistributionMetrics($uvAreaThreshold?: number):void;
        /**
         * Optimize mesh for frequent updates.
         */
        public MarkDynamic():void;
        /**
         * Upload previously done Mesh modifications to the graphics API.
         * @param markNoLongerReadable Frees up system memory copy of mesh data when set to true.
         */
        public UploadMeshData($markNoLongerReadable: boolean):void;
        /**
         * Optimizes the Mesh data to improve rendering performance.
         */
        public Optimize():void;
        /**
         * Optimizes the geometry of the Mesh to improve rendering performance.
         */
        public OptimizeIndexBuffers():void;
        /**
         * Optimizes the vertices of the Mesh to improve rendering performance.
         */
        public OptimizeReorderVertexBuffer():void;
        /**
         * Gets the topology of a sub-mesh.
         */
        public GetTopology($submesh: number):MeshTopology;
        /**
         * Combines several Meshes into this Mesh.
         * @param combine Descriptions of the Meshes to combine.
         * @param mergeSubMeshes Defines whether Meshes should be combined into a single sub-mesh.
         * @param useMatrices Defines whether the transforms supplied in the CombineInstance array should be used or ignored.
         */
        public CombineMeshes($combine: CombineInstance[], $mergeSubMeshes: boolean, $useMatrices: boolean, $hasLightmapData: boolean):void;
        /**
         * Combines several Meshes into this Mesh.
         * @param combine Descriptions of the Meshes to combine.
         * @param mergeSubMeshes Defines whether Meshes should be combined into a single sub-mesh.
         * @param useMatrices Defines whether the transforms supplied in the CombineInstance array should be used or ignored.
         */
        public CombineMeshes($combine: CombineInstance[], $mergeSubMeshes: boolean, $useMatrices: boolean):void;
        /**
         * Combines several Meshes into this Mesh.
         * @param combine Descriptions of the Meshes to combine.
         * @param mergeSubMeshes Defines whether Meshes should be combined into a single sub-mesh.
         * @param useMatrices Defines whether the transforms supplied in the CombineInstance array should be used or ignored.
         */
        public CombineMeshes($combine: CombineInstance[], $mergeSubMeshes: boolean):void;
        /**
         * Combines several Meshes into this Mesh.
         * @param combine Descriptions of the Meshes to combine.
         * @param mergeSubMeshes Defines whether Meshes should be combined into a single sub-mesh.
         * @param useMatrices Defines whether the transforms supplied in the CombineInstance array should be used or ignored.
         */
        public CombineMeshes($combine: CombineInstance[]):void;
        
                    
    }
    /**
     * A Camera is a device through which the player views the world.
     */
    class Camera extends Behaviour {
        /**
         * Delegate that you can use to execute custom code before a Camera culls the scene.
         */
        public static onPreCull: UnityEngine_Camera.CameraCallback;
        /**
         * Delegate that you can use to execute custom code before a Camera renders the scene.
         */
        public static onPreRender: UnityEngine_Camera.CameraCallback;
        /**
         * Delegate that you can use to execute custom code after a Camera renders the scene.
         */
        public static onPostRender: UnityEngine_Camera.CameraCallback;
        /**
         * The distance of the near clipping plane from the the Camera, in world units.
         */
        public get nearClipPlane(): number;
        public set nearClipPlane(value: number);
        /**
         * The distance of the far clipping plane from the Camera, in world units.
         */
        public get farClipPlane(): number;
        public set farClipPlane(value: number);
        /**
         * The field of view of the camera in degrees.
         */
        public get fieldOfView(): number;
        public set fieldOfView(value: number);
        /**
         * The rendering path that should be used, if possible.
         */
        public get renderingPath(): RenderingPath;
        public set renderingPath(value: RenderingPath);
        /**
         * The rendering path that is currently being used (Read Only).
         */
        public get actualRenderingPath(): RenderingPath;
        /**
         * High dynamic range rendering.
         */
        public get allowHDR(): boolean;
        public set allowHDR(value: boolean);
        /**
         * MSAA rendering.
         */
        public get allowMSAA(): boolean;
        public set allowMSAA(value: boolean);
        /**
         * Dynamic Resolution Scaling.
         */
        public get allowDynamicResolution(): boolean;
        public set allowDynamicResolution(value: boolean);
        /**
         * Should camera rendering be forced into a RenderTexture.
         */
        public get forceIntoRenderTexture(): boolean;
        public set forceIntoRenderTexture(value: boolean);
        /**
         * Camera's half-size when in orthographic mode.
         */
        public get orthographicSize(): number;
        public set orthographicSize(value: number);
        /**
         * Is the camera orthographic (true) or perspective (false)?
         */
        public get orthographic(): boolean;
        public set orthographic(value: boolean);
        /**
         * Opaque object sorting mode.
         */
        public get opaqueSortMode(): UnityEngine_Rendering.OpaqueSortMode;
        public set opaqueSortMode(value: UnityEngine_Rendering.OpaqueSortMode);
        /**
         * Transparent object sorting mode.
         */
        public get transparencySortMode(): TransparencySortMode;
        public set transparencySortMode(value: TransparencySortMode);
        /**
         * An axis that describes the direction along which the distances of objects are measured for the purpose of sorting.
         */
        public get transparencySortAxis(): Vector3;
        public set transparencySortAxis(value: Vector3);
        /**
         * Camera's depth in the camera rendering order.
         */
        public get depth(): number;
        public set depth(value: number);
        /**
         * The aspect ratio (width divided by height).
         */
        public get aspect(): number;
        public set aspect(value: number);
        /**
         * Get the world-space speed of the camera (Read Only).
         */
        public get velocity(): Vector3;
        /**
         * This is used to render parts of the Scene selectively.
         */
        public get cullingMask(): number;
        public set cullingMask(value: number);
        /**
         * Mask to select which layers can trigger events on the camera.
         */
        public get eventMask(): number;
        public set eventMask(value: number);
        /**
         * How to perform per-layer culling for a Camera.
         */
        public get layerCullSpherical(): boolean;
        public set layerCullSpherical(value: boolean);
        /**
         * Identifies what kind of camera this is, using the CameraType enum.
         */
        public get cameraType(): CameraType;
        public set cameraType(value: CameraType);
        /**
         * Sets the culling maks used to determine which objects from which Scenes to draw.
         * See EditorSceneManager.SetSceneCullingMask.
         */
        public get overrideSceneCullingMask(): bigint;
        public set overrideSceneCullingMask(value: bigint);
        /**
         * Per-layer culling distances.
         */
        public get layerCullDistances(): number[];
        public set layerCullDistances(value: number[]);
        /**
         * Whether or not the Camera will use occlusion culling during rendering.
         */
        public get useOcclusionCulling(): boolean;
        public set useOcclusionCulling(value: boolean);
        /**
         * Sets a custom matrix for the camera to use for all culling queries.
         */
        public get cullingMatrix(): Matrix4x4;
        public set cullingMatrix(value: Matrix4x4);
        /**
         * The color with which the screen will be cleared.
         */
        public get backgroundColor(): Color;
        public set backgroundColor(value: Color);
        /**
         * How the camera clears the background.
         */
        public get clearFlags(): CameraClearFlags;
        public set clearFlags(value: CameraClearFlags);
        /**
         * How and if camera generates a depth texture.
         */
        public get depthTextureMode(): DepthTextureMode;
        public set depthTextureMode(value: DepthTextureMode);
        /**
         * Should the camera clear the stencil buffer after the deferred light pass?
         */
        public get clearStencilAfterLightingPass(): boolean;
        public set clearStencilAfterLightingPass(value: boolean);
        /**
         * Enable [UsePhysicalProperties] to use physical camera properties to compute the field of view and the frustum.
         */
        public get usePhysicalProperties(): boolean;
        public set usePhysicalProperties(value: boolean);
        /**
         * The size of the camera sensor, expressed in millimeters.
         */
        public get sensorSize(): Vector2;
        public set sensorSize(value: Vector2);
        /**
         * The lens offset of the camera. The lens shift is relative to the sensor size. For example, a lens shift of 0.5 offsets the sensor by half its horizontal size.
         */
        public get lensShift(): Vector2;
        public set lensShift(value: Vector2);
        /**
         * The camera focal length, expressed in millimeters. To use this property, enable UsePhysicalProperties.
         */
        public get focalLength(): number;
        public set focalLength(value: number);
        /**
         * There are two gates for a camera, the sensor gate and the resolution gate. The physical camera sensor gate is defined by the sensorSize property, the resolution gate is defined by the render target area.
         */
        public get gateFit(): UnityEngine_Camera.GateFitMode;
        public set gateFit(value: UnityEngine_Camera.GateFitMode);
        /**
         * Where on the screen is the camera rendered in normalized coordinates.
         */
        public get rect(): Rect;
        public set rect(value: Rect);
        /**
         * Where on the screen is the camera rendered in pixel coordinates.
         */
        public get pixelRect(): Rect;
        public set pixelRect(value: Rect);
        /**
         * How wide is the camera in pixels (not accounting for dynamic resolution scaling) (Read Only).
         */
        public get pixelWidth(): number;
        /**
         * How tall is the camera in pixels (not accounting for dynamic resolution scaling) (Read Only).
         */
        public get pixelHeight(): number;
        /**
         * How wide is the camera in pixels (accounting for dynamic resolution scaling) (Read Only).
         */
        public get scaledPixelWidth(): number;
        /**
         * How tall is the camera in pixels (accounting for dynamic resolution scaling) (Read Only).
         */
        public get scaledPixelHeight(): number;
        /**
         * Destination render texture.
         */
        public get targetTexture(): RenderTexture;
        public set targetTexture(value: RenderTexture);
        /**
         * Gets the temporary RenderTexture target for this Camera.
         */
        public get activeTexture(): RenderTexture;
        /**
         * Set the target display for this Camera.
         */
        public get targetDisplay(): number;
        public set targetDisplay(value: number);
        /**
         * Matrix that transforms from camera space to world space (Read Only).
         */
        public get cameraToWorldMatrix(): Matrix4x4;
        /**
         * Matrix that transforms from world to camera space.
         */
        public get worldToCameraMatrix(): Matrix4x4;
        public set worldToCameraMatrix(value: Matrix4x4);
        /**
         * Set a custom projection matrix.
         */
        public get projectionMatrix(): Matrix4x4;
        public set projectionMatrix(value: Matrix4x4);
        /**
         * Get or set the raw projection matrix with no camera offset (no jittering).
         */
        public get nonJitteredProjectionMatrix(): Matrix4x4;
        public set nonJitteredProjectionMatrix(value: Matrix4x4);
        /**
         * Should the jittered matrix be used for transparency rendering?
         */
        public get useJitteredProjectionMatrixForTransparentRendering(): boolean;
        public set useJitteredProjectionMatrixForTransparentRendering(value: boolean);
        /**
         * Get the view projection matrix used on the last frame.
         */
        public get previousViewProjectionMatrix(): Matrix4x4;
        /**
         * The first enabled Camera component that is tagged "MainCamera" (Read Only).
         */
        public static get main(): Camera;
        /**
         * The camera we are currently rendering with, for low-level render control only (Read Only).
         */
        public static get current(): Camera;
        /**
         * If not null, the camera will only render the contents of the specified Scene.
         */
        public get scene(): UnityEngine_SceneManagement.Scene;
        public set scene(value: UnityEngine_SceneManagement.Scene);
        /**
         * Stereoscopic rendering.
         */
        public get stereoEnabled(): boolean;
        /**
         * The distance between the virtual eyes. Use this to query or set the current eye separation. Note that most VR devices provide this value, in which case setting the value will have no effect.
         */
        public get stereoSeparation(): number;
        public set stereoSeparation(value: number);
        /**
         * Distance to a point where virtual eyes converge.
         */
        public get stereoConvergence(): number;
        public set stereoConvergence(value: number);
        /**
         * Determines whether the stereo view matrices are suitable to allow for a single pass cull.
         */
        public get areVRStereoViewMatricesWithinSingleCullTolerance(): boolean;
        /**
         * Defines which eye of a VR display the Camera renders into.
         */
        public get stereoTargetEye(): StereoTargetEyeMask;
        public set stereoTargetEye(value: StereoTargetEyeMask);
        /**
         * Returns the eye that is currently rendering.
         * If called when stereo is not enabled it will return Camera.MonoOrStereoscopicEye.Mono.
         * If called during a camera rendering callback such as OnRenderImage it will return the currently rendering eye.
         * If called outside of a rendering callback and stereo is enabled, it will return the default eye which is Camera.MonoOrStereoscopicEye.Left.
         */
        public get stereoActiveEye(): UnityEngine_Camera.MonoOrStereoscopicEye;
        /**
         * The number of cameras in the current Scene.
         */
        public static get allCamerasCount(): number;
        /**
         * Returns all enabled cameras in the Scene.
         */
        public static get allCameras(): Camera[];
        /**
         * Number of command buffers set up on this camera (Read Only).
         */
        public get commandBufferCount(): number;
        
        public constructor();
        /**
         * Revert all camera parameters to default.
         */
        public Reset():void;
        /**
         * Resets this Camera's transparency sort settings to the default. Default transparency settings are taken from GraphicsSettings instead of directly from this Camera.
         */
        public ResetTransparencySortSettings():void;
        /**
         * Revert the aspect ratio to the screen's aspect ratio.
         */
        public ResetAspect():void;
        /**
         * Make culling queries reflect the camera's built in parameters.
         */
        public ResetCullingMatrix():void;
        /**
         * Make the camera render with shader replacement.
         */
        public SetReplacementShader($shader: Shader, $replacementTag: string):void;
        /**
         * Remove shader replacement from camera.
         */
        public ResetReplacementShader():void;
        /**
         * Retrieves the effective vertical field of view of the camera, including GateFit.
         * Fitting the sensor gate and the resolution gate has an impact on the final field of view. If the sensor gate aspect ratio is the same as the resolution gate aspect ratio or if the camera is not in physical mode, then this method returns the same value as the fieldofview property.
         * @returns Returns the effective vertical field of view.
         */
        public GetGateFittedFieldOfView():number;
        /**
         * Retrieves the effective lens offset of the camera, including GateFit.
         * Fitting the sensor gate and the resolution gate has an impact on the final obliqueness of the projection. If the sensor gate aspect ratio is the same as the resolution gate aspect ratio, then this method returns the same value as the lenshift property. If the camera is not in physical mode, then this methods returns Vector2.zero.
         * @returns Returns the effective lens shift value.
         */
        public GetGateFittedLensShift():Vector2;
        /**
         * Sets the Camera to render to the chosen buffers of one or more RenderTextures.
         * @param colorBuffer The RenderBuffer(s) to which color information will be rendered.
         * @param depthBuffer The RenderBuffer to which depth information will be rendered.
         */
        public SetTargetBuffers($colorBuffer: RenderBuffer, $depthBuffer: RenderBuffer):void;
        /**
         * Sets the Camera to render to the chosen buffers of one or more RenderTextures.
         * @param colorBuffer The RenderBuffer(s) to which color information will be rendered.
         * @param depthBuffer The RenderBuffer to which depth information will be rendered.
         */
        public SetTargetBuffers($colorBuffer: RenderBuffer[], $depthBuffer: RenderBuffer):void;
        /**
         * Make the rendering position reflect the camera's position in the Scene.
         */
        public ResetWorldToCameraMatrix():void;
        /**
         * Make the projection reflect normal camera's parameters.
         */
        public ResetProjectionMatrix():void;
        /**
         * Calculates and returns oblique near-plane projection matrix.
         * @param clipPlane Vector4 that describes a clip plane.
         * @returns Oblique near-plane projection matrix.
         */
        public CalculateObliqueMatrix($clipPlane: Vector4):Matrix4x4;
        /**
         * Transforms position from world space into screen space.
         * @param eye Optional argument that can be used to specify which eye transform to use. Default is Mono.
         */
        public WorldToScreenPoint($position: Vector3, $eye: UnityEngine_Camera.MonoOrStereoscopicEye):Vector3;
        /**
         * Transforms position from world space into viewport space.
         * @param eye Optional argument that can be used to specify which eye transform to use. Default is Mono.
         */
        public WorldToViewportPoint($position: Vector3, $eye: UnityEngine_Camera.MonoOrStereoscopicEye):Vector3;
        
        public ViewportToWorldPoint($position: Vector3, $eye: UnityEngine_Camera.MonoOrStereoscopicEye):Vector3;
        /**
         * Transforms a point from screen space into world space, where world space is defined as the coordinate system at the very top of your game's hierarchy.
         * @param position A screen space position (often mouse x, y), plus a z position for depth (for example, a camera clipping plane).
         * @param eye By default, Camera.MonoOrStereoscopicEye.Mono. Can be set to Camera.MonoOrStereoscopicEye.Left or Camera.MonoOrStereoscopicEye.Right for use in stereoscopic rendering (e.g., for VR).
         * @returns The worldspace point created by converting the screen space point at the provided distance z from the camera plane.
         */
        public ScreenToWorldPoint($position: Vector3, $eye: UnityEngine_Camera.MonoOrStereoscopicEye):Vector3;
        /**
         * Transforms position from world space into screen space.
         * @param eye Optional argument that can be used to specify which eye transform to use. Default is Mono.
         */
        public WorldToScreenPoint($position: Vector3):Vector3;
        /**
         * Transforms position from world space into viewport space.
         * @param eye Optional argument that can be used to specify which eye transform to use. Default is Mono.
         */
        public WorldToViewportPoint($position: Vector3):Vector3;
        /**
         * Transforms position from viewport space into world space.
         * @param position The 3d vector in Viewport space.
         * @returns The 3d vector in World space.
         */
        public ViewportToWorldPoint($position: Vector3):Vector3;
        /**
         * Transforms a point from screen space into world space, where world space is defined as the coordinate system at the very top of your game's hierarchy.
         * @param position A screen space position (often mouse x, y), plus a z position for depth (for example, a camera clipping plane).
         * @param eye By default, Camera.MonoOrStereoscopicEye.Mono. Can be set to Camera.MonoOrStereoscopicEye.Left or Camera.MonoOrStereoscopicEye.Right for use in stereoscopic rendering (e.g., for VR).
         * @returns The worldspace point created by converting the screen space point at the provided distance z from the camera plane.
         */
        public ScreenToWorldPoint($position: Vector3):Vector3;
        /**
         * Transforms position from screen space into viewport space.
         */
        public ScreenToViewportPoint($position: Vector3):Vector3;
        /**
         * Transforms position from viewport space into screen space.
         */
        public ViewportToScreenPoint($position: Vector3):Vector3;
        /**
         * Returns a ray going from camera through a viewport point.
         * @param eye Optional argument that can be used to specify which eye transform to use. Default is Mono.
         */
        public ViewportPointToRay($pos: Vector3, $eye: UnityEngine_Camera.MonoOrStereoscopicEye):Ray;
        /**
         * Returns a ray going from camera through a viewport point.
         * @param eye Optional argument that can be used to specify which eye transform to use. Default is Mono.
         */
        public ViewportPointToRay($pos: Vector3):Ray;
        /**
         * Returns a ray going from camera through a screen point.
         * @param eye Optional argument that can be used to specify which eye transform to use. Default is Mono.
         */
        public ScreenPointToRay($pos: Vector3, $eye: UnityEngine_Camera.MonoOrStereoscopicEye):Ray;
        /**
         * Returns a ray going from camera through a screen point.
         * @param eye Optional argument that can be used to specify which eye transform to use. Default is Mono.
         */
        public ScreenPointToRay($pos: Vector3):Ray;
        /**
         * Given viewport coordinates, calculates the view space vectors pointing to the four frustum corners at the specified camera depth.
         * @param viewport Normalized viewport coordinates to use for the frustum calculation.
         * @param z Z-depth from the camera origin at which the corners will be calculated.
         * @param eye Camera eye projection matrix to use.
         * @param outCorners Output array for the frustum corner vectors. Cannot be null and length must be >= 4.
         */
        public CalculateFrustumCorners($viewport: Rect, $z: number, $eye: UnityEngine_Camera.MonoOrStereoscopicEye, $outCorners: Vector3[]):void;
        
        public static CalculateProjectionMatrixFromPhysicalProperties($output: $Ref<Matrix4x4>, $focalLength: number, $sensorSize: Vector2, $lensShift: Vector2, $nearClip: number, $farClip: number, $gateFitParameters?: UnityEngine_Camera.GateFitParameters):void;
        /**
         * Converts focal length to field of view.
         * @param focalLength Focal length in millimeters.
         * @param sensorSize Sensor size in millimeters. Use the sensor height to get the vertical field of view. Use the sensor width to get the horizontal field of view.
         * @returns field of view in degrees.
         */
        public static FocalLengthToFieldOfView($focalLength: number, $sensorSize: number):number;
        /**
         * Converts field of view to focal length. Use either sensor height and vertical field of view or sensor width and horizontal field of view.
         * @param fieldOfView field of view in degrees.
         * @param sensorSize Sensor size in millimeters.
         * @returns Focal length in millimeters.
         */
        public static FieldOfViewToFocalLength($fieldOfView: number, $sensorSize: number):number;
        /**
         * Converts the horizontal field of view (FOV) to the vertical FOV, based on the value of the aspect ratio parameter.
         * @param horizontalFOV The horizontal FOV value in degrees.
         * @param aspectRatio The aspect ratio value used for the conversion
         */
        public static HorizontalToVerticalFieldOfView($horizontalFieldOfView: number, $aspectRatio: number):number;
        /**
         * Converts the vertical field of view (FOV) to the horizontal FOV, based on the value of the aspect ratio parameter.
         * @param verticalFieldOfView The vertical FOV value in degrees.
         * @param aspectRatio The aspect ratio value used for the conversion
         */
        public static VerticalToHorizontalFieldOfView($verticalFieldOfView: number, $aspectRatio: number):number;
        /**
         * Gets the non-jittered projection matrix of a specific left or right stereoscopic eye.
         * @param eye Specifies the stereoscopic eye whose non-jittered projection matrix needs to be returned.
         * @returns The non-jittered projection matrix of the specified stereoscopic eye.
         */
        public GetStereoNonJitteredProjectionMatrix($eye: UnityEngine_Camera.StereoscopicEye):Matrix4x4;
        /**
         * Gets the left or right view matrix of a specific stereoscopic eye.
         * @param eye Specifies the stereoscopic eye whose view matrix needs to be returned.
         * @returns The view matrix of the specified stereoscopic eye.
         */
        public GetStereoViewMatrix($eye: UnityEngine_Camera.StereoscopicEye):Matrix4x4;
        /**
         * Sets the non-jittered projection matrix, sourced from the VR SDK.
         * @param eye Specifies the stereoscopic eye whose non-jittered projection matrix will be sourced from the VR SDK.
         */
        public CopyStereoDeviceProjectionMatrixToNonJittered($eye: UnityEngine_Camera.StereoscopicEye):void;
        /**
         * Gets the projection matrix of a specific left or right stereoscopic eye.
         * @param eye Specifies the stereoscopic eye whose projection matrix needs to be returned.
         * @returns The projection matrix of the specified stereoscopic eye.
         */
        public GetStereoProjectionMatrix($eye: UnityEngine_Camera.StereoscopicEye):Matrix4x4;
        /**
         * Sets a custom projection matrix for a specific stereoscopic eye.
         * @param eye Specifies the stereoscopic eye whose projection matrix needs to be set.
         * @param matrix The matrix to be set.
         */
        public SetStereoProjectionMatrix($eye: UnityEngine_Camera.StereoscopicEye, $matrix: Matrix4x4):void;
        /**
         * Reset the camera to using the Unity computed projection matrices for all stereoscopic eyes.
         */
        public ResetStereoProjectionMatrices():void;
        /**
         * Sets a custom view matrix for a specific stereoscopic eye.
         * @param eye Specifies the stereoscopic view matrix to set.
         * @param matrix The matrix to be set.
         */
        public SetStereoViewMatrix($eye: UnityEngine_Camera.StereoscopicEye, $matrix: Matrix4x4):void;
        /**
         * Reset the camera to using the Unity computed view matrices for all stereoscopic eyes.
         */
        public ResetStereoViewMatrices():void;
        /**
         * Fills an array of Camera with the current cameras in the Scene, without allocating a new array.
         * @param cameras An array to be filled up with cameras currently in the Scene.
         */
        public static GetAllCameras($cameras: Camera[]):number;
        /**
         * Render into a static cubemap from this camera.
         * @param cubemap The cube map to render to.
         * @param faceMask A bitmask which determines which of the six faces are rendered to.
         * @returns False if rendering fails, else true.
         */
        public RenderToCubemap($cubemap: Cubemap, $faceMask: number):boolean;
        
        public RenderToCubemap($cubemap: Cubemap):boolean;
        /**
         * Render into a cubemap from this camera.
         * @param faceMask A bitfield indicating which cubemap faces should be rendered into.
         * @param cubemap The texture to render to.
         * @returns False if rendering fails, else true.
         */
        public RenderToCubemap($cubemap: RenderTexture, $faceMask: number):boolean;
        
        public RenderToCubemap($cubemap: RenderTexture):boolean;
        /**
         * Render one side of a stereoscopic 360-degree image into a cubemap from this camera.
         * @param cubemap The texture to render to.
         * @param faceMask A bitfield indicating which cubemap faces should be rendered into. Set to the integer value 63 to render all faces.
         * @param stereoEye A Camera eye corresponding to the left or right eye for stereoscopic rendering, or neither for non-stereoscopic rendering.
         * @returns False if rendering fails, else true.
         */
        public RenderToCubemap($cubemap: RenderTexture, $faceMask: number, $stereoEye: UnityEngine_Camera.MonoOrStereoscopicEye):boolean;
        /**
         * Render the camera manually.
         */
        public Render():void;
        /**
         * Render the camera with shader replacement.
         */
        public RenderWithShader($shader: Shader, $replacementTag: string):void;
        
        public RenderDontRestore():void;
        
        public SubmitRenderRequests($renderRequests: System_Collections_Generic.List$1<UnityEngine_Camera.RenderRequest>):void;
        
        public static SetupCurrent($cur: Camera):void;
        /**
         * Makes this camera's settings match other camera.
         * @param other Copy camera settings to the other camera.
         */
        public CopyFrom($other: Camera):void;
        /**
         * Remove command buffers from execution at a specified place.
         * @param evt When to execute the command buffer during rendering.
         */
        public RemoveCommandBuffers($evt: UnityEngine_Rendering.CameraEvent):void;
        /**
         * Remove all command buffers set on this camera.
         */
        public RemoveAllCommandBuffers():void;
        /**
         * Add a command buffer to be executed at a specified place.
         * @param evt When to execute the command buffer during rendering.
         * @param buffer The buffer to execute.
         */
        public AddCommandBuffer($evt: UnityEngine_Rendering.CameraEvent, $buffer: UnityEngine_Rendering.CommandBuffer):void;
        /**
         * Adds a command buffer to the GPU's async compute queues and executes that command buffer when graphics processing reaches a given point.
         * @param evt The point during the graphics processing at which this command buffer should commence on the GPU.
         * @param buffer The buffer to execute.
         * @param queueType The desired async compute queue type to execute the buffer on.
         */
        public AddCommandBufferAsync($evt: UnityEngine_Rendering.CameraEvent, $buffer: UnityEngine_Rendering.CommandBuffer, $queueType: UnityEngine_Rendering.ComputeQueueType):void;
        /**
         * Remove command buffer from execution at a specified place.
         * @param evt When to execute the command buffer during rendering.
         * @param buffer The buffer to execute.
         */
        public RemoveCommandBuffer($evt: UnityEngine_Rendering.CameraEvent, $buffer: UnityEngine_Rendering.CommandBuffer):void;
        /**
         * Get command buffers to be executed at a specified place.
         * @param evt When to execute the command buffer during rendering.
         * @returns Array of command buffers.
         */
        public GetCommandBuffers($evt: UnityEngine_Rendering.CameraEvent):UnityEngine_Rendering.CommandBuffer[];
        /**
         * Get culling parameters for a camera.
         * @param cullingParameters Resultant culling parameters.
         * @param stereoAware Generate single-pass stereo aware culling parameters.
         * @returns Flag indicating whether culling parameters are valid.
         */
        public TryGetCullingParameters($cullingParameters: $Ref<UnityEngine_Rendering.ScriptableCullingParameters>):boolean;
        /**
         * Get culling parameters for a camera.
         * @param cullingParameters Resultant culling parameters.
         * @param stereoAware Generate single-pass stereo aware culling parameters.
         * @returns Flag indicating whether culling parameters are valid.
         */
        public TryGetCullingParameters($stereoAware: boolean, $cullingParameters: $Ref<UnityEngine_Rendering.ScriptableCullingParameters>):boolean;
        
                    
    }
    /**
     * A block of material values to apply.
     */
    class MaterialPropertyBlock extends System.Object {
        /**
         * Is the material property block empty? (Read Only)
         */
        public get isEmpty(): boolean;
        
        public constructor();
        /**
         * Clear material property values.
         */
        public Clear():void;
        /**
         * Set a float property.
         * @param name The name of the property.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param value The float value to set.
         */
        public SetFloat($name: string, $value: number):void;
        /**
         * Set a float property.
         * @param name The name of the property.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param value The float value to set.
         */
        public SetFloat($nameID: number, $value: number):void;
        /**
         * Adds a property to the block. If an int property with the given name already exists, the old value is replaced.
         * @param name The name of the property.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param value The int value to set.
         */
        public SetInt($name: string, $value: number):void;
        /**
         * Adds a property to the block. If an int property with the given name already exists, the old value is replaced.
         * @param name The name of the property.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param value The int value to set.
         */
        public SetInt($nameID: number, $value: number):void;
        /**
         * Set a vector property.
         * @param name The name of the property.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param value The Vector4 value to set.
         */
        public SetVector($name: string, $value: Vector4):void;
        /**
         * Set a vector property.
         * @param name The name of the property.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param value The Vector4 value to set.
         */
        public SetVector($nameID: number, $value: Vector4):void;
        /**
         * Set a color property.
         * @param name The name of the property.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param value The Color value to set.
         */
        public SetColor($name: string, $value: Color):void;
        /**
         * Set a color property.
         * @param name The name of the property.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param value The Color value to set.
         */
        public SetColor($nameID: number, $value: Color):void;
        /**
         * Set a matrix property.
         * @param name The name of the property.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param value The matrix value to set.
         */
        public SetMatrix($name: string, $value: Matrix4x4):void;
        /**
         * Set a matrix property.
         * @param name The name of the property.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param value The matrix value to set.
         */
        public SetMatrix($nameID: number, $value: Matrix4x4):void;
        /**
         * Set a buffer property.
         * @param name The name of the property.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param value The ComputeBuffer or GraphicsBuffer to set.
         */
        public SetBuffer($name: string, $value: ComputeBuffer):void;
        /**
         * Set a buffer property.
         * @param name The name of the property.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param value The ComputeBuffer or GraphicsBuffer to set.
         */
        public SetBuffer($nameID: number, $value: ComputeBuffer):void;
        /**
         * Set a buffer property.
         * @param name The name of the property.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param value The ComputeBuffer or GraphicsBuffer to set.
         */
        public SetBuffer($name: string, $value: GraphicsBuffer):void;
        /**
         * Set a buffer property.
         * @param name The name of the property.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param value The ComputeBuffer or GraphicsBuffer to set.
         */
        public SetBuffer($nameID: number, $value: GraphicsBuffer):void;
        /**
         * Set a texture property.
         * @param name The name of the property.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param value The Texture to set.
         * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
         */
        public SetTexture($name: string, $value: Texture):void;
        /**
         * Set a texture property.
         * @param name The name of the property.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param value The Texture to set.
         * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
         */
        public SetTexture($nameID: number, $value: Texture):void;
        /**
         * Set a texture property.
         * @param name The name of the property.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param value The Texture to set.
         * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
         */
        public SetTexture($name: string, $value: RenderTexture, $element: UnityEngine_Rendering.RenderTextureSubElement):void;
        /**
         * Set a texture property.
         * @param name The name of the property.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param value The Texture to set.
         * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
         */
        public SetTexture($nameID: number, $value: RenderTexture, $element: UnityEngine_Rendering.RenderTextureSubElement):void;
        /**
         * Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for the MaterialPropertyBlock.
         * @param name The name of the constant buffer to override.
         * @param value The buffer to override the constant buffer values with.
         * @param offset Offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
         * @param size The number of bytes to bind.
         * @param nameID The shader property ID of the constant buffer to override.
         */
        public SetConstantBuffer($name: string, $value: ComputeBuffer, $offset: number, $size: number):void;
        /**
         * Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for the MaterialPropertyBlock.
         * @param name The name of the constant buffer to override.
         * @param value The buffer to override the constant buffer values with.
         * @param offset Offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
         * @param size The number of bytes to bind.
         * @param nameID The shader property ID of the constant buffer to override.
         */
        public SetConstantBuffer($nameID: number, $value: ComputeBuffer, $offset: number, $size: number):void;
        /**
         * Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for the MaterialPropertyBlock.
         * @param name The name of the constant buffer to override.
         * @param value The buffer to override the constant buffer values with.
         * @param offset Offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
         * @param size The number of bytes to bind.
         * @param nameID The shader property ID of the constant buffer to override.
         */
        public SetConstantBuffer($name: string, $value: GraphicsBuffer, $offset: number, $size: number):void;
        /**
         * Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for the MaterialPropertyBlock.
         * @param name The name of the constant buffer to override.
         * @param value The buffer to override the constant buffer values with.
         * @param offset Offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
         * @param size The number of bytes to bind.
         * @param nameID The shader property ID of the constant buffer to override.
         */
        public SetConstantBuffer($nameID: number, $value: GraphicsBuffer, $offset: number, $size: number):void;
        
        public SetFloatArray($name: string, $values: System_Collections_Generic.List$1<number>):void;
        
        public SetFloatArray($nameID: number, $values: System_Collections_Generic.List$1<number>):void;
        /**
         * Set a float array property.
         * @param name The name of the property.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param values The array to set.
         */
        public SetFloatArray($name: string, $values: number[]):void;
        /**
         * Set a float array property.
         * @param name The name of the property.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param values The array to set.
         */
        public SetFloatArray($nameID: number, $values: number[]):void;
        
        public SetVectorArray($name: string, $values: System_Collections_Generic.List$1<Vector4>):void;
        
        public SetVectorArray($nameID: number, $values: System_Collections_Generic.List$1<Vector4>):void;
        /**
         * Set a vector array property.
         * @param nameID The name of the property.
         * @param values The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The array to set.
         */
        public SetVectorArray($name: string, $values: Vector4[]):void;
        /**
         * Set a vector array property.
         * @param nameID The name of the property.
         * @param values The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The array to set.
         */
        public SetVectorArray($nameID: number, $values: Vector4[]):void;
        
        public SetMatrixArray($name: string, $values: System_Collections_Generic.List$1<Matrix4x4>):void;
        
        public SetMatrixArray($nameID: number, $values: System_Collections_Generic.List$1<Matrix4x4>):void;
        /**
         * Set a matrix array property.
         * @param name The name of the property.
         * @param values The name ID of the property retrieved by Shader.PropertyToID.
         * @param nameID The array to set.
         */
        public SetMatrixArray($name: string, $values: Matrix4x4[]):void;
        /**
         * Set a matrix array property.
         * @param name The name of the property.
         * @param values The name ID of the property retrieved by Shader.PropertyToID.
         * @param nameID The array to set.
         */
        public SetMatrixArray($nameID: number, $values: Matrix4x4[]):void;
        /**
         * Get a float from the property block.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public GetFloat($name: string):number;
        /**
         * Get a float from the property block.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public GetFloat($nameID: number):number;
        /**
         * Get an int from the property block.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public GetInt($name: string):number;
        /**
         * Get an int from the property block.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public GetInt($nameID: number):number;
        /**
         * Get a vector from the property block.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public GetVector($name: string):Vector4;
        /**
         * Get a vector from the property block.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public GetVector($nameID: number):Vector4;
        /**
         * Get a color from the property block.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public GetColor($name: string):Color;
        /**
         * Get a color from the property block.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public GetColor($nameID: number):Color;
        /**
         * Get a matrix from the property block.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public GetMatrix($name: string):Matrix4x4;
        /**
         * Get a matrix from the property block.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public GetMatrix($nameID: number):Matrix4x4;
        /**
         * Get a texture from the property block.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public GetTexture($name: string):Texture;
        /**
         * Get a texture from the property block.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public GetTexture($nameID: number):Texture;
        /**
         * Get a float array from the property block.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public GetFloatArray($name: string):number[];
        /**
         * Get a float array from the property block.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public GetFloatArray($nameID: number):number[];
        /**
         * Get a vector array from the property block.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public GetVectorArray($name: string):Vector4[];
        /**
         * Get a vector array from the property block.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public GetVectorArray($nameID: number):Vector4[];
        /**
         * Get a matrix array from the property block.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public GetMatrixArray($name: string):Matrix4x4[];
        /**
         * Get a matrix array from the property block.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public GetMatrixArray($nameID: number):Matrix4x4[];
        
        public GetFloatArray($name: string, $values: System_Collections_Generic.List$1<number>):void;
        
        public GetFloatArray($nameID: number, $values: System_Collections_Generic.List$1<number>):void;
        
        public GetVectorArray($name: string, $values: System_Collections_Generic.List$1<Vector4>):void;
        
        public GetVectorArray($nameID: number, $values: System_Collections_Generic.List$1<Vector4>):void;
        
        public GetMatrixArray($name: string, $values: System_Collections_Generic.List$1<Matrix4x4>):void;
        
        public GetMatrixArray($nameID: number, $values: System_Collections_Generic.List$1<Matrix4x4>):void;
        
        public CopySHCoefficientArraysFrom($lightProbes: System_Collections_Generic.List$1<UnityEngine_Rendering.SphericalHarmonicsL2>):void;
        /**
         * This function converts and copies the entire source array into 7 Vector4 property arrays named unity_SHAr, unity_SHAg, unity_SHAb, unity_SHBr, unity_SHBg, unity_SHBb and unity_SHC for use with instanced rendering.
         * @param lightProbes The array of SH values to copy from.
         */
        public CopySHCoefficientArraysFrom($lightProbes: UnityEngine_Rendering.SphericalHarmonicsL2[]):void;
        
        public CopySHCoefficientArraysFrom($lightProbes: System_Collections_Generic.List$1<UnityEngine_Rendering.SphericalHarmonicsL2>, $sourceStart: number, $destStart: number, $count: number):void;
        /**
         * This function converts and copies the source array into 7 Vector4 property arrays named unity_SHAr, unity_SHAg, unity_SHAb, unity_SHBr, unity_SHBg, unity_SHBb and unity_SHC with the specified source and destination range for use with instanced rendering.
         * @param lightProbes The array of SH values to copy from.
         * @param sourceStart The index of the first element in the source array to copy from.
         * @param destStart The index of the first element in the destination MaterialPropertyBlock array to copy to.
         * @param count The number of elements to copy.
         */
        public CopySHCoefficientArraysFrom($lightProbes: UnityEngine_Rendering.SphericalHarmonicsL2[], $sourceStart: number, $destStart: number, $count: number):void;
        
        public CopyProbeOcclusionArrayFrom($occlusionProbes: System_Collections_Generic.List$1<Vector4>):void;
        /**
         * This function copies the entire source array into a Vector4 property array named unity_ProbesOcclusion for use with instanced rendering.
         * @param occlusionProbes The array of probe occlusion values to copy from.
         */
        public CopyProbeOcclusionArrayFrom($occlusionProbes: Vector4[]):void;
        
        public CopyProbeOcclusionArrayFrom($occlusionProbes: System_Collections_Generic.List$1<Vector4>, $sourceStart: number, $destStart: number, $count: number):void;
        /**
         * This function copies the source array into a Vector4 property array named unity_ProbesOcclusion with the specified source and destination range for use with instanced rendering.
         * @param occlusionProbes The array of probe occlusion values to copy from.
         * @param sourceStart The index of the first element in the source array to copy from.
         * @param destStart The index of the first element in the destination MaterialPropertyBlock array to copy to.
         * @param count The number of elements to copy.
         */
        public CopyProbeOcclusionArrayFrom($occlusionProbes: Vector4[], $sourceStart: number, $destStart: number, $count: number):void;
        
                    
    }
    /**
     * The Light Probe Proxy Volume component offers the possibility to use higher resolution lighting for large non-static GameObjects.
     */
    class LightProbeProxyVolume extends Behaviour {
        /**
         * Checks if Light Probe Proxy Volumes are supported.
         */
        public static get isFeatureSupported(): boolean;
        /**
         * The world-space bounding box in which the 3D grid of interpolated Light Probes is generated.
         */
        public get boundsGlobal(): Bounds;
        /**
         * The size of the bounding box in which the 3D grid of interpolated Light Probes is generated.
         */
        public get sizeCustom(): Vector3;
        public set sizeCustom(value: Vector3);
        /**
         * The local-space origin of the bounding box in which the 3D grid of interpolated Light Probes is generated.
         */
        public get originCustom(): Vector3;
        public set originCustom(value: Vector3);
        /**
         * Interpolated Light Probe density.
         */
        public get probeDensity(): number;
        public set probeDensity(value: number);
        /**
         * The 3D grid resolution on the x-axis.
         */
        public get gridResolutionX(): number;
        public set gridResolutionX(value: number);
        /**
         * The 3D grid resolution on the y-axis.
         */
        public get gridResolutionY(): number;
        public set gridResolutionY(value: number);
        /**
         * The 3D grid resolution on the z-axis.
         */
        public get gridResolutionZ(): number;
        public set gridResolutionZ(value: number);
        /**
         * The bounding box mode for generating the 3D grid of interpolated Light Probes.
         */
        public get boundingBoxMode(): UnityEngine_LightProbeProxyVolume.BoundingBoxMode;
        public set boundingBoxMode(value: UnityEngine_LightProbeProxyVolume.BoundingBoxMode);
        /**
         * The resolution mode for generating the grid of interpolated Light Probes.
         */
        public get resolutionMode(): UnityEngine_LightProbeProxyVolume.ResolutionMode;
        public set resolutionMode(value: UnityEngine_LightProbeProxyVolume.ResolutionMode);
        /**
         * The mode in which the interpolated Light Probe positions are generated.
         */
        public get probePositionMode(): UnityEngine_LightProbeProxyVolume.ProbePositionMode;
        public set probePositionMode(value: UnityEngine_LightProbeProxyVolume.ProbePositionMode);
        /**
         * Sets the way the Light Probe Proxy Volume refreshes.
         */
        public get refreshMode(): UnityEngine_LightProbeProxyVolume.RefreshMode;
        public set refreshMode(value: UnityEngine_LightProbeProxyVolume.RefreshMode);
        /**
         * Determines how many Spherical Harmonics bands will be evaluated to compute the ambient color.
         */
        public get qualityMode(): UnityEngine_LightProbeProxyVolume.QualityMode;
        public set qualityMode(value: UnityEngine_LightProbeProxyVolume.QualityMode);
        /**
         * The texture data format used by the Light Probe Proxy Volume 3D texture.
         */
        public get dataFormat(): UnityEngine_LightProbeProxyVolume.DataFormat;
        public set dataFormat(value: UnityEngine_LightProbeProxyVolume.DataFormat);
        
        public constructor();
        /**
         * Triggers an update of the Light Probe Proxy Volume.
         */
        public Update():void;
        
                    
    }
    /**
     * Topology of Mesh faces.
     */
    enum MeshTopology { Triangles = 0, Quads = 2, Lines = 3, LineStrip = 4, Points = 5 }
    /**
     * A class you can derive from if you want to create objects that don't need to be attached to game objects.
     */
    class ScriptableObject extends Object {
        
        public constructor();
        /**
         * Creates an instance of a scriptable object.
         * @param className The type of the ScriptableObject to create, as the name of the type.
         * @param type The type of the ScriptableObject to create, as a System.Type instance.
         * @returns The created ScriptableObject.
         */
        public static CreateInstance($className: string):ScriptableObject;
        /**
         * Creates an instance of a scriptable object.
         * @param className The type of the ScriptableObject to create, as the name of the type.
         * @param type The type of the ScriptableObject to create, as a System.Type instance.
         * @returns The created ScriptableObject.
         */
        public static CreateInstance($type: System.Type):ScriptableObject;
        /**
         * Creates an instance of a scriptable object.
         * @returns The created ScriptableObject.
         */
        public static CreateInstance<T extends ScriptableObject>():T;
        
                    
    }
    /**
     * Store a collection of Keyframes that can be evaluated over time.
     */
    class AnimationCurve extends System.Object {
        /**
         * All keys defined in the animation curve.
         */
        public get keys(): Keyframe[];
        public set keys(value: Keyframe[]);
        /**
         * The number of keys in the curve. (Read Only)
         */
        public get length(): number;
        /**
         * The behaviour of the animation before the first keyframe.
         */
        public get preWrapMode(): WrapMode;
        public set preWrapMode(value: WrapMode);
        /**
         * The behaviour of the animation after the last keyframe.
         */
        public get postWrapMode(): WrapMode;
        public set postWrapMode(value: WrapMode);
        /**
         * Creates an animation curve from an arbitrary number of keyframes.
         * @param keys An array of Keyframes used to define the curve.
         */
        public constructor(...keys: Keyframe[]);
        /**
         * Creates an empty animation curve.
         */
        public constructor();
        /**
         * Evaluate the curve at time.
         * @param time The time within the curve you want to evaluate (the horizontal axis in the curve graph).
         * @returns The value of the curve, at the point in time specified.
         */
        public Evaluate($time: number):number;
        /**
         * Add a new key to the curve.
         * @param time The time at which to add the key (horizontal axis in the curve graph).
         * @param value The value for the key (vertical axis in the curve graph).
         * @returns The index of the added key, or -1 if the key could not be added.
         */
        public AddKey($time: number, $value: number):number;
        /**
         * Add a new key to the curve.
         * @param key The key to add to the curve.
         * @returns The index of the added key, or -1 if the key could not be added.
         */
        public AddKey($key: Keyframe):number;
        /**
         * Removes the keyframe at index and inserts key.
         * @param index The index of the key to move.
         * @param key The key (with its new time) to insert.
         * @returns The index of the keyframe after moving it.
         */
        public MoveKey($index: number, $key: Keyframe):number;
        /**
         * Removes a key.
         * @param index The index of the key to remove.
         */
        public RemoveKey($index: number):void;
        
        public get_Item($index: number):Keyframe;
        /**
         * Smooth the in and out tangents of the keyframe at index.
         * @param index The index of the keyframe to be smoothed.
         * @param weight The smoothing weight to apply to the keyframe's tangents.
         */
        public SmoothTangents($index: number, $weight: number):void;
        /**
         * Creates a constant "curve" starting at timeStart, ending at timeEnd and with the value value.
         * @param timeStart The start time for the constant curve.
         * @param timeEnd The start time for the constant curve.
         * @param value The value for the constant curve.
         * @returns The constant curve created from the specified values.
         */
        public static Constant($timeStart: number, $timeEnd: number, $value: number):AnimationCurve;
        /**
         * A straight Line starting at timeStart, valueStart and ending at timeEnd, valueEnd.
         * @param timeStart The start time for the linear curve.
         * @param valueStart The start value for the linear curve.
         * @param timeEnd The end time for the linear curve.
         * @param valueEnd The end value for the linear curve.
         * @returns The linear curve created from the specified values.
         */
        public static Linear($timeStart: number, $valueStart: number, $timeEnd: number, $valueEnd: number):AnimationCurve;
        /**
         * Creates an ease-in and out curve starting at timeStart, valueStart and ending at timeEnd, valueEnd.
         * @param timeStart The start time for the ease curve.
         * @param valueStart The start value for the ease curve.
         * @param timeEnd The end time for the ease curve.
         * @param valueEnd The end value for the ease curve.
         * @returns The ease-in and out curve generated from the specified values.
         */
        public static EaseInOut($timeStart: number, $valueStart: number, $timeEnd: number, $valueEnd: number):AnimationCurve;
        
        public Equals($o: any):boolean;
        
        public Equals($other: AnimationCurve):boolean;
        
        public GetHashCode():number;
        
                    
    }
    /**
     * A single keyframe that can be injected into an animation curve.
     */
    class Keyframe extends System.ValueType {
        /**
         * The time of the keyframe.
         */
        public get time(): number;
        public set time(value: number);
        /**
         * The value of the curve at keyframe.
         */
        public get value(): number;
        public set value(value: number);
        /**
         * Sets the incoming tangent for this key. The incoming tangent affects the slope of the curve from the previous key to this key.
         */
        public get inTangent(): number;
        public set inTangent(value: number);
        /**
         * Sets the outgoing tangent for this key. The outgoing tangent affects the slope of the curve from this key to the next key.
         */
        public get outTangent(): number;
        public set outTangent(value: number);
        /**
         * Sets the incoming weight for this key. The incoming weight affects the slope of the curve from the previous key to this key.
         */
        public get inWeight(): number;
        public set inWeight(value: number);
        /**
         * Sets the outgoing weight for this key. The outgoing weight affects the slope of the curve from this key to the next key.
         */
        public get outWeight(): number;
        public set outWeight(value: number);
        /**
         * Weighted mode for the keyframe.
         */
        public get weightedMode(): WeightedMode;
        public set weightedMode(value: WeightedMode);
        /**
         * Create a keyframe.
         */
        public constructor($time: number, $value: number);
        /**
         * Create a keyframe.
         */
        public constructor($time: number, $value: number, $inTangent: number, $outTangent: number);
        /**
         * Create a keyframe.
         */
        public constructor($time: number, $value: number, $inTangent: number, $outTangent: number, $inWeight: number, $outWeight: number);
        
        public get_Clone(): Keyframe;            
    }
    /**
     * Determines how time is treated outside of the keyframed range of an AnimationClip or AnimationCurve.
     */
    enum WrapMode { Once = 1, Loop = 2, PingPong = 4, Default = 0, ClampForever = 8, Clamp = 1 }
    /**
     * Representation of RGBA colors in 32 bit format.
     */
    class Color32 extends System.ValueType {
        /**
         * Red component of the color.
         */
        public r: number;
        /**
         * Green component of the color.
         */
        public g: number;
        /**
         * Blue component of the color.
         */
        public b: number;
        /**
         * Alpha component of the color.
         */
        public a: number;
        /**
         * Constructs a new Color32 with given r, g, b, a components.
         */
        public constructor($r: number, $g: number, $b: number, $a: number);
        
        public static op_Implicit($c: Color):Color32;
        
        public static op_Implicit($c: Color32):Color;
        /**
         * Linearly interpolates between colors a and b by t.
         */
        public static Lerp($a: Color32, $b: Color32, $t: number):Color32;
        /**
         * Linearly interpolates between colors a and b by t.
         */
        public static LerpUnclamped($a: Color32, $b: Color32, $t: number):Color32;
        
        public get_Item($index: number):number;
        
        public set_Item($index: number, $value: number):void;
        /**
         * Returns a formatted string for this color.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        public ToString():string;
        /**
         * Returns a formatted string for this color.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        public ToString($format: string):string;
        /**
         * Returns a formatted string for this color.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        public ToString($format: string, $formatProvider: System.IFormatProvider):string;
        
        public get_Clone(): Color32;            
    }
    /**
     * Shader scripts used for all rendering.
     */
    class Shader extends Object {
        /**
         * Shader LOD level for this shader.
         */
        public get maximumLOD(): number;
        public set maximumLOD(value: number);
        /**
         * Shader LOD level for all shaders.
         */
        public static get globalMaximumLOD(): number;
        public static set globalMaximumLOD(value: number);
        /**
         * Can this shader run on the end-users graphics card? (Read Only)
         */
        public get isSupported(): boolean;
        /**
         * Render pipeline currently in use.
         */
        public static get globalRenderPipeline(): string;
        public static set globalRenderPipeline(value: string);
        /**
         * Render queue of this shader. (Read Only)
         */
        public get renderQueue(): number;
        /**
         * Returns the number of shader passes on the active SubShader.
         */
        public get passCount(): number;
        /**
         * Finds a shader with the given name.
         */
        public static Find($name: string):Shader;
        /**
         * Set a global shader keyword.
         */
        public static EnableKeyword($keyword: string):void;
        /**
         * Unset a global shader keyword.
         */
        public static DisableKeyword($keyword: string):void;
        /**
         * Is global shader keyword enabled?
         */
        public static IsKeywordEnabled($keyword: string):boolean;
        /**
         * Prewarms all shader variants of all Shaders currently in memory.
         */
        public static WarmupAllShaders():void;
        /**
         * Gets unique identifier for a shader property name.
         * @param name Shader property name.
         * @returns Unique integer for the name.
         */
        public static PropertyToID($name: string):number;
        /**
         * Returns the dependency shader.
         * @param name The name of the dependency to query.
         */
        public GetDependency($name: string):Shader;
        /**
         * Search for the pass tag specified by tagName on the shader's active SubShader and returns the value of the tag.
         * @param passIndex The index of the pass.
         * @param tagName The name of the pass tag.
         */
        public FindPassTagValue($passIndex: number, $tagName: UnityEngine_Rendering.ShaderTagId):UnityEngine_Rendering.ShaderTagId;
        /**
         * Sets a global float property for all shaders.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public static SetGlobalFloat($name: string, $value: number):void;
        /**
         * Sets a global float property for all shaders.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public static SetGlobalFloat($nameID: number, $value: number):void;
        /**
         * Sets a global int property for all shaders.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public static SetGlobalInt($name: string, $value: number):void;
        /**
         * Sets a global int property for all shaders.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public static SetGlobalInt($nameID: number, $value: number):void;
        /**
         * Sets a global vector property for all shaders.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public static SetGlobalVector($name: string, $value: Vector4):void;
        /**
         * Sets a global vector property for all shaders.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public static SetGlobalVector($nameID: number, $value: Vector4):void;
        /**
         * Sets a global color property for all shaders.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public static SetGlobalColor($name: string, $value: Color):void;
        /**
         * Sets a global color property for all shaders.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public static SetGlobalColor($nameID: number, $value: Color):void;
        /**
         * Sets a global matrix property for all shaders.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public static SetGlobalMatrix($name: string, $value: Matrix4x4):void;
        /**
         * Sets a global matrix property for all shaders.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public static SetGlobalMatrix($nameID: number, $value: Matrix4x4):void;
        /**
         * Sets a global texture property for all shaders.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         * @param value The texture to set.
         * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
         */
        public static SetGlobalTexture($name: string, $value: Texture):void;
        /**
         * Sets a global texture property for all shaders.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         * @param value The texture to set.
         * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
         */
        public static SetGlobalTexture($nameID: number, $value: Texture):void;
        /**
         * Sets a global texture property for all shaders.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         * @param value The texture to set.
         * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
         */
        public static SetGlobalTexture($name: string, $value: RenderTexture, $element: UnityEngine_Rendering.RenderTextureSubElement):void;
        /**
         * Sets a global texture property for all shaders.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         * @param value The texture to set.
         * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
         */
        public static SetGlobalTexture($nameID: number, $value: RenderTexture, $element: UnityEngine_Rendering.RenderTextureSubElement):void;
        /**
         * Sets a global buffer property for all shaders.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         * @param value The buffer to set.
         */
        public static SetGlobalBuffer($name: string, $value: ComputeBuffer):void;
        /**
         * Sets a global buffer property for all shaders.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         * @param value The buffer to set.
         */
        public static SetGlobalBuffer($nameID: number, $value: ComputeBuffer):void;
        /**
         * Sets a global buffer property for all shaders.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         * @param value The buffer to set.
         */
        public static SetGlobalBuffer($name: string, $value: GraphicsBuffer):void;
        /**
         * Sets a global buffer property for all shaders.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         * @param value The buffer to set.
         */
        public static SetGlobalBuffer($nameID: number, $value: GraphicsBuffer):void;
        /**
         * Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for all shader types.
         * @param nameID The name ID of the constant buffer retrieved by Shader.PropertyToID.
         * @param name The name of the constant buffer to override.
         * @param value The buffer to override the constant buffer values with, or null to remove binding.
         * @param offset Offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
         * @param size The number of bytes to bind.
         */
        public static SetGlobalConstantBuffer($name: string, $value: ComputeBuffer, $offset: number, $size: number):void;
        /**
         * Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for all shader types.
         * @param nameID The name ID of the constant buffer retrieved by Shader.PropertyToID.
         * @param name The name of the constant buffer to override.
         * @param value The buffer to override the constant buffer values with, or null to remove binding.
         * @param offset Offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
         * @param size The number of bytes to bind.
         */
        public static SetGlobalConstantBuffer($nameID: number, $value: ComputeBuffer, $offset: number, $size: number):void;
        /**
         * Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for all shader types.
         * @param nameID The name ID of the constant buffer retrieved by Shader.PropertyToID.
         * @param name The name of the constant buffer to override.
         * @param value The buffer to override the constant buffer values with, or null to remove binding.
         * @param offset Offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
         * @param size The number of bytes to bind.
         */
        public static SetGlobalConstantBuffer($name: string, $value: GraphicsBuffer, $offset: number, $size: number):void;
        /**
         * Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for all shader types.
         * @param nameID The name ID of the constant buffer retrieved by Shader.PropertyToID.
         * @param name The name of the constant buffer to override.
         * @param value The buffer to override the constant buffer values with, or null to remove binding.
         * @param offset Offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
         * @param size The number of bytes to bind.
         */
        public static SetGlobalConstantBuffer($nameID: number, $value: GraphicsBuffer, $offset: number, $size: number):void;
        
        public static SetGlobalFloatArray($name: string, $values: System_Collections_Generic.List$1<number>):void;
        
        public static SetGlobalFloatArray($nameID: number, $values: System_Collections_Generic.List$1<number>):void;
        /**
         * Sets a global float array property for all shaders.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public static SetGlobalFloatArray($name: string, $values: number[]):void;
        /**
         * Sets a global float array property for all shaders.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public static SetGlobalFloatArray($nameID: number, $values: number[]):void;
        
        public static SetGlobalVectorArray($name: string, $values: System_Collections_Generic.List$1<Vector4>):void;
        
        public static SetGlobalVectorArray($nameID: number, $values: System_Collections_Generic.List$1<Vector4>):void;
        /**
         * Sets a global vector array property for all shaders.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public static SetGlobalVectorArray($name: string, $values: Vector4[]):void;
        /**
         * Sets a global vector array property for all shaders.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public static SetGlobalVectorArray($nameID: number, $values: Vector4[]):void;
        
        public static SetGlobalMatrixArray($name: string, $values: System_Collections_Generic.List$1<Matrix4x4>):void;
        
        public static SetGlobalMatrixArray($nameID: number, $values: System_Collections_Generic.List$1<Matrix4x4>):void;
        /**
         * Sets a global matrix array property for all shaders.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public static SetGlobalMatrixArray($name: string, $values: Matrix4x4[]):void;
        /**
         * Sets a global matrix array property for all shaders.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public static SetGlobalMatrixArray($nameID: number, $values: Matrix4x4[]):void;
        /**
         * Gets a global float property for all shaders previously set using SetGlobalFloat.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public static GetGlobalFloat($name: string):number;
        /**
         * Gets a global float property for all shaders previously set using SetGlobalFloat.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public static GetGlobalFloat($nameID: number):number;
        /**
         * Gets a global int property for all shaders previously set using SetGlobalInt.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public static GetGlobalInt($name: string):number;
        /**
         * Gets a global int property for all shaders previously set using SetGlobalInt.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public static GetGlobalInt($nameID: number):number;
        /**
         * Gets a global vector property for all shaders previously set using SetGlobalVector.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public static GetGlobalVector($name: string):Vector4;
        /**
         * Gets a global vector property for all shaders previously set using SetGlobalVector.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public static GetGlobalVector($nameID: number):Vector4;
        /**
         * Gets a global color property for all shaders previously set using SetGlobalColor.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public static GetGlobalColor($name: string):Color;
        /**
         * Gets a global color property for all shaders previously set using SetGlobalColor.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public static GetGlobalColor($nameID: number):Color;
        /**
         * Gets a global matrix property for all shaders previously set using SetGlobalMatrix.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public static GetGlobalMatrix($name: string):Matrix4x4;
        /**
         * Gets a global matrix property for all shaders previously set using SetGlobalMatrix.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public static GetGlobalMatrix($nameID: number):Matrix4x4;
        /**
         * Gets a global texture property for all shaders previously set using SetGlobalTexture.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public static GetGlobalTexture($name: string):Texture;
        /**
         * Gets a global texture property for all shaders previously set using SetGlobalTexture.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public static GetGlobalTexture($nameID: number):Texture;
        /**
         * Gets a global float array for all shaders previously set using SetGlobalFloatArray.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public static GetGlobalFloatArray($name: string):number[];
        /**
         * Gets a global float array for all shaders previously set using SetGlobalFloatArray.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public static GetGlobalFloatArray($nameID: number):number[];
        /**
         * Gets a global vector array for all shaders previously set using SetGlobalVectorArray.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public static GetGlobalVectorArray($name: string):Vector4[];
        /**
         * Gets a global vector array for all shaders previously set using SetGlobalVectorArray.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public static GetGlobalVectorArray($nameID: number):Vector4[];
        /**
         * Gets a global matrix array for all shaders previously set using SetGlobalMatrixArray.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public static GetGlobalMatrixArray($name: string):Matrix4x4[];
        /**
         * Gets a global matrix array for all shaders previously set using SetGlobalMatrixArray.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        public static GetGlobalMatrixArray($nameID: number):Matrix4x4[];
        
        public static GetGlobalFloatArray($name: string, $values: System_Collections_Generic.List$1<number>):void;
        
        public static GetGlobalFloatArray($nameID: number, $values: System_Collections_Generic.List$1<number>):void;
        
        public static GetGlobalVectorArray($name: string, $values: System_Collections_Generic.List$1<Vector4>):void;
        
        public static GetGlobalVectorArray($nameID: number, $values: System_Collections_Generic.List$1<Vector4>):void;
        
        public static GetGlobalMatrixArray($name: string, $values: System_Collections_Generic.List$1<Matrix4x4>):void;
        
        public static GetGlobalMatrixArray($nameID: number, $values: System_Collections_Generic.List$1<Matrix4x4>):void;
        /**
         * Returns the number of properties in this Shader.
         */
        public GetPropertyCount():number;
        /**
         * Finds the index of a shader property by its name.
         * @param propertyName The name of the shader property.
         */
        public FindPropertyIndex($propertyName: string):number;
        /**
         * Returns the name of the shader property at the specified index.
         * @param propertyIndex The index of the shader property.
         */
        public GetPropertyName($propertyIndex: number):string;
        /**
         * Returns the nameId of the shader property at the specified index.
         * @param propertyIndex The index of the shader property.
         */
        public GetPropertyNameId($propertyIndex: number):number;
        /**
         * Returns the ShaderPropertyType of the property at the specified index.
         * @param propertyIndex The index of the shader property.
         */
        public GetPropertyType($propertyIndex: number):UnityEngine_Rendering.ShaderPropertyType;
        /**
         * Returns the description string of the shader property at the specified index.
         * @param propertyIndex The index of the shader property.
         */
        public GetPropertyDescription($propertyIndex: number):string;
        /**
         * Returns the ShaderPropertyFlags of the shader property at the specified index.
         * @param propertyIndex The index of the shader property.
         */
        public GetPropertyFlags($propertyIndex: number):UnityEngine_Rendering.ShaderPropertyFlags;
        /**
         * Returns an array of strings containing attributes of the shader property at the specified index.
         * @param propertyIndex The index of the shader property.
         */
        public GetPropertyAttributes($propertyIndex: number):string[];
        /**
         * Returns the default float value of the shader property at the specified index.
         * @param propertyIndex The index of the shader property.
         */
        public GetPropertyDefaultFloatValue($propertyIndex: number):number;
        /**
         * Returns the default Vector4 value of the shader property at the specified index.
         * @param propertyIndex The index of the shader property.
         */
        public GetPropertyDefaultVectorValue($propertyIndex: number):Vector4;
        /**
         * Returns the min and max limits for a <a href="Rendering.ShaderPropertyType.Range.html">Range</a> property at the specified index.
         * @param propertyIndex The index of the shader property.
         */
        public GetPropertyRangeLimits($propertyIndex: number):Vector2;
        /**
         * Returns the TextureDimension of a <a href="Rendering.ShaderPropertyType.Texture.html">Texture</a> shader property at the specified index.
         * @param propertyIndex The index of the shader property.
         */
        public GetPropertyTextureDimension($propertyIndex: number):UnityEngine_Rendering.TextureDimension;
        /**
         * Returns the default Texture name of a <a href="Rendering.ShaderPropertyType.Texture.html">Texture</a> shader property at the specified index.
         * @param propertyIndex The index of the shader property.
         */
        public GetPropertyTextureDefaultName($propertyIndex: number):string;
        /**
         * Find the name of a texture stack a texture belongs too.
         * @param propertyIndex Index of the property.
         * @param stackName On exit, contanis the name of the stack if one was found.
         * @param layerIndex On exit, contains the stack layer index of the texture property.
         * @returns True, if a stack was found for the given texture property, false if not.
         */
        public FindTextureStack($propertyIndex: number, $stackName: $Ref<string>, $layerIndex: $Ref<number>):boolean;
        
                    
    }
    /**
     * The platform application is running. Returned by Application.platform.
     */
    enum RuntimePlatform { OSXEditor = 0, OSXPlayer = 1, WindowsPlayer = 2, OSXWebPlayer = 3, OSXDashboardPlayer = 4, WindowsWebPlayer = 5, WindowsEditor = 7, IPhonePlayer = 8, XBOX360 = 10, PS3 = 9, Android = 11, NaCl = 12, FlashPlayer = 15, LinuxPlayer = 13, LinuxEditor = 16, WebGLPlayer = 17, MetroPlayerX86 = 18, WSAPlayerX86 = 18, MetroPlayerX64 = 19, WSAPlayerX64 = 19, MetroPlayerARM = 20, WSAPlayerARM = 20, WP8Player = 21, BB10Player = 22, BlackBerryPlayer = 22, TizenPlayer = 23, PSP2 = 24, PS4 = 25, PSM = 26, XboxOne = 27, SamsungTVPlayer = 28, WiiU = 30, tvOS = 31, Switch = 32, Lumin = 33, Stadia = 34, CloudRendering = 35, GameCoreScarlett = 36, GameCoreXboxSeries = 36, GameCoreXboxOne = 37, PS5 = 38 }
    /**
     * The language the user's operating system is running in. Returned by Application.systemLanguage.
     */
    enum SystemLanguage { Afrikaans = 0, Arabic = 1, Basque = 2, Belarusian = 3, Bulgarian = 4, Catalan = 5, Chinese = 6, Czech = 7, Danish = 8, Dutch = 9, English = 10, Estonian = 11, Faroese = 12, Finnish = 13, French = 14, German = 15, Greek = 16, Hebrew = 17, Hugarian = 18, Icelandic = 19, Indonesian = 20, Italian = 21, Japanese = 22, Korean = 23, Latvian = 24, Lithuanian = 25, Norwegian = 26, Polish = 27, Portuguese = 28, Romanian = 29, Russian = 30, SerboCroatian = 31, Slovak = 32, Slovenian = 33, Spanish = 34, Swedish = 35, Thai = 36, Turkish = 37, Ukrainian = 38, Vietnamese = 39, ChineseSimplified = 40, ChineseTraditional = 41, Unknown = 42, Hungarian = 18 }
    /**
     * Priority of a thread.
     */
    enum ThreadPriority { Low = 0, BelowNormal = 1, Normal = 2, High = 4 }
    /**
     * SortingLayer allows you to set the render order of multiple sprites easily. There is always a default SortingLayer named "Default" which all sprites are added to initially. Added more SortingLayers to easily control the order of rendering of groups of sprites. Layers can be ordered before or after the default layer.
     */
    class SortingLayer extends System.ValueType {
        /**
         * This is the unique id assigned to the layer. It is not an ordered running value and it should not be used to compare with other layers to determine the sorting order.
         */
        public get id(): number;
        /**
         * Returns the name of the layer as defined in the TagManager.
         */
        public get name(): string;
        /**
         * This is the relative value that indicates the sort order of this layer relative to the other layers.
         */
        public get value(): number;
        /**
         * Returns all the layers defined in this project.
         */
        public static get layers(): SortingLayer[];
        /**
         * Returns the final sorting layer value. To determine the sorting order between the various sorting layers, use this method to retrieve the final sorting value and use CompareTo to determine the order.
         * @param id The unique value of the sorting layer as returned by any renderer's sortingLayerID property.
         * @returns The final sorting value of the layer relative to other layers.
         */
        public static GetLayerValueFromID($id: number):number;
        /**
         * Returns the final sorting layer value. See Also: GetLayerValueFromID.
         * @param name The unique value of the sorting layer as returned by any renderer's sortingLayerID property.
         * @returns The final sorting value of the layer relative to other layers.
         */
        public static GetLayerValueFromName($name: string):number;
        /**
         * Returns the id given the name. Will return 0 if an invalid name was given.
         * @param name The name of the layer.
         * @returns The unique id of the layer with name.
         */
        public static NameToID($name: string):number;
        /**
         * Returns the unique id of the layer. Will return "<unknown layer>" if an invalid id is given.
         * @param id The unique id of the layer.
         * @returns The name of the layer with id or "<unknown layer>" for invalid id.
         */
        public static IDToName($id: number):string;
        /**
         * Returns true if the id provided is a valid layer id.
         * @param id The unique id of a layer.
         * @returns True if the id provided is valid and assigned to a layer.
         */
        public static IsValid($id: number):boolean;
        
        public get_Clone(): SortingLayer;            
    }
    /**
     * Sets which weights to use when calculating curve segments.
     */
    enum WeightedMode { None = 0, In = 1, Out = 2, Both = 3 }
    /**
     * Access to application run-time data.
     */
    class Application extends System.Object {
        /**
         * Returns true when called in any kind of built Player, or when called in the Editor in Play Mode (Read Only).
         */
        public static get isPlaying(): boolean;
        /**
         * Whether the player currently has focus. Read-only.
         */
        public static get isFocused(): boolean;
        /**
         * Returns a GUID for this build (Read Only).
         */
        public static get buildGUID(): string;
        /**
         * Should the player be running when the application is in the background?
         */
        public static get runInBackground(): boolean;
        public static set runInBackground(value: boolean);
        /**
         * Returns true when Unity is launched with the -batchmode flag from the command line (Read Only).
         */
        public static get isBatchMode(): boolean;
        /**
         * Contains the path to the game data folder on the target device (Read Only).
         */
        public static get dataPath(): string;
        /**
         * The path to the StreamingAssets folder (Read Only).
         */
        public static get streamingAssetsPath(): string;
        /**
         * (Read Only) Contains the path to a persistent data directory.
         */
        public static get persistentDataPath(): string;
        /**
         * Contains the path to a temporary data / cache directory (Read Only).
         */
        public static get temporaryCachePath(): string;
        /**
         * The URL of the document. For WebGL, this a web URL. For Android, iOS, or Universal Windows Platform (UWP) this is a deep link URL. (Read Only)
         */
        public static get absoluteURL(): string;
        /**
         * The version of the Unity runtime used to play the content.
         */
        public static get unityVersion(): string;
        /**
         * Returns application version number  (Read Only).
         */
        public static get version(): string;
        /**
         * Returns the name of the store or package that installed the application (Read Only).
         */
        public static get installerName(): string;
        /**
         * Returns application identifier at runtime. On Apple platforms this is the 'bundleIdentifier' saved in the info.plist file, on Android it's the 'package' from the AndroidManifest.xml.
         */
        public static get identifier(): string;
        /**
         * Returns application install mode (Read Only).
         */
        public static get installMode(): ApplicationInstallMode;
        /**
         * Returns application running in sandbox (Read Only).
         */
        public static get sandboxType(): ApplicationSandboxType;
        /**
         * Returns application product name (Read Only).
         */
        public static get productName(): string;
        /**
         * Return application company name (Read Only).
         */
        public static get companyName(): string;
        /**
         * A unique cloud project identifier. It is unique for every project (Read Only).
         */
        public static get cloudProjectId(): string;
        /**
         * Instructs the game to try to render at a specified frame rate.
         */
        public static get targetFrameRate(): number;
        public static set targetFrameRate(value: number);
        /**
         * Returns the path to the console log file, or an empty string if the current platform does not support log files.
         */
        public static get consoleLogPath(): string;
        /**
         * Priority of background loading thread.
         */
        public static get backgroundLoadingPriority(): ThreadPriority;
        public static set backgroundLoadingPriority(value: ThreadPriority);
        /**
         * Returns false if application is altered in any way after it was built.
         */
        public static get genuine(): boolean;
        /**
         * Returns true if application integrity can be confirmed.
         */
        public static get genuineCheckAvailable(): boolean;
        /**
         * Returns the platform the game is running on (Read Only).
         */
        public static get platform(): RuntimePlatform;
        /**
         * Is the current Runtime platform a known mobile platform.
         */
        public static get isMobilePlatform(): boolean;
        /**
         * Is the current Runtime platform a known console platform.
         */
        public static get isConsolePlatform(): boolean;
        /**
         * The language the user's operating system is running in.
         */
        public static get systemLanguage(): SystemLanguage;
        /**
         * Returns the type of Internet reachability currently possible on the device.
         */
        public static get internetReachability(): NetworkReachability;
        /**
         * Are we running inside the Unity editor? (Read Only)
         */
        public static get isEditor(): boolean;
        
        public constructor();
        
        public static Quit($exitCode: number):void;
        /**
         * Quits the player application.
         * @param exitCode An optional exit code to return when the player application terminates on Windows, Mac and Linux. Defaults to 0.
         */
        public static Quit():void;
        /**
         * Unloads the Unity Player.
         */
        public static Unload():void;
        /**
         * Can the streamed level be loaded?
         */
        public static CanStreamedLevelBeLoaded($levelIndex: number):boolean;
        /**
         * Can the streamed level be loaded?
         */
        public static CanStreamedLevelBeLoaded($levelName: string):boolean;
        /**
         * Returns true if the given object is part of the playing world either in any kind of built Player or in Play Mode.
         * @param obj The object to test.
         * @returns True if the object is part of the playing world.
         */
        public static IsPlaying($obj: Object):boolean;
        /**
         * Returns an array of feature tags in use for this build.
         */
        public static GetBuildTags():string[];
        /**
         * Set an array of feature tags for this build.
         */
        public static SetBuildTags($buildTags: string[]):void;
        /**
         * Is Unity activated with the Pro license?
         */
        public static HasProLicense():boolean;
        /**
         * Request advertising ID for iOS and Windows Store.
         * @param delegateMethod Delegate method.
         * @returns Returns true if successful, or false for platforms which do not support Advertising Identifiers. In this case, the delegate method is not invoked.
         */
        public static RequestAdvertisingIdentifierAsync($delegateMethod: UnityEngine_Application.AdvertisingIdentifierCallback):boolean;
        /**
         * Opens the URL specified, subject to the permissions and limitations of your app’s current platform and environment. This is handled in different ways depending on the nature of the URL, and with different security restrictions, depending on the runtime platform.
         * @param url The URL to open.
         */
        public static OpenURL($url: string):void;
        /**
         * Get stack trace logging options. The default value is StackTraceLogType.ScriptOnly.
         */
        public static GetStackTraceLogType($logType: LogType):StackTraceLogType;
        /**
         * Set stack trace logging options. The default value is StackTraceLogType.ScriptOnly.
         */
        public static SetStackTraceLogType($logType: LogType, $stackTraceType: StackTraceLogType):void;
        /**
         * Request authorization to use the webcam or microphone on iOS.
         */
        public static RequestUserAuthorization($mode: UserAuthorization):AsyncOperation;
        /**
         * Check if the user has authorized use of the webcam or microphone in the Web Player.
         */
        public static HasUserAuthorization($mode: UserAuthorization):boolean;
        
        public static add_lowMemory($value: UnityEngine_Application.LowMemoryCallback):void;
        
        public static remove_lowMemory($value: UnityEngine_Application.LowMemoryCallback):void;
        
        public static add_logMessageReceived($value: UnityEngine_Application.LogCallback):void;
        
        public static remove_logMessageReceived($value: UnityEngine_Application.LogCallback):void;
        
        public static add_logMessageReceivedThreaded($value: UnityEngine_Application.LogCallback):void;
        
        public static remove_logMessageReceivedThreaded($value: UnityEngine_Application.LogCallback):void;
        
        public static add_onBeforeRender($value: UnityEngine_Events.UnityAction):void;
        
        public static remove_onBeforeRender($value: UnityEngine_Events.UnityAction):void;
        
        public static add_focusChanged($value: System.Action$1<boolean>):void;
        
        public static remove_focusChanged($value: System.Action$1<boolean>):void;
        
        public static add_deepLinkActivated($value: System.Action$1<string>):void;
        
        public static remove_deepLinkActivated($value: System.Action$1<string>):void;
        
        public static add_wantsToQuit($value: System.Func$1<boolean>):void;
        
        public static remove_wantsToQuit($value: System.Func$1<boolean>):void;
        
        public static add_quitting($value: System.Action):void;
        
        public static remove_quitting($value: System.Action):void;
        
        public static add_unloading($value: System.Action):void;
        
        public static remove_unloading($value: System.Action):void;
        /**
         * This event occurs when your app receives a low-memory notification from the device it is running on. This only occurs when your app is running in the foreground. You can release non-critical assets from memory (such as, textures or audio clips) in response to this in order to avoid the app being terminated. You can also load smaller versions of such assets.  Furthermore, you should serialize any transient data to permanent storage to avoid data loss if the app is terminated.
         * This event is supported on iOS, Android, and Universal Windows Platform (UWP).
         * This event corresponds to the following callbacks on the different platforms:
         * - iOS: [UIApplicationDelegate applicationDidReceiveMemoryWarning]
         * - Android: onLowMemory() and onTrimMemory(level == TRIM_MEMORY_RUNNING_CRITICAL)
         * - UWP: MemoryManager.AppMemoryUsageIncreased (AppMemoryUsageLevel == OverLimit)
         * Note: For UWP, this event will not occur on Desktop and only works on memory constrained devices, such as HoloLens and Xbox One. The OverLimit threshold specified by the OS in this case is so high it is not reasonably possible to reach it and trigger the event.
         * Here is an example of handling the callback:
         */
        public static lowMemory;
        /**
         * Event that is fired if a log message is received.
         */
        public static logMessageReceived;
        /**
         * Event that is fired if a log message is received.
         */
        public static logMessageReceivedThreaded;
        /**
         * Delegate method used to register for "Just Before Render" input updates for VR devices.
         */
        public static onBeforeRender;
        
        public static focusChanged;
        
        public static deepLinkActivated;
        
        public static wantsToQuit;
        /**
         * Unity raises this event when the player application is qutting.
         */
        public static quitting;
        /**
         * Unity raises this event when Player is unloading.
         */
        public static unloading;
        
                    
    }
    /**
     * Application installation mode (Read Only).
     */
    enum ApplicationInstallMode { Unknown = 0, Store = 1, DeveloperBuild = 2, Adhoc = 3, Enterprise = 4, Editor = 5 }
    /**
     * Application sandbox type.
     */
    enum ApplicationSandboxType { Unknown = 0, NotSandboxed = 1, Sandboxed = 2, SandboxBroken = 3 }
    /**
     * Stack trace logging options.
     */
    enum StackTraceLogType { None = 0, ScriptOnly = 1, Full = 2 }
    /**
     * Constants to pass to Application.RequestUserAuthorization.
     */
    enum UserAuthorization { WebCam = 1, Microphone = 2 }
    /**
     * Describes network reachability options.
     */
    enum NetworkReachability { NotReachable = 0, ReachableViaCarrierDataNetwork = 1, ReachableViaLocalAreaNetwork = 2 }
    /**
     * Type of the imported(native) data.
     */
    enum AudioType { UNKNOWN = 0, ACC = 1, AIFF = 2, IT = 10, MOD = 12, MPEG = 13, OGGVORBIS = 14, S3M = 17, WAV = 20, XM = 21, XMA = 22, VAG = 23, AUDIOQUEUE = 24 }
    /**
     * Data structure for downloading AssetBundles to a customized cache path. See Also:UnityWebRequestAssetBundle.GetAssetBundle for more information.
     */
    class CachedAssetBundle extends System.ValueType {
        /**
         * AssetBundle name which is used as the customized cache path.
         */
        public get name(): string;
        public set name(value: string);
        /**
         * Hash128 which is used as the version of the AssetBundle.
         */
        public get hash(): Hash128;
        public set hash(value: Hash128);
        
        public constructor($name: string, $hash: Hash128);
        
                    
    }
    /**
     * Data structure for cache. Please refer to See Also:Caching.AddCache for more information.
     */
    class Cache extends System.ValueType {
        /**
         * Returns true if the cache is valid.
         */
        public get valid(): boolean;
        /**
         * Returns true if the cache is ready.
         */
        public get ready(): boolean;
        /**
         * Returns true if the cache is readonly.
         */
        public get readOnly(): boolean;
        /**
         * Returns the path of the cache.
         */
        public get path(): string;
        /**
         * Returns the index of the cache in the cache list.
         */
        public get index(): number;
        /**
         * Returns the number of currently unused bytes in the cache.
         */
        public get spaceFree(): bigint;
        /**
         * Allows you to specify the total number of bytes that can be allocated for the cache.
         */
        public get maximumAvailableStorageSpace(): bigint;
        public set maximumAvailableStorageSpace(value: bigint);
        /**
         * Returns the used disk space in bytes.
         */
        public get spaceOccupied(): bigint;
        /**
         * The number of seconds that an AssetBundle may remain unused in the cache before it is automatically deleted.
         */
        public get expirationDelay(): number;
        public set expirationDelay(value: number);
        
        public static op_Equality($lhs: Cache, $rhs: Cache):boolean;
        
        public static op_Inequality($lhs: Cache, $rhs: Cache):boolean;
        
        public GetHashCode():number;
        
        public Equals($other: any):boolean;
        
        public Equals($other: Cache):boolean;
        /**
         * Removes all cached content in the cache that has been cached by the current application.
         * @param expiration The number of seconds that AssetBundles may remain unused in the cache.
         * @returns Returns True when cache clearing succeeded.
         */
        public ClearCache():boolean;
        /**
         * Removes all cached content in the cache that has been cached by the current application.
         * @param expiration The number of seconds that AssetBundles may remain unused in the cache.
         * @returns Returns True when cache clearing succeeded.
         */
        public ClearCache($expiration: number):boolean;
        
        public get_Clone(): Cache;            
    }
    /**
     * The Caching class lets you manage cached AssetBundles, downloaded using UnityWebRequestAssetBundle.GetAssetBundle().
     */
    class Caching extends System.Object {
        /**
         * Controls compression of cache data. Enabled by default.
         */
        public static get compressionEnabled(): boolean;
        public static set compressionEnabled(value: boolean);
        /**
         * Returns true if Caching system is ready for use.
         */
        public static get ready(): boolean;
        /**
         * Returns the cache count in the cache list.
         */
        public static get cacheCount(): number;
        /**
         * Returns the default cache which is added by Unity internally.
         */
        public static get defaultCache(): Cache;
        /**
         * Gets or sets the current cache in which AssetBundles should be cached.
         */
        public static get currentCacheForWriting(): Cache;
        public static set currentCacheForWriting(value: Cache);
        
        public constructor();
        /**
         * Removes all AssetBundle content that has been cached by the current application.
         * @param expiration The number of seconds that AssetBundles may remain unused in the cache.
         * @returns True when cache clearing succeeded, false if cache was in use.
         */
        public static ClearCache():boolean;
        /**
         * Removes all AssetBundle content that has been cached by the current application.
         * @param expiration The number of seconds that AssetBundles may remain unused in the cache.
         * @returns True when cache clearing succeeded, false if cache was in use.
         */
        public static ClearCache($expiration: number):boolean;
        /**
         * Removes the given version of the AssetBundle.
         * @param assetBundleName The AssetBundle name.
         * @param hash Version needs to be cleaned.
         * @returns Returns true when cache clearing succeeded.  Can return false if any cached bundle is in use.
         */
        public static ClearCachedVersion($assetBundleName: string, $hash: Hash128):boolean;
        /**
         * Removes all the cached versions of the AssetBundle from the cache, except for the specified version.
         * @param assetBundleName The AssetBundle name.
         * @param hash Version needs to be kept.
         * @returns Returns true when cache clearing succeeded.
         */
        public static ClearOtherCachedVersions($assetBundleName: string, $hash: Hash128):boolean;
        /**
         * Removes all the cached versions of the given AssetBundle from the cache.
         * @param assetBundleName The AssetBundle name.
         * @returns Returns true when cache clearing succeeded.
         */
        public static ClearAllCachedVersions($assetBundleName: string):boolean;
        
        public static GetCachedVersions($assetBundleName: string, $outCachedVersions: System_Collections_Generic.List$1<Hash128>):void;
        
        public static IsVersionCached($url: string, $hash: Hash128):boolean;
        
        public static IsVersionCached($cachedBundle: CachedAssetBundle):boolean;
        
        public static MarkAsUsed($url: string, $hash: Hash128):boolean;
        
        public static MarkAsUsed($cachedBundle: CachedAssetBundle):boolean;
        
        public static SetNoBackupFlag($url: string, $hash: Hash128):void;
        
        public static SetNoBackupFlag($cachedBundle: CachedAssetBundle):void;
        
        public static ResetNoBackupFlag($url: string, $hash: Hash128):void;
        
        public static ResetNoBackupFlag($cachedBundle: CachedAssetBundle):void;
        /**
         * Add a cache with the given path.
         * @param cachePath Path to the cache folder.
         */
        public static AddCache($cachePath: string):Cache;
        /**
         * Returns the Cache at the given position in the cache list.
         * @param cacheIndex Index of the cache to get.
         * @returns A reference to the Cache at the index specified.
         */
        public static GetCacheAt($cacheIndex: number):Cache;
        /**
         * Returns the Cache that has the given cache path.
         * @param cachePath The cache path.
         * @returns A reference to the Cache with the given path.
         */
        public static GetCacheByPath($cachePath: string):Cache;
        
        public static GetAllCachePaths($cachePaths: System_Collections_Generic.List$1<string>):void;
        /**
         * Removes the Cache from cache list.
         * @param cache The Cache to be removed.
         * @returns Returns true if the Cache is removed.
         */
        public static RemoveCache($cache: Cache):boolean;
        /**
         * Moves the source Cache before the destination Cache in the cache list.
         * @param src The Cache to move.
         * @param dst The Cache which should come after the source Cache in the cache list.
         */
        public static MoveCacheBefore($src: Cache, $dst: Cache):void;
        /**
         * Moves the source Cache after the destination Cache in the cache list.
         * @param src The Cache to move.
         * @param dst The Cache which should come before the source Cache in the cache list.
         */
        public static MoveCacheAfter($src: Cache, $dst: Cache):void;
        
                    
    }
    /**
     * Rendering path of a Camera.
     */
    enum RenderingPath { UsePlayerSettings = -1, VertexLit = 0, Forward = 1, DeferredLighting = 2, DeferredShading = 3 }
    /**
     * Transparent object sorting mode of a Camera.
     */
    enum TransparencySortMode { Default = 0, Perspective = 1, Orthographic = 2, CustomAxis = 3 }
    /**
     * Describes different types of camera.
     */
    enum CameraType { Game = 1, SceneView = 2, Preview = 4, VR = 8, Reflection = 16 }
    /**
     * Values for Camera.clearFlags, determining what to clear when rendering a Camera.
     */
    enum CameraClearFlags { Skybox = 1, Color = 2, SolidColor = 2, Depth = 3, Nothing = 4 }
    /**
     * Depth texture generation mode for Camera.
     */
    enum DepthTextureMode { None = 0, Depth = 1, DepthNormals = 2, MotionVectors = 4 }
    /**
     * Representation of rays.
     */
    class Ray extends System.ValueType {
        /**
         * The origin point of the ray.
         */
        public get origin(): Vector3;
        public set origin(value: Vector3);
        /**
         * The direction of the ray.
         */
        public get direction(): Vector3;
        public set direction(value: Vector3);
        /**
         * Creates a ray starting at origin along direction.
         */
        public constructor($origin: Vector3, $direction: Vector3);
        /**
         * Returns a point at distance units along the ray.
         */
        public GetPoint($distance: number):Vector3;
        /**
         * Returns a formatted string for this ray.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        public ToString():string;
        /**
         * Returns a formatted string for this ray.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        public ToString($format: string):string;
        /**
         * Returns a formatted string for this ray.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        public ToString($format: string, $formatProvider: System.IFormatProvider):string;
        
        public get_Clone(): Ray;            
    }
    /**
     * Enum values for the Camera's targetEye property.
     */
    enum StereoTargetEyeMask { None = 0, Left = 1, Right = 2, Both = 3 }
    /**
     * Class for handling cube maps, Use this to create or modify existing.
     */
    class Cubemap extends Texture {
        /**
         * The format of the pixel data in the texture (Read Only).
         */
        public get format(): TextureFormat;
        
        public get isReadable(): boolean;
        /**
         * Determines whether mipmap streaming is enabled for this Texture.
         */
        public get streamingMipmaps(): boolean;
        /**
         * Sets the relative priority for this Texture when reducing memory size to fit within the memory budget.
         */
        public get streamingMipmapsPriority(): number;
        /**
         * The mipmap level to load.
         */
        public get requestedMipmapLevel(): number;
        public set requestedMipmapLevel(value: number);
        /**
         * The mipmap level that the streaming system would load before memory budgets are applied.
         */
        public get desiredMipmapLevel(): number;
        /**
         * The mipmap level that the mipmap streaming system is in the process of loading.
         */
        public get loadingMipmapLevel(): number;
        /**
         * The mipmap level that is currently loaded by the streaming system.
         */
        public get loadedMipmapLevel(): number;
        
        public constructor($width: number, $format: UnityEngine_Experimental_Rendering.DefaultFormat, $flags: UnityEngine_Experimental_Rendering.TextureCreationFlags);
        
        public constructor($width: number, $format: UnityEngine_Experimental_Rendering.GraphicsFormat, $flags: UnityEngine_Experimental_Rendering.TextureCreationFlags);
        
        public constructor($width: number, $format: TextureFormat, $mipCount: number);
        
        public constructor($width: number, $format: UnityEngine_Experimental_Rendering.GraphicsFormat, $flags: UnityEngine_Experimental_Rendering.TextureCreationFlags, $mipCount: number);
        /**
         * Create a new empty cubemap texture.
         * @param size Width/height of a cube face in pixels.
         * @param format Pixel data format to be used for the Cubemap.
         * @param mipmap Should mipmaps be created?
         */
        public constructor($width: number, $textureFormat: TextureFormat, $mipChain: boolean);
        /**
         * Updates Unity cubemap to use different native cubemap texture object.
         * @param nativeTexture Native cubemap texture object.
         */
        public UpdateExternalTexture($nativeTexture: System.IntPtr):void;
        /**
         * Performs smoothing of near edge regions.
         * @param smoothRegionWidthInPixels Pixel distance at edges over which to apply smoothing.
         */
        public SmoothEdges($smoothRegionWidthInPixels: number):void;
        
        public SmoothEdges():void;
        /**
         * Returns pixel colors of a cubemap face.
         * @param face The face from which pixel data is taken.
         * @param miplevel Mipmap level for the chosen face.
         */
        public GetPixels($face: CubemapFace, $miplevel: number):Color[];
        
        public GetPixels($face: CubemapFace):Color[];
        /**
         * Sets pixel colors of a cubemap face.
         * @param colors Pixel data for the Cubemap face.
         * @param face The face to which the new data should be applied.
         * @param miplevel The mipmap level for the face.
         */
        public SetPixels($colors: Color[], $face: CubemapFace, $miplevel: number):void;
        
        public SetPixels($colors: Color[], $face: CubemapFace):void;
        /**
         * Resets the requestedMipmapLevel field.
         */
        public ClearRequestedMipmapLevel():void;
        /**
         * Checks to see whether the mipmap level set by requestedMipmapLevel has finished loading.
         * @returns True if the mipmap level requested by requestedMipmapLevel has finished loading.
         */
        public IsRequestedMipmapLevelLoaded():boolean;
        /**
         * Creates a Unity cubemap out of externally created native cubemap object.
         * @param size The width and height of each face of the cubemap should be the same.
         * @param format Format of underlying cubemap object.
         * @param mipmap Does the cubemap have mipmaps?
         * @param nativeTex Native cubemap texture object.
         */
        public static CreateExternalTexture($width: number, $format: TextureFormat, $mipmap: boolean, $nativeTex: System.IntPtr):Cubemap;
        /**
         * Set pixel values from raw preformatted data.
         * @param mipLevel Mip level to fill.
         * @param face Cubemap face to fill.
         * @param sourceDataStartIndex Index in the source array to start copying from (default 0).
         * @param data Data array to initialize texture pixels with.
         */
        public SetPixelData<T>($data: T[], $mipLevel: number, $face: CubemapFace, $sourceDataStartIndex?: number):void;
        
        public SetPixelData<T>($data: Unity_Collections.NativeArray$1<T>, $mipLevel: number, $face: CubemapFace, $sourceDataStartIndex?: number):void;
        /**
         * Gets raw data from a Texture for reading or writing.
         * @param mipLevel The mip level to reference.
         * @param face The Cubemap face to reference.
         */
        public GetPixelData<T>($mipLevel: number, $face: CubemapFace):Unity_Collections.NativeArray$1<T>;
        /**
         * Sets pixel color at coordinates (face, x, y).
         */
        public SetPixel($face: CubemapFace, $x: number, $y: number, $color: Color):void;
        /**
         * Returns pixel color at coordinates (face, x, y).
         */
        public GetPixel($face: CubemapFace, $x: number, $y: number):Color;
        /**
         * Actually apply all previous SetPixel and SetPixels changes.
         * @param updateMipmaps When set to true, mipmap levels are recalculated.
         * @param makeNoLongerReadable When set to true, system memory copy of a texture is released.
         */
        public Apply($updateMipmaps: boolean, $makeNoLongerReadable: boolean):void;
        
        public Apply($updateMipmaps: boolean):void;
        
        public Apply():void;
        
        public constructor();
        
                    
    }
    /**
     * Describes a single bounding sphere for use by a CullingGroup.
     */
    class BoundingSphere extends System.ValueType {
        /**
         * The position of the center of the BoundingSphere.
         */
        public position: Vector3;
        /**
         * The radius of the BoundingSphere.
         */
        public radius: number;
        /**
         * Initializes a BoundingSphere.
         * @param pos The center of the sphere.
         * @param rad The radius of the sphere.
         * @param packedSphere A four-component vector containing the position (packed into the XYZ components) and radius (packed into the W component).
         */
        public constructor($pos: Vector3, $rad: number);
        /**
         * Initializes a BoundingSphere.
         * @param pos The center of the sphere.
         * @param rad The radius of the sphere.
         * @param packedSphere A four-component vector containing the position (packed into the XYZ components) and radius (packed into the W component).
         */
        public constructor($packedSphere: Vector4);
        
        public get_Clone(): BoundingSphere;            
    }
    /**
     * Provides information about the current and previous states of one sphere in a CullingGroup.
     */
    class CullingGroupEvent extends System.ValueType {
        /**
         * The index of the sphere that has changed.
         */
        public get index(): number;
        /**
         * Was the sphere considered visible by the most recent culling pass?
         */
        public get isVisible(): boolean;
        /**
         * Was the sphere visible before the most recent culling pass?
         */
        public get wasVisible(): boolean;
        /**
         * Did this sphere change from being invisible to being visible in the most recent culling pass?
         */
        public get hasBecomeVisible(): boolean;
        /**
         * Did this sphere change from being visible to being invisible in the most recent culling pass?
         */
        public get hasBecomeInvisible(): boolean;
        /**
         * The current distance band index of the sphere, after the most recent culling pass.
         */
        public get currentDistance(): number;
        /**
         * The distance band index of the sphere before the most recent culling pass.
         */
        public get previousDistance(): number;
        
        public get_Clone(): CullingGroupEvent;            
    }
    /**
     * Describes a set of bounding spheres that should have their visibility and distances maintained.
     */
    class CullingGroup extends System.Object {
        /**
         * Sets the callback that will be called when a sphere's visibility and/or distance state has changed.
         */
        public get onStateChanged(): UnityEngine_CullingGroup.StateChanged;
        public set onStateChanged(value: UnityEngine_CullingGroup.StateChanged);
        /**
         * Pauses culling group execution.
         */
        public get enabled(): boolean;
        public set enabled(value: boolean);
        /**
         * Locks the CullingGroup to a specific camera.
         */
        public get targetCamera(): Camera;
        public set targetCamera(value: Camera);
        /**
         * Create a CullingGroup.
         */
        public constructor();
        /**
         * Clean up all memory used by the CullingGroup immediately.
         */
        public Dispose():void;
        /**
         * Sets the array of bounding sphere definitions that the CullingGroup should compute culling for.
         * @param array The BoundingSpheres to cull.
         */
        public SetBoundingSpheres($array: BoundingSphere[]):void;
        /**
         * Sets the number of bounding spheres in the bounding spheres array that are actually being used.
         * @param count The number of bounding spheres being used.
         */
        public SetBoundingSphereCount($count: number):void;
        /**
         * Erase a given bounding sphere by moving the final sphere on top of it.
         * @param index The index of the entry to erase.
         */
        public EraseSwapBack($index: number):void;
        /**
         * Erase a given entry in an arbitrary array by copying the final entry on top of it, then decrementing the number of entries used by one.
         * @param index The index of the entry to erase.
         * @param myArray An array of entries.
         * @param size The number of entries in the array that are actually used.
         */
        public static EraseSwapBack<T>($index: number, $myArray: T[], $size: $Ref<number>):void;
        /**
         * Retrieve the indices of spheres that have particular visibility and/or distance states.
         * @param visible True if only visible spheres should be retrieved; false if only invisible spheres should be retrieved.
         * @param distanceIndex The distance band that retrieved spheres must be in.
         * @param result An array that will be filled with the retrieved sphere indices.
         * @param firstIndex The index of the sphere to begin searching at.
         * @returns The number of sphere indices found and written into the result array.
         */
        public QueryIndices($visible: boolean, $result: number[], $firstIndex: number):number;
        /**
         * Retrieve the indices of spheres that have particular visibility and/or distance states.
         * @param visible True if only visible spheres should be retrieved; false if only invisible spheres should be retrieved.
         * @param distanceIndex The distance band that retrieved spheres must be in.
         * @param result An array that will be filled with the retrieved sphere indices.
         * @param firstIndex The index of the sphere to begin searching at.
         * @returns The number of sphere indices found and written into the result array.
         */
        public QueryIndices($distanceIndex: number, $result: number[], $firstIndex: number):number;
        /**
         * Retrieve the indices of spheres that have particular visibility and/or distance states.
         * @param visible True if only visible spheres should be retrieved; false if only invisible spheres should be retrieved.
         * @param distanceIndex The distance band that retrieved spheres must be in.
         * @param result An array that will be filled with the retrieved sphere indices.
         * @param firstIndex The index of the sphere to begin searching at.
         * @returns The number of sphere indices found and written into the result array.
         */
        public QueryIndices($visible: boolean, $distanceIndex: number, $result: number[], $firstIndex: number):number;
        /**
         * Returns true if the bounding sphere at index is currently visible from any of the contributing cameras.
         * @param index The index of the bounding sphere.
         * @returns True if the sphere is visible; false if it is invisible.
         */
        public IsVisible($index: number):boolean;
        /**
         * Get the current distance band index of a given sphere.
         * @param index The index of the sphere.
         * @returns The sphere's current distance band index.
         */
        public GetDistance($index: number):number;
        /**
         * Set bounding distances for 'distance bands' the group should compute, as well as options for how spheres falling into each distance band should be treated.
         * @param distances An array of bounding distances. The distances should be sorted in increasing order.
         */
        public SetBoundingDistances($distances: number[]):void;
        /**
         * Set the reference point from which distance bands are measured.
         * @param point A fixed point to measure the distance from.
         * @param transform A transform to measure the distance from. The transform's position will be automatically tracked.
         */
        public SetDistanceReferencePoint($point: Vector3):void;
        /**
         * Set the reference point from which distance bands are measured.
         * @param point A fixed point to measure the distance from.
         * @param transform A transform to measure the distance from. The transform's position will be automatically tracked.
         */
        public SetDistanceReferencePoint($transform: Transform):void;
        
                    
    }
    /**
     * FlareLayer component.
     */
    class FlareLayer extends Behaviour {
        
                    
    }
    /**
     * The reflection probe is used to capture the surroundings into a texture which is passed to the shaders and used for reflections.
     */
    class ReflectionProbe extends Behaviour {
        /**
         * The size of the box area in which reflections will be applied to the objects. Measured in the probes's local space.
         */
        public get size(): Vector3;
        public set size(value: Vector3);
        /**
         * The center of the box area in which reflections will be applied to the objects. Measured in the probes's local space.
         */
        public get center(): Vector3;
        public set center(value: Vector3);
        /**
         * The near clipping plane distance when rendering the probe.
         */
        public get nearClipPlane(): number;
        public set nearClipPlane(value: number);
        /**
         * The far clipping plane distance when rendering the probe.
         */
        public get farClipPlane(): number;
        public set farClipPlane(value: number);
        /**
         * The intensity modifier that is applied to the texture of reflection probe in the shader.
         */
        public get intensity(): number;
        public set intensity(value: number);
        /**
         * The bounding volume of the reflection probe (Read Only).
         */
        public get bounds(): Bounds;
        /**
         * Should this reflection probe use HDR rendering?
         */
        public get hdr(): boolean;
        public set hdr(value: boolean);
        /**
         * Specifies whether Unity should render non-static GameObjects into the Reflection Probe. If you set this to true, Unity renders non-static GameObjects into the Reflection Probe. If you set this to false, Unity does not render non-static GameObjects into the Reflection Probe. Unity only takes this property into account if the Reflection Probe's Type is Custom.
         */
        public get renderDynamicObjects(): boolean;
        public set renderDynamicObjects(value: boolean);
        /**
         * Shadow drawing distance when rendering the probe.
         */
        public get shadowDistance(): number;
        public set shadowDistance(value: number);
        /**
         * Resolution of the underlying reflection texture in pixels.
         */
        public get resolution(): number;
        public set resolution(value: number);
        /**
         * This is used to render parts of the reflecion probe's surrounding selectively.
         */
        public get cullingMask(): number;
        public set cullingMask(value: number);
        /**
         * How the reflection probe clears the background.
         */
        public get clearFlags(): UnityEngine_Rendering.ReflectionProbeClearFlags;
        public set clearFlags(value: UnityEngine_Rendering.ReflectionProbeClearFlags);
        /**
         * The color with which the texture of reflection probe will be cleared.
         */
        public get backgroundColor(): Color;
        public set backgroundColor(value: Color);
        /**
         * Distance around probe used for blending (used in deferred probes).
         */
        public get blendDistance(): number;
        public set blendDistance(value: number);
        /**
         * Should this reflection probe use box projection?
         */
        public get boxProjection(): boolean;
        public set boxProjection(value: boolean);
        /**
         * Should reflection probe texture be generated in the Editor (ReflectionProbeMode.Baked) or should probe use custom specified texure (ReflectionProbeMode.Custom)?
         */
        public get mode(): UnityEngine_Rendering.ReflectionProbeMode;
        public set mode(value: UnityEngine_Rendering.ReflectionProbeMode);
        /**
         * Reflection probe importance.
         */
        public get importance(): number;
        public set importance(value: number);
        /**
         * Sets the way the probe will refresh.
         * See Also: ReflectionProbeRefreshMode.
         */
        public get refreshMode(): UnityEngine_Rendering.ReflectionProbeRefreshMode;
        public set refreshMode(value: UnityEngine_Rendering.ReflectionProbeRefreshMode);
        /**
         * Sets this probe time-slicing mode
         * See Also: ReflectionProbeTimeSlicingMode.
         */
        public get timeSlicingMode(): UnityEngine_Rendering.ReflectionProbeTimeSlicingMode;
        public set timeSlicingMode(value: UnityEngine_Rendering.ReflectionProbeTimeSlicingMode);
        /**
         * Reference to the baked texture of the reflection probe's surrounding.
         */
        public get bakedTexture(): Texture;
        public set bakedTexture(value: Texture);
        /**
         * Reference to the baked texture of the reflection probe's surrounding. Use this to assign custom reflection texture.
         */
        public get customBakedTexture(): Texture;
        public set customBakedTexture(value: Texture);
        /**
         * Reference to the realtime texture of the reflection probe's surroundings. Use this to assign a RenderTexture to use for realtime reflection.
         */
        public get realtimeTexture(): RenderTexture;
        public set realtimeTexture(value: RenderTexture);
        /**
         * Texture which is passed to the shader of the objects in the vicinity of the reflection probe (Read Only).
         */
        public get texture(): Texture;
        /**
         * HDR decode values of the reflection probe texture.
         */
        public get textureHDRDecodeValues(): Vector4;
        
        public static get minBakedCubemapResolution(): number;
        
        public static get maxBakedCubemapResolution(): number;
        /**
         * HDR decode values of the default reflection probe texture.
         */
        public static get defaultTextureHDRDecodeValues(): Vector4;
        /**
         * Texture which is used outside of all reflection probes (Read Only).
         */
        public static get defaultTexture(): Texture;
        
        public constructor();
        /**
         * Revert all ReflectionProbe parameters to default.
         */
        public Reset():void;
        
        public RenderProbe():number;
        /**
         * Refreshes the probe's cubemap.
         * @param targetTexture Target RendeTexture in which rendering should be done. Specifying null will update the probe's default texture.
         * @returns 
                  An integer representing a RenderID which can subsequently be used to check if the probe has finished rendering while rendering in time-slice mode.
                  See Also: IsFinishedRendering
                  See Also: timeSlicingMode
                
         */
        public RenderProbe($targetTexture: RenderTexture):number;
        /**
         * Checks if a probe has finished a time-sliced render.
         * @param renderId An integer representing the RenderID as returned by the RenderProbe method.
         * @returns 
                  True if the render has finished, false otherwise.
                  See Also: timeSlicingMode
                
         */
        public IsFinishedRendering($renderId: number):boolean;
        /**
         * Utility method to blend 2 cubemaps into a target render texture.
         * @param src Cubemap to blend from.
         * @param dst Cubemap to blend to.
         * @param blend Blend weight.
         * @param target RenderTexture which will hold the result of the blend.
         * @returns Returns trues if cubemaps were blended, false otherwise.
         */
        public static BlendCubemap($src: Texture, $dst: Texture, $blend: number, $target: RenderTexture):boolean;
        
        public static add_reflectionProbeChanged($value: System.Action$2<ReflectionProbe, UnityEngine_ReflectionProbe.ReflectionProbeEvent>):void;
        
        public static remove_reflectionProbeChanged($value: System.Action$2<ReflectionProbe, UnityEngine_ReflectionProbe.ReflectionProbeEvent>):void;
        
        public static add_defaultReflectionSet($value: System.Action$1<Cubemap>):void;
        
        public static remove_defaultReflectionSet($value: System.Action$1<Cubemap>):void;
        
        public static reflectionProbeChanged;
        
        public static defaultReflectionSet;
        
                    
    }
    /**
     * Holds data for a single application crash event and provides access to all gathered crash reports.
     */
    class CrashReport extends System.Object {
        /**
         * Time, when the crash occured.
         */
        public time: Date;
        /**
         * Crash report data as formatted text.
         */
        public text: string;
        /**
         * Returns all currently available reports in a new array.
         */
        public static get reports(): CrashReport[];
        /**
         * Returns last crash report, or null if no reports are available.
         */
        public static get lastReport(): CrashReport;
        /**
         * Remove all reports from available reports list.
         */
        public static RemoveAll():void;
        /**
         * Remove report from available reports list.
         */
        public Remove():void;
        
                    
    }
    /**
     * Object that is used to resolve references to an ExposedReference field.
     */
    class ExposedPropertyResolver extends System.ValueType {
        
        public get_Clone(): ExposedPropertyResolver;            
    }
    /**
     * Interface for objects used as resolvers on ExposedReferences.
     */
    interface IExposedPropertyTable {
        /**
         * Assigns a value for an ExposedReference.
         * @param id Identifier of the ExposedReference.
         * @param value The value to assigned to the ExposedReference.
         */
        SetReferenceValue($id: PropertyName, $value: Object):void;
        /**
         * Retrieves a value for the given identifier.
         * @param id Identifier of the ExposedReference.
         * @param idValid Is the identifier valid?
         * @returns The value stored in the table.
         */
        GetReferenceValue($id: PropertyName, $idValid: $Ref<boolean>):Object;
        /**
         * Remove a value for the given reference.
         * @param id Identifier of the ExposedReference.
         */
        ClearReferenceValue($id: PropertyName):void;
        
                    
    }
    /**
     * Represents a string as an int for efficient lookup and comparison. Use this for common PropertyNames.
     * Internally stores just an int to represent the string. A PropertyName can be created from a string but can not be converted back to a string. The same string always results in the same int representing that string. Thus this is a very efficient string representation in both memory and speed when all you need is comparison.
     * PropertyName is serializable.
     * ToString() is only implemented for debugging purposes in the editor it returns "theName:3737" in the player it returns "Unknown:3737".
     */
    class PropertyName extends System.ValueType {
        /**
         * Initializes the PropertyName using a string.
         */
        public constructor($name: string);
        
        public constructor($other: PropertyName);
        
        public constructor($id: number);
        /**
         * Indicates whether the specified PropertyName is an Empty string.
         */
        public static IsNullOrEmpty($prop: PropertyName):boolean;
        
        public static op_Equality($lhs: PropertyName, $rhs: PropertyName):boolean;
        
        public static op_Inequality($lhs: PropertyName, $rhs: PropertyName):boolean;
        /**
         * Returns the hash code for this PropertyName.
         */
        public GetHashCode():number;
        /**
         * Determines whether this instance and a specified object, which must also be a PropertyName object, have the same value.
         */
        public Equals($other: any):boolean;
        
        public Equals($other: PropertyName):boolean;
        
        public static op_Implicit($name: string):PropertyName;
        
        public static op_Implicit($id: number):PropertyName;
        /**
         * For debugging purposes only. Returns the string value representing the string in the Editor.
         * Returns "UnityEngine.PropertyName" in the player.
         */
        public ToString():string;
        
        public get_Clone(): PropertyName;            
    }
    
    class EventProvider extends System.Object {
        
        public constructor();
        
        public static WriteCustomEvent($value: number, $text: string):void;
        
                    
    }
    /**
     * Allows to control the dynamic Global Illumination.
     */
    class DynamicGI extends System.Object {
        /**
         * Allows for scaling the contribution coming from realtime & baked lightmaps.
         * Note: this value can be set in the Lighting Window UI and it is serialized, that is not the case for other properties in this class.
         */
        public static get indirectScale(): number;
        public static set indirectScale(value: number);
        /**
         * Threshold for limiting updates of realtime GI. The unit of measurement is "percentage intensity change".
         */
        public static get updateThreshold(): number;
        public static set updateThreshold(value: number);
        /**
         * The number of milliseconds that can be spent on material updates.
         */
        public static get materialUpdateTimeSlice(): number;
        public static set materialUpdateTimeSlice(value: number);
        /**
         * When enabled, new dynamic Global Illumination output is shown in each frame.
         */
        public static get synchronousMode(): boolean;
        public static set synchronousMode(value: boolean);
        /**
         * Is precomputed realtime Global Illumination output converged?
         */
        public static get isConverged(): boolean;
        
        public constructor();
        /**
         * Allows to set an emissive color for a given renderer quickly, without the need to render the emissive input for the entire system.
         * @param renderer The Renderer that should get a new color.
         * @param color The emissive Color.
         */
        public static SetEmissive($renderer: Renderer, $color: Color):void;
        /**
         * Allows overriding the distant environment lighting for Realtime GI, without changing the Skybox Material.
         * @param input Array of float values to be used for Realtime GI environment lighting.
         */
        public static SetEnvironmentData($input: number[]):void;
        /**
         * Schedules an update of the environment texture.
         */
        public static UpdateEnvironment():void;
        
                    
    }
    /**
     * General functionality for all renderers.
     */
    class Renderer extends Component {
        /**
         * The bounding volume of the renderer (Read Only).
         */
        public get bounds(): Bounds;
        /**
         * Makes the rendered 3D object visible if enabled.
         */
        public get enabled(): boolean;
        public set enabled(value: boolean);
        /**
         * Is this renderer visible in any camera? (Read Only)
         */
        public get isVisible(): boolean;
        /**
         * Does this object cast shadows?
         */
        public get shadowCastingMode(): UnityEngine_Rendering.ShadowCastingMode;
        public set shadowCastingMode(value: UnityEngine_Rendering.ShadowCastingMode);
        /**
         * Does this object receive shadows?
         */
        public get receiveShadows(): boolean;
        public set receiveShadows(value: boolean);
        /**
         * Allows turning off rendering for a specific component.
         */
        public get forceRenderingOff(): boolean;
        public set forceRenderingOff(value: boolean);
        /**
         * Specifies the mode for motion vector rendering.
         */
        public get motionVectorGenerationMode(): MotionVectorGenerationMode;
        public set motionVectorGenerationMode(value: MotionVectorGenerationMode);
        /**
         * The light probe interpolation type.
         */
        public get lightProbeUsage(): UnityEngine_Rendering.LightProbeUsage;
        public set lightProbeUsage(value: UnityEngine_Rendering.LightProbeUsage);
        /**
         * Should reflection probes be used for this Renderer?
         */
        public get reflectionProbeUsage(): UnityEngine_Rendering.ReflectionProbeUsage;
        public set reflectionProbeUsage(value: UnityEngine_Rendering.ReflectionProbeUsage);
        /**
         * Determines which rendering layer this renderer lives on.
         */
        public get renderingLayerMask(): number;
        public set renderingLayerMask(value: number);
        /**
         * This value sorts renderers by priority. Lower values are rendered first and higher values are rendered last.
         */
        public get rendererPriority(): number;
        public set rendererPriority(value: number);
        /**
         * Describes how this renderer is updated for ray tracing.
         */
        public get rayTracingMode(): UnityEngine_Experimental_Rendering.RayTracingMode;
        public set rayTracingMode(value: UnityEngine_Experimental_Rendering.RayTracingMode);
        /**
         * Name of the Renderer's sorting layer.
         */
        public get sortingLayerName(): string;
        public set sortingLayerName(value: string);
        /**
         * Unique ID of the Renderer's sorting layer.
         */
        public get sortingLayerID(): number;
        public set sortingLayerID(value: number);
        /**
         * Renderer's order within a sorting layer.
         */
        public get sortingOrder(): number;
        public set sortingOrder(value: number);
        /**
         * Controls if dynamic occlusion culling should be performed for this renderer.
         */
        public get allowOcclusionWhenDynamic(): boolean;
        public set allowOcclusionWhenDynamic(value: boolean);
        /**
         * Has this renderer been statically batched with any other renderers?
         */
        public get isPartOfStaticBatch(): boolean;
        /**
         * Matrix that transforms a point from world space into local space (Read Only).
         */
        public get worldToLocalMatrix(): Matrix4x4;
        /**
         * Matrix that transforms a point from local space into world space (Read Only).
         */
        public get localToWorldMatrix(): Matrix4x4;
        /**
         * If set, the Renderer will use the Light Probe Proxy Volume component attached to the source GameObject.
         */
        public get lightProbeProxyVolumeOverride(): GameObject;
        public set lightProbeProxyVolumeOverride(value: GameObject);
        /**
         * If set, Renderer will use this Transform's position to find the light or reflection probe.
         */
        public get probeAnchor(): Transform;
        public set probeAnchor(value: Transform);
        /**
         * The index of the baked lightmap applied to this renderer.
         */
        public get lightmapIndex(): number;
        public set lightmapIndex(value: number);
        /**
         * The index of the realtime lightmap applied to this renderer.
         */
        public get realtimeLightmapIndex(): number;
        public set realtimeLightmapIndex(value: number);
        /**
         * The UV scale & offset used for a lightmap.
         */
        public get lightmapScaleOffset(): Vector4;
        public set lightmapScaleOffset(value: Vector4);
        /**
         * The UV scale & offset used for a realtime lightmap.
         */
        public get realtimeLightmapScaleOffset(): Vector4;
        public set realtimeLightmapScaleOffset(value: Vector4);
        /**
         * Returns all the instantiated materials of this object.
         */
        public get materials(): Material[];
        public set materials(value: Material[]);
        /**
         * Returns the first instantiated Material assigned to the renderer.
         */
        public get material(): Material;
        public set material(value: Material);
        /**
         * The shared material of this object.
         */
        public get sharedMaterial(): Material;
        public set sharedMaterial(value: Material);
        /**
         * All the shared materials of this object.
         */
        public get sharedMaterials(): Material[];
        public set sharedMaterials(value: Material[]);
        
        public constructor();
        /**
         * Returns true if the Renderer has a material property block attached via SetPropertyBlock.
         */
        public HasPropertyBlock():boolean;
        /**
         * Lets you set or clear per-renderer or per-material parameter overrides.
         * @param properties Property block with values you want to override.
         * @param materialIndex The index of the Material you want to override the parameters of. The index ranges from 0 to Renderer.sharedMaterial.Length-1.
         */
        public SetPropertyBlock($properties: MaterialPropertyBlock):void;
        /**
         * Lets you set or clear per-renderer or per-material parameter overrides.
         * @param properties Property block with values you want to override.
         * @param materialIndex The index of the Material you want to override the parameters of. The index ranges from 0 to Renderer.sharedMaterial.Length-1.
         */
        public SetPropertyBlock($properties: MaterialPropertyBlock, $materialIndex: number):void;
        /**
         * Get per-Renderer or per-Material property block.
         * @param properties Material parameters to retrieve.
         * @param materialIndex The index of the Material you want to get overridden parameters from. The index ranges from 0 to Renderer.sharedMaterials.Length-1.
         */
        public GetPropertyBlock($properties: MaterialPropertyBlock):void;
        /**
         * Get per-Renderer or per-Material property block.
         * @param properties Material parameters to retrieve.
         * @param materialIndex The index of the Material you want to get overridden parameters from. The index ranges from 0 to Renderer.sharedMaterials.Length-1.
         */
        public GetPropertyBlock($properties: MaterialPropertyBlock, $materialIndex: number):void;
        
        public GetMaterials($m: System_Collections_Generic.List$1<Material>):void;
        
        public GetSharedMaterials($m: System_Collections_Generic.List$1<Material>):void;
        
        public GetClosestReflectionProbes($result: System_Collections_Generic.List$1<UnityEngine_Rendering.ReflectionProbeBlendInfo>):void;
        
                    
    }
    /**
     * An object containing settings for precomputing lighting data, that Unity can serialize as a.
     */
    class LightingSettings extends Object {
        /**
         * Whether to enable the Baked Global Illumination system for this Scene.
         */
        public get bakedGI(): boolean;
        public set bakedGI(value: boolean);
        /**
         * Whether to enable the Realtime Global Illumination system for this Scene.
         */
        public get realtimeGI(): boolean;
        public set realtimeGI(value: boolean);
        /**
         * Determines the lightmap that Unity stores environment lighting in.
         */
        public get realtimeEnvironmentLighting(): boolean;
        public set realtimeEnvironmentLighting(value: boolean);
        /**
         * Whether the Unity Editor automatically precomputes lighting data when the Scene data changes. (Editor only).
         */
        public get autoGenerate(): boolean;
        public set autoGenerate(value: boolean);
        /**
         * Sets the MixedLightingMode that Unity uses for all Mixed Lights in the Scene. (Editor only).
         */
        public get mixedBakeMode(): MixedLightingMode;
        public set mixedBakeMode(value: MixedLightingMode);
        /**
         * The intensity of surface albedo throughout the Scene when considered in lighting calculations. This value influences the energy of light at each bounce. (Editor only).
         */
        public get albedoBoost(): number;
        public set albedoBoost(value: number);
        /**
         * Multiplies the intensity of of indirect lighting in lightmaps. (Editor only).
         */
        public get indirectScale(): number;
        public set indirectScale(value: number);
        /**
         * Determines which backend to use for baking lightmaps in the Baked Global Illumination system. (Editor only).
         */
        public get lightmapper(): UnityEngine_LightingSettings.Lightmapper;
        public set lightmapper(value: UnityEngine_LightingSettings.Lightmapper);
        /**
         * The maximum size in pixels of an individual lightmap texture. (Editor only).
         */
        public get lightmapMaxSize(): number;
        public set lightmapMaxSize(value: number);
        /**
         * Defines the number of texels to use per world unit when generating lightmaps.
         */
        public get lightmapResolution(): number;
        public set lightmapResolution(value: number);
        /**
         * Sets the distance (in texels) between separate UV tiles in lightmaps. (Editor only).
         */
        public get lightmapPadding(): number;
        public set lightmapPadding(value: number);
        /**
         * Whether to compress the lightmap textures that the Progressive Lightmapper generates. (Editor only)
         */
        public get compressLightmaps(): boolean;
        public set compressLightmaps(value: boolean);
        /**
         * Whether to apply ambient occlusion to lightmaps. (Editor only).
         */
        public get ao(): boolean;
        public set ao(value: boolean);
        /**
         * The distance that a ray travels before Unity considers it to be unoccluded when calculating ambient occlusion in lightmaps. (Editor only).
         */
        public get aoMaxDistance(): number;
        public set aoMaxDistance(value: number);
        /**
         * Sets the contrast of ambient occlusion that Unity applies to indirect lighting in lightmaps. (Editor only).
         */
        public get aoExponentIndirect(): number;
        public set aoExponentIndirect(value: number);
        /**
         * Determines the degree to which direct lighting is considered when calculating ambient occlusion in lightmaps. (Editor only).
         */
        public get aoExponentDirect(): number;
        public set aoExponentDirect(value: number);
        /**
         * Whether the Progressive Lightmapper extracts Ambient Occlusion to a separate lightmap. (Editor only).
         */
        public get extractAO(): boolean;
        public set extractAO(value: boolean);
        /**
         * Determines whether the lightmapper should generate directional or non-directional lightmaps. (Editor only).
         */
        public get directionalityMode(): LightmapsMode;
        public set directionalityMode(value: LightmapsMode);
        /**
         * Whether the Progressive Lightmapper exports machine learning training data to the Project folder when it performs the bake. ( Editor only).
         */
        public get exportTrainingData(): boolean;
        public set exportTrainingData(value: boolean);
        /**
         * Determines the name of the destination folder for the exported textures. (Editor only).
         */
        public get trainingDataDestination(): string;
        public set trainingDataDestination(value: string);
        /**
         * Defines the number of texels that Enlighten uses per world unit when calculating indirect lighting. (Editor only).
         */
        public get indirectResolution(): number;
        public set indirectResolution(value: number);
        /**
         * Specifies whether the final light bounce of the global illumination calculation is calculated at the same resolution as the baked lightmap. (Editor only).
         */
        public get finalGather(): boolean;
        public set finalGather(value: boolean);
        /**
         * Controls the number of rays emitted for every final gather point. A final gather point is a lightmap texel in the final, composited lightmap. (Editor only).
         */
        public get finalGatherRayCount(): number;
        public set finalGatherRayCount(value: number);
        /**
         * Controls whether a denoising filter is applied to the final gather output.
         */
        public get finalGatherFiltering(): boolean;
        public set finalGatherFiltering(value: boolean);
        
        public get sampling(): UnityEngine_LightingSettings.Sampling;
        public set sampling(value: UnityEngine_LightingSettings.Sampling);
        /**
         * Specifies the number of samples the Progressive Lightmapper uses for direct lighting calculations. (Editor only).
         */
        public get directSampleCount(): number;
        public set directSampleCount(value: number);
        /**
         * Specifies the number of samples the Progressive Lightmapper uses for indirect lighting calculations. (Editor only).
         */
        public get indirectSampleCount(): number;
        public set indirectSampleCount(value: number);
        /**
         * Stores the maximum number of bounces the Progressive Lightmapper computes for indirect lighting. (Editor only)
         */
        public get maxBounces(): number;
        public set maxBounces(value: number);
        /**
         * Stores the minimum number of bounces the Progressive Lightmapper computes for indirect lighting. (Editor only)
         */
        public get minBounces(): number;
        public set minBounces(value: number);
        /**
         * Whether the Progressive Lightmapper prioritizes baking visible texels within the frustum of the Scene view. (Editor only).
         */
        public get prioritizeView(): boolean;
        public set prioritizeView(value: boolean);
        /**
         * Specifies the filter type that the Progressive Lightmapper uses for ambient occlusion. (Editor only).
         */
        public get filteringMode(): UnityEngine_LightingSettings.FilterMode;
        public set filteringMode(value: UnityEngine_LightingSettings.FilterMode);
        /**
         * Determines the denoiser that the Progressive Lightmapper applies to direct lighting. (Editor only).
         */
        public get denoiserTypeDirect(): UnityEngine_LightingSettings.DenoiserType;
        public set denoiserTypeDirect(value: UnityEngine_LightingSettings.DenoiserType);
        /**
         * Determines the denoiser that the Progressive Lightmapper applies to indirect lighting. (Editor only).
         */
        public get denoiserTypeIndirect(): UnityEngine_LightingSettings.DenoiserType;
        public set denoiserTypeIndirect(value: UnityEngine_LightingSettings.DenoiserType);
        /**
         * Determines the type of denoising that the Progressive Lightmapper applies to ambient occlusion in lightmaps. (Editor only).
         */
        public get denoiserTypeAO(): UnityEngine_LightingSettings.DenoiserType;
        public set denoiserTypeAO(value: UnityEngine_LightingSettings.DenoiserType);
        /**
         * Specifies the filter kernel that the Progressive Lightmapper uses for the direct lighting. (Editor only).
         */
        public get filterTypeDirect(): UnityEngine_LightingSettings.FilterType;
        public set filterTypeDirect(value: UnityEngine_LightingSettings.FilterType);
        /**
         * Specifies the filter kernel that the Progressive Lightmapper uses for indirect lighting. (Editor only).
         */
        public get filterTypeIndirect(): UnityEngine_LightingSettings.FilterType;
        public set filterTypeIndirect(value: UnityEngine_LightingSettings.FilterType);
        /**
         * Specifies the filter kernel that the Progressive Lightmapper uses for ambient occlusion. (Editor only).
         */
        public get filterTypeAO(): UnityEngine_LightingSettings.FilterType;
        public set filterTypeAO(value: UnityEngine_LightingSettings.FilterType);
        /**
         * Specifies the radius the Progressive Lightmapper used to filter the indirect lighting component of the lightmap when using Gaussian filter. (Editor only).
         */
        public get filteringGaussRadiusDirect(): number;
        public set filteringGaussRadiusDirect(value: number);
        /**
         * Specifies the method used by the Progressive Lightmapper to reduce noise in lightmaps. (Editor only).
         */
        public get filteringGaussRadiusIndirect(): number;
        public set filteringGaussRadiusIndirect(value: number);
        /**
         * Specifies the radius the Progressive Lightmapper uses to filter the direct lighting component of the lightmap when using Gaussian filter. (Editor only).
         */
        public get filteringGaussRadiusAO(): number;
        public set filteringGaussRadiusAO(value: number);
        /**
         * Specifies the threshold the Progressive Lightmapper uses to filter the indirect lighting component of the lightmap when using the A-Trous filter. (Editor only).
         */
        public get filteringAtrousPositionSigmaDirect(): number;
        public set filteringAtrousPositionSigmaDirect(value: number);
        /**
         * Specifies the radius the Progressive Lightmapper uses to filter the ambient occlusion component in the lightmap when using Gaussian filter. (Editor only).
         */
        public get filteringAtrousPositionSigmaIndirect(): number;
        public set filteringAtrousPositionSigmaIndirect(value: number);
        /**
         * Specifies the threshold the Progressive Lightmapper uses to filter direct light stored in the lightmap when using the A-Trous filter. (Editor only).
         */
        public get filteringAtrousPositionSigmaAO(): number;
        public set filteringAtrousPositionSigmaAO(value: number);
        /**
         * Specifies the number of samples the Progressive Lightmapper uses when sampling indirect lighting from the skybox. (Editor only).
         */
        public get environmentSampleCount(): number;
        public set environmentSampleCount(value: number);
        /**
         * Specifies the number of samples to use for Light Probes relative to the number of samples for lightmap texels. (Editor only).
         */
        public get lightProbeSampleCountMultiplier(): number;
        public set lightProbeSampleCountMultiplier(value: number);
        
        public constructor();
        
                    
    }
    /**
     * Enum describing what lighting mode to be used with Mixed lights.
     */
    enum MixedLightingMode { IndirectOnly = 0, Shadowmask = 2, Subtractive = 1 }
    /**
     * Lightmap (and lighting) configuration mode, controls how lightmaps interact with lighting and what kind of information they store.
     */
    enum LightmapsMode { NonDirectional = 0, CombinedDirectional = 1, SeparateDirectional = 2, Single = 0, Dual = 1, Directional = 2 }
    /**
     * Represents an axis aligned bounding box with all values as integers.
     */
    class BoundsInt extends System.ValueType {
        /**
         * X value of the minimal point of the box.
         */
        public get x(): number;
        public set x(value: number);
        /**
         * Y value of the minimal point of the box.
         */
        public get y(): number;
        public set y(value: number);
        /**
         * Z value of the minimal point of the box.
         */
        public get z(): number;
        public set z(value: number);
        /**
         * The center of the bounding box.
         */
        public get center(): Vector3;
        /**
         * The minimal point of the box.
         */
        public get min(): Vector3Int;
        public set min(value: Vector3Int);
        /**
         * The maximal point of the box.
         */
        public get max(): Vector3Int;
        public set max(value: Vector3Int);
        /**
         * The minimal x point of the box.
         */
        public get xMin(): number;
        public set xMin(value: number);
        /**
         * The minimal y point of the box.
         */
        public get yMin(): number;
        public set yMin(value: number);
        /**
         * The minimal z point of the box.
         */
        public get zMin(): number;
        public set zMin(value: number);
        /**
         * The maximal x point of the box.
         */
        public get xMax(): number;
        public set xMax(value: number);
        /**
         * The maximal y point of the box.
         */
        public get yMax(): number;
        public set yMax(value: number);
        /**
         * The maximal z point of the box.
         */
        public get zMax(): number;
        public set zMax(value: number);
        /**
         * The position of the bounding box.
         */
        public get position(): Vector3Int;
        public set position(value: Vector3Int);
        /**
         * The total size of the box.
         */
        public get size(): Vector3Int;
        public set size(value: Vector3Int);
        /**
         * A BoundsInt.PositionCollection that contains all positions within the BoundsInt.
         */
        public get allPositionsWithin(): UnityEngine_BoundsInt.PositionEnumerator;
        
        public constructor($xMin: number, $yMin: number, $zMin: number, $sizeX: number, $sizeY: number, $sizeZ: number);
        
        public constructor($position: Vector3Int, $size: Vector3Int);
        /**
         * Sets the bounds to the min and max value of the box.
         */
        public SetMinMax($minPosition: Vector3Int, $maxPosition: Vector3Int):void;
        /**
         * Clamps the position and size of this bounding box to the given bounds.
         * @param bounds Bounds to clamp to.
         */
        public ClampToBounds($bounds: BoundsInt):void;
        /**
         * Is point contained in the bounding box?
         * @param position Point to check.
         * @param inclusive Whether the max limits are included in the check.
         * @returns Is point contained in the bounding box?
         */
        public Contains($position: Vector3Int):boolean;
        /**
         * Returns a formatted string for the bounds.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        public ToString():string;
        /**
         * Returns a formatted string for the bounds.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        public ToString($format: string):string;
        /**
         * Returns a formatted string for the bounds.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        public ToString($format: string, $formatProvider: System.IFormatProvider):string;
        
        public static op_Equality($lhs: BoundsInt, $rhs: BoundsInt):boolean;
        
        public static op_Inequality($lhs: BoundsInt, $rhs: BoundsInt):boolean;
        
        public Equals($other: any):boolean;
        
        public Equals($other: BoundsInt):boolean;
        
        public GetHashCode():number;
        
        public get_Clone(): BoundsInt;            
    }
    /**
     * Representation of 3D vectors and points using integers.
     */
    class Vector3Int extends System.ValueType {
        /**
         * X component of the vector.
         */
        public get x(): number;
        public set x(value: number);
        /**
         * Y component of the vector.
         */
        public get y(): number;
        public set y(value: number);
        /**
         * Z component of the vector.
         */
        public get z(): number;
        public set z(value: number);
        /**
         * Returns the length of this vector (Read Only).
         */
        public get magnitude(): number;
        /**
         * Returns the squared length of this vector (Read Only).
         */
        public get sqrMagnitude(): number;
        /**
         * Shorthand for writing Vector3Int(0, 0, 0).
         */
        public static get zero(): Vector3Int;
        /**
         * Shorthand for writing Vector3Int(1, 1, 1).
         */
        public static get one(): Vector3Int;
        /**
         * Shorthand for writing Vector3Int(0, 1, 0).
         */
        public static get up(): Vector3Int;
        /**
         * Shorthand for writing Vector3Int(0, -1, 0).
         */
        public static get down(): Vector3Int;
        /**
         * Shorthand for writing Vector3Int(-1, 0, 0).
         */
        public static get left(): Vector3Int;
        /**
         * Shorthand for writing Vector3Int(1, 0, 0).
         */
        public static get right(): Vector3Int;
        /**
         * Shorthand for writing Vector3Int(0, 0, 1).
         */
        public static get forward(): Vector3Int;
        /**
         * Shorthand for writing Vector3Int(0, 0, -1).
         */
        public static get back(): Vector3Int;
        
        public constructor($x: number, $y: number, $z: number);
        /**
         * Set x, y and z components of an existing Vector3Int.
         */
        public Set($x: number, $y: number, $z: number):void;
        
        public get_Item($index: number):number;
        
        public set_Item($index: number, $value: number):void;
        /**
         * Returns the distance between a and b.
         */
        public static Distance($a: Vector3Int, $b: Vector3Int):number;
        /**
         * Returns a vector that is made from the smallest components of two vectors.
         */
        public static Min($lhs: Vector3Int, $rhs: Vector3Int):Vector3Int;
        /**
         * Returns a vector that is made from the largest components of two vectors.
         */
        public static Max($lhs: Vector3Int, $rhs: Vector3Int):Vector3Int;
        /**
         * Multiplies two vectors component-wise.
         */
        public static Scale($a: Vector3Int, $b: Vector3Int):Vector3Int;
        /**
         * Multiplies every component of this vector by the same component of scale.
         */
        public Scale($scale: Vector3Int):void;
        /**
         * Clamps the Vector3Int to the bounds given by min and max.
         */
        public Clamp($min: Vector3Int, $max: Vector3Int):void;
        
        public static op_Implicit($v: Vector3Int):Vector3;
        /**
         * Converts a Vector3Int to a Vector2Int.
         */
        public static op_Explicit($v: Vector3Int):Vector2Int;
        /**
         * Converts a  Vector3 to a Vector3Int by doing a Floor to each value.
         */
        public static FloorToInt($v: Vector3):Vector3Int;
        /**
         * Converts a  Vector3 to a Vector3Int by doing a Ceiling to each value.
         */
        public static CeilToInt($v: Vector3):Vector3Int;
        /**
         * Converts a  Vector3 to a Vector3Int by doing a Round to each value.
         */
        public static RoundToInt($v: Vector3):Vector3Int;
        
        public static op_Addition($a: Vector3Int, $b: Vector3Int):Vector3Int;
        
        public static op_Subtraction($a: Vector3Int, $b: Vector3Int):Vector3Int;
        /**
         * Multiplies a vector by a number.
         */
        public static op_Multiply($a: Vector3Int, $b: Vector3Int):Vector3Int;
        
        public static op_UnaryNegation($a: Vector3Int):Vector3Int;
        /**
         * Multiplies a vector by a number.
         */
        public static op_Multiply($a: Vector3Int, $b: number):Vector3Int;
        
        public static op_Multiply($a: number, $b: Vector3Int):Vector3Int;
        
        public static op_Division($a: Vector3Int, $b: number):Vector3Int;
        
        public static op_Equality($lhs: Vector3Int, $rhs: Vector3Int):boolean;
        
        public static op_Inequality($lhs: Vector3Int, $rhs: Vector3Int):boolean;
        /**
         * Returns true if the objects are equal.
         */
        public Equals($other: any):boolean;
        
        public Equals($other: Vector3Int):boolean;
        /**
         * Gets the hash code for the Vector3Int.
         * @returns The hash code of the Vector3Int.
         */
        public GetHashCode():number;
        /**
         * Returns a formatted string for this vector.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        public ToString():string;
        /**
         * Returns a formatted string for this vector.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        public ToString($format: string):string;
        /**
         * Returns a formatted string for this vector.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        public ToString($format: string, $formatProvider: System.IFormatProvider):string;
        
        public get_Clone(): Vector3Int;            
    }
    /**
     * Utility class for common geometric functions.
     */
    class GeometryUtility extends System.Object {
        
        public constructor();
        /**
         * Calculates frustum planes.
         * @param camera The camera with the view frustum that you want to calculate planes from.
         * @returns The planes that form the camera's view frustum.
         */
        public static CalculateFrustumPlanes($camera: Camera):Plane[];
        /**
         * Calculates frustum planes.
         * @param worldToProjectionMatrix A matrix that transforms from world space to projection space, from which the planes will be calculated.
         * @returns The planes that enclose the projection space described by the matrix.
         */
        public static CalculateFrustumPlanes($worldToProjectionMatrix: Matrix4x4):Plane[];
        /**
         * Calculates frustum planes.
         * @param camera The camera with the view frustum that you want to calculate planes from.
         * @param planes An array of 6 Planes that will be overwritten with the calculated plane values.
         */
        public static CalculateFrustumPlanes($camera: Camera, $planes: Plane[]):void;
        /**
         * Calculates frustum planes.
         * @param worldToProjectionMatrix A matrix that transforms from world space to projection space, from which the planes will be calculated.
         * @param planes An array of 6 Planes that will be overwritten with the calculated plane values.
         */
        public static CalculateFrustumPlanes($worldToProjectionMatrix: Matrix4x4, $planes: Plane[]):void;
        /**
         * Calculates the bounding box from the given array of positions and the transformation matrix.
         * @param positions An array that stores the location of 3d positions.
         * @param transform A matrix that changes the position, rotation and size of the bounds calculation.
         * @returns Calculates the axis-aligned bounding box.
         */
        public static CalculateBounds($positions: Vector3[], $transform: Matrix4x4):Bounds;
        /**
         * GeometryUtility.TryCreatePlaneFromPolygon creates a plane from the given list of vertices that define the polygon, as long as they do not characterize a straight line or zero area.
         * @param vertices An array of vertex positions that define the shape of a polygon.
         * @param plane A valid plane that goes through the vertices.
         * @returns Returns true on success, false if Unity did not create a plane from the vertices.
         */
        public static TryCreatePlaneFromPolygon($vertices: Vector3[], $plane: $Ref<Plane>):boolean;
        /**
         * Returns true if bounds are inside the plane array.
         */
        public static TestPlanesAABB($planes: Plane[], $bounds: Bounds):boolean;
        
                    
    }
    /**
     * Representation of a plane in 3D space.
     */
    class Plane extends System.ValueType {
        /**
         * Normal vector of the plane.
         */
        public get normal(): Vector3;
        public set normal(value: Vector3);
        /**
         * The distance measured from the Plane to the origin, along the Plane's normal.
         */
        public get distance(): number;
        public set distance(value: number);
        /**
         * Returns a copy of the plane that faces in the opposite direction.
         */
        public get flipped(): Plane;
        /**
         * Creates a plane.
         */
        public constructor($inNormal: Vector3, $inPoint: Vector3);
        /**
         * Creates a plane.
         */
        public constructor($inNormal: Vector3, $d: number);
        /**
         * Creates a plane.
         */
        public constructor($a: Vector3, $b: Vector3, $c: Vector3);
        /**
         * Sets a plane using a point that lies within it along with a normal to orient it.
         * @param inNormal The plane's normal vector.
         * @param inPoint A point that lies on the plane.
         */
        public SetNormalAndPosition($inNormal: Vector3, $inPoint: Vector3):void;
        /**
         * Sets a plane using three points that lie within it.  The points go around clockwise as you look down on the top surface of the plane.
         * @param a First point in clockwise order.
         * @param b Second point in clockwise order.
         * @param c Third point in clockwise order.
         */
        public Set3Points($a: Vector3, $b: Vector3, $c: Vector3):void;
        /**
         * Makes the plane face in the opposite direction.
         */
        public Flip():void;
        /**
         * Moves the plane in space by the translation vector.
         * @param translation The offset in space to move the plane with.
         */
        public Translate($translation: Vector3):void;
        /**
         * Returns a copy of the given plane that is moved in space by the given translation.
         * @param plane The plane to move in space.
         * @param translation The offset in space to move the plane with.
         * @returns The translated plane.
         */
        public static Translate($plane: Plane, $translation: Vector3):Plane;
        /**
         * For a given point returns the closest point on the plane.
         * @param point The point to project onto the plane.
         * @returns A point on the plane that is closest to point.
         */
        public ClosestPointOnPlane($point: Vector3):Vector3;
        /**
         * Returns a signed distance from plane to point.
         */
        public GetDistanceToPoint($point: Vector3):number;
        /**
         * Is a point on the positive side of the plane?
         */
        public GetSide($point: Vector3):boolean;
        /**
         * Are two points on the same side of the plane?
         */
        public SameSide($inPt0: Vector3, $inPt1: Vector3):boolean;
        /**
         * Intersects a ray with the plane.
         */
        public Raycast($ray: Ray, $enter: $Ref<number>):boolean;
        
        public ToString():string;
        
        public ToString($format: string):string;
        
        public ToString($format: string, $formatProvider: System.IFormatProvider):string;
        
        public get_Clone(): Plane;            
    }
    /**
     * A ray in 2D space.
     */
    class Ray2D extends System.ValueType {
        /**
         * The starting point of the ray in world space.
         */
        public get origin(): Vector2;
        public set origin(value: Vector2);
        /**
         * The direction of the ray in world space.
         */
        public get direction(): Vector2;
        public set direction(value: Vector2);
        /**
         * Creates a 2D ray starting at origin along direction.
         * @param Vector2 Direction.
         */
        public constructor($origin: Vector2, $direction: Vector2);
        /**
         * Get a point that lies a given distance along a ray.
         * @param distance Distance of the desired point along the path of the ray.
         */
        public GetPoint($distance: number):Vector2;
        /**
         * Returns a formatted string for this 2D ray.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        public ToString():string;
        /**
         * Returns a formatted string for this 2D ray.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        public ToString($format: string):string;
        /**
         * Returns a formatted string for this 2D ray.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        public ToString($format: string, $formatProvider: System.IFormatProvider):string;
        
        public get_Clone(): Ray2D;            
    }
    /**
     * A 2D Rectangle defined by x, y, width, height with integers.
     */
    class RectInt extends System.ValueType {
        /**
         * Left coordinate of the rectangle.
         */
        public get x(): number;
        public set x(value: number);
        /**
         * Top coordinate of the rectangle.
         */
        public get y(): number;
        public set y(value: number);
        /**
         * Center coordinate of the rectangle.
         */
        public get center(): Vector2;
        /**
         * The lower left corner of the rectangle; which is the minimal position of the rectangle along the x- and y-axes, when it is aligned to both axes.
         */
        public get min(): Vector2Int;
        public set min(value: Vector2Int);
        /**
         * The upper right corner of the rectangle; which is the maximal position of the rectangle along the x- and y-axes, when it is aligned to both axes.
         */
        public get max(): Vector2Int;
        public set max(value: Vector2Int);
        /**
         * Width of the rectangle.
         */
        public get width(): number;
        public set width(value: number);
        /**
         * Height of the rectangle.
         */
        public get height(): number;
        public set height(value: number);
        /**
         * Shows the minimum X value of the RectInt.
         */
        public get xMin(): number;
        public set xMin(value: number);
        /**
         * Show the minimum Y value of the RectInt.
         */
        public get yMin(): number;
        public set yMin(value: number);
        /**
         * Shows the maximum X value of the RectInt.
         */
        public get xMax(): number;
        public set xMax(value: number);
        /**
         * Shows the maximum Y value of the RectInt.
         */
        public get yMax(): number;
        public set yMax(value: number);
        /**
         * Returns the position (x, y) of the RectInt.
         */
        public get position(): Vector2Int;
        public set position(value: Vector2Int);
        /**
         * Returns the width and height of the RectInt.
         */
        public get size(): Vector2Int;
        public set size(value: Vector2Int);
        /**
         * A RectInt.PositionCollection that contains all positions within the RectInt.
         */
        public get allPositionsWithin(): UnityEngine_RectInt.PositionEnumerator;
        
        public constructor($xMin: number, $yMin: number, $width: number, $height: number);
        
        public constructor($position: Vector2Int, $size: Vector2Int);
        /**
         * Sets the bounds to the min and max value of the rect.
         */
        public SetMinMax($minPosition: Vector2Int, $maxPosition: Vector2Int):void;
        /**
         * Clamps the position and size of the RectInt to the given bounds.
         * @param bounds Bounds to clamp the RectInt.
         */
        public ClampToBounds($bounds: RectInt):void;
        /**
         * Returns true if the given position is within the RectInt.
         * @param position Position to check.
         * @returns Whether the position is within the RectInt.
         */
        public Contains($position: Vector2Int):boolean;
        /**
         * RectInts overlap if each RectInt Contains a shared point.
         * @param other Other rectangle to test overlapping with.
         * @returns True if the other rectangle overlaps this one.
         */
        public Overlaps($other: RectInt):boolean;
        /**
         * Returns the x, y, width and height of the RectInt.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        public ToString():string;
        /**
         * Returns the x, y, width and height of the RectInt.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        public ToString($format: string):string;
        /**
         * Returns the x, y, width and height of the RectInt.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        public ToString($format: string, $formatProvider: System.IFormatProvider):string;
        /**
         * Returns true if the given RectInt is equal to this RectInt.
         */
        public Equals($other: RectInt):boolean;
        
        public get_Clone(): RectInt;            
    }
    /**
     * Representation of 2D vectors and points using integers.
     */
    class Vector2Int extends System.ValueType {
        /**
         * X component of the vector.
         */
        public get x(): number;
        public set x(value: number);
        /**
         * Y component of the vector.
         */
        public get y(): number;
        public set y(value: number);
        /**
         * Returns the length of this vector (Read Only).
         */
        public get magnitude(): number;
        /**
         * Returns the squared length of this vector (Read Only).
         */
        public get sqrMagnitude(): number;
        /**
         * Shorthand for writing Vector2Int(0, 0).
         */
        public static get zero(): Vector2Int;
        /**
         * Shorthand for writing Vector2Int(1, 1).
         */
        public static get one(): Vector2Int;
        /**
         * Shorthand for writing Vector2Int(0, 1).
         */
        public static get up(): Vector2Int;
        /**
         * Shorthand for writing Vector2Int(0, -1).
         */
        public static get down(): Vector2Int;
        /**
         * Shorthand for writing Vector2Int(-1, 0).
         */
        public static get left(): Vector2Int;
        /**
         * Shorthand for writing Vector2Int(1, 0).
         */
        public static get right(): Vector2Int;
        
        public constructor($x: number, $y: number);
        /**
         * Set x and y components of an existing Vector2Int.
         */
        public Set($x: number, $y: number):void;
        
        public get_Item($index: number):number;
        
        public set_Item($index: number, $value: number):void;
        /**
         * Returns the distance between a and b.
         */
        public static Distance($a: Vector2Int, $b: Vector2Int):number;
        /**
         * Returns a vector that is made from the smallest components of two vectors.
         */
        public static Min($lhs: Vector2Int, $rhs: Vector2Int):Vector2Int;
        /**
         * Returns a vector that is made from the largest components of two vectors.
         */
        public static Max($lhs: Vector2Int, $rhs: Vector2Int):Vector2Int;
        /**
         * Multiplies two vectors component-wise.
         */
        public static Scale($a: Vector2Int, $b: Vector2Int):Vector2Int;
        /**
         * Multiplies every component of this vector by the same component of scale.
         */
        public Scale($scale: Vector2Int):void;
        /**
         * Clamps the Vector2Int to the bounds given by min and max.
         */
        public Clamp($min: Vector2Int, $max: Vector2Int):void;
        
        public static op_Implicit($v: Vector2Int):Vector2;
        /**
         * Converts a Vector2Int to a Vector3Int.
         */
        public static op_Explicit($v: Vector2Int):Vector3Int;
        /**
         * Converts a Vector2 to a Vector2Int by doing a Floor to each value.
         */
        public static FloorToInt($v: Vector2):Vector2Int;
        /**
         * Converts a  Vector2 to a Vector2Int by doing a Ceiling to each value.
         */
        public static CeilToInt($v: Vector2):Vector2Int;
        /**
         * Converts a  Vector2 to a Vector2Int by doing a Round to each value.
         */
        public static RoundToInt($v: Vector2):Vector2Int;
        
        public static op_UnaryNegation($v: Vector2Int):Vector2Int;
        
        public static op_Addition($a: Vector2Int, $b: Vector2Int):Vector2Int;
        
        public static op_Subtraction($a: Vector2Int, $b: Vector2Int):Vector2Int;
        /**
         * Multiplies a vector by a number.
         */
        public static op_Multiply($a: Vector2Int, $b: Vector2Int):Vector2Int;
        
        public static op_Multiply($a: number, $b: Vector2Int):Vector2Int;
        /**
         * Multiplies a vector by a number.
         */
        public static op_Multiply($a: Vector2Int, $b: number):Vector2Int;
        
        public static op_Division($a: Vector2Int, $b: number):Vector2Int;
        
        public static op_Equality($lhs: Vector2Int, $rhs: Vector2Int):boolean;
        
        public static op_Inequality($lhs: Vector2Int, $rhs: Vector2Int):boolean;
        /**
         * Returns true if the objects are equal.
         */
        public Equals($other: any):boolean;
        
        public Equals($other: Vector2Int):boolean;
        /**
         * Gets the hash code for the Vector2Int.
         * @returns The hash code of the Vector2Int.
         */
        public GetHashCode():number;
        /**
         * Returns a formatted string for this vector.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        public ToString():string;
        /**
         * Returns a formatted string for this vector.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        public ToString($format: string):string;
        /**
         * Returns a formatted string for this vector.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        public ToString($format: string, $formatProvider: System.IFormatProvider):string;
        
        public get_Clone(): Vector2Int;            
    }
    /**
     * Offsets for rectangles, borders, etc.
     */
    class RectOffset extends System.Object {
        /**
         * Left edge size.
         */
        public get left(): number;
        public set left(value: number);
        /**
         * Right edge size.
         */
        public get right(): number;
        public set right(value: number);
        /**
         * Top edge size.
         */
        public get top(): number;
        public set top(value: number);
        /**
         * Bottom edge size.
         */
        public get bottom(): number;
        public set bottom(value: number);
        /**
         * Shortcut for left + right. (Read Only)
         */
        public get horizontal(): number;
        /**
         * Shortcut for top + bottom. (Read Only)
         */
        public get vertical(): number;
        /**
         * Creates a new rectangle with offsets.
         */
        public constructor();
        /**
         * Creates a new rectangle with offsets.
         */
        public constructor($left: number, $right: number, $top: number, $bottom: number);
        /**
         * Returns a formatted string for this RectOffset.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        public ToString():string;
        /**
         * Returns a formatted string for this RectOffset.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        public ToString($format: string):string;
        /**
         * Returns a formatted string for this RectOffset.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        public ToString($format: string, $formatProvider: System.IFormatProvider):string;
        /**
         * Add the border offsets to a rect.
         */
        public Add($rect: Rect):Rect;
        /**
         * Remove the border offsets from a rect.
         */
        public Remove($rect: Rect):Rect;
        
                    
    }
    /**
     * Gizmos are used to give visual debugging or setup aids in the Scene view.
     */
    class Gizmos extends System.Object {
        /**
         * Sets the color for the gizmos that will be drawn next.
         */
        public static get color(): Color;
        public static set color(value: Color);
        /**
         * Sets the Matrix4x4 that the Unity Editor uses to draw Gizmos.
         */
        public static get matrix(): Matrix4x4;
        public static set matrix(value: Matrix4x4);
        /**
         * Set a texture that contains the exposure correction for LightProbe gizmos. The value is sampled from the red channel in the middle of the texture.
         */
        public static get exposure(): Texture;
        public static set exposure(value: Texture);
        /**
         * Set a scale for Light Probe gizmos. This scale will be used to render the spherical harmonic preview spheres.
         */
        public static get probeSize(): number;
        
        public constructor();
        /**
         * Draws a line starting at from towards to.
         */
        public static DrawLine($from: Vector3, $to: Vector3):void;
        /**
         * Draws a wireframe sphere with center and radius.
         */
        public static DrawWireSphere($center: Vector3, $radius: number):void;
        /**
         * Draws a solid sphere with center and radius.
         */
        public static DrawSphere($center: Vector3, $radius: number):void;
        /**
         * Draw a wireframe box with center and size.
         */
        public static DrawWireCube($center: Vector3, $size: Vector3):void;
        /**
         * Draw a solid box with center and size.
         */
        public static DrawCube($center: Vector3, $size: Vector3):void;
        /**
         * Draws a mesh.
         * @param mesh Mesh to draw as a gizmo.
         * @param position Position (default is zero).
         * @param rotation Rotation (default is no rotation).
         * @param scale Scale (default is no scale).
         * @param submeshIndex Submesh to draw (default is -1, which draws whole mesh).
         */
        public static DrawMesh($mesh: Mesh, $submeshIndex: number, $position: Vector3, $rotation: Quaternion, $scale: Vector3):void;
        /**
         * Draws a wireframe mesh.
         * @param mesh Mesh to draw as a gizmo.
         * @param position Position (default is zero).
         * @param rotation Rotation (default is no rotation).
         * @param scale Scale (default is no scale).
         * @param submeshIndex Submesh to draw (default is -1, which draws whole mesh).
         */
        public static DrawWireMesh($mesh: Mesh, $submeshIndex: number, $position: Vector3, $rotation: Quaternion, $scale: Vector3):void;
        /**
         * Draw an icon at a position in the Scene view.
         */
        public static DrawIcon($center: Vector3, $name: string, $allowScaling: boolean):void;
        
        public static DrawIcon($center: Vector3, $name: string, $allowScaling: boolean, $tint: Color):void;
        /**
         * Draw a texture in the Scene.
         * @param screenRect The size and position of the texture on the "screen" defined by the XY plane.
         * @param texture The texture to be displayed.
         * @param mat An optional material to apply the texture.
         * @param leftBorder Inset from the rectangle's left edge.
         * @param rightBorder Inset from the rectangle's right edge.
         * @param topBorder Inset from the rectangle's top edge.
         * @param bottomBorder Inset from the rectangle's bottom edge.
         */
        public static DrawGUITexture($screenRect: Rect, $texture: Texture, $leftBorder: number, $rightBorder: number, $topBorder: number, $bottomBorder: number, $mat: Material):void;
        /**
         * Draw a camera frustum using the currently set Gizmos.matrix for it's location and rotation.
         * @param center The apex of the truncated pyramid.
         * @param fov Vertical field of view (ie, the angle at the apex in degrees).
         * @param maxRange Distance of the frustum's far plane.
         * @param minRange Distance of the frustum's near plane.
         * @param aspect Width/height ratio.
         */
        public static DrawFrustum($center: Vector3, $fov: number, $maxRange: number, $minRange: number, $aspect: number):void;
        /**
         * Draws a ray starting at from to from + direction.
         */
        public static DrawRay($r: Ray):void;
        /**
         * Draws a ray starting at from to from + direction.
         */
        public static DrawRay($from: Vector3, $direction: Vector3):void;
        
        public static DrawMesh($mesh: Mesh, $position: Vector3, $rotation: Quaternion):void;
        
        public static DrawMesh($mesh: Mesh, $position: Vector3):void;
        
        public static DrawMesh($mesh: Mesh):void;
        /**
         * Draws a mesh.
         * @param mesh Mesh to draw as a gizmo.
         * @param position Position (default is zero).
         * @param rotation Rotation (default is no rotation).
         * @param scale Scale (default is no scale).
         * @param submeshIndex Submesh to draw (default is -1, which draws whole mesh).
         */
        public static DrawMesh($mesh: Mesh, $position: Vector3, $rotation: Quaternion, $scale: Vector3):void;
        
        public static DrawMesh($mesh: Mesh, $submeshIndex: number, $position: Vector3, $rotation: Quaternion):void;
        
        public static DrawMesh($mesh: Mesh, $submeshIndex: number, $position: Vector3):void;
        
        public static DrawMesh($mesh: Mesh, $submeshIndex: number):void;
        
        public static DrawWireMesh($mesh: Mesh, $position: Vector3, $rotation: Quaternion):void;
        
        public static DrawWireMesh($mesh: Mesh, $position: Vector3):void;
        
        public static DrawWireMesh($mesh: Mesh):void;
        /**
         * Draws a wireframe mesh.
         * @param mesh Mesh to draw as a gizmo.
         * @param position Position (default is zero).
         * @param rotation Rotation (default is no rotation).
         * @param scale Scale (default is no scale).
         * @param submeshIndex Submesh to draw (default is -1, which draws whole mesh).
         */
        public static DrawWireMesh($mesh: Mesh, $position: Vector3, $rotation: Quaternion, $scale: Vector3):void;
        
        public static DrawWireMesh($mesh: Mesh, $submeshIndex: number, $position: Vector3, $rotation: Quaternion):void;
        
        public static DrawWireMesh($mesh: Mesh, $submeshIndex: number, $position: Vector3):void;
        
        public static DrawWireMesh($mesh: Mesh, $submeshIndex: number):void;
        /**
         * Draw an icon at a position in the Scene view.
         */
        public static DrawIcon($center: Vector3, $name: string):void;
        /**
         * Draw a texture in the Scene.
         * @param screenRect The size and position of the texture on the "screen" defined by the XY plane.
         * @param texture The texture to be displayed.
         * @param mat An optional material to apply the texture.
         * @param leftBorder Inset from the rectangle's left edge.
         * @param rightBorder Inset from the rectangle's right edge.
         * @param topBorder Inset from the rectangle's top edge.
         * @param bottomBorder Inset from the rectangle's bottom edge.
         */
        public static DrawGUITexture($screenRect: Rect, $texture: Texture):void;
        /**
         * Draw a texture in the Scene.
         * @param screenRect The size and position of the texture on the "screen" defined by the XY plane.
         * @param texture The texture to be displayed.
         * @param mat An optional material to apply the texture.
         * @param leftBorder Inset from the rectangle's left edge.
         * @param rightBorder Inset from the rectangle's right edge.
         * @param topBorder Inset from the rectangle's top edge.
         * @param bottomBorder Inset from the rectangle's bottom edge.
         */
        public static DrawGUITexture($screenRect: Rect, $texture: Texture, $mat: Material):void;
        /**
         * Draw a texture in the Scene.
         * @param screenRect The size and position of the texture on the "screen" defined by the XY plane.
         * @param texture The texture to be displayed.
         * @param mat An optional material to apply the texture.
         * @param leftBorder Inset from the rectangle's left edge.
         * @param rightBorder Inset from the rectangle's right edge.
         * @param topBorder Inset from the rectangle's top edge.
         * @param bottomBorder Inset from the rectangle's bottom edge.
         */
        public static DrawGUITexture($screenRect: Rect, $texture: Texture, $leftBorder: number, $rightBorder: number, $topBorder: number, $bottomBorder: number):void;
        
                    
    }
    /**
     * Use this BeforeRenderOrderAttribute when you need to specify a custom callback order for Application.onBeforeRender.
     */
    class BeforeRenderOrderAttribute extends System.Attribute {
        /**
         * The order, lowest to highest, that the Application.onBeforeRender event recievers will be called in.
         */
        public get order(): number;
        /**
         * When applied to methods, specifies the order called during Application.onBeforeRender events.
         * @param order The sorting order, sorted lowest to highest.
         */
        public constructor($order: number);
        
                    
    }
    /**
     * BillboardAsset describes how a billboard is rendered.
     */
    class BillboardAsset extends Object {
        /**
         * Width of the billboard.
         */
        public get width(): number;
        public set width(value: number);
        /**
         * Height of the billboard.
         */
        public get height(): number;
        public set height(value: number);
        /**
         * Height of the billboard that is below ground.
         */
        public get bottom(): number;
        public set bottom(value: number);
        /**
         * Number of pre-rendered images that can be switched when the billboard is viewed from different angles.
         */
        public get imageCount(): number;
        /**
         * Number of vertices in the billboard mesh.
         */
        public get vertexCount(): number;
        /**
         * Number of indices in the billboard mesh.
         */
        public get indexCount(): number;
        /**
         * The material used for rendering.
         */
        public get material(): Material;
        public set material(value: Material);
        /**
         * Constructs a new BillboardAsset.
         */
        public constructor();
        
        public GetImageTexCoords($imageTexCoords: System_Collections_Generic.List$1<Vector4>):void;
        /**
         * Get the array of billboard image texture coordinate data.
         * @param imageTexCoords The list that receives the array.
         */
        public GetImageTexCoords():Vector4[];
        
        public SetImageTexCoords($imageTexCoords: System_Collections_Generic.List$1<Vector4>):void;
        /**
         * Set the array of billboard image texture coordinate data.
         * @param imageTexCoords The array of data to set.
         */
        public SetImageTexCoords($imageTexCoords: Vector4[]):void;
        
        public GetVertices($vertices: System_Collections_Generic.List$1<Vector2>):void;
        /**
         * Get the vertices of the billboard mesh.
         * @param vertices The list that receives the array.
         */
        public GetVertices():Vector2[];
        
        public SetVertices($vertices: System_Collections_Generic.List$1<Vector2>):void;
        /**
         * Set the vertices of the billboard mesh.
         * @param vertices The array of data to set.
         */
        public SetVertices($vertices: Vector2[]):void;
        
        public GetIndices($indices: System_Collections_Generic.List$1<number>):void;
        /**
         * Get the indices of the billboard mesh.
         * @param indices The list that receives the array.
         */
        public GetIndices():number[];
        
        public SetIndices($indices: System_Collections_Generic.List$1<number>):void;
        /**
         * Set the indices of the billboard mesh.
         * @param indices The array of data to set.
         */
        public SetIndices($indices: number[]):void;
        
                    
    }
    /**
     * Renders a billboard from a BillboardAsset.
     */
    class BillboardRenderer extends Renderer {
        /**
         * The BillboardAsset to render.
         */
        public get billboard(): BillboardAsset;
        public set billboard(value: BillboardAsset);
        /**
         * Constructor.
         */
        public constructor();
        
                    
    }
    /**
     * Custom Render Texture Manager.
     */
    class CustomRenderTextureManager extends System.Object {
        
        public static add_textureLoaded($value: System.Action$1<CustomRenderTexture>):void;
        
        public static remove_textureLoaded($value: System.Action$1<CustomRenderTexture>):void;
        
        public static add_textureUnloaded($value: System.Action$1<CustomRenderTexture>):void;
        
        public static remove_textureUnloaded($value: System.Action$1<CustomRenderTexture>):void;
        
        public static GetAllCustomRenderTextures($currentCustomRenderTextures: System_Collections_Generic.List$1<CustomRenderTexture>):void;
        
        public static add_updateTriggered($value: System.Action$2<CustomRenderTexture, number>):void;
        
        public static remove_updateTriggered($value: System.Action$2<CustomRenderTexture, number>):void;
        
        public static add_initializeTriggered($value: System.Action$1<CustomRenderTexture>):void;
        
        public static remove_initializeTriggered($value: System.Action$1<CustomRenderTexture>):void;
        
        public static textureLoaded;
        
        public static textureUnloaded;
        
        public static updateTriggered;
        
        public static initializeTriggered;
        
                    
    }
    /**
     * Custom Render Textures are an extension to Render Textures that allow you to render directly to the Texture using a Shader.
     */
    class CustomRenderTexture extends RenderTexture {
        /**
         * The Material that Unity uses to initialize the content of a Custom Render Texture.
         */
        public get material(): Material;
        public set material(value: Material);
        /**
         * The Material that Unity uses to initialize a Custom Render Texture. Initialization texture and color are ignored if you have set this parameter.
         */
        public get initializationMaterial(): Material;
        public set initializationMaterial(value: Material);
        /**
         * The Texture that Unity uses to initialize a Custom Render Texture, multiplied by the initialization color. Unity ignores this parameter if an initializationMaterial is set.
         */
        public get initializationTexture(): Texture;
        public set initializationTexture(value: Texture);
        /**
         * Determine if Unity initializes the Custom Render Texture with a Texture and a Color or a Material.
         */
        public get initializationSource(): CustomRenderTextureInitializationSource;
        public set initializationSource(value: CustomRenderTextureInitializationSource);
        /**
         * The color that Unity uses to initialize a Custom Render Texture. Unity ignores this parameter if an initializationMaterial is set.
         */
        public get initializationColor(): Color;
        public set initializationColor(value: Color);
        /**
         * Determine how Unity updates the Custom Render Texture.
         */
        public get updateMode(): CustomRenderTextureUpdateMode;
        public set updateMode(value: CustomRenderTextureUpdateMode);
        /**
         * Determine how Unity initializes a texture.
         */
        public get initializationMode(): CustomRenderTextureUpdateMode;
        public set initializationMode(value: CustomRenderTextureUpdateMode);
        /**
         * The space in which Unity expresses update zones. You can set this to Normalized or Pixel space.
         */
        public get updateZoneSpace(): CustomRenderTextureUpdateZoneSpace;
        public set updateZoneSpace(value: CustomRenderTextureUpdateZoneSpace);
        /**
         * The Shader Pass Unity uses to update the Custom Render Texture.
         */
        public get shaderPass(): number;
        public set shaderPass(value: number);
        /**
         * The bit field that you can use to enable or disable update on each of the cubemap faces. The bit order from least to most significant bit is as follows: +X, -X, +Y, -Y, +Z, -Z.
         */
        public get cubemapFaceMask(): number;
        public set cubemapFaceMask(value: number);
        /**
         * When this parameter is set to true, Unity double-buffers the Custom Render Texture so that you can access it during its own update.
         */
        public get doubleBuffered(): boolean;
        public set doubleBuffered(value: boolean);
        /**
         * When this parameter is set to true, Unity wraps Update zones around the border of the Custom Render Texture. Otherwise, Unity clamps Update zones at the border of the Custom Render Texture.
         */
        public get wrapUpdateZones(): boolean;
        public set wrapUpdateZones(value: boolean);
        /**
         * The period in seconds that Unity updates real-time Custom Render Textures. A value of 0.0 means Unity updates real-time Custom Render Textures every frame.
         */
        public get updatePeriod(): number;
        public set updatePeriod(value: number);
        /**
         * Create a new Custom Render Texture.
         */
        public constructor($width: number, $height: number, $format: RenderTextureFormat, $readWrite: RenderTextureReadWrite);
        /**
         * Create a new Custom Render Texture.
         */
        public constructor($width: number, $height: number, $format: RenderTextureFormat);
        /**
         * Create a new Custom Render Texture.
         */
        public constructor($width: number, $height: number);
        
        public constructor($width: number, $height: number, $defaultFormat: UnityEngine_Experimental_Rendering.DefaultFormat);
        
        public constructor($width: number, $height: number, $format: UnityEngine_Experimental_Rendering.GraphicsFormat);
        /**
         * Triggers an update of the Custom Render Texture.
         * @param count Number of upate pass to perform. The default value of this count parameter is 1.
         */
        public Update($count: number):void;
        
        public Update():void;
        /**
         * Initializes the Custom Render Texture at the start of the next frame. Unity calls Initialise() before CustomRenderTexture.Update.
         */
        public Initialize():void;
        /**
         * Clear all Update Zones.
         */
        public ClearUpdateZones():void;
        
        public GetUpdateZones($updateZones: System_Collections_Generic.List$1<CustomRenderTextureUpdateZone>):void;
        /**
         * Gets the Render Texture that this Custom Render Texture uses for double buffering.
         * @returns If CustomRenderTexture. doubleBuffered is true, this returns the Render Texture that this Custom Render Texture uses for double buffering. If CustomRenderTexture. doubleBuffered is false, this returns null.
         */
        public GetDoubleBufferRenderTexture():RenderTexture;
        /**
         * Updates the internal Render Texture that a Custom Render Texture uses for double buffering, so that it matches the size and format of the Custom Render Texture.
         */
        public EnsureDoubleBufferConsistency():void;
        /**
         * Setup the list of Update Zones for the Custom Render Texture.
         */
        public SetUpdateZones($updateZones: CustomRenderTextureUpdateZone[]):void;
        /**
         * Creates a new RenderTexture object.
         * @param width Texture width in pixels.
         * @param height Texture height in pixels.
         * @param depth Number of bits in depth buffer (0, 16 or 24). Note that only 24 bit depth has stencil buffer.
         * @param format Texture color format.
         * @param readWrite How or if color space conversions should be done on texture read/write.
         * @param desc Create the RenderTexture with the settings in the RenderTextureDescriptor.
         * @param textureToCopy Copy the settings from another RenderTexture.
         */
        public constructor($desc: RenderTextureDescriptor);
        /**
         * Creates a new RenderTexture object.
         * @param width Texture width in pixels.
         * @param height Texture height in pixels.
         * @param depth Number of bits in depth buffer (0, 16 or 24). Note that only 24 bit depth has stencil buffer.
         * @param format Texture color format.
         * @param readWrite How or if color space conversions should be done on texture read/write.
         * @param desc Create the RenderTexture with the settings in the RenderTextureDescriptor.
         * @param textureToCopy Copy the settings from another RenderTexture.
         */
        public constructor($textureToCopy: RenderTexture);
        
        public constructor($width: number, $height: number, $depth: number, $format: UnityEngine_Experimental_Rendering.DefaultFormat);
        
        public constructor($width: number, $height: number, $depth: number, $format: UnityEngine_Experimental_Rendering.GraphicsFormat);
        
        public constructor($width: number, $height: number, $depth: number, $format: UnityEngine_Experimental_Rendering.GraphicsFormat, $mipCount: number);
        /**
         * Creates a new RenderTexture object.
         * @param width Texture width in pixels.
         * @param height Texture height in pixels.
         * @param depth Number of bits in depth buffer (0, 16 or 24). Note that only 24 bit depth has stencil buffer.
         * @param format Texture color format.
         * @param readWrite How or if color space conversions should be done on texture read/write.
         * @param desc Create the RenderTexture with the settings in the RenderTextureDescriptor.
         * @param textureToCopy Copy the settings from another RenderTexture.
         */
        public constructor($width: number, $height: number, $depth: number, $format: RenderTextureFormat, $readWrite: RenderTextureReadWrite);
        
        public constructor($width: number, $height: number, $depth: number, $format: RenderTextureFormat);
        
        public constructor($width: number, $height: number, $depth: number);
        
        public constructor($width: number, $height: number, $depth: number, $format: RenderTextureFormat, $mipCount: number);
        
        public constructor();
        
                    
    }
    /**
     * Provides access to a display / screen for rendering operations.
     */
    class Display extends System.Object {
        /**
         * The list of currently connected displays.
         */
        public static displays: Display[];
        /**
         * Horizontal resolution that the display is rendering at.
         */
        public get renderingWidth(): number;
        /**
         * Vertical resolution that the display is rendering at.
         */
        public get renderingHeight(): number;
        /**
         * Horizontal native display resolution.
         */
        public get systemWidth(): number;
        /**
         * Vertical native display resolution.
         */
        public get systemHeight(): number;
        /**
         * Color RenderBuffer.
         */
        public get colorBuffer(): RenderBuffer;
        /**
         * Depth RenderBuffer.
         */
        public get depthBuffer(): RenderBuffer;
        /**
         * Gets the state of the display and returns true if the display is active and false if otherwise.
         */
        public get active(): boolean;
        /**
         * True when the back buffer requires an intermediate texture to render.
         */
        public get requiresBlitToBackbuffer(): boolean;
        /**
         * True when doing a blit to the back buffer requires manual color space conversion.
         */
        public get requiresSrgbBlitToBackbuffer(): boolean;
        /**
         * Main Display.
         */
        public static get main(): Display;
        /**
         * Activate an external display. Eg. Secondary Monitors connected to the System.
         */
        public Activate():void;
        /**
         * This overloaded function available for Windows allows specifying desired Window Width, Height and Refresh Rate.
         * @param width Desired Width of the Window (for Windows only. On Linux and Mac uses Screen Width).
         * @param height Desired Height of the Window (for Windows only. On Linux and Mac uses Screen Height).
         * @param refreshRate Desired Refresh Rate.
         */
        public Activate($width: number, $height: number, $refreshRate: number):void;
        /**
         * Set rendering size and position on screen (Windows only).
         * @param width Change Window Width (Windows Only).
         * @param height Change Window Height (Windows Only).
         * @param x Change Window Position X (Windows Only).
         * @param y Change Window Position Y (Windows Only).
         */
        public SetParams($width: number, $height: number, $x: number, $y: number):void;
        /**
         * Sets rendering resolution for the display.
         * @param w Rendering width in pixels.
         * @param h Rendering height in pixels.
         */
        public SetRenderingResolution($w: number, $h: number):void;
        /**
         * Query relative mouse coordinates.
         * @param inputMouseCoordinates Mouse Input Position as Coordinates.
         */
        public static RelativeMouseAt($inputMouseCoordinates: Vector3):Vector3;
        
        public static add_onDisplaysUpdated($value: UnityEngine_Display.DisplaysUpdatedDelegate):void;
        
        public static remove_onDisplaysUpdated($value: UnityEngine_Display.DisplaysUpdatedDelegate):void;
        
        public static onDisplaysUpdated;
        
                    
    }
    /**
     * Platform agnostic fullscreen mode. Not all platforms support all modes.
     */
    enum FullScreenMode { ExclusiveFullScreen = 0, FullScreenWindow = 1, MaximizedWindow = 2, Windowed = 3 }
    /**
     * Constants for special values of Screen.sleepTimeout.
     */
    class SleepTimeout extends System.Object {
        /**
         * Prevent screen dimming.
         */
        public static NeverSleep: number;
        /**
         * Set the sleep timeout to whatever the user has specified in the system settings.
         */
        public static SystemSetting: number;
        
        public constructor();
        
                    
    }
    /**
     * Access to display information.
     */
    class Screen extends System.Object {
        /**
         * The current width of the screen window in pixels (Read Only).
         */
        public static get width(): number;
        /**
         * The current height of the screen window in pixels (Read Only).
         */
        public static get height(): number;
        /**
         * The current DPI of the screen / device (Read Only).
         */
        public static get dpi(): number;
        /**
         * The current screen resolution (Read Only).
         */
        public static get currentResolution(): Resolution;
        /**
         * All full-screen resolutions supported by the monitor (Read Only).
         */
        public static get resolutions(): Resolution[];
        /**
         * Is the game running full-screen?
         */
        public static get fullScreen(): boolean;
        public static set fullScreen(value: boolean);
        /**
         * Set this property to one of the values in FullScreenMode to change the display mode of your application.
         */
        public static get fullScreenMode(): FullScreenMode;
        public static set fullScreenMode(value: FullScreenMode);
        /**
         * Returns the safe area of the screen in pixels (Read Only).
         */
        public static get safeArea(): Rect;
        /**
         * Returns a list of screen areas that are not functional for displaying content (Read Only).
         */
        public static get cutouts(): Rect[];
        /**
         * Allow auto-rotation to portrait?
         */
        public static get autorotateToPortrait(): boolean;
        public static set autorotateToPortrait(value: boolean);
        /**
         * Allow auto-rotation to portrait, upside down?
         */
        public static get autorotateToPortraitUpsideDown(): boolean;
        public static set autorotateToPortraitUpsideDown(value: boolean);
        /**
         * Allow auto-rotation to landscape left?
         */
        public static get autorotateToLandscapeLeft(): boolean;
        public static set autorotateToLandscapeLeft(value: boolean);
        /**
         * Allow auto-rotation to landscape right?
         */
        public static get autorotateToLandscapeRight(): boolean;
        public static set autorotateToLandscapeRight(value: boolean);
        /**
         * Specifies logical orientation of the screen.
         */
        public static get orientation(): ScreenOrientation;
        public static set orientation(value: ScreenOrientation);
        /**
         * A power saving setting, allowing the screen to dim some time after the last active user interaction.
         */
        public static get sleepTimeout(): number;
        public static set sleepTimeout(value: number);
        /**
         * The current brightness of the screen.
         */
        public static get brightness(): number;
        public static set brightness(value: number);
        
        public constructor();
        /**
         * Switches the screen resolution.
         */
        public static SetResolution($width: number, $height: number, $fullscreenMode: FullScreenMode, $preferredRefreshRate: number):void;
        
        public static SetResolution($width: number, $height: number, $fullscreenMode: FullScreenMode):void;
        /**
         * Switches the screen resolution.
         */
        public static SetResolution($width: number, $height: number, $fullscreen: boolean, $preferredRefreshRate: number):void;
        /**
         * Switches the screen resolution.
         */
        public static SetResolution($width: number, $height: number, $fullscreen: boolean):void;
        
                    
    }
    /**
     * Represents a display resolution.
     */
    class Resolution extends System.ValueType {
        /**
         * Resolution width in pixels.
         */
        public get width(): number;
        public set width(value: number);
        /**
         * Resolution height in pixels.
         */
        public get height(): number;
        public set height(value: number);
        /**
         * Resolution's vertical refresh rate in Hz.
         */
        public get refreshRate(): number;
        public set refreshRate(value: number);
        /**
         * Returns a nicely formatted string of the resolution.
         * @returns A string with the format "width x height @ refreshRateHz".
         */
        public ToString():string;
        
        public get_Clone(): Resolution;            
    }
    /**
     * Describes screen orientation.
     */
    enum ScreenOrientation { Unknown = 0, Portrait = 1, PortraitUpsideDown = 2, LandscapeLeft = 3, LandscapeRight = 4, AutoRotation = 5, Landscape = 3 }
    /**
     * Intended usage of the buffer.
     */
    enum ComputeBufferMode { Immutable = 0, Dynamic = 1, Circular = 2, StreamOut = 3, SubUpdates = 4 }
    /**
     * Low-level graphics library.
     */
    class GL extends System.Object {
        /**
         * Mode for Begin: draw triangles.
         */
        public static TRIANGLES: number;
        /**
         * Mode for Begin: draw triangle strip.
         */
        public static TRIANGLE_STRIP: number;
        /**
         * Mode for Begin: draw quads.
         */
        public static QUADS: number;
        /**
         * Mode for Begin: draw lines.
         */
        public static LINES: number;
        /**
         * Mode for Begin: draw line strip.
         */
        public static LINE_STRIP: number;
        /**
         * Should rendering be done in wireframe?
         */
        public static get wireframe(): boolean;
        public static set wireframe(value: boolean);
        /**
         * Controls whether Linear-to-sRGB color conversion is performed while rendering.
         */
        public static get sRGBWrite(): boolean;
        public static set sRGBWrite(value: boolean);
        /**
         * Select whether to invert the backface culling (true) or not (false).
         */
        public static get invertCulling(): boolean;
        public static set invertCulling(value: boolean);
        /**
         * Gets or sets the modelview matrix.
         */
        public static get modelview(): Matrix4x4;
        public static set modelview(value: Matrix4x4);
        
        public constructor();
        /**
         * Submit a vertex.
         */
        public static Vertex3($x: number, $y: number, $z: number):void;
        /**
         * Submit a vertex.
         */
        public static Vertex($v: Vector3):void;
        /**
         * Sets current texture coordinate (x,y,z) for all texture units.
         */
        public static TexCoord3($x: number, $y: number, $z: number):void;
        /**
         * Sets current texture coordinate (v.x,v.y,v.z) for all texture units.
         */
        public static TexCoord($v: Vector3):void;
        /**
         * Sets current texture coordinate (x,y) for all texture units.
         */
        public static TexCoord2($x: number, $y: number):void;
        /**
         * Sets current texture coordinate (x,y,z) to the actual texture unit.
         */
        public static MultiTexCoord3($unit: number, $x: number, $y: number, $z: number):void;
        /**
         * Sets current texture coordinate (v.x,v.y,v.z) to the actual texture unit.
         */
        public static MultiTexCoord($unit: number, $v: Vector3):void;
        /**
         * Sets current texture coordinate (x,y) for the actual texture unit.
         */
        public static MultiTexCoord2($unit: number, $x: number, $y: number):void;
        /**
         * Sets current vertex color.
         */
        public static Color($c: Color):void;
        /**
         * Sends queued-up commands in the driver's command buffer to the GPU.
         */
        public static Flush():void;
        /**
         * Resolves the render target for subsequent operations sampling from it.
         */
        public static RenderTargetBarrier():void;
        /**
         * Sets the current model matrix to the one specified.
         */
        public static MultMatrix($m: Matrix4x4):void;
        /**
         * Saves the model, view and projection matrices to the top of the matrix stack.
         */
        public static PushMatrix():void;
        /**
         * Restores the model, view and projection matrices off the top of the matrix stack.
         */
        public static PopMatrix():void;
        /**
         * Load an identity into the current model and view matrices.
         */
        public static LoadIdentity():void;
        /**
         * Helper function to set up an orthograhic projection.
         */
        public static LoadOrtho():void;
        /**
         * Setup a matrix for pixel-correct rendering.
         */
        public static LoadPixelMatrix():void;
        /**
         * Load an arbitrary matrix to the current projection matrix.
         */
        public static LoadProjectionMatrix($mat: Matrix4x4):void;
        /**
         * Invalidate the internally cached render state.
         */
        public static InvalidateState():void;
        /**
         * Compute GPU projection matrix from camera's projection matrix.
         * @param proj Source projection matrix.
         * @param renderIntoTexture Will this projection be used for rendering into a RenderTexture?
         * @returns Adjusted projection matrix for the current graphics API.
         */
        public static GetGPUProjectionMatrix($proj: Matrix4x4, $renderIntoTexture: boolean):Matrix4x4;
        /**
         * Setup a matrix for pixel-correct rendering.
         */
        public static LoadPixelMatrix($left: number, $right: number, $bottom: number, $top: number):void;
        /**
         * Send a user-defined event to a native code plugin.
         * @param eventID User defined id to send to the callback.
         * @param callback Native code callback to queue for Unity's renderer to invoke.
         */
        public static IssuePluginEvent($callback: System.IntPtr, $eventID: number):void;
        /**
         * Begin drawing 3D primitives.
         * @param mode Primitives to draw: can be TRIANGLES, TRIANGLE_STRIP, QUADS or LINES.
         */
        public static Begin($mode: number):void;
        /**
         * End drawing 3D primitives.
         */
        public static End():void;
        /**
         * Clear the current render buffer.
         * @param clearDepth Should the depth buffer be cleared?
         * @param clearColor Should the color buffer be cleared?
         * @param backgroundColor The color to clear with, used only if clearColor is true.
         * @param depth The depth to clear the z-buffer with, used only if clearDepth is true. The valid
        range is from 0 (near plane) to 1 (far plane). The value is graphics API agnostic: the abstraction layer will convert
        the value to match the convention of the current graphics API.
         */
        public static Clear($clearDepth: boolean, $clearColor: boolean, $backgroundColor: Color, $depth: number):void;
        
        public static Clear($clearDepth: boolean, $clearColor: boolean, $backgroundColor: Color):void;
        /**
         * Set the rendering viewport.
         */
        public static Viewport($pixelRect: Rect):void;
        /**
         * Clear the current render buffer with camera's skybox.
         * @param clearDepth Should the depth buffer be cleared?
         * @param camera Camera to get projection parameters and skybox from.
         */
        public static ClearWithSkybox($clearDepth: boolean, $camera: Camera):void;
        
                    
    }
    /**
     * Scales render textures to support dynamic resolution if the target platform/graphics API supports it.
     */
    class ScalableBufferManager extends System.Object {
        /**
         * Width scale factor to control dynamic resolution.
         */
        public static get widthScaleFactor(): number;
        /**
         * Height scale factor to control dynamic resolution.
         */
        public static get heightScaleFactor(): number;
        /**
         * Function to resize all buffers marked as DynamicallyScalable.
         * @param widthScale New scale factor for the width the ScalableBufferManager will use to resize all render textures the user marked as DynamicallyScalable, has to be some value greater than 0.0 and less than or equal to 1.0.
         * @param heightScale New scale factor for the height the ScalableBufferManager will use to resize all render textures the user marked as DynamicallyScalable, has to be some value greater than 0.0 and less than or equal to 1.0.
         */
        public static ResizeBuffers($widthScale: number, $heightScale: number):void;
        
                    
    }
    /**
     * Struct containing basic FrameTimings and accompanying relevant data.
     */
    class FrameTiming extends System.ValueType {
        /**
         * This is the CPU clock time at the point Present was called for the current frame.
         */
        public cpuTimePresentCalled: bigint;
        /**
         * The CPU time for a given frame, in ms.
         */
        public cpuFrameTime: number;
        /**
         * This is the CPU clock time at the point GPU finished rendering the frame and interrupted the CPU.
         */
        public cpuTimeFrameComplete: bigint;
        /**
         * The GPU time for a given frame, in ms.
         */
        public gpuFrameTime: number;
        /**
         * This was the height scale factor of the Dynamic Resolution system(if used) for the given frame and the linked frame timings.
         */
        public heightScale: number;
        /**
         * This was the width scale factor of the Dynamic Resolution system(if used) for the given frame and the linked frame timings.
         */
        public widthScale: number;
        /**
         * This was the vsync mode for the given frame and the linked frame timings.
         */
        public syncInterval: number;
        
        public get_Clone(): FrameTiming;            
    }
    /**
     * The FrameTimingManager allows the user to capture and access FrameTiming data for multple frames.
     */
    class FrameTimingManager extends System.Object {
        /**
         * This function triggers the FrameTimingManager to capture a snapshot of FrameTiming's data, that can then be accessed by the user.
         */
        public static CaptureFrameTimings():void;
        /**
         * Allows the user to access the currently captured FrameTimings.
         * @param numFrames User supplies a desired number of frames they would like FrameTimings for. This should be equal to or less than the maximum FrameTimings the platform can capture.
         * @param timings An array of FrameTiming structs that is passed in by the user and will be filled with data as requested. It is the users job to make sure the array that is passed is large enough to hold the requested number of FrameTimings.
         * @returns Returns the number of FrameTimings it actually was able to get. This will always be equal to or less than the requested numFrames depending on availability of captured FrameTimings.
         */
        public static GetLatestTimings($numFrames: number, $timings: FrameTiming[]):number;
        /**
         * This returns the number of vsyncs per second on the current platform, used to interpret timing results. If the platform does not support returning this value it will return 0.
         * @returns Number of vsyncs per second of the current platform.
         */
        public static GetVSyncsPerSecond():number;
        /**
         * This returns the frequency of GPU timer on the current platform, used to interpret timing results. If the platform does not support returning this value it will return 0.
         * @returns GPU timer frequency for current platform.
         */
        public static GetGpuTimerFrequency():bigint;
        /**
         * This returns the frequency of CPU timer on the current platform, used to interpret timing results. If the platform does not support returning this value it will return 0.
         * @returns CPU timer frequency for current platform.
         */
        public static GetCpuTimerFrequency():bigint;
        
                    
    }
    /**
     * Data of a lightmap.
     */
    class LightmapData extends System.Object {
        /**
         * Lightmap storing color of incoming light.
         */
        public get lightmapColor(): Texture2D;
        public set lightmapColor(value: Texture2D);
        /**
         * Lightmap storing dominant direction of incoming light.
         */
        public get lightmapDir(): Texture2D;
        public set lightmapDir(value: Texture2D);
        /**
         * Texture storing occlusion mask per light (ShadowMask, up to four lights).
         */
        public get shadowMask(): Texture2D;
        public set shadowMask(value: Texture2D);
        
        public constructor();
        
                    
    }
    /**
     * Stores lightmaps of the Scene.
     */
    class LightmapSettings extends Object {
        /**
         * Lightmap array.
         */
        public static get lightmaps(): LightmapData[];
        public static set lightmaps(value: LightmapData[]);
        /**
         * NonDirectional or CombinedDirectional Specular lightmaps rendering mode.
         */
        public static get lightmapsMode(): LightmapsMode;
        public static set lightmapsMode(value: LightmapsMode);
        /**
         * Baked Light Probe data.
         */
        public static get lightProbes(): LightProbes;
        public static set lightProbes(value: LightProbes);
        
                    
    }
    /**
     * Stores light probe data for all currently loaded Scenes.
     */
    class LightProbes extends Object {
        /**
         * Positions of the baked light probes (Read Only).
         */
        public get positions(): Vector3[];
        /**
         * Coefficients of baked light probes.
         */
        public get bakedProbes(): UnityEngine_Rendering.SphericalHarmonicsL2[];
        public set bakedProbes(value: UnityEngine_Rendering.SphericalHarmonicsL2[]);
        /**
         * The number of light probes (Read Only).
         */
        public get count(): number;
        /**
         * The number of cells space is divided into (Read Only).
         */
        public get cellCount(): number;
        
        public static add_tetrahedralizationCompleted($value: System.Action):void;
        
        public static remove_tetrahedralizationCompleted($value: System.Action):void;
        
        public static add_needsRetetrahedralization($value: System.Action):void;
        
        public static remove_needsRetetrahedralization($value: System.Action):void;
        /**
         * Synchronously tetrahedralize the currently loaded LightProbe positions.
         * @returns Returns true if the tetrahedralization finished successfully.
         */
        public static Tetrahedralize():void;
        /**
         * Asynchronously tetrahedralize the currently loaded LightProbe positions.
         */
        public static TetrahedralizeAsync():void;
        /**
         * Returns an interpolated probe for the given position for both realtime and baked light probes combined.
         */
        public static GetInterpolatedProbe($position: Vector3, $renderer: Renderer, $probe: $Ref<UnityEngine_Rendering.SphericalHarmonicsL2>):void;
        /**
         * Calculate light probes and occlusion probes at the given world space positions.
         * @param positions The array of world space positions used to evaluate the probes.
         * @param lightProbes The array where the resulting light probes are written to.
         * @param occlusionProbes The array where the resulting occlusion probes are written to.
         */
        public static CalculateInterpolatedLightAndOcclusionProbes($positions: Vector3[], $lightProbes: UnityEngine_Rendering.SphericalHarmonicsL2[], $occlusionProbes: Vector4[]):void;
        
        public static CalculateInterpolatedLightAndOcclusionProbes($positions: System_Collections_Generic.List$1<Vector3>, $lightProbes: System_Collections_Generic.List$1<UnityEngine_Rendering.SphericalHarmonicsL2>, $occlusionProbes: System_Collections_Generic.List$1<Vector4>):void;
        /**
         * Event which is called after LightProbes.Tetrahedralize or LightProbes.TetrahedralizeAsync has finished computing a tetrahedralization.
         */
        public static tetrahedralizationCompleted;
        /**
         * An event which is called when the number of currently loaded light probes changes due to additive scene loading or unloading.
         */
        public static needsRetetrahedralization;
        
                    
    }
    /**
     * Single, dual, or directional lightmaps rendering mode, used only in GIWorkflowMode.Legacy
     */
    enum LightmapsModeLegacy { Single = 0, Dual = 1, Directional = 2 }
    /**
     * Color space for player settings.
     */
    enum ColorSpace { Uninitialized = -1, Gamma = 0, Linear = 1 }
    /**
     * The type for the number of bits to be used when an HDR display is active in each color channel of swap chain buffers. The bit count also defines the method Unity uses to render content to the display.
     */
    enum D3DHDRDisplayBitDepth { D3DHDRDisplayBitDepth10 = 0, D3DHDRDisplayBitDepth16 = 1 }
    /**
     * Provides access to HDR display settings and information.
     */
    class HDROutputSettings extends System.Object {
        /**
         * The list of currently connected displays with possible HDR availability.
         */
        public static displays: HDROutputSettings[];
        /**
         * The HDROutputSettings for the main display.
         */
        public static get main(): HDROutputSettings;
        /**
         * Describes whether HDR output is currently active on the display. It is true if this is the case, and @@false@ otherwise.
         */
        public get active(): boolean;
        /**
         * Describes whether HDR is currently available on your primary display and that you have HDR enabled in your Unity Project. It is true if this is the case, and false otherwise.
         */
        public get available(): boolean;
        /**
         * Describes whether Unity performs HDR tonemapping automatically.
         */
        public get automaticHDRTonemapping(): boolean;
        public set automaticHDRTonemapping(value: boolean);
        /**
         * The ColorGamut used to output to the active HDR display.
         */
        public get displayColorGamut(): ColorGamut;
        /**
         * The RenderTextureFormat of the display buffer for the active HDR display.
         */
        public get format(): RenderTextureFormat;
        /**
         * The Experimental.Rendering.GraphicsFormat of the display buffer for the active HDR display.
         */
        public get graphicsFormat(): UnityEngine_Experimental_Rendering.GraphicsFormat;
        /**
         * The base luminance of a white paper surface in nits or candela per square meter (cd/m2).
         */
        public get paperWhiteNits(): number;
        public set paperWhiteNits(value: number);
        /**
         * Maximum input luminance at which gradation is preserved even when the entire screen is bright.
         */
        public get maxFullFrameToneMapLuminance(): number;
        /**
         * Maximum input luminance at which gradation is preserved when 10% of the screen is bright.
         */
        public get maxToneMapLuminance(): number;
        /**
         * Minimum input luminance at which gradation is identifiable.
         */
        public get minToneMapLuminance(): number;
        /**
         * Describes whether the user has requested to change the HDR Output Mode. It is true if this is the case, and false otherwise.
         */
        public get HDRModeChangeRequested(): boolean;
        /**
         * Use this function to request a change in the HDR Output Mode and in the value of HDROutputSettings.active.
         * @param enabled Indicates whether HDR should be enabled.
         */
        public RequestHDRModeChange($enabled: boolean):void;
        
                    
    }
    /**
     * Format of a RenderTexture.
     */
    enum RenderTextureFormat { ARGB32 = 0, Depth = 1, ARGBHalf = 2, Shadowmap = 3, RGB565 = 4, ARGB4444 = 5, ARGB1555 = 6, Default = 7, ARGB2101010 = 8, DefaultHDR = 9, ARGB64 = 10, ARGBFloat = 11, RGFloat = 12, RGHalf = 13, RFloat = 14, RHalf = 15, R8 = 16, ARGBInt = 17, RGInt = 18, RInt = 19, BGRA32 = 20, RGB111110Float = 22, RG32 = 23, RGBAUShort = 24, RG16 = 25, BGRA10101010_XR = 26, BGR101010_XR = 27, R16 = 28 }
    /**
     * Script interface for.
     */
    class QualitySettings extends Object {
        /**
         * The maximum number of pixel lights that should affect any object.
         */
        public static get pixelLightCount(): number;
        public static set pixelLightCount(value: number);
        /**
         * Realtime Shadows type to be used.
         */
        public static get shadows(): ShadowQuality;
        public static set shadows(value: ShadowQuality);
        /**
         * Directional light shadow projection.
         */
        public static get shadowProjection(): ShadowProjection;
        public static set shadowProjection(value: ShadowProjection);
        /**
         * Number of cascades to use for directional light shadows.
         */
        public static get shadowCascades(): number;
        public static set shadowCascades(value: number);
        /**
         * Shadow drawing distance.
         */
        public static get shadowDistance(): number;
        public static set shadowDistance(value: number);
        /**
         * The default resolution of the shadow maps.
         */
        public static get shadowResolution(): ShadowResolution;
        public static set shadowResolution(value: ShadowResolution);
        /**
         * The rendering mode of Shadowmask.
         */
        public static get shadowmaskMode(): ShadowmaskMode;
        public static set shadowmaskMode(value: ShadowmaskMode);
        /**
         * Offset shadow frustum near plane.
         */
        public static get shadowNearPlaneOffset(): number;
        public static set shadowNearPlaneOffset(value: number);
        /**
         * The normalized cascade distribution for a 2 cascade setup. The value defines the position of the cascade with respect to Zero.
         */
        public static get shadowCascade2Split(): number;
        public static set shadowCascade2Split(value: number);
        /**
         * The normalized cascade start position for a 4 cascade setup. Each member of the vector defines the normalized position of the coresponding cascade with respect to Zero.
         */
        public static get shadowCascade4Split(): Vector3;
        public static set shadowCascade4Split(value: Vector3);
        /**
         * Global multiplier for the LOD's switching distance.
         */
        public static get lodBias(): number;
        public static set lodBias(value: number);
        /**
         * Global anisotropic filtering mode.
         */
        public static get anisotropicFiltering(): AnisotropicFiltering;
        public static set anisotropicFiltering(value: AnisotropicFiltering);
        /**
         * A texture size limit applied to all textures.
         */
        public static get masterTextureLimit(): number;
        public static set masterTextureLimit(value: number);
        /**
         * A maximum LOD level. All LOD groups.
         */
        public static get maximumLODLevel(): number;
        public static set maximumLODLevel(value: number);
        /**
         * Budget for how many ray casts can be performed per frame for approximate collision testing.
         */
        public static get particleRaycastBudget(): number;
        public static set particleRaycastBudget(value: number);
        /**
         * Should soft blending be used for particles?
         */
        public static get softParticles(): boolean;
        public static set softParticles(value: boolean);
        /**
         * Use a two-pass shader for the vegetation in the terrain engine.
         */
        public static get softVegetation(): boolean;
        public static set softVegetation(value: boolean);
        /**
         * The VSync Count.
         */
        public static get vSyncCount(): number;
        public static set vSyncCount(value: number);
        /**
         * Set The AA Filtering option.
         */
        public static get antiAliasing(): number;
        public static set antiAliasing(value: number);
        /**
         * Async texture upload provides timesliced async texture upload on the render thread with tight control over memory and timeslicing. There are no allocations except for the ones which driver has to do. To read data and upload texture data a ringbuffer whose size can be controlled is re-used.
         * Use asyncUploadTimeSlice to set the time-slice in milliseconds for asynchronous texture uploads per
         * frame. Minimum value is 1 and maximum is 33.
         */
        public static get asyncUploadTimeSlice(): number;
        public static set asyncUploadTimeSlice(value: number);
        /**
         * Asynchronous texture and mesh data upload provides timesliced async texture and mesh data upload on the render thread with tight control over memory and timeslicing. There are no allocations except for the ones which driver has to do. To read data and upload texture and mesh data, Unity re-uses a ringbuffer whose size can be controlled.
         * Use asyncUploadBufferSize to set the buffer size for asynchronous texture and mesh data uploads. The size is in megabytes. The minimum value is 2 and the maximum value is 512. The buffer resizes automatically to fit the largest texture currently loading. To avoid re-sizing of the buffer, which can incur performance cost, set the value approximately to the size of biggest texture used in the Scene.
         */
        public static get asyncUploadBufferSize(): number;
        public static set asyncUploadBufferSize(value: number);
        /**
         * This flag controls if the async upload pipeline's ring buffer remains allocated when there are no active loading operations.
         * Set this to true, to make the ring buffer allocation persist after all upload operations have completed.
         * If you have issues with excessive memory usage, you can set this to false. This means you reduce the runtime memory footprint, but memory fragmentation can occur.
         * The default value is true.
         */
        public static get asyncUploadPersistentBuffer(): boolean;
        public static set asyncUploadPersistentBuffer(value: boolean);
        /**
         * Enables realtime reflection probes.
         */
        public static get realtimeReflectionProbes(): boolean;
        public static set realtimeReflectionProbes(value: boolean);
        /**
         * If enabled, billboards will face towards camera position rather than camera orientation.
         */
        public static get billboardsFaceCameraPosition(): boolean;
        public static set billboardsFaceCameraPosition(value: boolean);
        /**
         * In resolution scaling mode, this factor is used to multiply with the target Fixed DPI specified to get the actual Fixed DPI to use for this quality setting.
         */
        public static get resolutionScalingFixedDPIFactor(): number;
        public static set resolutionScalingFixedDPIFactor(value: number);
        /**
         * The RenderPipelineAsset for this quality level
         */
        public static get renderPipeline(): UnityEngine_Rendering.RenderPipelineAsset;
        public static set renderPipeline(value: UnityEngine_Rendering.RenderPipelineAsset);
        /**
         * The maximum number of bones per vertex that are taken into account during skinning, for all meshes in the project.
         */
        public static get skinWeights(): SkinWeights;
        public static set skinWeights(value: SkinWeights);
        /**
         * Enable automatic streaming of texture mipmap levels based on their distance from all active cameras.
         */
        public static get streamingMipmapsActive(): boolean;
        public static set streamingMipmapsActive(value: boolean);
        /**
         * The total amount of memory to be used by streaming and non-streaming textures.
         */
        public static get streamingMipmapsMemoryBudget(): number;
        public static set streamingMipmapsMemoryBudget(value: number);
        /**
         * The number of renderer instances that are processed each frame when calculating which texture mipmap levels should be streamed.
         */
        public static get streamingMipmapsRenderersPerFrame(): number;
        public static set streamingMipmapsRenderersPerFrame(value: number);
        /**
         * The maximum number of mipmap levels to discard for each texture.
         */
        public static get streamingMipmapsMaxLevelReduction(): number;
        public static set streamingMipmapsMaxLevelReduction(value: number);
        /**
         * Process all enabled Cameras for texture streaming (rather than just those with StreamingController components).
         */
        public static get streamingMipmapsAddAllCameras(): boolean;
        public static set streamingMipmapsAddAllCameras(value: boolean);
        /**
         * The maximum number of active texture file IO requests from the texture streaming system.
         */
        public static get streamingMipmapsMaxFileIORequests(): number;
        public static set streamingMipmapsMaxFileIORequests(value: number);
        /**
         * Maximum number of frames queued up by graphics driver.
         */
        public static get maxQueuedFrames(): number;
        public static set maxQueuedFrames(value: number);
        /**
         * The indexed list of available Quality Settings.
         */
        public static get names(): string[];
        /**
         * Desired color space (Read Only).
         */
        public static get desiredColorSpace(): ColorSpace;
        /**
         * Active color space (Read Only).
         */
        public static get activeColorSpace(): ColorSpace;
        /**
         * Increase the current quality level.
         * @param applyExpensiveChanges Should expensive changes be applied (Anti-aliasing etc).
         */
        public static IncreaseLevel($applyExpensiveChanges: boolean):void;
        /**
         * Decrease the current quality level.
         * @param applyExpensiveChanges Should expensive changes be applied (Anti-aliasing etc).
         */
        public static DecreaseLevel($applyExpensiveChanges: boolean):void;
        
        public static SetQualityLevel($index: number):void;
        
        public static IncreaseLevel():void;
        
        public static DecreaseLevel():void;
        /**
         * Get the Render Pipeline Asset assigned at the specified quality level.
         * @param index Index of the quality level to check.
         * @returns Null if the quality level was not found or there is no assigned SRP Asset for this level, otherwise the SRP Asset assigned for this quality level.
         */
        public static GetRenderPipelineAssetAt($index: number):UnityEngine_Rendering.RenderPipelineAsset;
        /**
         * Returns the current graphics quality level.
         */
        public static GetQualityLevel():number;
        /**
         * Sets a new graphics quality level.
         * @param index Quality index to set.
         * @param applyExpensiveChanges Should expensive changes be applied (Anti-aliasing etc).
         */
        public static SetQualityLevel($index: number, $applyExpensiveChanges: boolean):void;
        
                    
    }
    
    enum QualityLevel { Fastest = 0, Fast = 1, Simple = 2, Good = 3, Beautiful = 4, Fantastic = 5 }
    /**
     * Determines which type of shadows should be used.
     */
    enum ShadowQuality { Disable = 0, HardOnly = 1, All = 2 }
    /**
     * Shadow projection type for.
     */
    enum ShadowProjection { CloseFit = 0, StableFit = 1 }
    /**
     * Default shadow resolution.
     */
    enum ShadowResolution { Low = 0, Medium = 1, High = 2, VeryHigh = 3 }
    /**
     * The rendering mode of Shadowmask.
     */
    enum ShadowmaskMode { Shadowmask = 0, DistanceShadowmask = 1 }
    
    enum BlendWeights { OneBone = 1, TwoBones = 2, FourBones = 4 }
    /**
     * Skin weights.
     */
    enum SkinWeights { OneBone = 1, TwoBones = 2, FourBones = 4, Unlimited = 255 }
    /**
     * Extension methods to the Renderer class, used only for the UpdateGIMaterials method used by the Global Illumination System.
     */
    class RendererExtensions extends System.Object {
        /**
         * Schedules an update of the albedo and emissive Textures of a system that contains the Renderer.
         */
        public static UpdateGIMaterials($renderer: Renderer):void;
        
                    
    }
    /**
     * When using HDR rendering it can sometime be desirable to switch to LDR rendering during ImageEffect rendering.
     */
    class ImageEffectTransformsToLDR extends System.Attribute {
        
        public constructor();
        
                    
    }
    /**
     * Any Image Effect with this attribute can be rendered into the Scene view camera.
     */
    class ImageEffectAllowedInSceneView extends System.Attribute {
        
        public constructor();
        
                    
    }
    /**
     * Any Image Effect with this attribute will be rendered after opaque geometry but before transparent geometry.
     */
    class ImageEffectOpaque extends System.Attribute {
        
        public constructor();
        
                    
    }
    /**
     * Any Image Effect with this attribute will be rendered after Dynamic Resolution stage.
     */
    class ImageEffectAfterScale extends System.Attribute {
        
        public constructor();
        
                    
    }
    /**
     * Use this attribute when image effects are implemented using Command Buffers.
     */
    class ImageEffectUsesCommandBuffer extends System.Attribute {
        
        public constructor();
        
                    
    }
    /**
     * Describes a bone weight that affects a vertex in a mesh.
     */
    class BoneWeight1 extends System.ValueType {
        /**
         * Skinning weight for bone.
         */
        public get weight(): number;
        public set weight(value: number);
        /**
         * Index of bone.
         */
        public get boneIndex(): number;
        public set boneIndex(value: number);
        
        public Equals($other: any):boolean;
        
        public Equals($other: BoneWeight1):boolean;
        
        public GetHashCode():number;
        
        public static op_Equality($lhs: BoneWeight1, $rhs: BoneWeight1):boolean;
        
        public static op_Inequality($lhs: BoneWeight1, $rhs: BoneWeight1):boolean;
        
        public get_Clone(): BoneWeight1;            
    }
    /**
     * Describes 4 skinning bone weights that affect a vertex in a mesh.
     */
    class BoneWeight extends System.ValueType {
        /**
         * Skinning weight for first bone.
         */
        public get weight0(): number;
        public set weight0(value: number);
        /**
         * Skinning weight for second bone.
         */
        public get weight1(): number;
        public set weight1(value: number);
        /**
         * Skinning weight for third bone.
         */
        public get weight2(): number;
        public set weight2(value: number);
        /**
         * Skinning weight for fourth bone.
         */
        public get weight3(): number;
        public set weight3(value: number);
        /**
         * Index of first bone.
         */
        public get boneIndex0(): number;
        public set boneIndex0(value: number);
        /**
         * Index of second bone.
         */
        public get boneIndex1(): number;
        public set boneIndex1(value: number);
        /**
         * Index of third bone.
         */
        public get boneIndex2(): number;
        public set boneIndex2(value: number);
        /**
         * Index of fourth bone.
         */
        public get boneIndex3(): number;
        public set boneIndex3(value: number);
        
        public GetHashCode():number;
        
        public Equals($other: any):boolean;
        
        public Equals($other: BoneWeight):boolean;
        
        public static op_Equality($lhs: BoneWeight, $rhs: BoneWeight):boolean;
        
        public static op_Inequality($lhs: BoneWeight, $rhs: BoneWeight):boolean;
        
        public get_Clone(): BoneWeight;            
    }
    /**
     * Struct used to describe meshes to be combined using Mesh.CombineMeshes.
     */
    class CombineInstance extends System.ValueType {
        /**
         * Mesh to combine.
         */
        public get mesh(): Mesh;
        public set mesh(value: Mesh);
        /**
         * Sub-Mesh index of the Mesh.
         */
        public get subMeshIndex(): number;
        public set subMeshIndex(value: number);
        /**
         * Matrix to transform the Mesh with before combining.
         */
        public get transform(): Matrix4x4;
        public set transform(value: Matrix4x4);
        /**
         * The baked lightmap UV scale and offset applied to the Mesh.
         */
        public get lightmapScaleOffset(): Vector4;
        public set lightmapScaleOffset(value: Vector4);
        /**
         * The realtime lightmap UV scale and offset applied to the Mesh.
         */
        public get realtimeLightmapScaleOffset(): Vector4;
        public set realtimeLightmapScaleOffset(value: Vector4);
        
        public get_Clone(): CombineInstance;            
    }
    /**
     * The type of motion vectors that should be generated.
     */
    enum MotionVectorGenerationMode { Camera = 0, Object = 1, ForceNoMotion = 2 }
    /**
     * A script interface for a.
     */
    class Projector extends Behaviour {
        /**
         * The near clipping plane distance.
         */
        public get nearClipPlane(): number;
        public set nearClipPlane(value: number);
        /**
         * The far clipping plane distance.
         */
        public get farClipPlane(): number;
        public set farClipPlane(value: number);
        /**
         * The field of view of the projection in degrees.
         */
        public get fieldOfView(): number;
        public set fieldOfView(value: number);
        /**
         * The aspect ratio of the projection.
         */
        public get aspectRatio(): number;
        public set aspectRatio(value: number);
        /**
         * Is the projection orthographic (true) or perspective (false)?
         */
        public get orthographic(): boolean;
        public set orthographic(value: boolean);
        /**
         * Projection's half-size when in orthographic mode.
         */
        public get orthographicSize(): number;
        public set orthographicSize(value: number);
        /**
         * Which object layers are ignored by the projector.
         */
        public get ignoreLayers(): number;
        public set ignoreLayers(value: number);
        /**
         * The material that will be projected onto every object.
         */
        public get material(): Material;
        public set material(value: Material);
        
        public constructor();
        
                    
    }
    
    enum TexGenMode { None = 0, SphereMap = 1, Object = 2, EyeLinear = 3, CubeReflect = 4, CubeNormal = 5 }
    /**
     * The trail renderer is used to make trails behind objects in the Scene as they move about.
     */
    class TrailRenderer extends Renderer {
        /**
         * How long does the trail take to fade out.
         */
        public get time(): number;
        public set time(value: number);
        /**
         * The width of the trail at the spawning point.
         */
        public get startWidth(): number;
        public set startWidth(value: number);
        /**
         * The width of the trail at the end of the trail.
         */
        public get endWidth(): number;
        public set endWidth(value: number);
        /**
         * Set an overall multiplier that is applied to the TrailRenderer.widthCurve to get the final width of the trail.
         */
        public get widthMultiplier(): number;
        public set widthMultiplier(value: number);
        /**
         * Does the GameObject of this Trail Renderer auto destruct?
         */
        public get autodestruct(): boolean;
        public set autodestruct(value: boolean);
        /**
         * Creates trails when the GameObject moves.
         */
        public get emitting(): boolean;
        public set emitting(value: boolean);
        /**
         * Set this to a value greater than 0, to get rounded corners between each segment of the trail.
         */
        public get numCornerVertices(): number;
        public set numCornerVertices(value: number);
        /**
         * Set this to a value greater than 0, to get rounded corners on each end of the trail.
         */
        public get numCapVertices(): number;
        public set numCapVertices(value: number);
        /**
         * Set the minimum distance the trail can travel before a new vertex is added to it.
         */
        public get minVertexDistance(): number;
        public set minVertexDistance(value: number);
        /**
         * Set the color at the start of the trail.
         */
        public get startColor(): Color;
        public set startColor(value: Color);
        /**
         * Set the color at the end of the trail.
         */
        public get endColor(): Color;
        public set endColor(value: Color);
        /**
         * Get the number of line segments in the trail.
         */
        public get positionCount(): number;
        /**
         * Apply a shadow bias to prevent self-shadowing artifacts. The specified value is the proportion of the trail width at each segment.
         */
        public get shadowBias(): number;
        public set shadowBias(value: number);
        /**
         * Configures a trail to generate Normals and Tangents. With this data, Scene lighting can affect the trail via Normal Maps and the Unity Standard Shader, or your own custom-built Shaders.
         */
        public get generateLightingData(): boolean;
        public set generateLightingData(value: boolean);
        /**
         * Choose whether the U coordinate of the trail texture is tiled or stretched.
         */
        public get textureMode(): LineTextureMode;
        public set textureMode(value: LineTextureMode);
        /**
         * Select whether the trail will face the camera, or the orientation of the Transform Component.
         */
        public get alignment(): LineAlignment;
        public set alignment(value: LineAlignment);
        /**
         * Set the curve describing the width of the trail at various points along its length.
         */
        public get widthCurve(): AnimationCurve;
        public set widthCurve(value: AnimationCurve);
        /**
         * Set the color gradient describing the color of the trail at various points along its length.
         */
        public get colorGradient(): Gradient;
        public set colorGradient(value: Gradient);
        
        public constructor();
        /**
         * Set the position of a vertex in the trail.
         * @param index Which position to set.
         * @param position The new position.
         */
        public SetPosition($index: number, $position: Vector3):void;
        /**
         * Get the position of a vertex in the trail.
         * @param index The index of the position to retrieve.
         * @returns The position at the specified index in the array.
         */
        public GetPosition($index: number):Vector3;
        /**
         * Removes all points from the TrailRenderer.
         * Useful for restarting a trail from a new position.
         */
        public Clear():void;
        /**
         * Creates a snapshot of TrailRenderer and stores it in mesh.
         * @param mesh A static mesh that will receive the snapshot of the trail.
         * @param camera The camera used for determining which way camera-space trails will face.
         * @param useTransform Include the rotation and scale of the Transform in the baked mesh.
         */
        public BakeMesh($mesh: Mesh, $useTransform?: boolean):void;
        /**
         * Creates a snapshot of TrailRenderer and stores it in mesh.
         * @param mesh A static mesh that will receive the snapshot of the trail.
         * @param camera The camera used for determining which way camera-space trails will face.
         * @param useTransform Include the rotation and scale of the Transform in the baked mesh.
         */
        public BakeMesh($mesh: Mesh, $camera: Camera, $useTransform?: boolean):void;
        /**
         * Get the positions of all vertices in the trail.
         * @param positions The array of positions to retrieve.
         * @returns How many positions were actually stored in the output array.
         */
        public GetPositions($positions: Vector3[]):number;
        /**
         * Sets the positions of all vertices in the trail.
         * @param positions The array of positions to set.
         */
        public SetPositions($positions: Vector3[]):void;
        /**
         * Adds a position to the trail.
         * @param position The position to add to the trail.
         */
        public AddPosition($position: Vector3):void;
        /**
         * Add an array of positions to the trail.
         * @param positions The positions to add to the trail.
         */
        public AddPositions($positions: Vector3[]):void;
        
        public SetPositions($positions: Unity_Collections.NativeArray$1<Vector3>):void;
        
        public SetPositions($positions: Unity_Collections.NativeSlice$1<Vector3>):void;
        
        public GetPositions($positions: Unity_Collections.NativeArray$1<Vector3>):number;
        
        public GetPositions($positions: Unity_Collections.NativeSlice$1<Vector3>):number;
        
        public AddPositions($positions: Unity_Collections.NativeArray$1<Vector3>):void;
        
        public AddPositions($positions: Unity_Collections.NativeSlice$1<Vector3>):void;
        
                    
    }
    /**
     * Choose how textures are applied to Lines and Trails.
     */
    enum LineTextureMode { Stretch = 0, Tile = 1, DistributePerSegment = 2, RepeatPerSegment = 3 }
    /**
     * Control the direction lines face, when using the LineRenderer or TrailRenderer.
     */
    enum LineAlignment { View = 0, Local = 1, TransformZ = 1 }
    /**
     * Gradient used for animating colors.
     */
    class Gradient extends System.Object {
        /**
         * All color keys defined in the gradient.
         */
        public get colorKeys(): GradientColorKey[];
        public set colorKeys(value: GradientColorKey[]);
        /**
         * All alpha keys defined in the gradient.
         */
        public get alphaKeys(): GradientAlphaKey[];
        public set alphaKeys(value: GradientAlphaKey[]);
        /**
         * Control how the gradient is evaluated.
         */
        public get mode(): GradientMode;
        public set mode(value: GradientMode);
        /**
         * Create a new Gradient object.
         */
        public constructor();
        /**
         * Calculate color at a given time.
         * @param time Time of the key (0 - 1).
         */
        public Evaluate($time: number):Color;
        /**
         * Setup Gradient with an array of color keys and alpha keys.
         * @param colorKeys Color keys of the gradient (maximum 8 color keys).
         * @param alphaKeys Alpha keys of the gradient (maximum 8 alpha keys).
         */
        public SetKeys($colorKeys: GradientColorKey[], $alphaKeys: GradientAlphaKey[]):void;
        
        public Equals($o: any):boolean;
        
        public Equals($other: Gradient):boolean;
        
        public GetHashCode():number;
        
                    
    }
    /**
     * The line renderer is used to draw free-floating lines in 3D space.
     */
    class LineRenderer extends Renderer {
        /**
         * Set the width at the start of the line.
         */
        public get startWidth(): number;
        public set startWidth(value: number);
        /**
         * Set the width at the end of the line.
         */
        public get endWidth(): number;
        public set endWidth(value: number);
        /**
         * Set an overall multiplier that is applied to the LineRenderer.widthCurve to get the final width of the line.
         */
        public get widthMultiplier(): number;
        public set widthMultiplier(value: number);
        /**
         * Set this to a value greater than 0, to get rounded corners between each segment of the line.
         */
        public get numCornerVertices(): number;
        public set numCornerVertices(value: number);
        /**
         * Set this to a value greater than 0, to get rounded corners on each end of the line.
         */
        public get numCapVertices(): number;
        public set numCapVertices(value: number);
        /**
         * If enabled, the lines are defined in world space.
         */
        public get useWorldSpace(): boolean;
        public set useWorldSpace(value: boolean);
        /**
         * Connect the start and end positions of the line together to form a continuous loop.
         */
        public get loop(): boolean;
        public set loop(value: boolean);
        /**
         * Set the color at the start of the line.
         */
        public get startColor(): Color;
        public set startColor(value: Color);
        /**
         * Set the color at the end of the line.
         */
        public get endColor(): Color;
        public set endColor(value: Color);
        /**
         * Set/get the number of vertices.
         */
        public get positionCount(): number;
        public set positionCount(value: number);
        /**
         * Apply a shadow bias to prevent self-shadowing artifacts. The specified value is the proportion of the line width at each segment.
         */
        public get shadowBias(): number;
        public set shadowBias(value: number);
        /**
         * Configures a line to generate Normals and Tangents. With this data, Scene lighting can affect the line via Normal Maps and the Unity Standard Shader, or your own custom-built Shaders.
         */
        public get generateLightingData(): boolean;
        public set generateLightingData(value: boolean);
        /**
         * Choose whether the U coordinate of the line texture is tiled or stretched.
         */
        public get textureMode(): LineTextureMode;
        public set textureMode(value: LineTextureMode);
        /**
         * Select whether the line will face the camera, or the orientation of the Transform Component.
         */
        public get alignment(): LineAlignment;
        public set alignment(value: LineAlignment);
        /**
         * Set the curve describing the width of the line at various points along its length.
         */
        public get widthCurve(): AnimationCurve;
        public set widthCurve(value: AnimationCurve);
        /**
         * Set the color gradient describing the color of the line at various points along its length.
         */
        public get colorGradient(): Gradient;
        public set colorGradient(value: Gradient);
        
        public constructor();
        /**
         * Set the position of a vertex in the line.
         * @param index Which position to set.
         * @param position The new position.
         */
        public SetPosition($index: number, $position: Vector3):void;
        /**
         * Get the position of a vertex in the line.
         * @param index The index of the position to retrieve.
         * @returns The position at the specified index in the array.
         */
        public GetPosition($index: number):Vector3;
        /**
         * Generates a simplified version of the original line by removing points that fall within the specified tolerance.
         * @param tolerance This value is used to evaluate which points should be removed from the line. A higher value results in a simpler line (less points). A positive value close to zero results in a line with little to no reduction. A value of zero or less has no effect.
         */
        public Simplify($tolerance: number):void;
        /**
         * Creates a snapshot of LineRenderer and stores it in mesh.
         * @param mesh A static mesh that will receive the snapshot of the line.
         * @param camera The camera used for determining which way camera-space lines will face.
         * @param useTransform Include the rotation and scale of the Transform in the baked mesh.
         */
        public BakeMesh($mesh: Mesh, $useTransform?: boolean):void;
        /**
         * Creates a snapshot of LineRenderer and stores it in mesh.
         * @param mesh A static mesh that will receive the snapshot of the line.
         * @param camera The camera used for determining which way camera-space lines will face.
         * @param useTransform Include the rotation and scale of the Transform in the baked mesh.
         */
        public BakeMesh($mesh: Mesh, $camera: Camera, $useTransform?: boolean):void;
        /**
         * Get the positions of all vertices in the line.
         * @param positions The array of positions to retrieve. The array passed should be of at least positionCount in size.
         * @returns How many positions were actually stored in the output array.
         */
        public GetPositions($positions: Vector3[]):number;
        /**
         * Set the positions of all vertices in the line.
         * @param positions The array of positions to set.
         */
        public SetPositions($positions: Vector3[]):void;
        
        public SetPositions($positions: Unity_Collections.NativeArray$1<Vector3>):void;
        
        public SetPositions($positions: Unity_Collections.NativeSlice$1<Vector3>):void;
        
        public GetPositions($positions: Unity_Collections.NativeArray$1<Vector3>):number;
        
        public GetPositions($positions: Unity_Collections.NativeSlice$1<Vector3>):number;
        
                    
    }
    /**
     * The Render Settings contain values for a range of visual elements in your Scene, like fog and ambient light.
     */
    class RenderSettings extends Object {
        /**
         * Is fog enabled?
         */
        public static get fog(): boolean;
        public static set fog(value: boolean);
        /**
         * The starting distance of linear fog.
         */
        public static get fogStartDistance(): number;
        public static set fogStartDistance(value: number);
        /**
         * The ending distance of linear fog.
         */
        public static get fogEndDistance(): number;
        public static set fogEndDistance(value: number);
        /**
         * Fog mode to use.
         */
        public static get fogMode(): FogMode;
        public static set fogMode(value: FogMode);
        /**
         * The color of the fog.
         */
        public static get fogColor(): Color;
        public static set fogColor(value: Color);
        /**
         * The density of the exponential fog.
         */
        public static get fogDensity(): number;
        public static set fogDensity(value: number);
        /**
         * Ambient lighting mode.
         */
        public static get ambientMode(): UnityEngine_Rendering.AmbientMode;
        public static set ambientMode(value: UnityEngine_Rendering.AmbientMode);
        /**
         * Ambient lighting coming from above.
         */
        public static get ambientSkyColor(): Color;
        public static set ambientSkyColor(value: Color);
        /**
         * Ambient lighting coming from the sides.
         */
        public static get ambientEquatorColor(): Color;
        public static set ambientEquatorColor(value: Color);
        /**
         * Ambient lighting coming from below.
         */
        public static get ambientGroundColor(): Color;
        public static set ambientGroundColor(value: Color);
        /**
         * How much the light from the Ambient Source affects the Scene.
         */
        public static get ambientIntensity(): number;
        public static set ambientIntensity(value: number);
        /**
         * Flat ambient lighting color.
         */
        public static get ambientLight(): Color;
        public static set ambientLight(value: Color);
        /**
         * The color used for the sun shadows in the Subtractive lightmode.
         */
        public static get subtractiveShadowColor(): Color;
        public static set subtractiveShadowColor(value: Color);
        /**
         * The global skybox to use.
         */
        public static get skybox(): Material;
        public static set skybox(value: Material);
        /**
         * The light used by the procedural skybox.
         */
        public static get sun(): Light;
        public static set sun(value: Light);
        /**
         * Custom or skybox ambient lighting data.
         */
        public static get ambientProbe(): UnityEngine_Rendering.SphericalHarmonicsL2;
        public static set ambientProbe(value: UnityEngine_Rendering.SphericalHarmonicsL2);
        /**
         * Custom specular reflection cubemap.
         */
        public static get customReflection(): Cubemap;
        public static set customReflection(value: Cubemap);
        /**
         * How much the skybox / custom cubemap reflection affects the Scene.
         */
        public static get reflectionIntensity(): number;
        public static set reflectionIntensity(value: number);
        /**
         * The number of times a reflection includes other reflections.
         */
        public static get reflectionBounces(): number;
        public static set reflectionBounces(value: number);
        /**
         * Default reflection mode.
         */
        public static get defaultReflectionMode(): UnityEngine_Rendering.DefaultReflectionMode;
        public static set defaultReflectionMode(value: UnityEngine_Rendering.DefaultReflectionMode);
        /**
         * Cubemap resolution for default reflection.
         */
        public static get defaultReflectionResolution(): number;
        public static set defaultReflectionResolution(value: number);
        /**
         * Size of the Light halos.
         */
        public static get haloStrength(): number;
        public static set haloStrength(value: number);
        /**
         * The intensity of all flares in the Scene.
         */
        public static get flareStrength(): number;
        public static set flareStrength(value: number);
        /**
         * The fade speed of all flares in the Scene.
         */
        public static get flareFadeSpeed(): number;
        public static set flareFadeSpeed(value: number);
        
                    
    }
    /**
     * Fog mode to use.
     */
    enum FogMode { Linear = 1, Exponential = 2, ExponentialSquared = 3 }
    /**
     * Script interface for.
     */
    class Light extends Behaviour {
        /**
         * The type of the light.
         */
        public get type(): LightType;
        public set type(value: LightType);
        /**
         * This property describes the shape of the spot light. Only Scriptable Render Pipelines use this property; the built-in renderer does not support it.
         */
        public get shape(): LightShape;
        public set shape(value: LightShape);
        /**
         * The angle of the light's spotlight cone in degrees.
         */
        public get spotAngle(): number;
        public set spotAngle(value: number);
        /**
         * The angle of the light's spotlight inner cone in degrees.
         */
        public get innerSpotAngle(): number;
        public set innerSpotAngle(value: number);
        /**
         * The color of the light.
         */
        public get color(): Color;
        public set color(value: Color);
        /**
         * The color temperature of the light.
         * Correlated Color Temperature (abbreviated as CCT) is multiplied with the color filter when calculating the final color of a light source. The color temperature of the electromagnetic radiation emitted from an ideal black body is defined as its surface temperature in Kelvin. White is 6500K according to the D65 standard. A candle light is 1800K and a soft warm light bulb is 2700K.
         * If you want to use colorTemperature, GraphicsSettings.lightsUseLinearIntensity and Light.useColorTemperature has to be enabled.
         * See Also: GraphicsSettings.lightsUseLinearIntensity, GraphicsSettings.useColorTemperature.
         */
        public get colorTemperature(): number;
        public set colorTemperature(value: number);
        /**
         * Set to true to use the color temperature.
         */
        public get useColorTemperature(): boolean;
        public set useColorTemperature(value: boolean);
        /**
         * The Intensity of a light is multiplied with the Light color.
         */
        public get intensity(): number;
        public set intensity(value: number);
        /**
         * The multiplier that defines the strength of the bounce lighting.
         */
        public get bounceIntensity(): number;
        public set bounceIntensity(value: number);
        /**
         * Set to true to override light bounding sphere for culling.
         */
        public get useBoundingSphereOverride(): boolean;
        public set useBoundingSphereOverride(value: boolean);
        /**
         * Bounding sphere used to override the regular light bounding sphere during culling.
         */
        public get boundingSphereOverride(): Vector4;
        public set boundingSphereOverride(value: Vector4);
        /**
         * Whether to cull shadows for this Light when the Light is outside of the view frustum.
         */
        public get useViewFrustumForShadowCasterCull(): boolean;
        public set useViewFrustumForShadowCasterCull(value: boolean);
        /**
         * The custom resolution of the shadow map.
         */
        public get shadowCustomResolution(): number;
        public set shadowCustomResolution(value: number);
        /**
         * Shadow mapping constant bias.
         */
        public get shadowBias(): number;
        public set shadowBias(value: number);
        /**
         * Shadow mapping normal-based bias.
         */
        public get shadowNormalBias(): number;
        public set shadowNormalBias(value: number);
        /**
         * Near plane value to use for shadow frustums.
         */
        public get shadowNearPlane(): number;
        public set shadowNearPlane(value: number);
        /**
         * Set to true to enable custom matrix for culling during shadows.
         */
        public get useShadowMatrixOverride(): boolean;
        public set useShadowMatrixOverride(value: boolean);
        /**
         * Projection matrix used to override the regular light matrix during shadow culling.
         */
        public get shadowMatrixOverride(): Matrix4x4;
        public set shadowMatrixOverride(value: Matrix4x4);
        /**
         * The range of the light.
         */
        public get range(): number;
        public set range(value: number);
        /**
         * The to use for this light.
         */
        public get flare(): Flare;
        public set flare(value: Flare);
        /**
         * This property describes the output of the last Global Illumination bake.
         */
        public get bakingOutput(): LightBakingOutput;
        public set bakingOutput(value: LightBakingOutput);
        /**
         * This is used to light certain objects in the Scene selectively.
         */
        public get cullingMask(): number;
        public set cullingMask(value: number);
        /**
         * Determines which rendering LayerMask this Light affects.
         */
        public get renderingLayerMask(): number;
        public set renderingLayerMask(value: number);
        /**
         * Allows you to override the global Shadowmask Mode per light. Only use this with render pipelines that can handle per light Shadowmask modes. Incompatible with the legacy renderers.
         */
        public get lightShadowCasterMode(): LightShadowCasterMode;
        public set lightShadowCasterMode(value: LightShadowCasterMode);
        /**
         * Controls the amount of artificial softening applied to the edges of shadows cast by the Point or Spot light.
         */
        public get shadowRadius(): number;
        public set shadowRadius(value: number);
        /**
         * Controls the amount of artificial softening applied to the edges of shadows cast by directional lights.
         */
        public get shadowAngle(): number;
        public set shadowAngle(value: number);
        /**
         * How this light casts shadows
         */
        public get shadows(): LightShadows;
        public set shadows(value: LightShadows);
        /**
         * Strength of light's shadows.
         */
        public get shadowStrength(): number;
        public set shadowStrength(value: number);
        /**
         * The resolution of the shadow map.
         */
        public get shadowResolution(): UnityEngine_Rendering.LightShadowResolution;
        public set shadowResolution(value: UnityEngine_Rendering.LightShadowResolution);
        /**
         * Per-light, per-layer shadow culling distances. Directional lights only.
         */
        public get layerShadowCullDistances(): number[];
        public set layerShadowCullDistances(value: number[]);
        /**
         * The size of a directional light's cookie.
         */
        public get cookieSize(): number;
        public set cookieSize(value: number);
        /**
         * The cookie texture projected by the light.
         */
        public get cookie(): Texture;
        public set cookie(value: Texture);
        /**
         * How to render the light.
         */
        public get renderMode(): LightRenderMode;
        public set renderMode(value: LightRenderMode);
        /**
         * The size of the area light (Editor only).
         */
        public get areaSize(): Vector2;
        public set areaSize(value: Vector2);
        /**
         * This property describes what part of a light's contribution can be baked (Editor only).
         */
        public get lightmapBakeType(): LightmapBakeType;
        public set lightmapBakeType(value: LightmapBakeType);
        /**
         * Number of command buffers set up on this light (Read Only).
         */
        public get commandBufferCount(): number;
        
        public constructor();
        /**
         * Revert all light parameters to default.
         */
        public Reset():void;
        /**
         * Sets a light dirty to notify the light baking backends to update their internal light representation (Editor only).
         */
        public SetLightDirty():void;
        /**
         * Add a command buffer to be executed at a specified place.
         * @param evt When to execute the command buffer during rendering.
         * @param buffer The buffer to execute.
         * @param shadowPassMask A mask specifying which shadow passes to execute the buffer for.
         */
        public AddCommandBuffer($evt: UnityEngine_Rendering.LightEvent, $buffer: UnityEngine_Rendering.CommandBuffer):void;
        /**
         * Add a command buffer to be executed at a specified place.
         * @param evt When to execute the command buffer during rendering.
         * @param buffer The buffer to execute.
         * @param shadowPassMask A mask specifying which shadow passes to execute the buffer for.
         */
        public AddCommandBuffer($evt: UnityEngine_Rendering.LightEvent, $buffer: UnityEngine_Rendering.CommandBuffer, $shadowPassMask: UnityEngine_Rendering.ShadowMapPass):void;
        /**
         * Adds a command buffer to the GPU's async compute queues and executes that command buffer when graphics processing reaches a given point.
         * @param evt The point during the graphics processing at which this command buffer should commence on the GPU.
         * @param buffer The buffer to execute.
         * @param queueType The desired async compute queue type to execute the buffer on.
         * @param shadowPassMask A mask specifying which shadow passes to execute the buffer for.
         */
        public AddCommandBufferAsync($evt: UnityEngine_Rendering.LightEvent, $buffer: UnityEngine_Rendering.CommandBuffer, $queueType: UnityEngine_Rendering.ComputeQueueType):void;
        /**
         * Adds a command buffer to the GPU's async compute queues and executes that command buffer when graphics processing reaches a given point.
         * @param evt The point during the graphics processing at which this command buffer should commence on the GPU.
         * @param buffer The buffer to execute.
         * @param queueType The desired async compute queue type to execute the buffer on.
         * @param shadowPassMask A mask specifying which shadow passes to execute the buffer for.
         */
        public AddCommandBufferAsync($evt: UnityEngine_Rendering.LightEvent, $buffer: UnityEngine_Rendering.CommandBuffer, $shadowPassMask: UnityEngine_Rendering.ShadowMapPass, $queueType: UnityEngine_Rendering.ComputeQueueType):void;
        /**
         * Remove command buffer from execution at a specified place.
         * @param evt When to execute the command buffer during rendering.
         * @param buffer The buffer to execute.
         */
        public RemoveCommandBuffer($evt: UnityEngine_Rendering.LightEvent, $buffer: UnityEngine_Rendering.CommandBuffer):void;
        /**
         * Remove command buffers from execution at a specified place.
         * @param evt When to execute the command buffer during rendering.
         */
        public RemoveCommandBuffers($evt: UnityEngine_Rendering.LightEvent):void;
        /**
         * Remove all command buffers set on this light.
         */
        public RemoveAllCommandBuffers():void;
        /**
         * Get command buffers to be executed at a specified place.
         * @param evt When to execute the command buffer during rendering.
         * @returns Array of command buffers.
         */
        public GetCommandBuffers($evt: UnityEngine_Rendering.LightEvent):UnityEngine_Rendering.CommandBuffer[];
        
        public static GetLights($type: LightType, $layer: number):Light[];
        
                    
    }
    /**
     * How the material interacts with lightmaps and lightprobes.
     */
    enum MaterialGlobalIlluminationFlags { None = 0, RealtimeEmissive = 1, BakedEmissive = 2, EmissiveIsBlack = 4, AnyEmissive = 3 }
    /**
     * The portal for dynamically changing occlusion at runtime.
     */
    class OcclusionPortal extends Component {
        /**
         * Gets / sets the portal's open state.
         */
        public get open(): boolean;
        public set open(value: boolean);
        
        public constructor();
        
                    
    }
    /**
     * OcclusionArea is an area in which occlusion culling is performed.
     */
    class OcclusionArea extends Component {
        /**
         * Center of the occlusion area relative to the transform.
         */
        public get center(): Vector3;
        public set center(value: Vector3);
        /**
         * Size that the occlusion area will have.
         */
        public get size(): Vector3;
        public set size(value: Vector3);
        
        public constructor();
        
                    
    }
    /**
     * A flare asset. Read more about flares in the.
     */
    class Flare extends Object {
        
        public constructor();
        
                    
    }
    /**
     * Script interface for a.
     */
    class LensFlare extends Behaviour {
        /**
         * The strength of the flare.
         */
        public get brightness(): number;
        public set brightness(value: number);
        /**
         * The fade speed of the flare.
         */
        public get fadeSpeed(): number;
        public set fadeSpeed(value: number);
        /**
         * The color of the flare.
         */
        public get color(): Color;
        public set color(value: Color);
        /**
         * The to use.
         */
        public get flare(): Flare;
        public set flare(value: Flare);
        
        public constructor();
        
                    
    }
    /**
     * Struct describing the result of a Global Illumination bake for a given light.
     */
    class LightBakingOutput extends System.ValueType {
        /**
         * In case of a LightmapBakeType.Mixed light, contains the index of the light as seen from the occlusion probes point of view if any, otherwise -1.
         */
        public probeOcclusionLightIndex: number;
        /**
         * In case of a LightmapBakeType.Mixed light, contains the index of the occlusion mask channel to use if any, otherwise -1.
         */
        public occlusionMaskChannel: number;
        /**
         * This property describes what part of a light's contribution was baked.
         */
        public lightmapBakeType: LightmapBakeType;
        /**
         * In case of a LightmapBakeType.Mixed light, describes what Mixed mode was used to bake the light, irrelevant otherwise.
         */
        public mixedLightingMode: MixedLightingMode;
        /**
         * Is the light contribution already stored in lightmaps and/or lightprobes?
         */
        public isBaked: boolean;
        
                    
    }
    /**
     * Enum describing what part of a light contribution can be baked.
     */
    enum LightmapBakeType { Realtime = 4, Baked = 2, Mixed = 1 }
    /**
     * Allows mixed lights to control shadow caster culling when Shadowmasks are present.
     */
    enum LightShadowCasterMode { Default = 0, NonLightmappedOnly = 1, Everything = 2 }
    /**
     * The type of a Light.
     */
    enum LightType { Spot = 0, Directional = 1, Point = 2, Area = 3, Rectangle = 3, Disc = 4 }
    /**
     * Describes the shape of a spot light.
     */
    enum LightShape { Cone = 0, Pyramid = 1, Box = 2 }
    /**
     * Shadow casting options for a Light.
     */
    enum LightShadows { None = 0, Hard = 1, Soft = 2 }
    /**
     * How the Light is rendered.
     */
    enum LightRenderMode { Auto = 0, ForcePixel = 1, ForceVertex = 2 }
    
    enum LightmappingMode { Realtime = 4, Baked = 2, Mixed = 1 }
    /**
     * A script interface for the.
     */
    class Skybox extends Behaviour {
        /**
         * The material used by the skybox.
         */
        public get material(): Material;
        public set material(value: Material);
        
        public constructor();
        
                    
    }
    /**
     * A class to access the Mesh of the.
     */
    class MeshFilter extends Component {
        /**
         * Returns the shared mesh of the mesh filter.
         */
        public get sharedMesh(): Mesh;
        public set sharedMesh(value: Mesh);
        /**
         * Returns the instantiated Mesh assigned to the mesh filter.
         */
        public get mesh(): Mesh;
        public set mesh(value: Mesh);
        
        public constructor();
        
                    
    }
    /**
     * ComputeBuffer type.
     */
    enum ComputeBufferType { Default = 0, Raw = 1, Append = 2, Counter = 4, Constant = 8, Structured = 16, DrawIndirect = 256, IndirectArguments = 256, GPUMemory = 512 }
    /**
     * This property only takes effect if you enable a global illumination setting such as for the GameObject associated with the target Mesh Renderer. Otherwise this property defaults to the Light Probes setting.
     */
    enum ReceiveGI { Lightmaps = 1, LightProbes = 2 }
    /**
     * The maximum number of bones affecting a single vertex.
     */
    enum SkinQuality { Auto = 0, Bone1 = 1, Bone2 = 2, Bone4 = 4 }
    /**
     * NPOT Texture2D|textures support.
     */
    enum NPOTSupport { None = 0, Restricted = 1, Full = 2 }
    /**
     * Format used when creating textures from scripts.
     */
    enum TextureFormat { Alpha8 = 1, ARGB4444 = 2, RGB24 = 3, RGBA32 = 4, ARGB32 = 5, RGB565 = 7, R16 = 9, DXT1 = 10, DXT5 = 12, RGBA4444 = 13, BGRA32 = 14, RHalf = 15, RGHalf = 16, RGBAHalf = 17, RFloat = 18, RGFloat = 19, RGBAFloat = 20, YUY2 = 21, RGB9e5Float = 22, BC4 = 26, BC5 = 27, BC6H = 24, BC7 = 25, DXT1Crunched = 28, DXT5Crunched = 29, PVRTC_RGB2 = 30, PVRTC_RGBA2 = 31, PVRTC_RGB4 = 32, PVRTC_RGBA4 = 33, ETC_RGB4 = 34, ATC_RGB4 = -127, ATC_RGBA8 = -127, EAC_R = 41, EAC_R_SIGNED = 42, EAC_RG = 43, EAC_RG_SIGNED = 44, ETC2_RGB = 45, ETC2_RGBA1 = 46, ETC2_RGBA8 = 47, ASTC_4x4 = 48, ASTC_5x5 = 49, ASTC_6x6 = 50, ASTC_8x8 = 51, ASTC_10x10 = 52, ASTC_12x12 = 53, ETC_RGB4_3DS = 60, ETC_RGBA8_3DS = 61, RG16 = 62, R8 = 63, ETC_RGB4Crunched = 64, ETC2_RGBA8Crunched = 65, ASTC_HDR_4x4 = 66, ASTC_HDR_5x5 = 67, ASTC_HDR_6x6 = 68, ASTC_HDR_8x8 = 69, ASTC_HDR_10x10 = 70, ASTC_HDR_12x12 = 71, RG32 = 72, RGB48 = 73, RGBA64 = 74, ASTC_RGB_4x4 = 48, ASTC_RGB_5x5 = 49, ASTC_RGB_6x6 = 50, ASTC_RGB_8x8 = 51, ASTC_RGB_10x10 = 52, ASTC_RGB_12x12 = 53, ASTC_RGBA_4x4 = 54, ASTC_RGBA_5x5 = 55, ASTC_RGBA_6x6 = 56, ASTC_RGBA_8x8 = 57, ASTC_RGBA_10x10 = 58, ASTC_RGBA_12x12 = 59, PVRTC_2BPP_RGB = -127, PVRTC_2BPP_RGBA = -127, PVRTC_4BPP_RGB = -127, PVRTC_4BPP_RGBA = -127 }
    /**
     * This enum describes how the RenderTexture is used as a VR eye texture. Instead of using the values of this enum manually, use the value returned by XR.XRSettings.eyeTextureDesc|eyeTextureDesc or other VR functions returning a RenderTextureDescriptor.
     */
    enum VRTextureUsage { None = 0, OneEye = 1, TwoEyes = 2, DeviceSpecific = 3 }
    /**
     * Set of flags that control the state of a newly-created RenderTexture.
     */
    enum RenderTextureCreationFlags { MipMap = 1, AutoGenerateMips = 2, SRGB = 4, EyeTexture = 8, EnableRandomWrite = 16, CreatedFromScript = 32, AllowVerticalFlip = 128, NoResolvedColorSurface = 256, DynamicallyScalable = 1024, BindMS = 2048 }
    /**
     * Color space conversion mode of a RenderTexture.
     */
    enum RenderTextureReadWrite { Default = 0, Linear = 1, sRGB = 2 }
    /**
     * Flags enumeration of the render texture memoryless modes.
     */
    enum RenderTextureMemoryless { None = 0, Color = 1, Depth = 2, MSAA = 4 }
    /**
     * A set of flags that describe the level of HDR display support available on the system.
     */
    enum HDRDisplaySupportFlags { None = 0, Supported = 1, RuntimeSwitchable = 2, AutomaticTonemapping = 4 }
    /**
     * Specify the source of a Custom Render Texture initialization.
     */
    enum CustomRenderTextureInitializationSource { TextureAndColor = 0, Material = 1 }
    /**
     * Frequency of update or initialization of a Custom Render Texture.
     */
    enum CustomRenderTextureUpdateMode { OnLoad = 0, Realtime = 1, OnDemand = 2 }
    /**
     * Space in which coordinates are provided for Update Zones.
     */
    enum CustomRenderTextureUpdateZoneSpace { Normalized = 0, Pixel = 1 }
    /**
     * The Skinned Mesh filter.
     */
    class SkinnedMeshRenderer extends Renderer {
        /**
         * The maximum number of bones per vertex that are taken into account during skinning.
         */
        public get quality(): SkinQuality;
        public set quality(value: SkinQuality);
        /**
         * If enabled, the Skinned Mesh will be updated when offscreen. If disabled, this also disables updating animations.
         */
        public get updateWhenOffscreen(): boolean;
        public set updateWhenOffscreen(value: boolean);
        /**
         * Forces the Skinned Mesh to recalculate its matricies when rendered
         */
        public get forceMatrixRecalculationPerRender(): boolean;
        public set forceMatrixRecalculationPerRender(value: boolean);
        
        public get rootBone(): Transform;
        public set rootBone(value: Transform);
        /**
         * The bones used to skin the mesh.
         */
        public get bones(): Transform[];
        public set bones(value: Transform[]);
        /**
         * The mesh used for skinning.
         */
        public get sharedMesh(): Mesh;
        public set sharedMesh(value: Mesh);
        /**
         * Specifies whether skinned motion vectors should be used for this renderer.
         */
        public get skinnedMotionVectors(): boolean;
        public set skinnedMotionVectors(value: boolean);
        /**
         * AABB of this Skinned Mesh in its local space.
         */
        public get localBounds(): Bounds;
        public set localBounds(value: Bounds);
        
        public constructor();
        /**
         * Returns the weight of a BlendShape for this Renderer.
         * @param index The index of the BlendShape whose weight you want to retrieve. Index must be smaller than the Mesh.blendShapeCount of the Mesh attached to this Renderer.
         * @returns The weight of the BlendShape.
         */
        public GetBlendShapeWeight($index: number):number;
        /**
         * Sets the weight of a BlendShape for this Renderer.
         * @param index The index of the BlendShape to modify. Index must be smaller than the Mesh.blendShapeCount of the Mesh attached to this Renderer.
         * @param value The weight for this BlendShape.
         */
        public SetBlendShapeWeight($index: number, $value: number):void;
        /**
         * Creates a snapshot of SkinnedMeshRenderer and stores it in mesh.
         * @param mesh A static mesh that will receive the snapshot of the skinned mesh.
         * @param useScale Whether to use the SkinnedMeshRenderer's Transform scale when baking the Mesh. If this is true, Unity bakes the Mesh using the position, rotation, and scale values from the SkinnedMeshRenderer's Transform. If this is false, Unity bakes the Mesh using the position and rotation values from the SkinnedMeshRenderer's Transform, but without using the scale value from the SkinnedMeshRenderer's Transform. The default value is false.
         */
        public BakeMesh($mesh: Mesh):void;
        /**
         * Creates a snapshot of SkinnedMeshRenderer and stores it in mesh.
         * @param mesh A static mesh that will receive the snapshot of the skinned mesh.
         * @param useScale Whether to use the SkinnedMeshRenderer's Transform scale when baking the Mesh. If this is true, Unity bakes the Mesh using the position, rotation, and scale values from the SkinnedMeshRenderer's Transform. If this is false, Unity bakes the Mesh using the position and rotation values from the SkinnedMeshRenderer's Transform, but without using the scale value from the SkinnedMeshRenderer's Transform. The default value is false.
         */
        public BakeMesh($mesh: Mesh, $useScale: boolean):void;
        
                    
    }
    /**
     * Renders meshes inserted by the MeshFilter or TextMesh.
     */
    class MeshRenderer extends Renderer {
        /**
         * Vertex attributes in this mesh will override or add attributes of the primary mesh in the MeshRenderer.
         */
        public get additionalVertexStreams(): Mesh;
        public set additionalVertexStreams(value: Mesh);
        /**
         * Vertex attributes in this mesh will override or add attributes of the primary mesh and the additionalVertexStreams in the MeshRenderer.
         */
        public get enlightenVertexStream(): Mesh;
        public set enlightenVertexStream(value: Mesh);
        /**
         * Index of the first sub-mesh to use from the Mesh associated with this MeshRenderer (Read Only).
         */
        public get subMeshStartIndex(): number;
        /**
         * Specifies the relative lightmap resolution of this object. (Editor only)
         */
        public get scaleInLightmap(): number;
        public set scaleInLightmap(value: number);
        /**
         * Determines how the object will receive global illumination. (Editor only)
         */
        public get receiveGI(): ReceiveGI;
        public set receiveGI(value: ReceiveGI);
        /**
         * When enabled, seams in baked lightmaps will get smoothed. (Editor only)
         */
        public get stitchLightmapSeams(): boolean;
        public set stitchLightmapSeams(value: boolean);
        
        public constructor();
        
                    
    }
    /**
     * The LOD fade modes. Modes other than LODFadeMode.None will result in Unity calculating a blend factor for blending/interpolating between two neighbouring LODs and pass it to your shader.
     */
    enum LODFadeMode { None = 0, CrossFade = 1, SpeedTree = 2 }
    /**
     * Structure for building a LOD for passing to the SetLODs function.
     */
    class LOD extends System.ValueType {
        /**
         * The screen relative height to use for the transition [0-1].
         */
        public screenRelativeTransitionHeight: number;
        /**
         * Width of the cross-fade transition zone (proportion to the current LOD's whole length) [0-1]. Only used if it's not animated.
         */
        public fadeTransitionWidth: number;
        /**
         * List of renderers for this LOD level.
         */
        public renderers: Renderer[];
        /**
         * Construct a LOD.
         * @param screenRelativeTransitionHeight The screen relative height to use for the transition [0-1].
         * @param renderers An array of renderers to use for this LOD level.
         */
        public constructor($screenRelativeTransitionHeight: number, $renderers: Renderer[]);
        
                    
    }
    /**
     * LODGroup lets you group multiple Renderers into LOD levels.
     */
    class LODGroup extends Component {
        /**
         * The local reference point against which the LOD distance is calculated.
         */
        public get localReferencePoint(): Vector3;
        public set localReferencePoint(value: Vector3);
        /**
         * The size of the LOD object in local space.
         */
        public get size(): number;
        public set size(value: number);
        /**
         * The number of LOD levels.
         */
        public get lodCount(): number;
        /**
         * The LOD fade mode used.
         */
        public get fadeMode(): LODFadeMode;
        public set fadeMode(value: LODFadeMode);
        /**
         * Specify if the cross-fading should be animated by time. The animation duration is specified globally as crossFadeAnimationDuration.
         */
        public get animateCrossFading(): boolean;
        public set animateCrossFading(value: boolean);
        /**
         * Allows you to enable or disable the LODGroup.
         */
        public get enabled(): boolean;
        public set enabled(value: boolean);
        /**
         * The cross-fading animation duration in seconds. ArgumentException will be thrown if it is set to zero or a negative value.
         */
        public static get crossFadeAnimationDuration(): number;
        public static set crossFadeAnimationDuration(value: number);
        
        public constructor();
        /**
         * Recalculate the bounding region for the LODGroup (Relatively slow, do not call often).
         */
        public RecalculateBounds():void;
        /**
         * Returns the array of LODs.
         * @returns The LOD array.
         */
        public GetLODs():LOD[];
        /**
         * Set the LODs for the LOD group. This will remove any existing LODs configured on the LODGroup.
         * @param lods The LODs to use for this group.
         */
        public SetLODs($lods: LOD[]):void;
        /**
         * @param index The LOD level to use. Passing index < 0 will return to standard LOD processing.
         */
        public ForceLOD($index: number):void;
        
                    
    }
    /**
     * Light Probe Group.
     */
    class LightProbeGroup extends Behaviour {
        /**
         * Editor only function to access and modify probe positions.
         */
        public get probePositions(): Vector3[];
        public set probePositions(value: Vector3[]);
        /**
         * Removes ringing from probes if enabled.
         */
        public get dering(): boolean;
        public set dering(value: boolean);
        
        public constructor();
        
                    
    }
    /**
     * A collection of common line functions.
     */
    class LineUtility extends System.Object {
        
        public constructor();
        
        public static Simplify($points: System_Collections_Generic.List$1<Vector3>, $tolerance: number, $pointsToKeep: System_Collections_Generic.List$1<number>):void;
        
        public static Simplify($points: System_Collections_Generic.List$1<Vector3>, $tolerance: number, $simplifiedPoints: System_Collections_Generic.List$1<Vector3>):void;
        
        public static Simplify($points: System_Collections_Generic.List$1<Vector2>, $tolerance: number, $pointsToKeep: System_Collections_Generic.List$1<number>):void;
        
        public static Simplify($points: System_Collections_Generic.List$1<Vector2>, $tolerance: number, $simplifiedPoints: System_Collections_Generic.List$1<Vector2>):void;
        
                    
    }
    /**
     * Class for handling 3D Textures, Use this to create.
     */
    class Texture3D extends Texture {
        /**
         * The depth of the texture (Read Only).
         */
        public get depth(): number;
        /**
         * The format of the pixel data in the texture (Read Only).
         */
        public get format(): TextureFormat;
        /**
         * Returns true if this 3D texture is Read/Write Enabled; otherwise returns false. For dynamic textures created from script, always returns true.
         */
        public get isReadable(): boolean;
        
        public constructor($width: number, $height: number, $depth: number, $format: UnityEngine_Experimental_Rendering.DefaultFormat, $flags: UnityEngine_Experimental_Rendering.TextureCreationFlags);
        
        public constructor($width: number, $height: number, $depth: number, $format: UnityEngine_Experimental_Rendering.GraphicsFormat, $flags: UnityEngine_Experimental_Rendering.TextureCreationFlags);
        
        public constructor($width: number, $height: number, $depth: number, $format: UnityEngine_Experimental_Rendering.GraphicsFormat, $flags: UnityEngine_Experimental_Rendering.TextureCreationFlags, $mipCount: number);
        
        public constructor($width: number, $height: number, $depth: number, $textureFormat: TextureFormat, $mipCount: number);
        
        public constructor($width: number, $height: number, $depth: number, $textureFormat: TextureFormat, $mipCount: number, $nativeTex: System.IntPtr);
        /**
         * Create a new empty 3D Texture.
         * @param width Width of texture in pixels.
         * @param height Height of texture in pixels.
         * @param depth Depth of texture in pixels.
         * @param textureFormat Texture data format.
         * @param mipChain Determines whether the texture has mipmaps or not. A value of 1 (true) means the texture does have mipmaps, and a value of 0 (false) means the texture doesn't have mipmaps.
         */
        public constructor($width: number, $height: number, $depth: number, $textureFormat: TextureFormat, $mipChain: boolean);
        
        public constructor($width: number, $height: number, $depth: number, $textureFormat: TextureFormat, $mipChain: boolean, $nativeTex: System.IntPtr);
        /**
         * Updates Unity texture to use different native texture object.
         * @param nativeTex Native 3D texture object.
         */
        public UpdateExternalTexture($nativeTex: System.IntPtr):void;
        /**
         * Returns an array of pixel colors representing one mip level of the 3D texture.
         * @param miplevel The mipmap level to be accessed.
         * @returns The colors to get the array of pixels.
         */
        public GetPixels($miplevel: number):Color[];
        
        public GetPixels():Color[];
        /**
         * Returns an array of pixel colors representing one mip level of the 3D texture.
         * @param miplevel The mipmap level to be accessed.
         * @returns The colors to get the array of pixels.
         */
        public GetPixels32($miplevel: number):Color32[];
        
        public GetPixels32():Color32[];
        /**
         * Sets pixel colors of a 3D texture.
         * @param colors The colors to set the pixels to.
         * @param miplevel The mipmap level to be affected by the new colors.
         */
        public SetPixels($colors: Color[], $miplevel: number):void;
        
        public SetPixels($colors: Color[]):void;
        /**
         * Sets pixel colors of a 3D texture.
         * @param colors The colors to set the pixels to.
         * @param miplevel The mipmap level to be affected by the new colors.
         */
        public SetPixels32($colors: Color32[], $miplevel: number):void;
        
        public SetPixels32($colors: Color32[]):void;
        /**
         * Creates Unity Texture out of externally created native texture object.
         * @param nativeTex Native 3D texture object.
         * @param width Width of texture in pixels.
         * @param height Height of texture in pixels.
         * @param depth Depth of texture in pixels
         * @param format Format of underlying texture object.
         * @param mipmap Does the texture have mipmaps?
         */
        public static CreateExternalTexture($width: number, $height: number, $depth: number, $format: TextureFormat, $mipChain: boolean, $nativeTex: System.IntPtr):Texture3D;
        /**
         * Actually apply all previous SetPixels changes.
         * @param updateMipmaps When set to true, mipmap levels are recalculated.
         * @param makeNoLongerReadable When set to true, system memory copy of a texture is released.
         */
        public Apply($updateMipmaps: boolean, $makeNoLongerReadable: boolean):void;
        
        public Apply($updateMipmaps: boolean):void;
        
        public Apply():void;
        
        public SetPixel($x: number, $y: number, $z: number, $color: Color):void;
        /**
         * Sets the pixel color that represents one mip level of the 3D texture at coordinates (x,y,z).
         * @param x X coordinate to access a pixel.
         * @param y Y coordinate to access a pixel.
         * @param z Z coordinate to access a pixel.
         * @param color The colors to set the pixels to.
         * @param mipLevel The mipmap level to be affected by the new colors.
         */
        public SetPixel($x: number, $y: number, $z: number, $color: Color, $mipLevel: number):void;
        
        public GetPixel($x: number, $y: number, $z: number):Color;
        /**
         * Returns the pixel color that represents one mip level of the 3D texture at coordinates (x,y,z).
         * @param x X coordinate to access a pixel.
         * @param y Y coordinate to access a pixel.
         * @param z Z coordinate to access a pixel.
         * @param mipLevel The mipmap level to be accessed.
         * @returns The color of the pixel.
         */
        public GetPixel($x: number, $y: number, $z: number, $mipLevel: number):Color;
        
        public GetPixelBilinear($u: number, $v: number, $w: number):Color;
        /**
         * Returns the filtered pixel color that represents one mip level of the 3D texture at normalized coordinates (u,v,w).
         * @param u U normalized coordinate to access a pixel.
         * @param v V normalized coordinate to access a pixel.
         * @param w W normalized coordinate to access a pixel.
         * @param mipLevel The mipmap level to be accessed.
         * @returns The colors to return by bilinear filtering.
         */
        public GetPixelBilinear($u: number, $v: number, $w: number, $mipLevel: number):Color;
        /**
         * Set pixel values from raw preformatted data.
         * @param data Data array to initialize texture pixels with.
         * @param mipLevel Mip level to fill.
         * @param sourceDataStartIndex Index in the source array to start copying from (default 0).
         */
        public SetPixelData<T>($data: T[], $mipLevel: number, $sourceDataStartIndex?: number):void;
        
        public SetPixelData<T>($data: Unity_Collections.NativeArray$1<T>, $mipLevel: number, $sourceDataStartIndex?: number):void;
        /**
         * Gets raw data from a Texture for reading or writing.
         * @param mipLevel The mip level to reference.
         */
        public GetPixelData<T>($mipLevel: number):Unity_Collections.NativeArray$1<T>;
        
        public constructor();
        
                    
    }
    /**
     * Class for handling 2D texture arrays.
     */
    class Texture2DArray extends Texture {
        /**
         * Read Only. This property is used as a parameter in some overloads of the CommandBuffer.Blit, Graphics.Blit, CommandBuffer.SetRenderTarget, and Graphics.SetRenderTarget methods to indicate that all texture array slices are bound. The value of this property is -1.
         */
        public static get allSlices(): number;
        /**
         * Number of elements in a texture array (Read Only).
         */
        public get depth(): number;
        /**
         * Texture format (Read Only).
         */
        public get format(): TextureFormat;
        /**
         * Returns true if this texture array is Read/Write Enabled; otherwise returns false. For dynamic textures created from script, always returns true.
         */
        public get isReadable(): boolean;
        
        public constructor($width: number, $height: number, $depth: number, $format: UnityEngine_Experimental_Rendering.DefaultFormat, $flags: UnityEngine_Experimental_Rendering.TextureCreationFlags);
        
        public constructor($width: number, $height: number, $depth: number, $format: UnityEngine_Experimental_Rendering.GraphicsFormat, $flags: UnityEngine_Experimental_Rendering.TextureCreationFlags);
        
        public constructor($width: number, $height: number, $depth: number, $format: UnityEngine_Experimental_Rendering.GraphicsFormat, $flags: UnityEngine_Experimental_Rendering.TextureCreationFlags, $mipCount: number);
        
        public constructor($width: number, $height: number, $depth: number, $textureFormat: TextureFormat, $mipCount: number, $linear: boolean);
        /**
         * Create a new texture array.
         * @param width Width of texture array in pixels.
         * @param height Height of texture array in pixels.
         * @param depth Number of elements in the texture array.
         * @param format Format of the texture.
         * @param mipmap Should mipmaps be created?
         * @param linear Does the texture contain non-color data (i.e. don't do any color space conversions when sampling)? Default is false.
         */
        public constructor($width: number, $height: number, $depth: number, $textureFormat: TextureFormat, $mipChain: boolean, $linear: boolean);
        /**
         * Create a new texture array.
         * @param width Width of texture array in pixels.
         * @param height Height of texture array in pixels.
         * @param depth Number of elements in the texture array.
         * @param format Format of the texture.
         * @param mipmap Should mipmaps be created?
         * @param linear Does the texture contain non-color data (i.e. don't do any color space conversions when sampling)? Default is false.
         */
        public constructor($width: number, $height: number, $depth: number, $textureFormat: TextureFormat, $mipChain: boolean);
        /**
         * Returns pixel colors of a single array slice.
         * @param arrayElement Array slice to read pixels from.
         * @param miplevel Mipmap level to read pixels from.
         * @returns Array of pixel colors.
         */
        public GetPixels($arrayElement: number, $miplevel: number):Color[];
        
        public GetPixels($arrayElement: number):Color[];
        /**
         * Returns pixel colors of a single array slice.
         * @param arrayElement Array slice to read pixels from.
         * @param miplevel Mipmap level to read pixels from.
         * @returns Array of pixel colors in low precision (8 bits/channel) format.
         */
        public GetPixels32($arrayElement: number, $miplevel: number):Color32[];
        
        public GetPixels32($arrayElement: number):Color32[];
        /**
         * Set pixel colors for the whole mip level.
         * @param colors An array of pixel colors.
         * @param arrayElement The texture array element index.
         * @param miplevel The mip level.
         */
        public SetPixels($colors: Color[], $arrayElement: number, $miplevel: number):void;
        
        public SetPixels($colors: Color[], $arrayElement: number):void;
        /**
         * Set pixel colors for the whole mip level.
         * @param colors An array of pixel colors.
         * @param arrayElement The texture array element index.
         * @param miplevel The mip level.
         */
        public SetPixels32($colors: Color32[], $arrayElement: number, $miplevel: number):void;
        
        public SetPixels32($colors: Color32[], $arrayElement: number):void;
        /**
         * Actually apply all previous SetPixels changes.
         * @param updateMipmaps When set to true, mipmap levels are recalculated.
         * @param makeNoLongerReadable When set to true, system memory copy of a texture is released.
         */
        public Apply($updateMipmaps: boolean, $makeNoLongerReadable: boolean):void;
        /**
         * Set pixel values from raw preformatted data.
         * @param data Data array to initialize texture pixels with.
         * @param mipLevel Mip level to fill.
         * @param element Array slice to copy pixels to.
         * @param sourceDataStartIndex Index in the source array to start copying from (default 0).
         */
        public SetPixelData<T>($data: T[], $mipLevel: number, $element: number, $sourceDataStartIndex?: number):void;
        
        public SetPixelData<T>($data: Unity_Collections.NativeArray$1<T>, $mipLevel: number, $element: number, $sourceDataStartIndex?: number):void;
        /**
         * Gets raw data from a Texture for reading or writing.
         * @param mipLevel The mip level to reference.
         * @param element The array slice to reference.
         */
        public GetPixelData<T>($mipLevel: number, $element: number):Unity_Collections.NativeArray$1<T>;
        
        public Apply($updateMipmaps: boolean):void;
        
        public Apply():void;
        
        public constructor();
        
                    
    }
    /**
     * Class for handling Cubemap arrays.
     */
    class CubemapArray extends Texture {
        /**
         * Number of cubemaps in the array (Read Only).
         */
        public get cubemapCount(): number;
        /**
         * Texture format (Read Only).
         */
        public get format(): TextureFormat;
        
        public get isReadable(): boolean;
        
        public constructor($width: number, $cubemapCount: number, $format: UnityEngine_Experimental_Rendering.DefaultFormat, $flags: UnityEngine_Experimental_Rendering.TextureCreationFlags);
        
        public constructor($width: number, $cubemapCount: number, $format: UnityEngine_Experimental_Rendering.GraphicsFormat, $flags: UnityEngine_Experimental_Rendering.TextureCreationFlags);
        
        public constructor($width: number, $cubemapCount: number, $format: UnityEngine_Experimental_Rendering.GraphicsFormat, $flags: UnityEngine_Experimental_Rendering.TextureCreationFlags, $mipCount: number);
        
        public constructor($width: number, $cubemapCount: number, $textureFormat: TextureFormat, $mipCount: number, $linear: boolean);
        /**
         * Create a new cubemap array.
         * @param faceSize Cubemap face size in pixels.
         * @param cubemapCount Number of elements in the cubemap array.
         * @param format Format of the pixel data.
         * @param mipmap Should mipmaps be created?
         * @param linear Does the texture contain non-color data (i.e. don't do any color space conversions when sampling)? Default is false.
         */
        public constructor($width: number, $cubemapCount: number, $textureFormat: TextureFormat, $mipChain: boolean, $linear: boolean);
        /**
         * Create a new cubemap array.
         * @param faceSize Cubemap face size in pixels.
         * @param cubemapCount Number of elements in the cubemap array.
         * @param format Format of the pixel data.
         * @param mipmap Should mipmaps be created?
         * @param linear Does the texture contain non-color data (i.e. don't do any color space conversions when sampling)? Default is false.
         */
        public constructor($width: number, $cubemapCount: number, $textureFormat: TextureFormat, $mipChain: boolean);
        /**
         * Returns pixel colors of a single array slice/face.
         * @param face Cubemap face to read pixels from.
         * @param arrayElement Array slice to read pixels from.
         * @param miplevel Mipmap level to read pixels from.
         * @returns Array of pixel colors.
         */
        public GetPixels($face: CubemapFace, $arrayElement: number, $miplevel: number):Color[];
        
        public GetPixels($face: CubemapFace, $arrayElement: number):Color[];
        /**
         * Returns pixel colors of a single array slice/face.
         * @param face Cubemap face to read pixels from.
         * @param arrayElement Array slice to read pixels from.
         * @param miplevel Mipmap level to read pixels from.
         * @returns Array of pixel colors in low precision (8 bits/channel) format.
         */
        public GetPixels32($face: CubemapFace, $arrayElement: number, $miplevel: number):Color32[];
        
        public GetPixels32($face: CubemapFace, $arrayElement: number):Color32[];
        /**
         * Set pixel colors for a single array slice/face.
         * @param colors An array of pixel colors.
         * @param face Cubemap face to set pixels for.
         * @param arrayElement Array element index to set pixels for.
         * @param miplevel Mipmap level to set pixels for.
         */
        public SetPixels($colors: Color[], $face: CubemapFace, $arrayElement: number, $miplevel: number):void;
        
        public SetPixels($colors: Color[], $face: CubemapFace, $arrayElement: number):void;
        /**
         * Set pixel colors for a single array slice/face.
         * @param colors An array of pixel colors in low precision (8 bits/channel) format.
         * @param face Cubemap face to set pixels for.
         * @param arrayElement Array element index to set pixels for.
         * @param miplevel Mipmap level to set pixels for.
         */
        public SetPixels32($colors: Color32[], $face: CubemapFace, $arrayElement: number, $miplevel: number):void;
        
        public SetPixels32($colors: Color32[], $face: CubemapFace, $arrayElement: number):void;
        /**
         * Actually apply all previous SetPixels changes.
         * @param updateMipmaps When set to true, mipmap levels are recalculated.
         * @param makeNoLongerReadable When set to true, system memory copy of a texture is released.
         */
        public Apply($updateMipmaps: boolean, $makeNoLongerReadable: boolean):void;
        
        public Apply($updateMipmaps: boolean):void;
        
        public Apply():void;
        /**
         * Set pixel values from raw preformatted data.
         * @param mipLevel Mip level to fill.
         * @param element Array slice to copy pixels to.
         * @param sourceDataStartIndex Index in the source array to start copying from (default 0).
         * @param face Cubemap face to fill.
         * @param data Data array to initialize texture pixels with.
         */
        public SetPixelData<T>($data: T[], $mipLevel: number, $face: CubemapFace, $element: number, $sourceDataStartIndex?: number):void;
        
        public SetPixelData<T>($data: Unity_Collections.NativeArray$1<T>, $mipLevel: number, $face: CubemapFace, $element: number, $sourceDataStartIndex?: number):void;
        /**
         * Gets raw data from a Texture for reading or writing.
         * @param mipLevel The mip level to reference.
         * @param face The Cubemap face to reference.
         * @param element The array slice to reference.
         */
        public GetPixelData<T>($mipLevel: number, $face: CubemapFace, $element: number):Unity_Collections.NativeArray$1<T>;
        
        public constructor();
        
                    
    }
    /**
     * Class for handling Sparse Textures.
     */
    class SparseTexture extends Texture {
        /**
         * Get sparse texture tile width (Read Only).
         */
        public get tileWidth(): number;
        /**
         * Get sparse texture tile height (Read Only).
         */
        public get tileHeight(): number;
        /**
         * Is the sparse texture actually created? (Read Only)
         */
        public get isCreated(): boolean;
        
        public constructor($width: number, $height: number, $format: UnityEngine_Experimental_Rendering.DefaultFormat, $mipCount: number);
        
        public constructor($width: number, $height: number, $format: UnityEngine_Experimental_Rendering.GraphicsFormat, $mipCount: number);
        /**
         * Create a sparse texture.
         * @param width Texture width in pixels.
         * @param height Texture height in pixels.
         * @param format Texture format.
         * @param mipCount Mipmap count. Pass -1 to create full mipmap chain.
         * @param linear Whether texture data will be in linear or sRGB color space (default is sRGB).
         */
        public constructor($width: number, $height: number, $textureFormat: TextureFormat, $mipCount: number);
        /**
         * Create a sparse texture.
         * @param width Texture width in pixels.
         * @param height Texture height in pixels.
         * @param format Texture format.
         * @param mipCount Mipmap count. Pass -1 to create full mipmap chain.
         * @param linear Whether texture data will be in linear or sRGB color space (default is sRGB).
         */
        public constructor($width: number, $height: number, $textureFormat: TextureFormat, $mipCount: number, $linear: boolean);
        /**
         * Update sparse texture tile with color values.
         * @param tileX Tile X coordinate.
         * @param tileY Tile Y coordinate.
         * @param miplevel Mipmap level of the texture.
         * @param data Tile color data.
         */
        public UpdateTile($tileX: number, $tileY: number, $miplevel: number, $data: Color32[]):void;
        /**
         * Update sparse texture tile with raw pixel values.
         * @param tileX Tile X coordinate.
         * @param tileY Tile Y coordinate.
         * @param miplevel Mipmap level of the texture.
         * @param data Tile raw pixel data.
         */
        public UpdateTileRaw($tileX: number, $tileY: number, $miplevel: number, $data: number[]):void;
        /**
         * Unload sparse texture tile.
         * @param tileX Tile X coordinate.
         * @param tileY Tile Y coordinate.
         * @param miplevel Mipmap level of the texture.
         */
        public UnloadTile($tileX: number, $tileY: number, $miplevel: number):void;
        
        public constructor();
        
                    
    }
    /**
     * This struct contains all the information required to create a RenderTexture. It can be copied, cached, and reused to easily create RenderTextures that all share the same properties. Avoid using the default constructor as it does not initialize some flags with the recommended values.
     */
    class RenderTextureDescriptor extends System.ValueType {
        /**
         * The width of the render texture in pixels.
         */
        public get width(): number;
        public set width(value: number);
        /**
         * The height of the render texture in pixels.
         */
        public get height(): number;
        public set height(value: number);
        /**
         * The multisample antialiasing level for the RenderTexture.
         * See Also: RenderTexture.antiAliasing.
         */
        public get msaaSamples(): number;
        public set msaaSamples(value: number);
        /**
         * Volume extent of a 3D render texture.
         */
        public get volumeDepth(): number;
        public set volumeDepth(value: number);
        /**
         * User-defined mipmap count.
         */
        public get mipCount(): number;
        public set mipCount(value: number);
        /**
         * The color format for the RenderTexture.
         */
        public get graphicsFormat(): UnityEngine_Experimental_Rendering.GraphicsFormat;
        public set graphicsFormat(value: UnityEngine_Experimental_Rendering.GraphicsFormat);
        /**
         * The format of the stencil data that you can encapsulate within a RenderTexture.
         * Specifying this property creates a stencil element for the RenderTexture and sets its format.
         * This allows for stencil data to be bound as a Texture to all shader types for the platforms that support it.
         * This property does not specify the format of the stencil buffer, which is constrained by the depth buffer format specified in RenderTexture.depth.
         * Currently, most platforms only support R8_UInt (DirectX11, DirectX12), while PS4 also supports R8_UNorm.
         */
        public get stencilFormat(): UnityEngine_Experimental_Rendering.GraphicsFormat;
        public set stencilFormat(value: UnityEngine_Experimental_Rendering.GraphicsFormat);
        
        public get colorFormat(): RenderTextureFormat;
        public set colorFormat(value: RenderTextureFormat);
        /**
         * This flag causes the render texture uses sRGB read/write conversions.
         */
        public get sRGB(): boolean;
        public set sRGB(value: boolean);
        /**
         * The precision of the render texture's depth buffer in bits (0, 16, 24/32 are supported).
         * See Also: RenderTexture.depth.
         */
        public get depthBufferBits(): number;
        public set depthBufferBits(value: number);
        /**
         * Dimensionality (type) of the render texture.
         * See Also: RenderTexture.dimension.
         */
        public get dimension(): UnityEngine_Rendering.TextureDimension;
        public set dimension(value: UnityEngine_Rendering.TextureDimension);
        /**
         * Determines how the RenderTexture is sampled if it is used as a shadow map.
         * See Also: ShadowSamplingMode for more details.
         */
        public get shadowSamplingMode(): UnityEngine_Rendering.ShadowSamplingMode;
        public set shadowSamplingMode(value: UnityEngine_Rendering.ShadowSamplingMode);
        /**
         * If this RenderTexture is a VR eye texture used in stereoscopic rendering, this property decides what special rendering occurs, if any. Instead of setting this manually, use the value returned by XR.XRSettings.eyeTextureDesc|eyeTextureDesc or other VR functions returning a RenderTextureDescriptor.
         */
        public get vrUsage(): VRTextureUsage;
        public set vrUsage(value: VRTextureUsage);
        /**
         * A set of RenderTextureCreationFlags that control how the texture is created.
         */
        public get flags(): RenderTextureCreationFlags;
        /**
         * The render texture memoryless mode property.
         */
        public get memoryless(): RenderTextureMemoryless;
        public set memoryless(value: RenderTextureMemoryless);
        /**
         * Render texture has mipmaps when this flag is set.
         * See Also: RenderTexture.useMipMap.
         */
        public get useMipMap(): boolean;
        public set useMipMap(value: boolean);
        /**
         * Mipmap levels are generated automatically when this flag is set.
         */
        public get autoGenerateMips(): boolean;
        public set autoGenerateMips(value: boolean);
        /**
         * Enable random access write into this render texture on Shader Model 5.0 level shaders.
         * See Also: RenderTexture.enableRandomWrite.
         */
        public get enableRandomWrite(): boolean;
        public set enableRandomWrite(value: boolean);
        /**
         * If true and msaaSamples is greater than 1, the render texture will not be resolved by default.  Use this if the render texture needs to be bound as a multisampled texture in a shader.
         */
        public get bindMS(): boolean;
        public set bindMS(value: boolean);
        /**
         * Set to true to enable dynamic resolution scaling on this render texture.
         * See Also: RenderTexture.useDynamicScale.
         */
        public get useDynamicScale(): boolean;
        public set useDynamicScale(value: boolean);
        /**
         * Create a RenderTextureDescriptor with default values, or a certain width, height, and format.
         * @param width Width of the RenderTexture in pixels.
         * @param height Height of the RenderTexture in pixels.
         * @param colorFormat The color format for the RenderTexture.
         * @param depthBufferBits The number of bits to use for the depth buffer.
         */
        public constructor($width: number, $height: number);
        /**
         * Create a RenderTextureDescriptor with default values, or a certain width, height, and format.
         * @param width Width of the RenderTexture in pixels.
         * @param height Height of the RenderTexture in pixels.
         * @param colorFormat The color format for the RenderTexture.
         * @param depthBufferBits The number of bits to use for the depth buffer.
         */
        public constructor($width: number, $height: number, $colorFormat: RenderTextureFormat);
        /**
         * Create a RenderTextureDescriptor with default values, or a certain width, height, and format.
         * @param width Width of the RenderTexture in pixels.
         * @param height Height of the RenderTexture in pixels.
         * @param colorFormat The color format for the RenderTexture.
         * @param depthBufferBits The number of bits to use for the depth buffer.
         */
        public constructor($width: number, $height: number, $colorFormat: RenderTextureFormat, $depthBufferBits: number);
        
        public constructor($width: number, $height: number, $colorFormat: UnityEngine_Experimental_Rendering.GraphicsFormat, $depthBufferBits: number);
        
        public constructor($width: number, $height: number, $colorFormat: RenderTextureFormat, $depthBufferBits: number, $mipCount: number);
        
        public constructor($width: number, $height: number, $colorFormat: UnityEngine_Experimental_Rendering.GraphicsFormat, $depthBufferBits: number, $mipCount: number);
        
        public get_Clone(): RenderTextureDescriptor;            
    }
    /**
     * Structure describing an Update Zone.
     */
    class CustomRenderTextureUpdateZone extends System.ValueType {
        /**
         * Position of the center of the Update Zone within the Custom Render Texture.
         */
        public updateZoneCenter: Vector3;
        /**
         * Size of the Update Zone.
         */
        public updateZoneSize: Vector3;
        /**
         * Rotation of the Update Zone.
         */
        public rotation: number;
        /**
         * Shader Pass used to update the Custom Render Texture for this Update Zone.
         */
        public passIndex: number;
        /**
         * If true, and if the texture is double buffered, a request is made to swap the buffers before the next update. Otherwise, the buffers will not be swapped.
         */
        public needSwap: boolean;
        
                    
    }
    /**
     * Describes options for displaying movie playback controls.
     */
    enum FullScreenMovieControlMode { Full = 0, Minimal = 1, CancelOnInput = 2, Hidden = 3 }
    /**
     * Describes scaling modes for displaying movies.
     */
    enum FullScreenMovieScalingMode { None = 0, AspectFit = 1, AspectFill = 2, Fill = 3 }
    /**
     * ActivityIndicator Style (Android Specific).
     */
    enum AndroidActivityIndicatorStyle { DontShow = -1, Large = 0, InversedLarge = 1, Small = 2, InversedSmall = 3 }
    /**
     * Interface into functionality unique to handheld devices.
     */
    class Handheld extends System.Object {
        
        public constructor();
        /**
         * Plays a full-screen movie.
         * @param path Filesystem path to the movie file.
         * @param bgColor Background color.
         * @param controlMode How the playback controls are to be displayed.
         * @param scalingMode How the movie is to be scaled to fit the screen.
         */
        public static PlayFullScreenMovie($path: string, $bgColor: Color, $controlMode: FullScreenMovieControlMode, $scalingMode: FullScreenMovieScalingMode):boolean;
        /**
         * Plays a full-screen movie.
         * @param path Filesystem path to the movie file.
         * @param bgColor Background color.
         * @param controlMode How the playback controls are to be displayed.
         * @param scalingMode How the movie is to be scaled to fit the screen.
         */
        public static PlayFullScreenMovie($path: string, $bgColor: Color, $controlMode: FullScreenMovieControlMode):boolean;
        /**
         * Plays a full-screen movie.
         * @param path Filesystem path to the movie file.
         * @param bgColor Background color.
         * @param controlMode How the playback controls are to be displayed.
         * @param scalingMode How the movie is to be scaled to fit the screen.
         */
        public static PlayFullScreenMovie($path: string, $bgColor: Color):boolean;
        /**
         * Plays a full-screen movie.
         * @param path Filesystem path to the movie file.
         * @param bgColor Background color.
         * @param controlMode How the playback controls are to be displayed.
         * @param scalingMode How the movie is to be scaled to fit the screen.
         */
        public static PlayFullScreenMovie($path: string):boolean;
        /**
         * Triggers device vibration.
         */
        public static Vibrate():void;
        
        public static SetActivityIndicatorStyle($style: UnityEngine_iOS.ActivityIndicatorStyle):void;
        /**
         * Sets the desired activity indicator style.
         */
        public static SetActivityIndicatorStyle($style: AndroidActivityIndicatorStyle):void;
        /**
         * Gets the current activity indicator style.
         */
        public static GetActivityIndicatorStyle():number;
        /**
         * Starts os activity indicator.
         */
        public static StartActivityIndicator():void;
        /**
         * Stops os activity indicator.
         */
        public static StopActivityIndicator():void;
        
        public static ClearShaderCache():void;
        
                    
    }
    /**
     * Utilities to compute hashes.
     */
    class HashUtilities extends System.Object {
        /**
         * Append inHash in outHash.
         * @param inHash Hash to append.
         * @param outHash Hash that will be updated.
         */
        public static AppendHash($inHash: $Ref<Hash128>, $outHash: $Ref<Hash128>):void;
        /**
         * Compute a Hash128 of a Matrix4x4.
         * @param value The Matrix4x4 to hash.
         * @param hash The computed hash.
         */
        public static QuantisedMatrixHash($value: $Ref<Matrix4x4>, $hash: $Ref<Hash128>):void;
        /**
         * Compute a Hash128 of a Vector3.
         * @param hash The Vector3 to hash.
         * @param value The computed hash.
         */
        public static QuantisedVectorHash($value: $Ref<Vector3>, $hash: $Ref<Hash128>):void;
        
        public static ComputeHash128<T>($value: $Ref<T>, $hash: $Ref<Hash128>):void;
        /**
         * Compute a 128 bit hash based on a value. the type of the value must be a value type.
         * @param value A reference to the value to hash.
         * @param hash A reference to the Hash128 to updated with the computed hash.
         */
        public static ComputeHash128($value: number[], $hash: $Ref<Hash128>):void;
        
                    
    }
    /**
     * Utilities to compute hashes with unsafe code.
     */
    class HashUnsafeUtilities extends System.Object {
        
                    
    }
    /**
     * Determines whether the mouse cursor is rendered using software rendering or, on supported platforms, hardware rendering.
     */
    enum CursorMode { Auto = 0, ForceSoftware = 1 }
    /**
     * How the cursor should behave.
     */
    enum CursorLockMode { None = 0, Locked = 1, Confined = 2 }
    /**
     * Cursor API for setting the cursor (mouse pointer).
     */
    class Cursor extends System.Object {
        /**
         * Determines whether the hardware pointer is visible or not.
         */
        public static get visible(): boolean;
        public static set visible(value: boolean);
        /**
         * Determines whether the hardware pointer is locked to the center of the view, constrained to the window, or not constrained at all.
         */
        public static get lockState(): CursorLockMode;
        public static set lockState(value: CursorLockMode);
        
        public constructor();
        /**
         * Specify a custom cursor that you wish to use as a cursor.
         * @param texture The texture to use for the cursor. To use a texture, you must first import it with `Read/Write`enabled. Alternatively, you can use the default cursor import setting. If you created your cursor texture from code, it must be in RGBA32 format, have alphaIsTransparency enabled, and have no mip chain. To use the default cursor, set the texture to `Null`.
         * @param hotspot The offset from the top left of the texture to use as the target point (must be within the bounds of the cursor).
         * @param cursorMode Allow this cursor to render as a hardware cursor on supported platforms, or force software cursor.
         */
        public static SetCursor($texture: Texture2D, $hotspot: Vector2, $cursorMode: CursorMode):void;
        
                    
    }
    /**
     * Key codes returned by Event.keyCode. These map directly to a physical key on the keyboard.
     */
    enum KeyCode { None = 0, Backspace = 8, Delete = 127, Tab = 9, Clear = 12, Return = 13, Pause = 19, Escape = 27, Space = 32, Keypad0 = 256, Keypad1 = 257, Keypad2 = 258, Keypad3 = 259, Keypad4 = 260, Keypad5 = 261, Keypad6 = 262, Keypad7 = 263, Keypad8 = 264, Keypad9 = 265, KeypadPeriod = 266, KeypadDivide = 267, KeypadMultiply = 268, KeypadMinus = 269, KeypadPlus = 270, KeypadEnter = 271, KeypadEquals = 272, UpArrow = 273, DownArrow = 274, RightArrow = 275, LeftArrow = 276, Insert = 277, Home = 278, End = 279, PageUp = 280, PageDown = 281, F1 = 282, F2 = 283, F3 = 284, F4 = 285, F5 = 286, F6 = 287, F7 = 288, F8 = 289, F9 = 290, F10 = 291, F11 = 292, F12 = 293, F13 = 294, F14 = 295, F15 = 296, Alpha0 = 48, Alpha1 = 49, Alpha2 = 50, Alpha3 = 51, Alpha4 = 52, Alpha5 = 53, Alpha6 = 54, Alpha7 = 55, Alpha8 = 56, Alpha9 = 57, Exclaim = 33, DoubleQuote = 34, Hash = 35, Dollar = 36, Percent = 37, Ampersand = 38, Quote = 39, LeftParen = 40, RightParen = 41, Asterisk = 42, Plus = 43, Comma = 44, Minus = 45, Period = 46, Slash = 47, Colon = 58, Semicolon = 59, Less = 60, Equals = 61, Greater = 62, Question = 63, At = 64, LeftBracket = 91, Backslash = 92, RightBracket = 93, Caret = 94, Underscore = 95, BackQuote = 96, A = 97, B = 98, C = 99, D = 100, E = 101, F = 102, G = 103, H = 104, I = 105, J = 106, K = 107, L = 108, M = 109, N = 110, O = 111, P = 112, Q = 113, R = 114, S = 115, T = 116, U = 117, V = 118, W = 119, X = 120, Y = 121, Z = 122, LeftCurlyBracket = 123, Pipe = 124, RightCurlyBracket = 125, Tilde = 126, Numlock = 300, CapsLock = 301, ScrollLock = 302, RightShift = 303, LeftShift = 304, RightControl = 305, LeftControl = 306, RightAlt = 307, LeftAlt = 308, LeftCommand = 310, LeftApple = 310, LeftWindows = 311, RightCommand = 309, RightApple = 309, RightWindows = 312, AltGr = 313, Help = 315, Print = 316, SysReq = 317, Break = 318, Menu = 319, Mouse0 = 323, Mouse1 = 324, Mouse2 = 325, Mouse3 = 326, Mouse4 = 327, Mouse5 = 328, Mouse6 = 329, JoystickButton0 = 330, JoystickButton1 = 331, JoystickButton2 = 332, JoystickButton3 = 333, JoystickButton4 = 334, JoystickButton5 = 335, JoystickButton6 = 336, JoystickButton7 = 337, JoystickButton8 = 338, JoystickButton9 = 339, JoystickButton10 = 340, JoystickButton11 = 341, JoystickButton12 = 342, JoystickButton13 = 343, JoystickButton14 = 344, JoystickButton15 = 345, JoystickButton16 = 346, JoystickButton17 = 347, JoystickButton18 = 348, JoystickButton19 = 349, Joystick1Button0 = 350, Joystick1Button1 = 351, Joystick1Button2 = 352, Joystick1Button3 = 353, Joystick1Button4 = 354, Joystick1Button5 = 355, Joystick1Button6 = 356, Joystick1Button7 = 357, Joystick1Button8 = 358, Joystick1Button9 = 359, Joystick1Button10 = 360, Joystick1Button11 = 361, Joystick1Button12 = 362, Joystick1Button13 = 363, Joystick1Button14 = 364, Joystick1Button15 = 365, Joystick1Button16 = 366, Joystick1Button17 = 367, Joystick1Button18 = 368, Joystick1Button19 = 369, Joystick2Button0 = 370, Joystick2Button1 = 371, Joystick2Button2 = 372, Joystick2Button3 = 373, Joystick2Button4 = 374, Joystick2Button5 = 375, Joystick2Button6 = 376, Joystick2Button7 = 377, Joystick2Button8 = 378, Joystick2Button9 = 379, Joystick2Button10 = 380, Joystick2Button11 = 381, Joystick2Button12 = 382, Joystick2Button13 = 383, Joystick2Button14 = 384, Joystick2Button15 = 385, Joystick2Button16 = 386, Joystick2Button17 = 387, Joystick2Button18 = 388, Joystick2Button19 = 389, Joystick3Button0 = 390, Joystick3Button1 = 391, Joystick3Button2 = 392, Joystick3Button3 = 393, Joystick3Button4 = 394, Joystick3Button5 = 395, Joystick3Button6 = 396, Joystick3Button7 = 397, Joystick3Button8 = 398, Joystick3Button9 = 399, Joystick3Button10 = 400, Joystick3Button11 = 401, Joystick3Button12 = 402, Joystick3Button13 = 403, Joystick3Button14 = 404, Joystick3Button15 = 405, Joystick3Button16 = 406, Joystick3Button17 = 407, Joystick3Button18 = 408, Joystick3Button19 = 409, Joystick4Button0 = 410, Joystick4Button1 = 411, Joystick4Button2 = 412, Joystick4Button3 = 413, Joystick4Button4 = 414, Joystick4Button5 = 415, Joystick4Button6 = 416, Joystick4Button7 = 417, Joystick4Button8 = 418, Joystick4Button9 = 419, Joystick4Button10 = 420, Joystick4Button11 = 421, Joystick4Button12 = 422, Joystick4Button13 = 423, Joystick4Button14 = 424, Joystick4Button15 = 425, Joystick4Button16 = 426, Joystick4Button17 = 427, Joystick4Button18 = 428, Joystick4Button19 = 429, Joystick5Button0 = 430, Joystick5Button1 = 431, Joystick5Button2 = 432, Joystick5Button3 = 433, Joystick5Button4 = 434, Joystick5Button5 = 435, Joystick5Button6 = 436, Joystick5Button7 = 437, Joystick5Button8 = 438, Joystick5Button9 = 439, Joystick5Button10 = 440, Joystick5Button11 = 441, Joystick5Button12 = 442, Joystick5Button13 = 443, Joystick5Button14 = 444, Joystick5Button15 = 445, Joystick5Button16 = 446, Joystick5Button17 = 447, Joystick5Button18 = 448, Joystick5Button19 = 449, Joystick6Button0 = 450, Joystick6Button1 = 451, Joystick6Button2 = 452, Joystick6Button3 = 453, Joystick6Button4 = 454, Joystick6Button5 = 455, Joystick6Button6 = 456, Joystick6Button7 = 457, Joystick6Button8 = 458, Joystick6Button9 = 459, Joystick6Button10 = 460, Joystick6Button11 = 461, Joystick6Button12 = 462, Joystick6Button13 = 463, Joystick6Button14 = 464, Joystick6Button15 = 465, Joystick6Button16 = 466, Joystick6Button17 = 467, Joystick6Button18 = 468, Joystick6Button19 = 469, Joystick7Button0 = 470, Joystick7Button1 = 471, Joystick7Button2 = 472, Joystick7Button3 = 473, Joystick7Button4 = 474, Joystick7Button5 = 475, Joystick7Button6 = 476, Joystick7Button7 = 477, Joystick7Button8 = 478, Joystick7Button9 = 479, Joystick7Button10 = 480, Joystick7Button11 = 481, Joystick7Button12 = 482, Joystick7Button13 = 483, Joystick7Button14 = 484, Joystick7Button15 = 485, Joystick7Button16 = 486, Joystick7Button17 = 487, Joystick7Button18 = 488, Joystick7Button19 = 489, Joystick8Button0 = 490, Joystick8Button1 = 491, Joystick8Button2 = 492, Joystick8Button3 = 493, Joystick8Button4 = 494, Joystick8Button5 = 495, Joystick8Button6 = 496, Joystick8Button7 = 497, Joystick8Button8 = 498, Joystick8Button9 = 499, Joystick8Button10 = 500, Joystick8Button11 = 501, Joystick8Button12 = 502, Joystick8Button13 = 503, Joystick8Button14 = 504, Joystick8Button15 = 505, Joystick8Button16 = 506, Joystick8Button17 = 507, Joystick8Button18 = 508, Joystick8Button19 = 509 }
    /**
     * Interface for custom log handler implementation.
     */
    interface ILogHandler {
        /**
         * Logs a formatted message.
         * @param logType The type of the log message.
         * @param context Object to which the message applies.
         * @param format A composite format string.
         * @param args Format arguments.
         */
        LogFormat($logType: LogType, $context: Object, $format: string, ...args: any[]):void;
        /**
         * A variant of ILogHandler.LogFormat that logs an exception message.
         * @param exception Runtime Exception.
         * @param context Object to which the message applies.
         */
        LogException($exception: System.Exception, $context: Object):void;
        
                    
    }
    /**
     * Initializes a new instance of the Logger.
     */
    class Logger extends System.Object {
        /**
         * Set  Logger.ILogHandler.
         */
        public get logHandler(): ILogHandler;
        public set logHandler(value: ILogHandler);
        /**
         * To runtime toggle debug logging [ON/OFF].
         */
        public get logEnabled(): boolean;
        public set logEnabled(value: boolean);
        /**
         * To selective enable debug log message.
         */
        public get filterLogType(): LogType;
        public set filterLogType(value: LogType);
        /**
         * Create a custom Logger.
         * @param logHandler Pass in default log handler or custom log handler.
         */
        public constructor($logHandler: ILogHandler);
        /**
         * Check logging is enabled based on the LogType.
         * @param logType The type of the log message.
         * @returns Retrun true in case logs of LogType will be logged otherwise returns false.
         */
        public IsLogTypeAllowed($logType: LogType):boolean;
        /**
         * Logs message to the Unity Console using default logger.
         * @param logType The type of the log message.
         * @param tag Used to identify the source of a log message. It usually identifies the class where the log call occurs.
         * @param message String or object to be converted to string representation for display.
         * @param context Object to which the message applies.
         */
        public Log($logType: LogType, $message: any):void;
        /**
         * Logs message to the Unity Console using default logger.
         * @param logType The type of the log message.
         * @param tag Used to identify the source of a log message. It usually identifies the class where the log call occurs.
         * @param message String or object to be converted to string representation for display.
         * @param context Object to which the message applies.
         */
        public Log($logType: LogType, $message: any, $context: Object):void;
        /**
         * Logs message to the Unity Console using default logger.
         * @param logType The type of the log message.
         * @param tag Used to identify the source of a log message. It usually identifies the class where the log call occurs.
         * @param message String or object to be converted to string representation for display.
         * @param context Object to which the message applies.
         */
        public Log($logType: LogType, $tag: string, $message: any):void;
        /**
         * Logs message to the Unity Console using default logger.
         * @param logType The type of the log message.
         * @param tag Used to identify the source of a log message. It usually identifies the class where the log call occurs.
         * @param message String or object to be converted to string representation for display.
         * @param context Object to which the message applies.
         */
        public Log($logType: LogType, $tag: string, $message: any, $context: Object):void;
        /**
         * Logs message to the Unity Console using default logger.
         * @param logType The type of the log message.
         * @param tag Used to identify the source of a log message. It usually identifies the class where the log call occurs.
         * @param message String or object to be converted to string representation for display.
         * @param context Object to which the message applies.
         */
        public Log($message: any):void;
        /**
         * Logs message to the Unity Console using default logger.
         * @param logType The type of the log message.
         * @param tag Used to identify the source of a log message. It usually identifies the class where the log call occurs.
         * @param message String or object to be converted to string representation for display.
         * @param context Object to which the message applies.
         */
        public Log($tag: string, $message: any):void;
        /**
         * Logs message to the Unity Console using default logger.
         * @param logType The type of the log message.
         * @param tag Used to identify the source of a log message. It usually identifies the class where the log call occurs.
         * @param message String or object to be converted to string representation for display.
         * @param context Object to which the message applies.
         */
        public Log($tag: string, $message: any, $context: Object):void;
        /**
         * A variant of Logger.Log that logs an warning message.
         * @param tag Used to identify the source of a log message. It usually identifies the class where the log call occurs.
         * @param message String or object to be converted to string representation for display.
         * @param context Object to which the message applies.
         */
        public LogWarning($tag: string, $message: any):void;
        /**
         * A variant of Logger.Log that logs an warning message.
         * @param tag Used to identify the source of a log message. It usually identifies the class where the log call occurs.
         * @param message String or object to be converted to string representation for display.
         * @param context Object to which the message applies.
         */
        public LogWarning($tag: string, $message: any, $context: Object):void;
        /**
         * A variant of Logger.Log that logs an error message.
         * @param tag Used to identify the source of a log message. It usually identifies the class where the log call occurs.
         * @param message String or object to be converted to string representation for display.
         * @param context Object to which the message applies.
         */
        public LogError($tag: string, $message: any):void;
        /**
         * A variant of Logger.Log that logs an error message.
         * @param tag Used to identify the source of a log message. It usually identifies the class where the log call occurs.
         * @param message String or object to be converted to string representation for display.
         * @param context Object to which the message applies.
         */
        public LogError($tag: string, $message: any, $context: Object):void;
        /**
         * A variant of Logger.Log that logs an exception message.
         * @param exception Runtime Exception.
         * @param context Object to which the message applies.
         */
        public LogException($exception: System.Exception):void;
        /**
         * A variant of Logger.Log that logs an exception message.
         * @param exception Runtime Exception.
         * @param context Object to which the message applies.
         */
        public LogException($exception: System.Exception, $context: Object):void;
        /**
         * Logs a formatted message.
         * @param logType The type of the log message.
         * @param context Object to which the message applies.
         * @param format A composite format string.
         * @param args Format arguments.
         */
        public LogFormat($logType: LogType, $format: string, ...args: any[]):void;
        /**
         * Logs a formatted message.
         * @param logType The type of the log message.
         * @param context Object to which the message applies.
         * @param format A composite format string.
         * @param args Format arguments.
         */
        public LogFormat($logType: LogType, $context: Object, $format: string, ...args: any[]):void;
        
                    
    }
    /**
     * A collection of common color functions.
     */
    class ColorUtility extends System.Object {
        
        public constructor();
        /**
         * Attempts to convert a html color string.
         * @param htmlString Case insensitive html string to be converted into a color.
         * @param color The converted color.
         * @returns True if the string was successfully converted else false.
         */
        public static TryParseHtmlString($htmlString: string, $color: $Ref<Color>):boolean;
        /**
         * Returns the color as a hexadecimal string in the format "RRGGBB".
         * @param color The color to be converted.
         * @returns Hexadecimal string representing the color.
         */
        public static ToHtmlStringRGB($color: Color):string;
        /**
         * Returns the color as a hexadecimal string in the format "RRGGBBAA".
         * @param color The color to be converted.
         * @returns Hexadecimal string representing the color.
         */
        public static ToHtmlStringRGBA($color: Color):string;
        
                    
    }
    /**
     * Color key used by Gradient.
     */
    class GradientColorKey extends System.ValueType {
        /**
         * Color of key.
         */
        public color: Color;
        /**
         * Time of the key (0 - 1).
         */
        public time: number;
        /**
         * Gradient color key.
         * @param color Color of key.
         * @param time Time of the key (0 - 1).
         */
        public constructor($col: Color, $time: number);
        
        public get_Clone(): GradientColorKey;            
    }
    /**
     * Alpha key used by Gradient.
     */
    class GradientAlphaKey extends System.ValueType {
        /**
         * Alpha channel of key.
         */
        public alpha: number;
        /**
         * Time of the key (0 - 1).
         */
        public time: number;
        /**
         * Gradient alpha key.
         * @param alpha Alpha of key (0 - 1).
         * @param time Time of the key (0 - 1).
         */
        public constructor($alpha: number, $time: number);
        
        public get_Clone(): GradientAlphaKey;            
    }
    /**
     * Select how gradients will be evaluated.
     */
    enum GradientMode { Blend = 0, Fixed = 1 }
    /**
     * This struct contains the view space coordinates of the near projection plane.
     */
    class FrustumPlanes extends System.ValueType {
        /**
         * Position in view space of the left side of the near projection plane.
         */
        public left: number;
        /**
         * Position in view space of the right side of the near projection plane.
         */
        public right: number;
        /**
         * Position in view space of the bottom side of the near projection plane.
         */
        public bottom: number;
        /**
         * Position in view space of the top side of the near projection plane.
         */
        public top: number;
        /**
         * Z distance from the origin of view space to the near projection plane.
         */
        public zNear: number;
        /**
         * Z distance from the origin of view space to the far projection plane.
         */
        public zFar: number;
        
        public get_Clone(): FrustumPlanes;            
    }
    /**
     * Ping any given IP address (given in dot notation).
     */
    class Ping extends System.Object {
        /**
         * Has the ping function completed?
         */
        public get isDone(): boolean;
        /**
         * This property contains the ping time result after isDone returns true.
         */
        public get time(): number;
        /**
         * The IP target of the ping.
         */
        public get ip(): string;
        /**
         * Perform a ping to the supplied target IP address.
         */
        public constructor($address: string);
        
        public DestroyPing():void;
        
                    
    }
    /**
     * An exception thrown by the PlayerPrefs class in a  web player build.
     */
    class PlayerPrefsException extends System.Exception {
        
        public constructor($error: string);
        
                    
    }
    /**
     * `PlayerPrefs` is a class that stores Player preferences between game sessions. It can store string, float and integer values into the user’s platform registry.
     */
    class PlayerPrefs extends System.Object {
        
        public constructor();
        /**
         * Sets a single integer value for the preference identified by the given key. You can use PlayerPrefs.GetInt to retrieve this value.
         */
        public static SetInt($key: string, $value: number):void;
        /**
         * Returns the value corresponding to key in the preference file if it exists.
         */
        public static GetInt($key: string, $defaultValue: number):number;
        /**
         * Returns the value corresponding to key in the preference file if it exists.
         */
        public static GetInt($key: string):number;
        /**
         * Sets the float value of the preference identified by the given key. You can use PlayerPrefs.GetFloat to retrieve this value.
         */
        public static SetFloat($key: string, $value: number):void;
        /**
         * Returns the value corresponding to key in the preference file if it exists.
         */
        public static GetFloat($key: string, $defaultValue: number):number;
        /**
         * Returns the value corresponding to key in the preference file if it exists.
         */
        public static GetFloat($key: string):number;
        /**
         * Sets a single string value for the preference identified by the given key. You can use PlayerPrefs.GetString to retrieve this value.
         */
        public static SetString($key: string, $value: string):void;
        /**
         * Returns the value corresponding to key in the preference file if it exists.
         */
        public static GetString($key: string, $defaultValue: string):string;
        /**
         * Returns the value corresponding to key in the preference file if it exists.
         */
        public static GetString($key: string):string;
        /**
         * Returns true if the given key exists in PlayerPrefs, otherwise returns false.
         */
        public static HasKey($key: string):boolean;
        /**
         * Removes the given key from the PlayerPrefs. If the key does not exist, DeleteKey has no impact.
         */
        public static DeleteKey($key: string):void;
        /**
         * Removes all keys and values from the preferences. Use with caution.
         */
        public static DeleteAll():void;
        /**
         * Writes all modified preferences to disk.
         */
        public static Save():void;
        
                    
    }
    /**
     * Base class to derive custom property attributes from. Use this to create custom attributes for script variables.
     */
    class PropertyAttribute extends System.Attribute {
        /**
         * Optional field to specify the order that multiple DecorationDrawers should be drawn in.
         */
        public get order(): number;
        public set order(value: number);
        
                    
    }
    /**
     * Use this attribute to add a context menu to a field that calls a  named method.
     */
    class ContextMenuItemAttribute extends PropertyAttribute {
        /**
         * The name of the context menu item.
         */
        public name: string;
        /**
         * The name of the function that should be called.
         */
        public function: string;
        /**
         * Use this attribute to add a context menu to a field that calls a  named method.
         * @param name The name of the context menu item.
         * @param function The name of the function that should be called.
         */
        public constructor($name: string, $function: string);
        
                    
    }
    /**
     * Use this attribute on enum value declarations to change the display name shown in the Inspector.
     */
    class InspectorNameAttribute extends PropertyAttribute {
        /**
         * Name to display in the Inspector.
         */
        public displayName: string;
        /**
         * Specify a display name for an enum value.
         * @param displayName The name to display.
         */
        public constructor($displayName: string);
        
                    
    }
    /**
     * Specify a tooltip for a field in the Inspector window.
     */
    class TooltipAttribute extends PropertyAttribute {
        /**
         * The tooltip text.
         */
        public tooltip: string;
        /**
         * Specify a tooltip for a field.
         * @param tooltip The tooltip text.
         */
        public constructor($tooltip: string);
        
                    
    }
    /**
     * Use this PropertyAttribute to add some spacing in the Inspector.
     */
    class SpaceAttribute extends PropertyAttribute {
        /**
         * The spacing in pixels.
         */
        public height: number;
        
        public constructor();
        /**
         * Use this DecoratorDrawer to add some spacing in the Inspector.
         * @param height The spacing in pixels.
         */
        public constructor($height: number);
        
                    
    }
    /**
     * Use this PropertyAttribute to add a header above some fields in the Inspector.
     */
    class HeaderAttribute extends PropertyAttribute {
        /**
         * The header text.
         */
        public header: string;
        /**
         * Add a header above some fields in the Inspector.
         * @param header The header text.
         */
        public constructor($header: string);
        
                    
    }
    /**
     * Attribute used to make a float or int variable in a script be restricted to a specific range.
     */
    class RangeAttribute extends PropertyAttribute {
        
        public min: number;
        
        public max: number;
        /**
         * Attribute used to make a float or int variable in a script be restricted to a specific range.
         * @param min The minimum allowed value.
         * @param max The maximum allowed value.
         */
        public constructor($min: number, $max: number);
        
                    
    }
    /**
     * Attribute used to make a float or int variable in a script be restricted to a specific minimum value.
     */
    class MinAttribute extends PropertyAttribute {
        /**
         * The minimum allowed value.
         */
        public min: number;
        /**
         * Attribute used to make a float or int variable in a script be restricted to a specific minimum value.
         * @param min The minimum allowed value.
         */
        public constructor($min: number);
        
                    
    }
    /**
     * Attribute to make a string be edited with a multi-line textfield.
     */
    class MultilineAttribute extends PropertyAttribute {
        
        public lines: number;
        /**
         * Attribute used to make a string value be shown in a multiline textarea.
         * @param lines How many lines of text to make room for. Default is 3.
         */
        public constructor();
        /**
         * Attribute used to make a string value be shown in a multiline textarea.
         * @param lines How many lines of text to make room for. Default is 3.
         */
        public constructor($lines: number);
        
                    
    }
    /**
     * Attribute to make a string be edited with a height-flexible and scrollable text area.
     */
    class TextAreaAttribute extends PropertyAttribute {
        /**
         * The minimum amount of lines the text area will use.
         */
        public minLines: number;
        /**
         * The maximum amount of lines the text area can show before it starts using a scrollbar.
         */
        public maxLines: number;
        /**
         * Attribute to make a string be edited with a height-flexible and scrollable text area.
         * @param minLines The minimum amount of lines the text area will use.
         * @param maxLines The maximum amount of lines the text area can show before it starts using a scrollbar.
         */
        public constructor();
        /**
         * Attribute to make a string be edited with a height-flexible and scrollable text area.
         * @param minLines The minimum amount of lines the text area will use.
         * @param maxLines The maximum amount of lines the text area can show before it starts using a scrollbar.
         */
        public constructor($minLines: number, $maxLines: number);
        
                    
    }
    /**
     * Attribute used to configure the usage of the ColorField and Color Picker for a color.
     */
    class ColorUsageAttribute extends PropertyAttribute {
        /**
         * If false then the alpha bar is hidden in the ColorField and the alpha value is not shown in the Color Picker.
         */
        public showAlpha: boolean;
        /**
         * If set to true the Color is treated as a HDR color.
         */
        public hdr: boolean;
        /**
         * Attribute for Color fields. Used for configuring the GUI for the color.
         * @param showAlpha If false then the alpha channel info is hidden both in the ColorField and in the Color Picker.
         * @param hdr Set to true if the color should be treated as a HDR color (default value: false).
         * @param minBrightness Minimum allowed HDR color component value when using the HDR Color Picker (default value: 0).
         * @param maxBrightness Maximum allowed HDR color component value when using the HDR Color Picker (default value: 8).
         * @param minExposureValue Minimum exposure value allowed in the HDR Color Picker (default value: 1/8 = 0.125).
         * @param maxExposureValue Maximum exposure value allowed in the HDR Color Picker (default value: 3).
         */
        public constructor($showAlpha: boolean);
        /**
         * Attribute for Color fields. Used for configuring the GUI for the color.
         * @param showAlpha If false then the alpha channel info is hidden both in the ColorField and in the Color Picker.
         * @param hdr Set to true if the color should be treated as a HDR color (default value: false).
         * @param minBrightness Minimum allowed HDR color component value when using the HDR Color Picker (default value: 0).
         * @param maxBrightness Maximum allowed HDR color component value when using the HDR Color Picker (default value: 8).
         * @param minExposureValue Minimum exposure value allowed in the HDR Color Picker (default value: 1/8 = 0.125).
         * @param maxExposureValue Maximum exposure value allowed in the HDR Color Picker (default value: 3).
         */
        public constructor($showAlpha: boolean, $hdr: boolean);
        
                    
    }
    /**
     * Attribute used to configure the usage of the GradientField and Gradient Editor for a gradient.
     */
    class GradientUsageAttribute extends PropertyAttribute {
        /**
         * If set to true the Gradient uses HDR colors.
         */
        public hdr: boolean;
        /**
         * The color space the Gradient uses.
         */
        public colorSpace: ColorSpace;
        
        public constructor($hdr: boolean);
        /**
         * Attribute for gradient fields. Used to configure the GUI for the Gradient Editor.
         * @param hdr Set to true if the colors should be treated as HDR colors (default value: false).
         * @param colorSpace The colors should be treated as from this color space (default value: ColorSpace.Gamma).
         */
        public constructor($hdr: boolean, $colorSpace: ColorSpace);
        
                    
    }
    /**
     * Attribute used to make a float, int, or string variable in a script be delayed.
     */
    class DelayedAttribute extends PropertyAttribute {
        /**
         * Attribute used to make a float, int, or string variable in a script be delayed.
         */
        public constructor();
        
                    
    }
    /**
     * Disables reordering of an array or list in the Inspector window.
     */
    class NonReorderableAttribute extends PropertyAttribute {
        
        public constructor();
        
                    
    }
    /**
     * Derive from this base class to provide alternative implementations to the C# behavior of specific Resources methods.
     */
    class ResourcesAPI extends System.Object {
        /**
         * The specific ResourcesAPI instance to use to handle overridden Resources methods.
         */
        public static get overrideAPI(): ResourcesAPI;
        public static set overrideAPI(value: ResourcesAPI);
        
                    
    }
    /**
     * Prevents MonoBehaviour of same type (or subtype) to be added more than once to a GameObject.
     */
    class DisallowMultipleComponent extends System.Attribute {
        
        public constructor();
        
                    
    }
    /**
     * The RequireComponent attribute automatically adds required components as dependencies.
     */
    class RequireComponent extends System.Attribute {
        
        public m_Type0: System.Type;
        
        public m_Type1: System.Type;
        
        public m_Type2: System.Type;
        /**
         * Require a single component.
         */
        public constructor($requiredComponent: System.Type);
        /**
         * Require two components.
         */
        public constructor($requiredComponent: System.Type, $requiredComponent2: System.Type);
        /**
         * Require three components.
         */
        public constructor($requiredComponent: System.Type, $requiredComponent2: System.Type, $requiredComponent3: System.Type);
        
                    
    }
    /**
     * The AddComponentMenu attribute allows you to place a script anywhere in the "Component" menu, instead of just the "Component->Scripts" menu.
     */
    class AddComponentMenu extends System.Attribute {
        
        public get componentMenu(): string;
        /**
         * The order of the component in the component menu (lower is higher to the top).
         */
        public get componentOrder(): number;
        /**
         * Add an item in the Component menu.
         * @param menuName The path to the component.
         * @param order Where in the component menu to add the new item.
         */
        public constructor($menuName: string);
        /**
         * Add an item in the Component menu.
         * @param menuName The path to the component.
         * @param order Where in the component menu to add the new item.
         */
        public constructor($menuName: string, $order: number);
        
                    
    }
    /**
     * Mark a ScriptableObject-derived type to be automatically listed in the Assets/Create submenu, so that instances of the type can be easily created and stored in the project as ".asset" files.
     */
    class CreateAssetMenuAttribute extends System.Attribute {
        /**
         * The display name for this type shown in the Assets/Create menu.
         */
        public get menuName(): string;
        public set menuName(value: string);
        /**
         * The default file name used by newly created instances of this type.
         */
        public get fileName(): string;
        public set fileName(value: string);
        /**
         * The position of the menu item within the Assets/Create menu.
         */
        public get order(): number;
        public set order(value: number);
        
        public constructor();
        
                    
    }
    /**
     * The ContextMenu attribute allows you to add commands to the context menu.
     */
    class ContextMenu extends System.Attribute {
        
        public menuItem: string;
        
        public validate: boolean;
        
        public priority: number;
        /**
         * Adds the function to the context menu of the component.
         * @param itemName The name of the context menu item.
         * @param isValidateFunction Whether this is a validate function (defaults to false).
         * @param priority Priority used to override the ordering of the menu items (defaults to 1000000). The lower the number the earlier in the menu it will appear.
         */
        public constructor($itemName: string);
        /**
         * Adds the function to the context menu of the component.
         * @param itemName The name of the context menu item.
         * @param isValidateFunction Whether this is a validate function (defaults to false).
         * @param priority Priority used to override the ordering of the menu items (defaults to 1000000). The lower the number the earlier in the menu it will appear.
         */
        public constructor($itemName: string, $isValidateFunction: boolean);
        /**
         * Adds the function to the context menu of the component.
         * @param itemName The name of the context menu item.
         * @param isValidateFunction Whether this is a validate function (defaults to false).
         * @param priority Priority used to override the ordering of the menu items (defaults to 1000000). The lower the number the earlier in the menu it will appear.
         */
        public constructor($itemName: string, $isValidateFunction: boolean, $priority: number);
        
                    
    }
    /**
     * Makes all instances of a script execute in Edit Mode.
     */
    class ExecuteInEditMode extends System.Attribute {
        
        public constructor();
        
                    
    }
    /**
     * Makes instances of a script always execute, both as part of Play Mode and when editing.
     */
    class ExecuteAlways extends System.Attribute {
        
        public constructor();
        
                    
    }
    /**
     * Makes a variable not show up in the inspector but be serialized.
     */
    class HideInInspector extends System.Attribute {
        
        public constructor();
        
                    
    }
    /**
     * Provide a custom documentation URL for a class.
     */
    class HelpURLAttribute extends System.Attribute {
        /**
         * The documentation URL specified for this class.
         */
        public get URL(): string;
        /**
         * Initialize the HelpURL attribute with a documentation url.
         * @param url The custom documentation URL for this class.
         */
        public constructor($url: string);
        
                    
    }
    
    class DefaultExecutionOrder extends System.Attribute {
        
        public get order(): number;
        
        public constructor($order: number);
        
                    
    }
    /**
     * Assembly level attribute. Any classes in an assembly with this attribute will be considered to be Editor Classes.
     */
    class AssemblyIsEditorAssembly extends System.Attribute {
        /**
         * Constructor.
         */
        public constructor();
        
                    
    }
    /**
     * Add this attribute to a class to prevent creating a Preset from the instances of the class.
     */
    class ExcludeFromPresetAttribute extends System.Attribute {
        
        public constructor();
        
                    
    }
    /**
     * Add this attribute to a class to prevent the class and its inherited classes from being created with ObjectFactory methods.
     */
    class ExcludeFromObjectFactoryAttribute extends System.Attribute {
        /**
         * Default constructor.
         */
        public constructor();
        
                    
    }
    /**
     * Describes an integer range.
     */
    class RangeInt extends System.ValueType {
        /**
         * The starting index of the range, where 0 is the first position, 1 is the second, 2 is the third, and so on.
         */
        public start: number;
        /**
         * The length of the range.
         */
        public length: number;
        /**
         * The end index of the range (not inclusive).
         */
        public get end(): number;
        /**
         * Constructs a new RangeInt with given start, length values.
         * @param start The starting index of the range.
         * @param length The length of the range.
         */
        public constructor($start: number, $length: number);
        
        public get_Clone(): RangeInt;            
    }
    /**
     * Set RuntimeInitializeOnLoadMethod type.
     */
    enum RuntimeInitializeLoadType { AfterSceneLoad = 0, BeforeSceneLoad = 1, AfterAssembliesLoaded = 2, BeforeSplashScreen = 3, SubsystemRegistration = 4 }
    /**
     * Allow a runtime class method to be initialized when a game is loaded at runtime
     * without action from the user.
     */
    class RuntimeInitializeOnLoadMethodAttribute extends UnityEngine_Scripting.PreserveAttribute {
        /**
         * Set RuntimeInitializeOnLoadMethod type.
         */
        public get loadType(): RuntimeInitializeLoadType;
        /**
         * Creation of the runtime class used when Scenes are loaded.
         * @param loadType Determine whether methods are called before or after the
                Scene is loaded.
         */
        public constructor();
        /**
         * Creation of the runtime class used when Scenes are loaded.
         * @param loadType Determine whether methods are called before or after the
                Scene is loaded.
         */
        public constructor($loadType: RuntimeInitializeLoadType);
        
                    
    }
    /**
     * Add this attribute to a script class to mark its GameObject as a selection base object for Scene View picking.
     */
    class SelectionBaseAttribute extends System.Attribute {
        
        public constructor();
        
                    
    }
    
    class StackTraceUtility extends System.Object {
        
        public static ExtractStackTrace():string;
        
        public static ExtractStringFromException($exception: any):string;
        
                    
    }
    
    class UnityException extends System.SystemException {
        
        public constructor();
        
        public constructor($message: string);
        
        public constructor($message: string, $innerException: System.Exception);
        
                    
    }
    
    class MissingComponentException extends System.SystemException {
        
        public constructor();
        
        public constructor($message: string);
        
        public constructor($message: string, $innerException: System.Exception);
        
                    
    }
    
    class UnassignedReferenceException extends System.SystemException {
        
        public constructor();
        
        public constructor($message: string);
        
        public constructor($message: string, $innerException: System.Exception);
        
                    
    }
    
    class MissingReferenceException extends System.SystemException {
        
        public constructor();
        
        public constructor($message: string);
        
        public constructor($message: string, $innerException: System.Exception);
        
                    
    }
    /**
     * Text file assets.
     */
    class TextAsset extends Object {
        /**
         * The raw bytes of the text asset. (Read Only)
         */
        public get bytes(): number[];
        /**
         * The text contents of the .txt file as a string. (Read Only)
         */
        public get text(): string;
        
        public constructor();
        /**
         * Create a new TextAsset with the specified text contents.
         * This constructor creates a TextAsset, which is not the same as a plain text file. When saved to disk using the AssetDatabase class, the TextAsset should be saved with the .asset extension.
         * @param text The text contents for the TextAsset.
         */
        public constructor($text: string);
        /**
         * Returns the contents of the TextAsset.
         */
        public ToString():string;
        
                    
    }
    
    class TrackedReference extends System.Object {
        
        public static op_Equality($x: TrackedReference, $y: TrackedReference):boolean;
        
        public static op_Inequality($x: TrackedReference, $y: TrackedReference):boolean;
        
        public Equals($o: any):boolean;
        
        public GetHashCode():number;
        
        public static op_Implicit($exists: TrackedReference):boolean;
        
                    
    }
    /**
     * Declares an assembly to be compatible (API wise) with a specific Unity API. Used by internal tools to avoid processing the assembly in order to decide whether assemblies may be using old Unity API.
     */
    class UnityAPICompatibilityVersionAttribute extends System.Attribute {
        /**
         * Version of Unity API.
         */
        public get version(): string;
        /**
         * Initializes a new instance of UnityAPICompatibilityVersionAttribute.
         * @param version Unity version that this assembly is compatible with.
         * @param checkOnlyUnityVersion Must be set to true.
         */
        public constructor($version: string, $checkOnlyUnityVersion: boolean);
        /**
         * Initializes a new instance of UnityAPICompatibilityVersionAttribute. This constructor is used by internal tooling.
         * @param version Unity version that this assembly is compatible with.
         * @param configurationAssembliesHashes A comma-separated list comprised of the assembly name and attribute hash pairs. For example, assemblyname:hash,assemblyname:hash.
         */
        public constructor($version: string, $configurationAssembliesHashes: string[]);
        
                    
    }
    /**
     * Waits until the end of the frame after Unity has rendererd every Camera and GUI, just before displaying the frame on screen.
     */
    class WaitForEndOfFrame extends YieldInstruction {
        
        public constructor();
        
                    
    }
    /**
     * Waits until next fixed frame rate update function. See Also: MonoBehaviour.FixedUpdate.
     */
    class WaitForFixedUpdate extends YieldInstruction {
        
        public constructor();
        
                    
    }
    /**
     * Suspends the coroutine execution for the given amount of seconds using unscaled time.
     */
    class WaitForSecondsRealtime extends CustomYieldInstruction {
        /**
         * The given amount of seconds that the yield instruction will wait for.
         */
        public get waitTime(): number;
        public set waitTime(value: number);
        
        public get keepWaiting(): boolean;
        /**
         * Creates a yield instruction to wait for a given number of seconds using unscaled time.
         */
        public constructor($time: number);
        
                    
    }
    /**
     * Webplayer security related class. Not supported from 5.4.0 onwards.
     */
    class Security extends System.Object {
        
        public constructor();
        
                    
    }
    
    class Types extends System.Object {
        
                    
    }
    /**
     * Force Unity to serialize a private field.
     */
    class SerializeField extends System.Attribute {
        
        public constructor();
        
                    
    }
    /**
     * Instruct Unity to serialize a field as a reference.
     */
    class SerializeReference extends System.Attribute {
        
        public constructor();
        
                    
    }
    /**
     * Prefer ScriptableObject derived type to use binary serialization regardless of project's asset serialization mode.
     */
    class PreferBinarySerialization extends System.Attribute {
        
        public constructor();
        
                    
    }
    /**
     * Interface to receive callbacks upon serialization and deserialization.
     */
    interface ISerializationCallbackReceiver {
        /**
         * Implement this method to receive a callback before Unity serializes your object.
         */
        OnBeforeSerialize():void;
        /**
         * Implement this method to receive a callback after Unity deserializes your object.
         */
        OnAfterDeserialize():void;
        
                    
    }
    /**
     * ShaderVariantCollection records which shader variants are actually used in each shader.
     */
    class ShaderVariantCollection extends Object {
        /**
         * Number of shaders in this collection (Read Only).
         */
        public get shaderCount(): number;
        /**
         * Number of total varians in this collection (Read Only).
         */
        public get variantCount(): number;
        /**
         * Is this ShaderVariantCollection already warmed up? (Read Only)
         */
        public get isWarmedUp(): boolean;
        /**
         * Create a new empty shader variant collection.
         */
        public constructor();
        /**
         * Remove all shader variants from the collection.
         */
        public Clear():void;
        /**
         * Prewarms all shader variants in this shader variant collection.
         */
        public WarmUp():void;
        /**
         * Adds a new shader variant to the collection.
         * @param variant Shader variant to add.
         * @returns False if already in the collection.
         */
        public Add($variant: UnityEngine_ShaderVariantCollection.ShaderVariant):boolean;
        /**
         * Adds shader variant from the collection.
         * @param variant Shader variant to add.
         * @returns False if was not in the collection.
         */
        public Remove($variant: UnityEngine_ShaderVariantCollection.ShaderVariant):boolean;
        /**
         * Checks if a shader variant is in the collection.
         * @param variant Shader variant to check.
         * @returns True if the variant is in the collection.
         */
        public Contains($variant: UnityEngine_ShaderVariantCollection.ShaderVariant):boolean;
        
                    
    }
    /**
     * Compute Shader asset.
     */
    class ComputeShader extends Object {
        /**
         * Array of locally enabled shader keywords.
         */
        public get shaderKeywords(): string[];
        public set shaderKeywords(value: string[]);
        /**
         * Find ComputeShader kernel index.
         * @param name Name of kernel function.
         * @returns The Kernel index, or logs a "FindKernel failed" error message if the kernel is not found.
         */
        public FindKernel($name: string):number;
        /**
         * Checks whether a shader contains a given kernel.
         * @param name The name of the kernel to look for.
         * @returns True if the kernel is found, false otherwise.
         */
        public HasKernel($name: string):boolean;
        /**
         * Set a float parameter.
         * @param name Variable name in shader code.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param val Value to set.
         */
        public SetFloat($nameID: number, $val: number):void;
        /**
         * Set an integer parameter.
         * @param name Variable name in shader code.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param val Value to set.
         */
        public SetInt($nameID: number, $val: number):void;
        /**
         * Set a vector parameter.
         * @param name Variable name in shader code.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param val Value to set.
         */
        public SetVector($nameID: number, $val: Vector4):void;
        /**
         * Set a Matrix parameter.
         * @param name Variable name in shader code.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param val Value to set.
         */
        public SetMatrix($nameID: number, $val: Matrix4x4):void;
        /**
         * Set a vector array parameter.
         * @param name Variable name in shader code.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param values Value to set.
         */
        public SetVectorArray($nameID: number, $values: Vector4[]):void;
        /**
         * Set a Matrix array parameter.
         * @param name Variable name in shader code.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param values Value to set.
         */
        public SetMatrixArray($nameID: number, $values: Matrix4x4[]):void;
        /**
         * Set a texture parameter.
         * @param kernelIndex For which kernel the texture is being set. See FindKernel.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param name Name of the buffer variable in shader code.
         * @param texture Texture to set.
         * @param mipLevel Optional mipmap level of the read-write texture.
         * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
         */
        public SetTexture($kernelIndex: number, $nameID: number, $texture: Texture, $mipLevel: number):void;
        /**
         * Set a texture parameter from a global texture property.
         * @param kernelIndex For which kernel the texture is being set. See FindKernel.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param name Name of the buffer variable in shader code.
         * @param globalTextureName Global texture property to assign to shader.
         * @param globalTextureNameID Property name ID, use Shader.PropertyToID to get it.
         */
        public SetTextureFromGlobal($kernelIndex: number, $nameID: number, $globalTextureNameID: number):void;
        /**
         * Sets an input or output compute buffer.
         * @param kernelIndex For which kernel the buffer is being set. See FindKernel.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param name Name of the buffer variable in shader code.
         * @param buffer Buffer to set.
         */
        public SetBuffer($kernelIndex: number, $nameID: number, $buffer: ComputeBuffer):void;
        /**
         * Sets an input or output compute buffer.
         * @param kernelIndex For which kernel the buffer is being set. See FindKernel.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param name Name of the buffer variable in shader code.
         * @param buffer Buffer to set.
         */
        public SetBuffer($kernelIndex: number, $nameID: number, $buffer: GraphicsBuffer):void;
        /**
         * Get kernel thread group sizes.
         * @param kernelIndex Which kernel to query. A single compute shader asset can have multiple kernel entry points.
         * @param x Thread group size in the X dimension.
         * @param y Thread group size in the Y dimension.
         * @param z Thread group size in the Z dimension.
         */
        public GetKernelThreadGroupSizes($kernelIndex: number, $x: $Ref<number>, $y: $Ref<number>, $z: $Ref<number>):void;
        /**
         * Execute a compute shader.
         * @param kernelIndex Which kernel to execute. A single compute shader asset can have multiple kernel entry points.
         * @param threadGroupsX Number of work groups in the X dimension.
         * @param threadGroupsY Number of work groups in the Y dimension.
         * @param threadGroupsZ Number of work groups in the Z dimension.
         */
        public Dispatch($kernelIndex: number, $threadGroupsX: number, $threadGroupsY: number, $threadGroupsZ: number):void;
        /**
         * Sets a Shader keyword locally for this Compute Shader.
         */
        public EnableKeyword($keyword: string):void;
        /**
         * Disables a locally set Shader keyword.
         */
        public DisableKeyword($keyword: string):void;
        /**
         * Specifies whether the Shader keyword is enabled in this Compute Shader.
         */
        public IsKeywordEnabled($keyword: string):boolean;
        /**
         * Set a float parameter.
         * @param name Variable name in shader code.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param val Value to set.
         */
        public SetFloat($name: string, $val: number):void;
        /**
         * Set an integer parameter.
         * @param name Variable name in shader code.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param val Value to set.
         */
        public SetInt($name: string, $val: number):void;
        /**
         * Set a vector parameter.
         * @param name Variable name in shader code.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param val Value to set.
         */
        public SetVector($name: string, $val: Vector4):void;
        /**
         * Set a Matrix parameter.
         * @param name Variable name in shader code.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param val Value to set.
         */
        public SetMatrix($name: string, $val: Matrix4x4):void;
        /**
         * Set a vector array parameter.
         * @param name Variable name in shader code.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param values Value to set.
         */
        public SetVectorArray($name: string, $values: Vector4[]):void;
        /**
         * Set a Matrix array parameter.
         * @param name Variable name in shader code.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param values Value to set.
         */
        public SetMatrixArray($name: string, $values: Matrix4x4[]):void;
        /**
         * Set multiple consecutive float parameters at once.
         * @param name Array variable name in the shader code.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param values Value array to set.
         */
        public SetFloats($name: string, ...values: number[]):void;
        /**
         * Set multiple consecutive float parameters at once.
         * @param name Array variable name in the shader code.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param values Value array to set.
         */
        public SetFloats($nameID: number, ...values: number[]):void;
        /**
         * Set multiple consecutive integer parameters at once.
         * @param name Array variable name in the shader code.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param values Value array to set.
         */
        public SetInts($name: string, ...values: number[]):void;
        /**
         * Set multiple consecutive integer parameters at once.
         * @param name Array variable name in the shader code.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param values Value array to set.
         */
        public SetInts($nameID: number, ...values: number[]):void;
        /**
         * Set a bool parameter.
         * @param name Variable name in shader code.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param val Value to set.
         */
        public SetBool($name: string, $val: boolean):void;
        /**
         * Set a bool parameter.
         * @param name Variable name in shader code.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param val Value to set.
         */
        public SetBool($nameID: number, $val: boolean):void;
        /**
         * Set a texture parameter.
         * @param kernelIndex For which kernel the texture is being set. See FindKernel.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param name Name of the buffer variable in shader code.
         * @param texture Texture to set.
         * @param mipLevel Optional mipmap level of the read-write texture.
         * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
         */
        public SetTexture($kernelIndex: number, $nameID: number, $texture: Texture):void;
        /**
         * Set a texture parameter.
         * @param kernelIndex For which kernel the texture is being set. See FindKernel.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param name Name of the buffer variable in shader code.
         * @param texture Texture to set.
         * @param mipLevel Optional mipmap level of the read-write texture.
         * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
         */
        public SetTexture($kernelIndex: number, $name: string, $texture: Texture):void;
        /**
         * Set a texture parameter.
         * @param kernelIndex For which kernel the texture is being set. See FindKernel.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param name Name of the buffer variable in shader code.
         * @param texture Texture to set.
         * @param mipLevel Optional mipmap level of the read-write texture.
         * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
         */
        public SetTexture($kernelIndex: number, $name: string, $texture: Texture, $mipLevel: number):void;
        /**
         * Set a texture parameter.
         * @param kernelIndex For which kernel the texture is being set. See FindKernel.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param name Name of the buffer variable in shader code.
         * @param texture Texture to set.
         * @param mipLevel Optional mipmap level of the read-write texture.
         * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
         */
        public SetTexture($kernelIndex: number, $nameID: number, $texture: RenderTexture, $mipLevel: number, $element: UnityEngine_Rendering.RenderTextureSubElement):void;
        /**
         * Set a texture parameter.
         * @param kernelIndex For which kernel the texture is being set. See FindKernel.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param name Name of the buffer variable in shader code.
         * @param texture Texture to set.
         * @param mipLevel Optional mipmap level of the read-write texture.
         * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
         */
        public SetTexture($kernelIndex: number, $name: string, $texture: RenderTexture, $mipLevel: number, $element: UnityEngine_Rendering.RenderTextureSubElement):void;
        /**
         * Set a texture parameter from a global texture property.
         * @param kernelIndex For which kernel the texture is being set. See FindKernel.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param name Name of the buffer variable in shader code.
         * @param globalTextureName Global texture property to assign to shader.
         * @param globalTextureNameID Property name ID, use Shader.PropertyToID to get it.
         */
        public SetTextureFromGlobal($kernelIndex: number, $name: string, $globalTextureName: string):void;
        /**
         * Sets an input or output compute buffer.
         * @param kernelIndex For which kernel the buffer is being set. See FindKernel.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param name Name of the buffer variable in shader code.
         * @param buffer Buffer to set.
         */
        public SetBuffer($kernelIndex: number, $name: string, $buffer: ComputeBuffer):void;
        /**
         * Sets an input or output compute buffer.
         * @param kernelIndex For which kernel the buffer is being set. See FindKernel.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param name Name of the buffer variable in shader code.
         * @param buffer Buffer to set.
         */
        public SetBuffer($kernelIndex: number, $name: string, $buffer: GraphicsBuffer):void;
        /**
         * Sets a ComputeBuffer or a GraphicsBuffer as a named constant buffer for the ComputeShader.
         * @param nameID The ID of the property name for the constant buffer in shader code. Use Shader.PropertyToID to get this ID.
         * @param name The name of the buffer to bind as constant buffer.
         * @param buffer The buffer to bind as constant buffer.
         * @param offset The offset in bytes from the beginning of the ComputeBuffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
         * @param size The number of bytes to bind.
         */
        public SetConstantBuffer($nameID: number, $buffer: ComputeBuffer, $offset: number, $size: number):void;
        /**
         * Sets a ComputeBuffer or a GraphicsBuffer as a named constant buffer for the ComputeShader.
         * @param nameID The ID of the property name for the constant buffer in shader code. Use Shader.PropertyToID to get this ID.
         * @param name The name of the buffer to bind as constant buffer.
         * @param buffer The buffer to bind as constant buffer.
         * @param offset The offset in bytes from the beginning of the ComputeBuffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
         * @param size The number of bytes to bind.
         */
        public SetConstantBuffer($name: string, $buffer: ComputeBuffer, $offset: number, $size: number):void;
        /**
         * Sets a ComputeBuffer or a GraphicsBuffer as a named constant buffer for the ComputeShader.
         * @param nameID The ID of the property name for the constant buffer in shader code. Use Shader.PropertyToID to get this ID.
         * @param name The name of the buffer to bind as constant buffer.
         * @param buffer The buffer to bind as constant buffer.
         * @param offset The offset in bytes from the beginning of the ComputeBuffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
         * @param size The number of bytes to bind.
         */
        public SetConstantBuffer($nameID: number, $buffer: GraphicsBuffer, $offset: number, $size: number):void;
        /**
         * Sets a ComputeBuffer or a GraphicsBuffer as a named constant buffer for the ComputeShader.
         * @param nameID The ID of the property name for the constant buffer in shader code. Use Shader.PropertyToID to get this ID.
         * @param name The name of the buffer to bind as constant buffer.
         * @param buffer The buffer to bind as constant buffer.
         * @param offset The offset in bytes from the beginning of the ComputeBuffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
         * @param size The number of bytes to bind.
         */
        public SetConstantBuffer($name: string, $buffer: GraphicsBuffer, $offset: number, $size: number):void;
        /**
         * Execute a compute shader.
         * @param kernelIndex Which kernel to execute. A single compute shader asset can have multiple kernel entry points.
         * @param argsBuffer Buffer with dispatch arguments.
         * @param argsOffset The byte offset into the buffer, where the draw arguments start.
         */
        public DispatchIndirect($kernelIndex: number, $argsBuffer: ComputeBuffer, $argsOffset: number):void;
        
        public DispatchIndirect($kernelIndex: number, $argsBuffer: ComputeBuffer):void;
        /**
         * Execute a compute shader.
         * @param kernelIndex Which kernel to execute. A single compute shader asset can have multiple kernel entry points.
         * @param argsBuffer Buffer with dispatch arguments.
         * @param argsOffset The byte offset into the buffer, where the draw arguments start.
         */
        public DispatchIndirect($kernelIndex: number, $argsBuffer: GraphicsBuffer, $argsOffset: number):void;
        
        public DispatchIndirect($kernelIndex: number, $argsBuffer: GraphicsBuffer):void;
        
                    
    }
    /**
     * Defines the axes that can be snapped.
     */
    enum SnapAxis { None = 0, X = 1, Y = 2, Z = 4, All = 7 }
    /**
     * Snap values to rounded increments.
     */
    class Snapping extends System.Object {
        /**
         * Rounds value to the closest multiple of snap.
         * @param val The value to round.
         * @param snap The increment to round to.
         * @returns The rounded value.
         */
        public static Snap($val: number, $snap: number):number;
        /**
         * Rounds value to the closest multiple of snap.
         * @param val The value to round.
         * @param snap The increment to round to.
         * @returns The rounded value.
         */
        public static Snap($val: Vector2, $snap: Vector2):Vector2;
        /**
         * Rounds value to the closest multiple of snap.
         * @param val The value to round.
         * @param snap The increment to round to.
         * @param axis Restrict snapping to the components on these axes.
         * @returns The rounded value.
         */
        public static Snap($val: Vector3, $snap: Vector3, $axis?: SnapAxis):Vector3;
        
                    
    }
    /**
     * StaticBatchingUtility can prepare your objects to take advantage of Unity's static batching.
     */
    class StaticBatchingUtility extends System.Object {
        
        public constructor();
        /**
         * StaticBatchingUtility.Combine prepares all children of the staticBatchRoot for static batching.
         * @param staticBatchRoot The GameObject that should become the root of the combined batch.
         */
        public static Combine($staticBatchRoot: GameObject):void;
        /**
         * StaticBatchingUtility.Combine prepares all GameObjects contained in gos for static batching. staticBatchRoot is treated as their parent.
         * @param gos The GameObjects to prepare for static batching.
         * @param staticBatchRoot The GameObject that should become the root of the combined batch.
         */
        public static Combine($gos: GameObject[], $staticBatchRoot: GameObject):void;
        
                    
    }
    /**
     * Enumeration for SystemInfo.batteryStatus which represents the current status of the device's battery.
     */
    enum BatteryStatus { Unknown = 0, Charging = 1, Discharging = 2, NotCharging = 3, Full = 4 }
    /**
     * Enumeration for SystemInfo.operatingSystemFamily.
     */
    enum OperatingSystemFamily { Other = 0, MacOSX = 1, Windows = 2, Linux = 3 }
    /**
     * Enumeration for SystemInfo.deviceType, denotes a coarse grouping of kinds of devices.
     */
    enum DeviceType { Unknown = 0, Handheld = 1, Console = 2, Desktop = 3 }
    /**
     * Access system and hardware information.
     */
    class SystemInfo extends System.Object {
        /**
         * Value returned by SystemInfo string properties which are not supported on the current platform.
         */
        public static unsupportedIdentifier: string;
        /**
         * The current battery level (Read Only).
         */
        public static get batteryLevel(): number;
        /**
         * Returns the current status of the device's battery (Read Only).
         */
        public static get batteryStatus(): BatteryStatus;
        /**
         * Operating system name with version (Read Only).
         */
        public static get operatingSystem(): string;
        /**
         * Returns the operating system family the game is running on (Read Only).
         */
        public static get operatingSystemFamily(): OperatingSystemFamily;
        /**
         * Processor name (Read Only).
         */
        public static get processorType(): string;
        /**
         * Processor frequency in MHz (Read Only).
         */
        public static get processorFrequency(): number;
        /**
         * Number of processors present (Read Only).
         */
        public static get processorCount(): number;
        /**
         * Amount of system memory present (Read Only).
         */
        public static get systemMemorySize(): number;
        /**
         * A unique device identifier. It is guaranteed to be unique for every device (Read Only).
         */
        public static get deviceUniqueIdentifier(): string;
        /**
         * The user defined name of the device (Read Only).
         */
        public static get deviceName(): string;
        /**
         * The model of the device (Read Only).
         */
        public static get deviceModel(): string;
        /**
         * Is an accelerometer available on the device?
         */
        public static get supportsAccelerometer(): boolean;
        /**
         * Is a gyroscope available on the device?
         */
        public static get supportsGyroscope(): boolean;
        /**
         * Is the device capable of reporting its location?
         */
        public static get supportsLocationService(): boolean;
        /**
         * Is the device capable of providing the user haptic feedback by vibration?
         */
        public static get supportsVibration(): boolean;
        /**
         * Is there an Audio device available for playback? (Read Only)
         */
        public static get supportsAudio(): boolean;
        /**
         * Returns the kind of device the application is running on (Read Only).
         */
        public static get deviceType(): DeviceType;
        /**
         * Amount of video memory present (Read Only).
         */
        public static get graphicsMemorySize(): number;
        /**
         * The name of the graphics device (Read Only).
         */
        public static get graphicsDeviceName(): string;
        /**
         * The vendor of the graphics device (Read Only).
         */
        public static get graphicsDeviceVendor(): string;
        /**
         * The identifier code of the graphics device (Read Only).
         */
        public static get graphicsDeviceID(): number;
        /**
         * The identifier code of the graphics device vendor (Read Only).
         */
        public static get graphicsDeviceVendorID(): number;
        /**
         * The graphics API type used by the graphics device (Read Only).
         */
        public static get graphicsDeviceType(): UnityEngine_Rendering.GraphicsDeviceType;
        /**
         * Returns true if the texture UV coordinate convention for this platform has Y starting at the top of the image.
         */
        public static get graphicsUVStartsAtTop(): boolean;
        /**
         * The graphics API type and driver version used by the graphics device (Read Only).
         */
        public static get graphicsDeviceVersion(): string;
        /**
         * Graphics device shader capability level (Read Only).
         */
        public static get graphicsShaderLevel(): number;
        /**
         * Is graphics device using multi-threaded rendering (Read Only)?
         */
        public static get graphicsMultiThreaded(): boolean;
        /**
         * Application's actual rendering threading mode (Read Only).
         */
        public static get renderingThreadingMode(): UnityEngine_Rendering.RenderingThreadingMode;
        /**
         * True if the GPU supports hidden surface removal.
         */
        public static get hasHiddenSurfaceRemovalOnGPU(): boolean;
        /**
         * Returns true when the GPU has native support for indexing uniform arrays in fragment shaders without restrictions.
         */
        public static get hasDynamicUniformArrayIndexingInFragmentShaders(): boolean;
        /**
         * Are built-in shadows supported? (Read Only)
         */
        public static get supportsShadows(): boolean;
        /**
         * Is sampling raw depth from shadowmaps supported? (Read Only)
         */
        public static get supportsRawShadowDepthSampling(): boolean;
        /**
         * Whether motion vectors are supported on this platform.
         */
        public static get supportsMotionVectors(): boolean;
        /**
         * Are 3D (volume) textures supported? (Read Only)
         */
        public static get supports3DTextures(): boolean;
        /**
         * Are compressed formats for 3D (volume) textures supported? (Read Only).
         */
        public static get supportsCompressed3DTextures(): boolean;
        /**
         * Are 2D Array textures supported? (Read Only)
         */
        public static get supports2DArrayTextures(): boolean;
        /**
         * Are 3D (volume) RenderTextures supported? (Read Only)
         */
        public static get supports3DRenderTextures(): boolean;
        /**
         * Are Cubemap Array textures supported? (Read Only)
         */
        public static get supportsCubemapArrayTextures(): boolean;
        /**
         * Support for various Graphics.CopyTexture cases (Read Only).
         */
        public static get copyTextureSupport(): UnityEngine_Rendering.CopyTextureSupport;
        /**
         * Are compute shaders supported? (Read Only)
         */
        public static get supportsComputeShaders(): boolean;
        /**
         * Is conservative rasterization supported? (Read Only)
         */
        public static get supportsConservativeRaster(): boolean;
        /**
         * Boolean that indicates whether Multiview is supported (true if supported, false if not supported). (Read Only)
         */
        public static get supportsMultiview(): boolean;
        /**
         * Are geometry shaders supported? (Read Only)
         */
        public static get supportsGeometryShaders(): boolean;
        /**
         * Are tessellation shaders supported? (Read Only)
         */
        public static get supportsTessellationShaders(): boolean;
        /**
         * Boolean that indicates if SV_RenderTargetArrayIndex can be used in a vertex shader (true if it can be used, false if not).
         */
        public static get supportsRenderTargetArrayIndexFromVertexShader(): boolean;
        /**
         * Is GPU draw call instancing supported? (Read Only)
         */
        public static get supportsInstancing(): boolean;
        /**
         * Does the hardware support quad topology? (Read Only)
         */
        public static get supportsHardwareQuadTopology(): boolean;
        /**
         * Are 32-bit index buffers supported? (Read Only)
         */
        public static get supports32bitsIndexBuffer(): boolean;
        /**
         * Are sparse textures supported? (Read Only)
         */
        public static get supportsSparseTextures(): boolean;
        /**
         * How many simultaneous render targets (MRTs) are supported? (Read Only)
         */
        public static get supportedRenderTargetCount(): number;
        /**
         * Returns true when the platform supports different blend modes when rendering to multiple render targets, or false otherwise.
         */
        public static get supportsSeparatedRenderTargetsBlend(): boolean;
        /**
         * The maximum number of random write targets (UAV) that Unity supports simultaneously. (Read Only)
         */
        public static get supportedRandomWriteTargetCount(): number;
        /**
         * Are multisampled textures supported? (Read Only)
         */
        public static get supportsMultisampledTextures(): number;
        /**
         * Boolean that indicates whether multisampled texture arrays are supported (true if supported, false if not supported).
         */
        public static get supportsMultisampled2DArrayTextures(): boolean;
        /**
         * Returns true if multisampled textures are resolved automatically
         */
        public static get supportsMultisampleAutoResolve(): boolean;
        /**
         * Returns true if the 'Mirror Once' texture wrap mode is supported. (Read Only)
         */
        public static get supportsTextureWrapMirrorOnce(): number;
        /**
         * This property is true if the current platform uses a reversed depth buffer (where values range from 1 at the near plane and 0 at far plane), and false if the depth buffer is normal (0 is near, 1 is far). (Read Only)
         */
        public static get usesReversedZBuffer(): boolean;
        /**
         * What NPOT (non-power of two size) texture support does the GPU provide? (Read Only)
         */
        public static get npotSupport(): NPOTSupport;
        /**
         * Maximum texture size (Read Only).
         */
        public static get maxTextureSize(): number;
        /**
         * Maximum Cubemap texture size (Read Only).
         */
        public static get maxCubemapSize(): number;
        /**
         * Determines how many compute buffers Unity supports simultaneously in a vertex shader for reading. (Read Only)
         */
        public static get maxComputeBufferInputsVertex(): number;
        /**
         * Determines how many compute buffers Unity supports simultaneously in a fragment shader for reading. (Read Only)
         */
        public static get maxComputeBufferInputsFragment(): number;
        /**
         * Determines how many compute buffers Unity supports simultaneously in a geometry shader for reading. (Read Only)
         */
        public static get maxComputeBufferInputsGeometry(): number;
        /**
         * Determines how many compute buffers Unity supports simultaneously in a domain shader for reading. (Read Only)
         */
        public static get maxComputeBufferInputsDomain(): number;
        /**
         * Determines how many compute buffers Unity supports simultaneously in a hull shader for reading. (Read Only)
         */
        public static get maxComputeBufferInputsHull(): number;
        /**
         * Determines how many compute buffers Unity supports simultaneously in a compute shader for reading. (Read Only)
         */
        public static get maxComputeBufferInputsCompute(): number;
        /**
         * The largest total number of invocations in a single local work group that can be dispatched to a compute shader (Read Only).
         */
        public static get maxComputeWorkGroupSize(): number;
        /**
         * The maximum number of work groups that a compute shader can use in X dimension (Read Only).
         */
        public static get maxComputeWorkGroupSizeX(): number;
        /**
         * The maximum number of work groups that a compute shader can use in Y dimension (Read Only).
         */
        public static get maxComputeWorkGroupSizeY(): number;
        /**
         * The maximum number of work groups that a compute shader can use in Z dimension (Read Only).
         */
        public static get maxComputeWorkGroupSizeZ(): number;
        /**
         * Returns true when the platform supports asynchronous compute queues and false if otherwise.
         */
        public static get supportsAsyncCompute(): boolean;
        /**
         * Specifies whether the current platform supports the GPU Recorder or not. (Read Only).
         */
        public static get supportsGpuRecorder(): boolean;
        /**
         * Returns true when the platform supports GraphicsFences, and false if otherwise.
         */
        public static get supportsGraphicsFence(): boolean;
        /**
         * Returns true if asynchronous readback of GPU data is available for this device and false otherwise.
         */
        public static get supportsAsyncGPUReadback(): boolean;
        /**
         * Checks if ray tracing is supported by the current configuration.
         */
        public static get supportsRayTracing(): boolean;
        /**
         * Does the current renderer support binding constant buffers directly? (Read Only)
         */
        public static get supportsSetConstantBuffer(): boolean;
        /**
         * Minimum buffer offset (in bytes) when binding a constant buffer using Shader.SetConstantBuffer or Material.SetConstantBuffer.
         */
        public static get constantBufferOffsetAlignment(): number;
        /**
         * Returns true if the GPU supports partial mipmap chains (Read Only).
         */
        public static get hasMipMaxLevel(): boolean;
        /**
         * Is streaming of texture mip maps supported? (Read Only)
         */
        public static get supportsMipStreaming(): boolean;
        /**
         * True if the Graphics API takes RenderBufferLoadAction and RenderBufferStoreAction into account, false if otherwise.
         */
        public static get usesLoadStoreActions(): boolean;
        /**
         * Returns a bitwise combination of HDRDisplaySupportFlags describing the support for HDR displays on the system.
         */
        public static get hdrDisplaySupportFlags(): HDRDisplaySupportFlags;
        /**
         * This property is true if the graphics API of the target build platform takes RenderBufferStoreAction.StoreAndResolve into account, false if otherwise.
         */
        public static get supportsStoreAndResolveAction(): boolean;
        
        public constructor();
        /**
         * Is render texture format supported?
         * @param format The format to look up.
         * @returns True if the format is supported.
         */
        public static SupportsRenderTextureFormat($format: RenderTextureFormat):boolean;
        /**
         * Is blending supported on render texture format?
         * @param format The format to look up.
         * @returns True if blending is supported on the given format.
         */
        public static SupportsBlendingOnRenderTextureFormat($format: RenderTextureFormat):boolean;
        /**
         * Is texture format supported on this device?
         * @param format The TextureFormat format to look up.
         * @returns True if the format is supported.
         */
        public static SupportsTextureFormat($format: TextureFormat):boolean;
        /**
         * Indicates whether the given combination of a vertex attribute format and dimension is supported on this device.
         * @param format The VertexAttributeFormat format to look up.
         * @param dimension The dimension of vertex data to check for.
         * @returns True if the format with the given dimension is supported.
         */
        public static SupportsVertexAttributeFormat($format: UnityEngine_Rendering.VertexAttributeFormat, $dimension: number):boolean;
        
        public static IsFormatSupported($format: UnityEngine_Experimental_Rendering.GraphicsFormat, $usage: UnityEngine_Experimental_Rendering.FormatUsage):boolean;
        
        public static GetCompatibleFormat($format: UnityEngine_Experimental_Rendering.GraphicsFormat, $usage: UnityEngine_Experimental_Rendering.FormatUsage):UnityEngine_Experimental_Rendering.GraphicsFormat;
        /**
         * Returns the platform-specific GraphicsFormat that is associated with the DefaultFormat.
         * @param format The DefaultFormat format to look up.
         */
        public static GetGraphicsFormat($format: UnityEngine_Experimental_Rendering.DefaultFormat):UnityEngine_Experimental_Rendering.GraphicsFormat;
        /**
         * Checks if the target platform supports the MSAA samples count in the RenderTextureDescriptor argument.
         * @param desc The RenderTextureDescriptor to check.
         * @returns If the target platform supports the given MSAA samples count of RenderTextureDescriptor, returns the given MSAA samples count. Otherwise returns a lower fallback MSAA samples count value that the target platform supports.
         */
        public static GetRenderTextureSupportedMSAASampleCount($desc: RenderTextureDescriptor):number;
        
                    
    }
    /**
     * Interface for on-screen keyboards. Only native iPhone, Android, and Windows Store Apps are supported.
     */
    class TouchScreenKeyboard extends System.Object {
        /**
         * Is touch screen keyboard supported.
         */
        public static get isSupported(): boolean;
        /**
         * Checks if the text within an input field can be selected and modified while TouchScreenKeyboard is open.
         * @returns Returns true when you are able to select and modify the input field, returns false otherwise.
         */
        public static get isInPlaceEditingAllowed(): boolean;
        /**
         * Returns the text displayed by the input field of the keyboard.
         */
        public get text(): string;
        public set text(value: string);
        /**
         * Will text input field above the keyboard be hidden when the keyboard is on screen?
         */
        public static get hideInput(): boolean;
        public static set hideInput(value: boolean);
        /**
         * Is the keyboard visible or sliding into the position on the screen?
         */
        public get active(): boolean;
        public set active(value: boolean);
        /**
         * Returns the status of the on-screen keyboard. (Read Only)
         */
        public get status(): UnityEngine_TouchScreenKeyboard.Status;
        /**
         * How many characters the keyboard input field is limited to. 0 = infinite.
         */
        public get characterLimit(): number;
        public set characterLimit(value: number);
        /**
         * Specifies whether the TouchScreenKeyboard supports the selection property. (Read Only)
         */
        public get canGetSelection(): boolean;
        /**
         * Specifies whether the TouchScreenKeyboard supports the selection property. (Read Only)
         */
        public get canSetSelection(): boolean;
        /**
         * Gets or sets the character range of the selected text within the string currently being edited.
         */
        public get selection(): RangeInt;
        public set selection(value: RangeInt);
        /**
         * Returns the TouchScreenKeyboardType of the keyboard.
         */
        public get type(): TouchScreenKeyboardType;
        /**
         * Specified on which display the on-screen keyboard will appear.
         */
        public get targetDisplay(): number;
        public set targetDisplay(value: number);
        /**
         * Returns portion of the screen which is covered by the keyboard.
         */
        public static get area(): Rect;
        /**
         * Returns true whenever any keyboard is visible on the screen.
         */
        public static get visible(): boolean;
        
        public constructor($text: string, $keyboardType: TouchScreenKeyboardType, $autocorrection: boolean, $multiline: boolean, $secure: boolean, $alert: boolean, $textPlaceholder: string, $characterLimit: number);
        /**
         * Opens the native keyboard provided by OS on the screen.
         * @param text Text to edit.
         * @param keyboardType Type of keyboard (eg, any text, numbers only, etc).
         * @param autocorrection Is autocorrection applied?
         * @param multiline Can more than one line of text be entered?
         * @param secure Is the text masked (for passwords, etc)?
         * @param alert Is the keyboard opened in alert mode?
         * @param textPlaceholder Text to be used if no other text is present.
         * @param characterLimit How many characters the keyboard input field is limited to. 0 = infinite. (Android and iOS only)
         */
        public static Open($text: string, $keyboardType: TouchScreenKeyboardType, $autocorrection: boolean, $multiline: boolean, $secure: boolean, $alert: boolean, $textPlaceholder: string, $characterLimit: number):TouchScreenKeyboard;
        /**
         * Opens the native keyboard provided by OS on the screen.
         * @param text Text to edit.
         * @param keyboardType Type of keyboard (eg, any text, numbers only, etc).
         * @param autocorrection Is autocorrection applied?
         * @param multiline Can more than one line of text be entered?
         * @param secure Is the text masked (for passwords, etc)?
         * @param alert Is the keyboard opened in alert mode?
         * @param textPlaceholder Text to be used if no other text is present.
         * @param characterLimit How many characters the keyboard input field is limited to. 0 = infinite. (Android and iOS only)
         */
        public static Open($text: string, $keyboardType: TouchScreenKeyboardType, $autocorrection: boolean, $multiline: boolean, $secure: boolean, $alert: boolean, $textPlaceholder: string):TouchScreenKeyboard;
        /**
         * Opens the native keyboard provided by OS on the screen.
         * @param text Text to edit.
         * @param keyboardType Type of keyboard (eg, any text, numbers only, etc).
         * @param autocorrection Is autocorrection applied?
         * @param multiline Can more than one line of text be entered?
         * @param secure Is the text masked (for passwords, etc)?
         * @param alert Is the keyboard opened in alert mode?
         * @param textPlaceholder Text to be used if no other text is present.
         * @param characterLimit How many characters the keyboard input field is limited to. 0 = infinite. (Android and iOS only)
         */
        public static Open($text: string, $keyboardType: TouchScreenKeyboardType, $autocorrection: boolean, $multiline: boolean, $secure: boolean, $alert: boolean):TouchScreenKeyboard;
        /**
         * Opens the native keyboard provided by OS on the screen.
         * @param text Text to edit.
         * @param keyboardType Type of keyboard (eg, any text, numbers only, etc).
         * @param autocorrection Is autocorrection applied?
         * @param multiline Can more than one line of text be entered?
         * @param secure Is the text masked (for passwords, etc)?
         * @param alert Is the keyboard opened in alert mode?
         * @param textPlaceholder Text to be used if no other text is present.
         * @param characterLimit How many characters the keyboard input field is limited to. 0 = infinite. (Android and iOS only)
         */
        public static Open($text: string, $keyboardType: TouchScreenKeyboardType, $autocorrection: boolean, $multiline: boolean, $secure: boolean):TouchScreenKeyboard;
        /**
         * Opens the native keyboard provided by OS on the screen.
         * @param text Text to edit.
         * @param keyboardType Type of keyboard (eg, any text, numbers only, etc).
         * @param autocorrection Is autocorrection applied?
         * @param multiline Can more than one line of text be entered?
         * @param secure Is the text masked (for passwords, etc)?
         * @param alert Is the keyboard opened in alert mode?
         * @param textPlaceholder Text to be used if no other text is present.
         * @param characterLimit How many characters the keyboard input field is limited to. 0 = infinite. (Android and iOS only)
         */
        public static Open($text: string, $keyboardType: TouchScreenKeyboardType, $autocorrection: boolean, $multiline: boolean):TouchScreenKeyboard;
        /**
         * Opens the native keyboard provided by OS on the screen.
         * @param text Text to edit.
         * @param keyboardType Type of keyboard (eg, any text, numbers only, etc).
         * @param autocorrection Is autocorrection applied?
         * @param multiline Can more than one line of text be entered?
         * @param secure Is the text masked (for passwords, etc)?
         * @param alert Is the keyboard opened in alert mode?
         * @param textPlaceholder Text to be used if no other text is present.
         * @param characterLimit How many characters the keyboard input field is limited to. 0 = infinite. (Android and iOS only)
         */
        public static Open($text: string, $keyboardType: TouchScreenKeyboardType, $autocorrection: boolean):TouchScreenKeyboard;
        /**
         * Opens the native keyboard provided by OS on the screen.
         * @param text Text to edit.
         * @param keyboardType Type of keyboard (eg, any text, numbers only, etc).
         * @param autocorrection Is autocorrection applied?
         * @param multiline Can more than one line of text be entered?
         * @param secure Is the text masked (for passwords, etc)?
         * @param alert Is the keyboard opened in alert mode?
         * @param textPlaceholder Text to be used if no other text is present.
         * @param characterLimit How many characters the keyboard input field is limited to. 0 = infinite. (Android and iOS only)
         */
        public static Open($text: string, $keyboardType: TouchScreenKeyboardType):TouchScreenKeyboard;
        /**
         * Opens the native keyboard provided by OS on the screen.
         * @param text Text to edit.
         * @param keyboardType Type of keyboard (eg, any text, numbers only, etc).
         * @param autocorrection Is autocorrection applied?
         * @param multiline Can more than one line of text be entered?
         * @param secure Is the text masked (for passwords, etc)?
         * @param alert Is the keyboard opened in alert mode?
         * @param textPlaceholder Text to be used if no other text is present.
         * @param characterLimit How many characters the keyboard input field is limited to. 0 = infinite. (Android and iOS only)
         */
        public static Open($text: string):TouchScreenKeyboard;
        
                    
    }
    /**
     * Enumeration of the different types of supported touchscreen keyboards.
     */
    enum TouchScreenKeyboardType { Default = 0, ASCIICapable = 1, NumbersAndPunctuation = 2, URL = 3, NumberPad = 4, PhonePad = 5, NamePhonePad = 6, EmailAddress = 7, NintendoNetworkAccount = 8, Social = 9, Search = 10, DecimalPad = 11, OneTimeCode = 12 }
    
    class UnityEventQueueSystem extends System.Object {
        
        public constructor();
        
        public static GenerateEventIdForPayload($eventPayloadName: string):string;
        
        public static GetGlobalEventQueue():System.IntPtr;
        
                    
    }
    /**
     * Representation of a Position, and a Rotation in 3D Space
     */
    class Pose extends System.ValueType {
        /**
         * The position component of the pose.
         */
        public position: Vector3;
        /**
         * The rotation component of the pose.
         */
        public rotation: Quaternion;
        /**
         * Returns the forward vector of the pose.
         */
        public get forward(): Vector3;
        /**
         * Returns the right vector of the pose.
         */
        public get right(): Vector3;
        /**
         * Returns the up vector of the pose.
         */
        public get up(): Vector3;
        /**
         * Shorthand for pose which represents zero position, and an identity rotation.
         */
        public static get identity(): Pose;
        
        public constructor($position: Vector3, $rotation: Quaternion);
        
        public ToString():string;
        
        public ToString($format: string):string;
        /**
         * Transforms the current pose into the local space of the provided pose.
         */
        public GetTransformedBy($lhs: Pose):Pose;
        /**
         * Transforms the current pose into the local space of the provided pose.
         */
        public GetTransformedBy($lhs: Transform):Pose;
        
        public Equals($obj: any):boolean;
        
        public Equals($other: Pose):boolean;
        
        public GetHashCode():number;
        
        public static op_Equality($a: Pose, $b: Pose):boolean;
        
        public static op_Inequality($a: Pose, $b: Pose):boolean;
        
        public get_Clone(): Pose;            
    }
    
    class iPhoneSettings extends System.Object {
        
        public constructor();
        
                    
    }
    
    enum iPhoneScreenOrientation { Unknown = 0, Portrait = 1, PortraitUpsideDown = 2, LandscapeLeft = 3, LandscapeRight = 4, AutoRotation = 5, Landscape = 6 }
    
    enum iPhoneNetworkReachability { NotReachable = 0, ReachableViaCarrierDataNetwork = 1, ReachableViaWiFiNetwork = 2 }
    
    enum iPhoneGeneration { Unknown = 0, iPhone = 1, iPhone3G = 2, iPhone3GS = 3, iPodTouch1Gen = 4, iPodTouch2Gen = 5, iPodTouch3Gen = 6, iPad1Gen = 7, iPhone4 = 8, iPodTouch4Gen = 9, iPad2Gen = 10, iPhone4S = 11, iPad3Gen = 12, iPhone5 = 13, iPodTouch5Gen = 14, iPadMini1Gen = 15, iPad4Gen = 16, iPhone5C = 17, iPhone5S = 18, iPhoneUnknown = 19, iPadUnknown = 20, iPodTouchUnknown = 21 }
    
    class iPhoneUtils extends System.Object {
        
        public constructor();
        
                    
    }
    
    enum iPhoneMovieControlMode { Full = 0, Minimal = 1, CancelOnTouch = 2, Hidden = 3, VolumeOnly = 4 }
    
    enum iPhoneMovieScalingMode { None = 0, AspectFit = 1, AspectFill = 2, Fill = 3 }
    
    interface ADBannerView extends System.Object {
        
                    
    }
    
    interface ADInterstitialAd extends System.Object {
        
                    
    }
    /**
     * An enumeration of transform properties that can be driven on a RectTransform by an object.
     */
    enum DrivenTransformProperties { None = 0, All = -1, AnchoredPositionX = 2, AnchoredPositionY = 4, AnchoredPositionZ = 8, Rotation = 16, ScaleX = 32, ScaleY = 64, ScaleZ = 128, AnchorMinX = 256, AnchorMinY = 512, AnchorMaxX = 1024, AnchorMaxY = 2048, SizeDeltaX = 4096, SizeDeltaY = 8192, PivotX = 16384, PivotY = 32768, AnchoredPosition = 6, AnchoredPosition3D = 14, Scale = 224, AnchorMin = 768, AnchorMax = 3072, Anchors = 3840, SizeDelta = 12288, Pivot = 49152 }
    /**
     * A component can be designed to drive a RectTransform. The DrivenRectTransformTracker struct is used to specify which RectTransforms it is driving.
     */
    class DrivenRectTransformTracker extends System.ValueType {
        /**
         * Stop recording undo actions from driven RectTransforms.
         */
        public static StopRecordingUndo():void;
        /**
         * Resume recording undo of driven RectTransforms.
         */
        public static StartRecordingUndo():void;
        /**
         * Add a RectTransform to be driven.
         * @param driver The object to drive properties.
         * @param rectTransform The RectTransform to be driven.
         * @param drivenProperties The properties to be driven.
         */
        public Add($driver: Object, $rectTransform: RectTransform, $drivenProperties: DrivenTransformProperties):void;
        /**
         * Clear the list of RectTransforms being driven.
         */
        public Clear():void;
        
                    
    }
    /**
     * SpriteRenderer draw mode.
     */
    enum SpriteDrawMode { Simple = 0, Sliced = 1, Tiled = 2 }
    /**
     * Tiling mode for SpriteRenderer.tileMode.
     */
    enum SpriteTileMode { Continuous = 0, Adaptive = 1 }
    /**
     * This enum controls the mode under which the sprite will interact with the masking system.
     */
    enum SpriteMaskInteraction { None = 0, VisibleInsideMask = 1, VisibleOutsideMask = 2 }
    /**
     * Renders a Sprite for 2D graphics.
     */
    class SpriteRenderer extends Renderer {
        /**
         * The Sprite to render.
         */
        public get sprite(): Sprite;
        public set sprite(value: Sprite);
        /**
         * The current draw mode of the Sprite Renderer.
         */
        public get drawMode(): SpriteDrawMode;
        public set drawMode(value: SpriteDrawMode);
        /**
         * Property to set/get the size to render when the SpriteRenderer.drawMode is set to SpriteDrawMode.Sliced.
         */
        public get size(): Vector2;
        public set size(value: Vector2);
        /**
         * The current threshold for Sprite Renderer tiling.
         */
        public get adaptiveModeThreshold(): number;
        public set adaptiveModeThreshold(value: number);
        /**
         * The current tile mode of the Sprite Renderer.
         */
        public get tileMode(): SpriteTileMode;
        public set tileMode(value: SpriteTileMode);
        /**
         * Rendering color for the Sprite graphic.
         */
        public get color(): Color;
        public set color(value: Color);
        /**
         * Specifies how the sprite interacts with the masks.
         */
        public get maskInteraction(): SpriteMaskInteraction;
        public set maskInteraction(value: SpriteMaskInteraction);
        /**
         * Flips the sprite on the X axis.
         */
        public get flipX(): boolean;
        public set flipX(value: boolean);
        /**
         * Flips the sprite on the Y axis.
         */
        public get flipY(): boolean;
        public set flipY(value: boolean);
        /**
         * Determines the position of the Sprite used for sorting the SpriteRenderer.
         */
        public get spriteSortPoint(): SpriteSortPoint;
        public set spriteSortPoint(value: SpriteSortPoint);
        
        public constructor();
        
                    
    }
    /**
     * Determines the position of the Sprite used for sorting the Renderer.
     */
    enum SpriteSortPoint { Center = 0, Pivot = 1 }
    /**
     * How a Sprite's graphic rectangle is aligned with its pivot point.
     */
    enum SpriteAlignment { Center = 0, TopLeft = 1, TopCenter = 2, TopRight = 3, LeftCenter = 4, RightCenter = 5, BottomLeft = 6, BottomCenter = 7, BottomRight = 8, Custom = 9 }
    /**
     * Encapsulates a Texture2D and its shader property name to give Sprite-based renderers access to a secondary texture, in addition to the main Sprite texture.
     */
    class SecondarySpriteTexture extends System.ValueType {
        /**
         * The shader property name of the secondary Sprite texture. Use this name to identify and sample the texture in the shader.
         */
        public name: string;
        /**
         * The texture to be used as a secondary Sprite texture.
         */
        public texture: Texture2D;
        
                    
    }
    
    interface Renderer {
        /**
         * Schedules an update of the albedo and emissive Textures of a system that contains the Renderer.
         * @extension UnityEngine.RendererExtensions
         */
        UpdateGIMaterials():void;
        
                    
    }
    
    interface Sprite {
        /**
         * Retrieves a strided accessor to the internal vertex attributes.
         * @returns A read-only list of.
         * @extension UnityEngine.U2D.SpriteDataAccessExtensions
         */
        GetVertexAttribute<T>($channel: UnityEngine_Rendering.VertexAttribute):Unity_Collections.NativeSlice$1<T>;
        /** @extension UnityEngine.U2D.SpriteDataAccessExtensions */
        SetVertexAttribute<T>($channel: UnityEngine_Rendering.VertexAttribute, $src: Unity_Collections.NativeArray$1<T>):void;
        /**
         * Returns an array of BindPoses.
         * @param sprite The sprite to retrieve the bind pose from.
         * @returns A list of bind poses for this sprite. There is no need to dispose the returned NativeArray.
         * @extension UnityEngine.U2D.SpriteDataAccessExtensions
         */
        GetBindPoses():Unity_Collections.NativeArray$1<UnityEngine.Matrix4x4>;
        /** @extension UnityEngine.U2D.SpriteDataAccessExtensions */
        SetBindPoses($src: Unity_Collections.NativeArray$1<UnityEngine.Matrix4x4>):void;
        /**
         * Returns a list of indices. This is the same as Sprite.triangle.
         * @returns A read-only list of indices indicating how the triangles are formed between the vertices. The array is marked as undisposable.
         * @extension UnityEngine.U2D.SpriteDataAccessExtensions
         */
        GetIndices():Unity_Collections.NativeArray$1<number>;
        /** @extension UnityEngine.U2D.SpriteDataAccessExtensions */
        SetIndices($src: Unity_Collections.NativeArray$1<number>):void;
        /**
         * Returns a list of SpriteBone in this Sprite.
         * @param sprite The sprite to get the list of SpriteBone from.
         * @returns An array of SpriteBone that belongs to this Sprite.
         * @extension UnityEngine.U2D.SpriteDataAccessExtensions
         */
        GetBones():SpriteBone[];
        /**
         * Sets the SpriteBones for this Sprite.
         * @extension UnityEngine.U2D.SpriteDataAccessExtensions
         */
        SetBones($src: SpriteBone[]):void;
        /**
         * Checks if a specific channel exists for this Sprite.
         * @returns True if the channel exists.
         * @extension UnityEngine.U2D.SpriteDataAccessExtensions
         */
        HasVertexAttribute($channel: UnityEngine_Rendering.VertexAttribute):boolean;
        /**
         * Sets the vertex count. This resizes the internal buffer. It also preserves any configurations of VertexAttributes.
         * @extension UnityEngine.U2D.SpriteDataAccessExtensions
         */
        SetVertexCount($count: number):void;
        /**
         * Returns the number of vertices in this Sprite.
         * @extension UnityEngine.U2D.SpriteDataAccessExtensions
         */
        GetVertexCount():number;
        
                    
    }
    
    interface SpriteRenderer {
        /**
         * Stop using the deformable buffer to render the Sprite and use the original mesh instead.
         * @extension UnityEngine.U2D.SpriteRendererDataAccessExtensions
         */
        DeactivateDeformableBuffer():void;
        
                    
    }
    
}
declare module 'System' {

    import * as System_Reflection from 'System.Reflection';
        
    
    interface Object {
        
                    
    }
    
    interface Int32 extends ValueType {
        
                    
    }
    
    interface ValueType extends Object {
        
                    
    }
    
    interface Boolean extends ValueType {
        
                    
    }
    
    interface String extends Object {
        
                    
    }
    
    interface Void extends ValueType {
        
                    
    }
    
    interface Single extends ValueType {
        
                    
    }
    
    interface Type extends System_Reflection.MemberInfo {
        
                    
    }
    
    interface Enum extends ValueType {
        
                    
    }
    
    interface Array extends Object {
        
                    
    }
    
    interface UInt64 extends ValueType {
        
                    
    }
    
    type MulticastDelegate = (...args:any[]) => any;
    var MulticastDelegate: {new (func: (...args:any[]) => any): MulticastDelegate;}
    
    interface Delegate extends Object {
        
                    
    }
    
    interface IFormatProvider {
        
                    
    }
    
    interface UInt16 extends ValueType {
        
                    
    }
    
    interface Double extends ValueType {
        
                    
    }
    
    interface IntPtr extends ValueType {
        
                    
    }
    
    interface UInt32 extends ValueType {
        
                    
    }
    
    interface Exception extends Object {
        
                    
    }
    
    type Func$1<TResult> = () => TResult;
    
    interface Attribute extends Object {
        
                    
    }
    
    interface Byte extends ValueType {
        
                    
    }
    
    interface Int64 extends ValueType {
        
                    
    }
    
    type Action$1<T> = (obj: T) => void;
    
    type Action = () => void;
    var Action: {new (func: () => void): Action;}
    
    interface IAsyncResult {
        
                    
    }
    
    type AsyncCallback = (ar: IAsyncResult) => void;
    var AsyncCallback: {new (func: (ar: IAsyncResult) => void): AsyncCallback;}
    
    type Action$2<T1,T2> = (arg1: T1, arg2: T2) => void;
    
    interface DateTime extends ValueType {
        
                    
    }
    
    interface SystemException extends Exception {
        
                    
    }
    
    interface Guid extends ValueType {
        
                    
    }
    
    type Action$3<T1,T2,T3> = (arg1: T1, arg2: T2, arg3: T3) => void;
    
    interface TimeSpan extends ValueType {
        
                    
    }
    
    interface Nullable$1<T> extends ValueType {
        
                    
    }
    
    interface Int16 extends ValueType {
        
                    
    }
    
    interface SByte extends ValueType {
        
                    
    }
    
    interface Char extends ValueType {
        
                    
    }
    
}
declare module 'System.Reflection' {

    import * as System from 'System';
        
    
    interface MemberInfo extends System.Object {
        
                    
    }
    
    interface FieldInfo extends MemberInfo {
        
                    
    }
    
    interface Assembly extends System.Object {
        
                    
    }
    
    interface MethodInfo extends MethodBase {
        
                    
    }
    
    interface MethodBase extends MemberInfo {
        
                    
    }
    
}
declare module 'System.Collections.Generic' {

    import * as System from 'System';
        
    
    interface List$1<T> extends System.Object {
        
                    
    }
    
    interface IList$1<T> {
        
                    
    }
    
    interface IEnumerable$1<T> {
        
                    
    }
    
    interface IEqualityComparer$1<T> {
        
                    
    }
    
}
declare module 'UnityEngine.SceneManagement' {

    import * as System from 'System';
    import * as UnityEngine from 'UnityEngine';
    import * as System_Collections_Generic from 'System.Collections.Generic';
    import * as UnityEngine_Events from 'UnityEngine.Events';
        
    /**
     * Run-time data structure for *.unity file.
     */
    class Scene extends System.ValueType {
        
        public get handle(): number;
        /**
         * Returns the relative path of the Scene. Like: "AssetsMyScenesMyScene.unity".
         */
        public get path(): string;
        /**
         * Returns the name of the Scene that is currently active in the game or app.
         */
        public get name(): string;
        public set name(value: string);
        /**
         * Returns true if the Scene is loaded.
         */
        public get isLoaded(): boolean;
        /**
         * Return the index of the Scene in the Build Settings.
         */
        public get buildIndex(): number;
        /**
         * Returns true if the Scene is modifed.
         */
        public get isDirty(): boolean;
        /**
         * The number of root transforms of this Scene.
         */
        public get rootCount(): number;
        
        public get isSubScene(): boolean;
        public set isSubScene(value: boolean);
        /**
         * Whether this is a valid Scene.
         * A Scene may be invalid if, for example, you tried to open a Scene that does not exist. In this case, the Scene returned from EditorSceneManager.OpenScene would return False for IsValid.
         * @returns Whether this is a valid Scene.
         */
        public IsValid():boolean;
        /**
         * Returns all the root game objects in the Scene.
         * @returns An array of game objects.
         */
        public GetRootGameObjects():UnityEngine.GameObject[];
        
        public GetRootGameObjects($rootGameObjects: System_Collections_Generic.List$1<UnityEngine.GameObject>):void;
        
        public static op_Equality($lhs: Scene, $rhs: Scene):boolean;
        
        public static op_Inequality($lhs: Scene, $rhs: Scene):boolean;
        
        public GetHashCode():number;
        
        public Equals($other: any):boolean;
        
        public get_Clone(): Scene;            
    }
    /**
     * Derive from this base class to provide alternative implementations to the C# behavior of specific SceneManagement.SceneManager methods.
     */
    class SceneManagerAPI extends System.Object {
        /**
         * The specific SceneManagement.SceneManagerAPI instance to use to handle overridden SceneManagement.SceneManager methods.
         */
        public static get overrideAPI(): SceneManagerAPI;
        public static set overrideAPI(value: SceneManagerAPI);
        
                    
    }
    /**
     * Scene management at run-time.
     */
    class SceneManager extends System.Object {
        /**
         * The total number of currently loaded Scenes.
         */
        public static get sceneCount(): number;
        /**
         * Number of Scenes in Build Settings.
         */
        public static get sceneCountInBuildSettings(): number;
        
        public constructor();
        /**
         * Gets the currently active Scene.
         * @returns The active Scene.
         */
        public static GetActiveScene():Scene;
        /**
         * Set the Scene to be active.
         * @param scene The Scene to be set.
         * @returns Returns false if the Scene is not loaded yet.
         */
        public static SetActiveScene($scene: Scene):boolean;
        /**
         * Searches all Scenes loaded for a Scene that has the given asset path.
         * @param scenePath Path of the Scene. Should be relative to the project folder. Like: "AssetsMyScenesMyScene.unity".
         * @returns A reference to the Scene, if valid. If not, an invalid Scene is returned.
         */
        public static GetSceneByPath($scenePath: string):Scene;
        /**
         * Searches through the Scenes loaded for a Scene with the given name.
         * @param name Name of Scene to find.
         * @returns A reference to the Scene, if valid. If not, an invalid Scene is returned.
         */
        public static GetSceneByName($name: string):Scene;
        /**
         * Get a Scene struct from a build index.
         * @param buildIndex Build index as shown in the Build Settings window.
         * @returns A reference to the Scene, if valid. If not, an invalid Scene is returned.
         */
        public static GetSceneByBuildIndex($buildIndex: number):Scene;
        /**
         * Get the Scene at index in the SceneManager's list of loaded Scenes.
         * @param index Index of the Scene to get. Index must be greater than or equal to 0 and less than SceneManager.sceneCount.
         * @returns A reference to the Scene at the index specified.
         */
        public static GetSceneAt($index: number):Scene;
        /**
         * Create an empty new Scene at runtime with the given name.
         * @param sceneName The name of the new Scene. It cannot be empty or null, or same as the name of the existing Scenes.
         * @param parameters Various parameters used to create the Scene.
         * @returns A reference to the new Scene that was created, or an invalid Scene if creation failed.
         */
        public static CreateScene($sceneName: string, $parameters: CreateSceneParameters):Scene;
        /**
         * This will merge the source Scene into the destinationScene.
         * @param sourceScene The Scene that will be merged into the destination Scene.
         * @param destinationScene Existing Scene to merge the source Scene into.
         */
        public static MergeScenes($sourceScene: Scene, $destinationScene: Scene):void;
        /**
         * Move a GameObject from its current Scene to a new Scene.
         * @param go GameObject to move.
         * @param scene Scene to move into.
         */
        public static MoveGameObjectToScene($go: UnityEngine.GameObject, $scene: Scene):void;
        
        public static add_sceneLoaded($value: UnityEngine_Events.UnityAction$2<Scene, LoadSceneMode>):void;
        
        public static remove_sceneLoaded($value: UnityEngine_Events.UnityAction$2<Scene, LoadSceneMode>):void;
        
        public static add_sceneUnloaded($value: UnityEngine_Events.UnityAction$1<Scene>):void;
        
        public static remove_sceneUnloaded($value: UnityEngine_Events.UnityAction$1<Scene>):void;
        
        public static add_activeSceneChanged($value: UnityEngine_Events.UnityAction$2<Scene, Scene>):void;
        
        public static remove_activeSceneChanged($value: UnityEngine_Events.UnityAction$2<Scene, Scene>):void;
        /**
         * Create an empty new Scene at runtime with the given name.
         * @param sceneName The name of the new Scene. It cannot be empty or null, or same as the name of the existing Scenes.
         * @param parameters Various parameters used to create the Scene.
         * @returns A reference to the new Scene that was created, or an invalid Scene if creation failed.
         */
        public static CreateScene($sceneName: string):Scene;
        /**
         * Loads the Scene by its name or index in Build Settings.
         * @param sceneName Name or path of the Scene to load.
         * @param sceneBuildIndex Index of the Scene in the Build Settings to load.
         * @param mode Allows you to specify whether or not to load the Scene additively. See SceneManagement.LoadSceneMode for more information about the options.
         */
        public static LoadScene($sceneName: string, $mode: LoadSceneMode):void;
        
        public static LoadScene($sceneName: string):void;
        /**
         * Loads the Scene by its name or index in Build Settings.
         * @param sceneName Name or path of the Scene to load.
         * @param sceneBuildIndex Index of the Scene in the Build Settings to load.
         * @param parameters Various parameters used to load the Scene.
         * @returns A handle to the Scene being loaded.
         */
        public static LoadScene($sceneName: string, $parameters: LoadSceneParameters):Scene;
        /**
         * Loads the Scene by its name or index in Build Settings.
         * @param sceneName Name or path of the Scene to load.
         * @param sceneBuildIndex Index of the Scene in the Build Settings to load.
         * @param mode Allows you to specify whether or not to load the Scene additively. See SceneManagement.LoadSceneMode for more information about the options.
         */
        public static LoadScene($sceneBuildIndex: number, $mode: LoadSceneMode):void;
        
        public static LoadScene($sceneBuildIndex: number):void;
        /**
         * Loads the Scene by its name or index in Build Settings.
         * @param sceneName Name or path of the Scene to load.
         * @param sceneBuildIndex Index of the Scene in the Build Settings to load.
         * @param parameters Various parameters used to load the Scene.
         * @returns A handle to the Scene being loaded.
         */
        public static LoadScene($sceneBuildIndex: number, $parameters: LoadSceneParameters):Scene;
        /**
         * Loads the Scene asynchronously in the background.
         * @param sceneName Name or path of the Scene to load.
         * @param sceneBuildIndex Index of the Scene in the Build Settings to load.
         * @param mode If LoadSceneMode.Single then all current Scenes will be unloaded before loading.
         * @param parameters Struct that collects the various parameters into a single place except for the name and index.
         * @returns Use the AsyncOperation to determine if the operation has completed.
         */
        public static LoadSceneAsync($sceneBuildIndex: number, $mode: LoadSceneMode):UnityEngine.AsyncOperation;
        
        public static LoadSceneAsync($sceneBuildIndex: number):UnityEngine.AsyncOperation;
        /**
         * Loads the Scene asynchronously in the background.
         * @param sceneName Name or path of the Scene to load.
         * @param sceneBuildIndex Index of the Scene in the Build Settings to load.
         * @param mode If LoadSceneMode.Single then all current Scenes will be unloaded before loading.
         * @param parameters Struct that collects the various parameters into a single place except for the name and index.
         * @returns Use the AsyncOperation to determine if the operation has completed.
         */
        public static LoadSceneAsync($sceneBuildIndex: number, $parameters: LoadSceneParameters):UnityEngine.AsyncOperation;
        /**
         * Loads the Scene asynchronously in the background.
         * @param sceneName Name or path of the Scene to load.
         * @param sceneBuildIndex Index of the Scene in the Build Settings to load.
         * @param mode If LoadSceneMode.Single then all current Scenes will be unloaded before loading.
         * @param parameters Struct that collects the various parameters into a single place except for the name and index.
         * @returns Use the AsyncOperation to determine if the operation has completed.
         */
        public static LoadSceneAsync($sceneName: string, $mode: LoadSceneMode):UnityEngine.AsyncOperation;
        
        public static LoadSceneAsync($sceneName: string):UnityEngine.AsyncOperation;
        /**
         * Loads the Scene asynchronously in the background.
         * @param sceneName Name or path of the Scene to load.
         * @param sceneBuildIndex Index of the Scene in the Build Settings to load.
         * @param mode If LoadSceneMode.Single then all current Scenes will be unloaded before loading.
         * @param parameters Struct that collects the various parameters into a single place except for the name and index.
         * @returns Use the AsyncOperation to determine if the operation has completed.
         */
        public static LoadSceneAsync($sceneName: string, $parameters: LoadSceneParameters):UnityEngine.AsyncOperation;
        /**
         * Destroys all GameObjects associated with the given Scene and removes the Scene from the SceneManager.
         * @param sceneBuildIndex Index of the Scene in BuildSettings.
         * @param sceneName Name or path of the Scene to unload.
         * @param scene Scene to unload.
         * @param options Scene unloading options.
         * @returns Use the AsyncOperation to determine if the operation has completed.
         */
        public static UnloadSceneAsync($sceneBuildIndex: number):UnityEngine.AsyncOperation;
        /**
         * Destroys all GameObjects associated with the given Scene and removes the Scene from the SceneManager.
         * @param sceneBuildIndex Index of the Scene in BuildSettings.
         * @param sceneName Name or path of the Scene to unload.
         * @param scene Scene to unload.
         * @param options Scene unloading options.
         * @returns Use the AsyncOperation to determine if the operation has completed.
         */
        public static UnloadSceneAsync($sceneName: string):UnityEngine.AsyncOperation;
        /**
         * Destroys all GameObjects associated with the given Scene and removes the Scene from the SceneManager.
         * @param sceneBuildIndex Index of the Scene in BuildSettings.
         * @param sceneName Name or path of the Scene to unload.
         * @param scene Scene to unload.
         * @param options Scene unloading options.
         * @returns Use the AsyncOperation to determine if the operation has completed.
         */
        public static UnloadSceneAsync($scene: Scene):UnityEngine.AsyncOperation;
        /**
         * Destroys all GameObjects associated with the given Scene and removes the Scene from the SceneManager.
         * @param sceneBuildIndex Index of the Scene in BuildSettings.
         * @param sceneName Name or path of the Scene to unload.
         * @param scene Scene to unload.
         * @param options Scene unloading options.
         * @returns Use the AsyncOperation to determine if the operation has completed.
         */
        public static UnloadSceneAsync($sceneBuildIndex: number, $options: UnloadSceneOptions):UnityEngine.AsyncOperation;
        /**
         * Destroys all GameObjects associated with the given Scene and removes the Scene from the SceneManager.
         * @param sceneBuildIndex Index of the Scene in BuildSettings.
         * @param sceneName Name or path of the Scene to unload.
         * @param scene Scene to unload.
         * @param options Scene unloading options.
         * @returns Use the AsyncOperation to determine if the operation has completed.
         */
        public static UnloadSceneAsync($sceneName: string, $options: UnloadSceneOptions):UnityEngine.AsyncOperation;
        /**
         * Destroys all GameObjects associated with the given Scene and removes the Scene from the SceneManager.
         * @param sceneBuildIndex Index of the Scene in BuildSettings.
         * @param sceneName Name or path of the Scene to unload.
         * @param scene Scene to unload.
         * @param options Scene unloading options.
         * @returns Use the AsyncOperation to determine if the operation has completed.
         */
        public static UnloadSceneAsync($scene: Scene, $options: UnloadSceneOptions):UnityEngine.AsyncOperation;
        
        public static sceneLoaded;
        
        public static sceneUnloaded;
        
        public static activeSceneChanged;
        
                    
    }
    /**
     * This struct collects all the CreateScene parameters in to a single place.
     */
    class CreateSceneParameters extends System.ValueType {
        /**
         * See SceneManagement.LocalPhysicsMode.
         */
        public get localPhysicsMode(): LocalPhysicsMode;
        public set localPhysicsMode(value: LocalPhysicsMode);
        
        public constructor($physicsMode: LocalPhysicsMode);
        
        public get_Clone(): CreateSceneParameters;            
    }
    /**
     * Used when loading a Scene in a player.
     */
    enum LoadSceneMode { Single = 0, Additive = 1 }
    /**
     * This struct collects all the LoadScene parameters in to a single place.
     */
    class LoadSceneParameters extends System.ValueType {
        /**
         * See LoadSceneMode.
         */
        public get loadSceneMode(): LoadSceneMode;
        public set loadSceneMode(value: LoadSceneMode);
        /**
         * See SceneManagement.LocalPhysicsMode.
         */
        public get localPhysicsMode(): LocalPhysicsMode;
        public set localPhysicsMode(value: LocalPhysicsMode);
        /**
         * Constructor for LoadSceneParameters. See SceneManager.LoadScene.
         * @param mode See LoadSceneParameters.loadSceneMode.
         */
        public constructor($mode: LoadSceneMode);
        
        public constructor($mode: LoadSceneMode, $physicsMode: LocalPhysicsMode);
        
        public get_Clone(): LoadSceneParameters;            
    }
    /**
     * Scene unloading options passed to SceneManager.UnloadScene.
     */
    enum UnloadSceneOptions { None = 0, UnloadAllEmbeddedSceneObjects = 1 }
    /**
     * Provides options for 2D and 3D local physics.
     */
    enum LocalPhysicsMode { None = 0, Physics2D = 1, Physics3D = 2 }
    /**
     * Scene and Build Settings related utilities.
     */
    class SceneUtility extends System.Object {
        /**
         * Get the Scene path from a build index.
         * @returns Scene path (e.g "AssetsScenesScene1.unity").
         */
        public static GetScenePathByBuildIndex($buildIndex: number):string;
        /**
         * Get the build index from a Scene path.
         * @param scenePath Scene path (e.g: "AssetsScenesScene1.unity").
         * @returns Build index.
         */
        public static GetBuildIndexByScenePath($scenePath: string):number;
        
                    
    }
    
}
declare module 'System.Collections' {

    import * as System from 'System';
        
    
    interface IEnumerator {
        
                    
    }
    
    interface Stack extends System.Object {
        
                    
    }
    
}
declare module 'UnityEngine.RectTransform' {

    import * as UnityEngine from 'UnityEngine';
    import * as System from 'System';
        
    /**
     * Delegate used for the reapplyDrivenProperties event.
     */
    type ReapplyDrivenProperties = (driven: UnityEngine.RectTransform) => void;
    var ReapplyDrivenProperties: {new (func: (driven: UnityEngine.RectTransform) => void): ReapplyDrivenProperties;}
    /**
     * Enum used to specify one edge of a rectangle.
     */
    enum Edge { Left = 0, Right = 1, Top = 2, Bottom = 3 }
    /**
     * An axis that can be horizontal or vertical.
     */
    enum Axis { Horizontal = 0, Vertical = 1 }
    
}
declare module 'UnityEngine.Random' {

    import * as System from 'System';
        
    /**
     * Serializable structure used to hold the full internal state of the random number generator. See Also: Random.state.
     * This is an opaque data structure intended for serialization (save and restore) purposes only. Its fields are all private and
     * have no useful meaning on their own outside of the algorithm. A seed set with InitState, for example, cannot be
     * retrieved after even a single iteration of the generator.
     * See Random for details on the algorithm.
     */
    class State extends System.ValueType {
        
        public get_Clone(): State;            
    }
    
}
declare module 'UnityEngine.Experimental.Rendering' {

    import * as System from 'System';
    import * as UnityEngine from 'UnityEngine';
    import * as UnityEngine_Rendering from 'UnityEngine.Rendering';
        
    /**
     * Use this format to create either Textures or RenderTextures from scripts.
     */
    enum GraphicsFormat { None = 0, R8_SRGB = 1, R8G8_SRGB = 2, R8G8B8_SRGB = 3, R8G8B8A8_SRGB = 4, R8_UNorm = 5, R8G8_UNorm = 6, R8G8B8_UNorm = 7, R8G8B8A8_UNorm = 8, R8_SNorm = 9, R8G8_SNorm = 10, R8G8B8_SNorm = 11, R8G8B8A8_SNorm = 12, R8_UInt = 13, R8G8_UInt = 14, R8G8B8_UInt = 15, R8G8B8A8_UInt = 16, R8_SInt = 17, R8G8_SInt = 18, R8G8B8_SInt = 19, R8G8B8A8_SInt = 20, R16_UNorm = 21, R16G16_UNorm = 22, R16G16B16_UNorm = 23, R16G16B16A16_UNorm = 24, R16_SNorm = 25, R16G16_SNorm = 26, R16G16B16_SNorm = 27, R16G16B16A16_SNorm = 28, R16_UInt = 29, R16G16_UInt = 30, R16G16B16_UInt = 31, R16G16B16A16_UInt = 32, R16_SInt = 33, R16G16_SInt = 34, R16G16B16_SInt = 35, R16G16B16A16_SInt = 36, R32_UInt = 37, R32G32_UInt = 38, R32G32B32_UInt = 39, R32G32B32A32_UInt = 40, R32_SInt = 41, R32G32_SInt = 42, R32G32B32_SInt = 43, R32G32B32A32_SInt = 44, R16_SFloat = 45, R16G16_SFloat = 46, R16G16B16_SFloat = 47, R16G16B16A16_SFloat = 48, R32_SFloat = 49, R32G32_SFloat = 50, R32G32B32_SFloat = 51, R32G32B32A32_SFloat = 52, B8G8R8_SRGB = 56, B8G8R8A8_SRGB = 57, B8G8R8_UNorm = 58, B8G8R8A8_UNorm = 59, B8G8R8_SNorm = 60, B8G8R8A8_SNorm = 61, B8G8R8_UInt = 62, B8G8R8A8_UInt = 63, B8G8R8_SInt = 64, B8G8R8A8_SInt = 65, R4G4B4A4_UNormPack16 = 66, B4G4R4A4_UNormPack16 = 67, R5G6B5_UNormPack16 = 68, B5G6R5_UNormPack16 = 69, R5G5B5A1_UNormPack16 = 70, B5G5R5A1_UNormPack16 = 71, A1R5G5B5_UNormPack16 = 72, E5B9G9R9_UFloatPack32 = 73, B10G11R11_UFloatPack32 = 74, A2B10G10R10_UNormPack32 = 75, A2B10G10R10_UIntPack32 = 76, A2B10G10R10_SIntPack32 = 77, A2R10G10B10_UNormPack32 = 78, A2R10G10B10_UIntPack32 = 79, A2R10G10B10_SIntPack32 = 80, A2R10G10B10_XRSRGBPack32 = 81, A2R10G10B10_XRUNormPack32 = 82, R10G10B10_XRSRGBPack32 = 83, R10G10B10_XRUNormPack32 = 84, A10R10G10B10_XRSRGBPack32 = 85, A10R10G10B10_XRUNormPack32 = 86, RGB_DXT1_SRGB = 96, RGBA_DXT1_SRGB = 96, RGB_DXT1_UNorm = 97, RGBA_DXT1_UNorm = 97, RGBA_DXT3_SRGB = 98, RGBA_DXT3_UNorm = 99, RGBA_DXT5_SRGB = 100, RGBA_DXT5_UNorm = 101, R_BC4_UNorm = 102, R_BC4_SNorm = 103, RG_BC5_UNorm = 104, RG_BC5_SNorm = 105, RGB_BC6H_UFloat = 106, RGB_BC6H_SFloat = 107, RGBA_BC7_SRGB = 108, RGBA_BC7_UNorm = 109, RGB_PVRTC_2Bpp_SRGB = 110, RGB_PVRTC_2Bpp_UNorm = 111, RGB_PVRTC_4Bpp_SRGB = 112, RGB_PVRTC_4Bpp_UNorm = 113, RGBA_PVRTC_2Bpp_SRGB = 114, RGBA_PVRTC_2Bpp_UNorm = 115, RGBA_PVRTC_4Bpp_SRGB = 116, RGBA_PVRTC_4Bpp_UNorm = 117, RGB_ETC_UNorm = 118, RGB_ETC2_SRGB = 119, RGB_ETC2_UNorm = 120, RGB_A1_ETC2_SRGB = 121, RGB_A1_ETC2_UNorm = 122, RGBA_ETC2_SRGB = 123, RGBA_ETC2_UNorm = 124, R_EAC_UNorm = 125, R_EAC_SNorm = 126, RG_EAC_UNorm = 127, RG_EAC_SNorm = 128, RGBA_ASTC4X4_SRGB = 129, RGBA_ASTC4X4_UNorm = 130, RGBA_ASTC5X5_SRGB = 131, RGBA_ASTC5X5_UNorm = 132, RGBA_ASTC6X6_SRGB = 133, RGBA_ASTC6X6_UNorm = 134, RGBA_ASTC8X8_SRGB = 135, RGBA_ASTC8X8_UNorm = 136, RGBA_ASTC10X10_SRGB = 137, RGBA_ASTC10X10_UNorm = 138, RGBA_ASTC12X12_SRGB = 139, RGBA_ASTC12X12_UNorm = 140, RGBA_ASTC4X4_UFloat = 145, RGBA_ASTC5X5_UFloat = 146, RGBA_ASTC6X6_UFloat = 147, RGBA_ASTC8X8_UFloat = 148, RGBA_ASTC10X10_UFloat = 149, RGBA_ASTC12X12_UFloat = 150 }
    /**
     * Indicates how a Renderer is updated.
     */
    enum RayTracingMode { Off = 0, Static = 1, DynamicTransform = 2, DynamicGeometry = 3 }
    /**
     * Use a default format to create either Textures or RenderTextures from scripts based on platform specific capability.
     */
    enum DefaultFormat { LDR = 0, HDR = 1 }
    
    enum TextureCreationFlags { None = 0, MipChain = 1, Crunch = 64 }
    /**
     * Use this format usages to figure out the capabilities of specific GraphicsFormat
     */
    enum FormatUsage { Sample = 0, Linear = 1, Sparse = 2, Render = 4, Blend = 5, GetPixels = 6, SetPixels = 7, SetPixels32 = 8, ReadPixels = 9, LoadStore = 10, MSAA2x = 11, MSAA4x = 12, MSAA8x = 13, StencilSampling = 16 }
    /**
     * A shader for GPU ray tracing.
     */
    class RayTracingShader extends UnityEngine.Object {
        /**
         * The maximum number of ray bounces this shader can trace (Read Only).
         */
        public get maxRecursionDepth(): number;
        /**
         * Sets the value of a float uniform.
         * @param name The name of the property being set.
         * @param nameID The ID of the property as given by Shader.PropertyToID.
         * @param val The float value to set.
         */
        public SetFloat($nameID: number, $val: number):void;
        /**
         * Sets the value of a int uniform.
         * @param name The name of the property being set.
         * @param nameID The ID of the property as given by Shader.PropertyToID.
         * @param val The int value to set.
         */
        public SetInt($nameID: number, $val: number):void;
        /**
         * Sets the value for a vector uniform.
         * @param name The name of the property being set.
         * @param nameID The ID of the property as given by Shader.PropertyToID.
         * @param val The vector to set.
         */
        public SetVector($nameID: number, $val: UnityEngine.Vector4):void;
        /**
         * Sets the value of a matrix uniform.
         * @param name The name of the property being set.
         * @param nameID The ID of the property as given by Shader.PropertyToID.
         * @param val The matrix to set.
         */
        public SetMatrix($nameID: number, $val: UnityEngine.Matrix4x4):void;
        /**
         * Sets a vector array uniform.
         * @param name The name of the property being set.
         * @param nameID The ID of the property as given by Shader.PropertyToID.
         * @param values The array of vectors to set.
         */
        public SetVectorArray($nameID: number, $values: UnityEngine.Vector4[]):void;
        /**
         * Sets a matrix array uniform.
         * @param name The name of the property being set.
         * @param nameID The ID of the property as given by Shader.PropertyToID.
         * @param values The matrix array to set.
         */
        public SetMatrixArray($nameID: number, $values: UnityEngine.Matrix4x4[]):void;
        /**
         * Binds a texture resource. This can be a input or an output texture (UAV).
         * @param nameID The ID of the resource as given by Shader.PropertyToID.
         * @param name The name of the texture being set.
         * @param texture The texture to bind the named local resource to.
         */
        public SetTexture($nameID: number, $texture: UnityEngine.Texture):void;
        /**
         * Binds a ComputeBuffer or GraphicsBuffer to a RayTracingShader.
         * @param nameID The ID of the buffer name in shader code. Use Shader.PropertyToID to get this ID.
         * @param name The name of the buffer in shader code.
         * @param buffer The buffer to bind the named local resource to.
         */
        public SetBuffer($nameID: number, $buffer: UnityEngine.ComputeBuffer):void;
        /**
         * Sets the value for RayTracingAccelerationStructure property of this RayTracingShader.
         * @param name The name of the RayTracingAccelerationStructure being set.
         * @param nameID The ID of the RayTracingAccelerationStructure as given by Shader.PropertyToID.
         * @param accelerationStructure The value to set the RayTracingAccelerationStructure to.
         */
        public SetAccelerationStructure($nameID: number, $accelerationStructure: RayTracingAccelerationStructure):void;
        /**
         * Selects which Shader Pass to use when executing ray/geometry intersection shaders.
         * @param passName The Shader Pass to use when executing ray tracing shaders.
         */
        public SetShaderPass($passName: string):void;
        /**
         * Binds a global texture to a RayTracingShader.
         * @param nameID The ID of the texture as given by Shader.PropertyToID.
         * @param name The name of the texture to bind.
         * @param globalTextureName The name of the global resource to bind to the RayTracingShader.
         * @param globalTextureNameID The ID of the global resource as given by Shader.PropertyToID.
         */
        public SetTextureFromGlobal($nameID: number, $globalTextureNameID: number):void;
        /**
         * Dispatches this RayTracingShader.
         * @param rayGenFunctionName The name of the ray generation shader.
         * @param width The width of the ray generation shader thread grid.
         * @param height The height of the ray generation shader thread grid.
         * @param depth The depth of the ray generation shader thread grid.
         * @param camera Optional parameter used to setup camera-related built-in shader variables.
         */
        public Dispatch($rayGenFunctionName: string, $width: number, $height: number, $depth: number, $camera?: UnityEngine.Camera):void;
        /**
         * Binds a ComputeBuffer or GraphicsBuffer to a RayTracingShader.
         * @param nameID The ID of the buffer name in shader code. Use Shader.PropertyToID to get this ID.
         * @param name The name of the buffer in shader code.
         * @param buffer The buffer to bind the named local resource to.
         */
        public SetBuffer($nameID: number, $buffer: UnityEngine.GraphicsBuffer):void;
        /**
         * Sets the value of a float uniform.
         * @param name The name of the property being set.
         * @param nameID The ID of the property as given by Shader.PropertyToID.
         * @param val The float value to set.
         */
        public SetFloat($name: string, $val: number):void;
        /**
         * Sets the value of a int uniform.
         * @param name The name of the property being set.
         * @param nameID The ID of the property as given by Shader.PropertyToID.
         * @param val The int value to set.
         */
        public SetInt($name: string, $val: number):void;
        /**
         * Sets the value for a vector uniform.
         * @param name The name of the property being set.
         * @param nameID The ID of the property as given by Shader.PropertyToID.
         * @param val The vector to set.
         */
        public SetVector($name: string, $val: UnityEngine.Vector4):void;
        /**
         * Sets the value of a matrix uniform.
         * @param name The name of the property being set.
         * @param nameID The ID of the property as given by Shader.PropertyToID.
         * @param val The matrix to set.
         */
        public SetMatrix($name: string, $val: UnityEngine.Matrix4x4):void;
        /**
         * Sets a vector array uniform.
         * @param name The name of the property being set.
         * @param nameID The ID of the property as given by Shader.PropertyToID.
         * @param values The array of vectors to set.
         */
        public SetVectorArray($name: string, $values: UnityEngine.Vector4[]):void;
        /**
         * Sets a matrix array uniform.
         * @param name The name of the property being set.
         * @param nameID The ID of the property as given by Shader.PropertyToID.
         * @param values The matrix array to set.
         */
        public SetMatrixArray($name: string, $values: UnityEngine.Matrix4x4[]):void;
        /**
         * Sets the values for a float array uniform.
         * @param name The name of the property being set.
         * @param nameID The ID of the property as given by Shader.PropertyToID.
         * @param values The float array to set.
         */
        public SetFloats($name: string, ...values: number[]):void;
        /**
         * Sets the values for a float array uniform.
         * @param name The name of the property being set.
         * @param nameID The ID of the property as given by Shader.PropertyToID.
         * @param values The float array to set.
         */
        public SetFloats($nameID: number, ...values: number[]):void;
        /**
         * Sets the values for a int array uniform.
         * @param name The name of the property being set.
         * @param nameID The ID of the property as given by Shader.PropertyToID.
         * @param values The int array to set.
         */
        public SetInts($name: string, ...values: number[]):void;
        /**
         * Sets the values for a int array uniform.
         * @param name The name of the property being set.
         * @param nameID The ID of the property as given by Shader.PropertyToID.
         * @param values The int array to set.
         */
        public SetInts($nameID: number, ...values: number[]):void;
        /**
         * Sets the value of a boolean uniform.
         * @param name The name of the property being set.
         * @param nameID The ID of the property as given by Shader.PropertyToID.
         * @param val The boolean value to set.
         */
        public SetBool($name: string, $val: boolean):void;
        /**
         * Sets the value of a boolean uniform.
         * @param name The name of the property being set.
         * @param nameID The ID of the property as given by Shader.PropertyToID.
         * @param val The boolean value to set.
         */
        public SetBool($nameID: number, $val: boolean):void;
        /**
         * Binds a texture resource. This can be a input or an output texture (UAV).
         * @param nameID The ID of the resource as given by Shader.PropertyToID.
         * @param name The name of the texture being set.
         * @param texture The texture to bind the named local resource to.
         */
        public SetTexture($name: string, $texture: UnityEngine.Texture):void;
        /**
         * Binds a ComputeBuffer or GraphicsBuffer to a RayTracingShader.
         * @param nameID The ID of the buffer name in shader code. Use Shader.PropertyToID to get this ID.
         * @param name The name of the buffer in shader code.
         * @param buffer The buffer to bind the named local resource to.
         */
        public SetBuffer($name: string, $buffer: UnityEngine.ComputeBuffer):void;
        /**
         * Binds a ComputeBuffer or GraphicsBuffer to a RayTracingShader.
         * @param nameID The ID of the buffer name in shader code. Use Shader.PropertyToID to get this ID.
         * @param name The name of the buffer in shader code.
         * @param buffer The buffer to bind the named local resource to.
         */
        public SetBuffer($name: string, $buffer: UnityEngine.GraphicsBuffer):void;
        /**
         * Binds a constant buffer created through a ComputeBuffer or a GraphicsBuffer.
         * @param nameID The ID of the property name for the constant buffer in shader code. Use Shader.PropertyToID to get this ID.
         * @param name The name of the constant buffer in shader code.
         * @param buffer The buffer to bind as constant buffer.
         * @param offset The offset in bytes from the beginning of the ComputeBuffer or GraphicsBuffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
         * @param size The number of bytes to bind.
         */
        public SetConstantBuffer($nameID: number, $buffer: UnityEngine.ComputeBuffer, $offset: number, $size: number):void;
        /**
         * Binds a constant buffer created through a ComputeBuffer or a GraphicsBuffer.
         * @param nameID The ID of the property name for the constant buffer in shader code. Use Shader.PropertyToID to get this ID.
         * @param name The name of the constant buffer in shader code.
         * @param buffer The buffer to bind as constant buffer.
         * @param offset The offset in bytes from the beginning of the ComputeBuffer or GraphicsBuffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
         * @param size The number of bytes to bind.
         */
        public SetConstantBuffer($name: string, $buffer: UnityEngine.ComputeBuffer, $offset: number, $size: number):void;
        /**
         * Binds a constant buffer created through a ComputeBuffer or a GraphicsBuffer.
         * @param nameID The ID of the property name for the constant buffer in shader code. Use Shader.PropertyToID to get this ID.
         * @param name The name of the constant buffer in shader code.
         * @param buffer The buffer to bind as constant buffer.
         * @param offset The offset in bytes from the beginning of the ComputeBuffer or GraphicsBuffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
         * @param size The number of bytes to bind.
         */
        public SetConstantBuffer($nameID: number, $buffer: UnityEngine.GraphicsBuffer, $offset: number, $size: number):void;
        /**
         * Binds a constant buffer created through a ComputeBuffer or a GraphicsBuffer.
         * @param nameID The ID of the property name for the constant buffer in shader code. Use Shader.PropertyToID to get this ID.
         * @param name The name of the constant buffer in shader code.
         * @param buffer The buffer to bind as constant buffer.
         * @param offset The offset in bytes from the beginning of the ComputeBuffer or GraphicsBuffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
         * @param size The number of bytes to bind.
         */
        public SetConstantBuffer($name: string, $buffer: UnityEngine.GraphicsBuffer, $offset: number, $size: number):void;
        /**
         * Sets the value for RayTracingAccelerationStructure property of this RayTracingShader.
         * @param name The name of the RayTracingAccelerationStructure being set.
         * @param nameID The ID of the RayTracingAccelerationStructure as given by Shader.PropertyToID.
         * @param accelerationStructure The value to set the RayTracingAccelerationStructure to.
         */
        public SetAccelerationStructure($name: string, $accelerationStructure: RayTracingAccelerationStructure):void;
        /**
         * Binds a global texture to a RayTracingShader.
         * @param nameID The ID of the texture as given by Shader.PropertyToID.
         * @param name The name of the texture to bind.
         * @param globalTextureName The name of the global resource to bind to the RayTracingShader.
         * @param globalTextureNameID The ID of the global resource as given by Shader.PropertyToID.
         */
        public SetTextureFromGlobal($name: string, $globalTextureName: string):void;
        
                    
    }
    /**
     * A data structure used to represent the Renderers in the Scene for GPU ray tracing.
     */
    class RayTracingAccelerationStructure extends System.Object {
        /**
         * Creates a RayTracingAccelerationStructure with the given RayTracingAccelerationStructure.RASSettings.
         * @param settings Defines whether a RayTracingAccelerationStructure is updated by the user or the Engine, and whether to mask certain object layers or RayTracingModes.
         */
        public constructor($settings: UnityEngine_Experimental_Rendering_RayTracingAccelerationStructure.RASSettings);
        /**
         * Creates a RayTracingAccelerationStructure with the given RayTracingAccelerationStructure.RASSettings.
         * @param settings Defines whether a RayTracingAccelerationStructure is updated by the user or the Engine, and whether to mask certain object layers or RayTracingModes.
         */
        public constructor();
        /**
         * Destroys this RayTracingAccelerationStructure.
         */
        public Dispose():void;
        /**
         * See Also: RayTracingAccelerationStructure.Dispose.
         */
        public Release():void;
        /**
         * Builds this RayTracingAccelerationStructure on the GPU.
         */
        public Build():void;
        
        public Build($relativeOrigin: UnityEngine.Vector3):void;
        /**
         * Add an instance to this RayTracingAccelerationStructure. Instance geometry can be either a Renderer or a GraphicsBuffer that includes a number of axis-aligned bounding boxes.
         * @param targetRenderer The renderer to be added to RayTracingAccelerationStructure.
         * @param subMeshMask A bit mask of any size that indicates whether or not to add a submesh to the RayTracingAccelerationStructure. For a Renderer with multiple submeshes, if subMeshMask[i] = true, the submesh is added to the RayTracingAccelerationStructure. For a Renderer with only one submesh, you may pass an uninitialized array as a default value.
         * @param subMeshTransparencyFlags A bit array of any size that indicates whether a given submesh is transparent. For a Renderer with multiple submeshes, if subMeshTransparencyFlag[i] = true, that submesh is marked as transparent. For a Renderer with only one submesh, pass an array with a single initialized entry, and indicate whether or not the one submesh is transparent.
         * @param enableTriangleCulling A bool that indicates whether the GPU driver-level culling passes (such as front-face culling or back-face culling) should cull this Renderer. Culling is enabled (true) by default.
         * @param frontTriangleCounterClockwise A bool that indicates whether to flip the way triangles face in this renderer. If this is set to true, front-facing triangles will become back-facing and vice versa. Set to false by default.
         * @param mask An 8-bit mask you can use to selectively intersect this renderer with rays that only pass the mask. All rays are enabled (0xff) by default.
         * @param aabbBuffer A GraphicsBuffer that defines a number of axis-aligned bounding boxes (AABBs). An AABB is defined by a list of bounds, written as floats in the following order: minX, minY, minZ, maxX, maxY, maxZ.
         * @param numElements The number of axis-aligned bounding boxes defined in the given GraphicsBuffer.
         * @param material The Material to apply to an instance defined by axis-aligned bounding boxes in a GraphicsBuffer.
         * @param instanceTransform The object to world matrix to apply to an instance defined by axis-aligned bounding boxes in a GraphicsBuffer. This is optional, and takes the value of a Matrix4x4.identity by default.
         * @param isCutOff A bool that indicates whether the Material applied to a GraphicsBuffer instance has cutoff transparency.
         * @param reuseBounds A bool that indicates whether Unity reuses the AABBs defined in the GraphicsBuffer without change. If the exact same bounds can be used across multiple acceleration structures or multiple frames, set this to true. This is false by default.
         */
        public AddInstance($targetRenderer: UnityEngine.Renderer, $subMeshMask?: boolean[], $subMeshTransparencyFlags?: boolean[], $enableTriangleCulling?: boolean, $frontTriangleCounterClockwise?: boolean, $mask?: number):void;
        /**
         * Add an instance to this RayTracingAccelerationStructure. Instance geometry can be either a Renderer or a GraphicsBuffer that includes a number of axis-aligned bounding boxes.
         * @param targetRenderer The renderer to be added to RayTracingAccelerationStructure.
         * @param subMeshMask A bit mask of any size that indicates whether or not to add a submesh to the RayTracingAccelerationStructure. For a Renderer with multiple submeshes, if subMeshMask[i] = true, the submesh is added to the RayTracingAccelerationStructure. For a Renderer with only one submesh, you may pass an uninitialized array as a default value.
         * @param subMeshTransparencyFlags A bit array of any size that indicates whether a given submesh is transparent. For a Renderer with multiple submeshes, if subMeshTransparencyFlag[i] = true, that submesh is marked as transparent. For a Renderer with only one submesh, pass an array with a single initialized entry, and indicate whether or not the one submesh is transparent.
         * @param enableTriangleCulling A bool that indicates whether the GPU driver-level culling passes (such as front-face culling or back-face culling) should cull this Renderer. Culling is enabled (true) by default.
         * @param frontTriangleCounterClockwise A bool that indicates whether to flip the way triangles face in this renderer. If this is set to true, front-facing triangles will become back-facing and vice versa. Set to false by default.
         * @param mask An 8-bit mask you can use to selectively intersect this renderer with rays that only pass the mask. All rays are enabled (0xff) by default.
         * @param aabbBuffer A GraphicsBuffer that defines a number of axis-aligned bounding boxes (AABBs). An AABB is defined by a list of bounds, written as floats in the following order: minX, minY, minZ, maxX, maxY, maxZ.
         * @param numElements The number of axis-aligned bounding boxes defined in the given GraphicsBuffer.
         * @param material The Material to apply to an instance defined by axis-aligned bounding boxes in a GraphicsBuffer.
         * @param instanceTransform The object to world matrix to apply to an instance defined by axis-aligned bounding boxes in a GraphicsBuffer. This is optional, and takes the value of a Matrix4x4.identity by default.
         * @param isCutOff A bool that indicates whether the Material applied to a GraphicsBuffer instance has cutoff transparency.
         * @param reuseBounds A bool that indicates whether Unity reuses the AABBs defined in the GraphicsBuffer without change. If the exact same bounds can be used across multiple acceleration structures or multiple frames, set this to true. This is false by default.
         */
        public AddInstance($aabbBuffer: UnityEngine.GraphicsBuffer, $numElements: number, $material: UnityEngine.Material, $isCutOff: boolean, $enableTriangleCulling?: boolean, $frontTriangleCounterClockwise?: boolean, $mask?: number, $reuseBounds?: boolean):void;
        /**
         * Add an instance to this RayTracingAccelerationStructure. Instance geometry can be either a Renderer or a GraphicsBuffer that includes a number of axis-aligned bounding boxes.
         * @param targetRenderer The renderer to be added to RayTracingAccelerationStructure.
         * @param subMeshMask A bit mask of any size that indicates whether or not to add a submesh to the RayTracingAccelerationStructure. For a Renderer with multiple submeshes, if subMeshMask[i] = true, the submesh is added to the RayTracingAccelerationStructure. For a Renderer with only one submesh, you may pass an uninitialized array as a default value.
         * @param subMeshTransparencyFlags A bit array of any size that indicates whether a given submesh is transparent. For a Renderer with multiple submeshes, if subMeshTransparencyFlag[i] = true, that submesh is marked as transparent. For a Renderer with only one submesh, pass an array with a single initialized entry, and indicate whether or not the one submesh is transparent.
         * @param enableTriangleCulling A bool that indicates whether the GPU driver-level culling passes (such as front-face culling or back-face culling) should cull this Renderer. Culling is enabled (true) by default.
         * @param frontTriangleCounterClockwise A bool that indicates whether to flip the way triangles face in this renderer. If this is set to true, front-facing triangles will become back-facing and vice versa. Set to false by default.
         * @param mask An 8-bit mask you can use to selectively intersect this renderer with rays that only pass the mask. All rays are enabled (0xff) by default.
         * @param aabbBuffer A GraphicsBuffer that defines a number of axis-aligned bounding boxes (AABBs). An AABB is defined by a list of bounds, written as floats in the following order: minX, minY, minZ, maxX, maxY, maxZ.
         * @param numElements The number of axis-aligned bounding boxes defined in the given GraphicsBuffer.
         * @param material The Material to apply to an instance defined by axis-aligned bounding boxes in a GraphicsBuffer.
         * @param instanceTransform The object to world matrix to apply to an instance defined by axis-aligned bounding boxes in a GraphicsBuffer. This is optional, and takes the value of a Matrix4x4.identity by default.
         * @param isCutOff A bool that indicates whether the Material applied to a GraphicsBuffer instance has cutoff transparency.
         * @param reuseBounds A bool that indicates whether Unity reuses the AABBs defined in the GraphicsBuffer without change. If the exact same bounds can be used across multiple acceleration structures or multiple frames, set this to true. This is false by default.
         */
        public AddInstance($aabbBuffer: UnityEngine.GraphicsBuffer, $numElements: number, $material: UnityEngine.Material, $instanceTransform: UnityEngine.Matrix4x4, $isCutOff: boolean, $enableTriangleCulling?: boolean, $frontTriangleCounterClockwise?: boolean, $mask?: number, $reuseBounds?: boolean):void;
        /**
         * Updates the transform of the instance associated with the given Renderer for this RayTracingAccelerationStructure.
         */
        public UpdateInstanceTransform($renderer: UnityEngine.Renderer):void;
        /**
         * Returns the total size of this RayTracingAccelerationStructure on the GPU in bytes.
         */
        public GetSize():bigint;
        
                    
    }
    /**
     * Defines the required members for a Runtime Reflection Systems.
     */
    interface IScriptableRuntimeReflectionSystem {
        /**
         * Update the reflection probes.
         * @returns Whether a reflection probe was updated.
         */
        TickRealtimeProbes():boolean;
        
                    
    }
    /**
     * Empty implementation of IScriptableRuntimeReflectionSystem.
     */
    class ScriptableRuntimeReflectionSystem extends System.Object {
        /**
         * Update the reflection probes.
         * @returns Whether a reflection probe was updated.
         */
        public TickRealtimeProbes():boolean;
        
                    
    }
    /**
     * Global settings for the scriptable runtime reflection system.
     */
    class ScriptableRuntimeReflectionSystemSettings extends System.Object {
        /**
         * The current scriptable runtime reflection system instance.
         */
        public static get system(): IScriptableRuntimeReflectionSystem;
        public static set system(value: IScriptableRuntimeReflectionSystem);
        
                    
    }
    /**
     * The ExternalGPUProfiler API allows developers to programatically take GPU frame captures in conjunction with supported external GPU profilers.
     * GPU frame captures can be used to both analyze performance and debug graphics related issues.
     */
    class ExternalGPUProfiler extends System.Object {
        /**
         * Begins the current GPU frame capture in the external GPU profiler.
         */
        public static BeginGPUCapture():void;
        /**
         * Ends the current GPU frame capture in the external GPU profiler.
         */
        public static EndGPUCapture():void;
        /**
         * Returns true when a development build is launched by an external GPU profiler.
         */
        public static IsAttached():boolean;
        
                    
    }
    
    enum WaitForPresentSyncPoint { BeginFrame = 0, EndFrame = 1 }
    
    enum GraphicsJobsSyncPoint { EndOfFrame = 0, AfterScriptUpdate = 1, AfterScriptLateUpdate = 2, WaitForPresent = 3 }
    
    class GraphicsDeviceSettings extends System.Object {
        
        public static get waitForPresentSyncPoint(): WaitForPresentSyncPoint;
        public static set waitForPresentSyncPoint(value: WaitForPresentSyncPoint);
        
        public static get graphicsJobsSyncPoint(): GraphicsJobsSyncPoint;
        public static set graphicsJobsSyncPoint(value: GraphicsJobsSyncPoint);
        
                    
    }
    
    class GraphicsFormatUtility extends System.Object {
        
        public constructor();
        
        public static GetGraphicsFormat($format: UnityEngine.TextureFormat, $isSRGB: boolean):GraphicsFormat;
        
        public static GetTextureFormat($format: GraphicsFormat):UnityEngine.TextureFormat;
        
        public static GetGraphicsFormat($format: UnityEngine.RenderTextureFormat, $isSRGB: boolean):GraphicsFormat;
        
        public static GetGraphicsFormat($format: UnityEngine.RenderTextureFormat, $readWrite: UnityEngine.RenderTextureReadWrite):GraphicsFormat;
        
        public static IsSRGBFormat($format: GraphicsFormat):boolean;
        
        public static IsSwizzleFormat($format: GraphicsFormat):boolean;
        
        public static GetSRGBFormat($format: GraphicsFormat):GraphicsFormat;
        
        public static GetLinearFormat($format: GraphicsFormat):GraphicsFormat;
        
        public static GetRenderTextureFormat($format: GraphicsFormat):UnityEngine.RenderTextureFormat;
        
        public static GetColorComponentCount($format: GraphicsFormat):number;
        
        public static GetAlphaComponentCount($format: GraphicsFormat):number;
        
        public static GetComponentCount($format: GraphicsFormat):number;
        
        public static GetFormatString($format: GraphicsFormat):string;
        
        public static IsCompressedFormat($format: GraphicsFormat):boolean;
        
        public static IsPackedFormat($format: GraphicsFormat):boolean;
        
        public static Is16BitPackedFormat($format: GraphicsFormat):boolean;
        
        public static ConvertToAlphaFormat($format: GraphicsFormat):GraphicsFormat;
        
        public static IsAlphaOnlyFormat($format: GraphicsFormat):boolean;
        
        public static IsAlphaTestFormat($format: GraphicsFormat):boolean;
        
        public static HasAlphaChannel($format: GraphicsFormat):boolean;
        
        public static IsDepthFormat($format: GraphicsFormat):boolean;
        
        public static IsStencilFormat($format: GraphicsFormat):boolean;
        
        public static IsIEEE754Format($format: GraphicsFormat):boolean;
        
        public static IsFloatFormat($format: GraphicsFormat):boolean;
        
        public static IsHalfFormat($format: GraphicsFormat):boolean;
        
        public static IsUnsignedFormat($format: GraphicsFormat):boolean;
        
        public static IsSignedFormat($format: GraphicsFormat):boolean;
        
        public static IsNormFormat($format: GraphicsFormat):boolean;
        
        public static IsUNormFormat($format: GraphicsFormat):boolean;
        
        public static IsSNormFormat($format: GraphicsFormat):boolean;
        
        public static IsIntegerFormat($format: GraphicsFormat):boolean;
        
        public static IsUIntFormat($format: GraphicsFormat):boolean;
        
        public static IsSIntFormat($format: GraphicsFormat):boolean;
        
        public static IsXRFormat($format: GraphicsFormat):boolean;
        
        public static IsDXTCFormat($format: GraphicsFormat):boolean;
        
        public static IsRGTCFormat($format: GraphicsFormat):boolean;
        
        public static IsBPTCFormat($format: GraphicsFormat):boolean;
        
        public static IsBCFormat($format: GraphicsFormat):boolean;
        
        public static IsPVRTCFormat($format: GraphicsFormat):boolean;
        
        public static IsETCFormat($format: GraphicsFormat):boolean;
        
        public static IsEACFormat($format: GraphicsFormat):boolean;
        
        public static IsASTCFormat($format: GraphicsFormat):boolean;
        
        public static IsCrunchFormat($format: UnityEngine.TextureFormat):boolean;
        
        public static GetSwizzleR($format: GraphicsFormat):UnityEngine_Rendering.FormatSwizzle;
        
        public static GetSwizzleG($format: GraphicsFormat):UnityEngine_Rendering.FormatSwizzle;
        
        public static GetSwizzleB($format: GraphicsFormat):UnityEngine_Rendering.FormatSwizzle;
        
        public static GetSwizzleA($format: GraphicsFormat):UnityEngine_Rendering.FormatSwizzle;
        
        public static GetBlockSize($format: GraphicsFormat):number;
        
        public static GetBlockWidth($format: GraphicsFormat):number;
        
        public static GetBlockHeight($format: GraphicsFormat):number;
        
        public static ComputeMipmapSize($width: number, $height: number, $format: GraphicsFormat):number;
        
        public static ComputeMipmapSize($width: number, $height: number, $depth: number, $format: GraphicsFormat):number;
        
                    
    }
    /**
     * The rendering configuration to use when prewarming shader variants.
     */
    class ShaderWarmupSetup extends System.ValueType {
        /**
         * The vertex data layout to use when prewarming shader variants.
         */
        public vdecl: UnityEngine_Rendering.VertexAttributeDescriptor[];
        
                    
    }
    /**
     * Prewarms shaders in a way that is supported by all graphics APIs.
     */
    class ShaderWarmup extends System.Object {
        /**
         * Prewarms all shader variants for a given Shader, using a given rendering configuration.
         */
        public static WarmupShader($shader: UnityEngine.Shader, $setup: ShaderWarmupSetup):void;
        /**
         * Prewarms the shader variants for a given Shader that are in a given ShaderVariantCollection, using a given rendering configuration.
         */
        public static WarmupShaderFromCollection($collection: UnityEngine.ShaderVariantCollection, $shader: UnityEngine.Shader, $setup: ShaderWarmupSetup):void;
        
                    
    }
    
}
declare module 'UnityEngine.Rendering' {

    import * as System from 'System';
    import * as UnityEngine from 'UnityEngine';
    import * as UnityEngine_Experimental_Rendering from 'UnityEngine.Experimental.Rendering';
    import * as Unity_Collections from 'Unity.Collections';
    import * as UnityEngine_Profiling from 'UnityEngine.Profiling';
    import * as System_Collections_Generic from 'System.Collections.Generic';
    import * as UnityEngine_Rendering_SplashScreen from 'UnityEngine.Rendering.SplashScreen';
    import * as UnityEngine_Rendering_SupportedRenderingFeatures from 'UnityEngine.Rendering.SupportedRenderingFeatures';
        
    /**
     * Texture "dimension" (type).
     */
    enum TextureDimension { Unknown = -1, None = 0, Any = 1, Tex2D = 2, Tex3D = 3, Cube = 4, Tex2DArray = 5, CubeArray = 6 }
    /**
     * The Graphics Tier Unity uses. You can only set a GraphicsTier in the Built-in Render Pipeline.
     * See Also: Graphics.activeTier.
     */
    enum GraphicsTier { Tier1 = 0, Tier2 = 1, Tier3 = 2 }
    /**
     * Specifies the OpenGL ES version.
     */
    enum OpenGLESVersion { None = 0, OpenGLES20 = 1, OpenGLES30 = 2, OpenGLES31 = 3, OpenGLES31AEP = 4, OpenGLES32 = 5 }
    /**
     * List of graphics commands to execute.
     */
    class CommandBuffer extends System.Object {
        /**
         * Name of this command buffer.
         */
        public get name(): string;
        public set name(value: string);
        /**
         * Size of this command buffer in bytes (Read Only).
         */
        public get sizeInBytes(): number;
        /**
         * Create a new empty command buffer.
         */
        public constructor();
        /**
         * Converts and copies a source texture to a destination texture with a different format or dimensions.
         * @param src Source texture.
         * @param dst Destination texture.
         * @param srcElement Source element (e.g. cubemap face). Set this to 0 for 2D source textures.
         * @param dstElement Destination element (e.g. cubemap face or texture array element).
         */
        public ConvertTexture($src: RenderTargetIdentifier, $dst: RenderTargetIdentifier):void;
        /**
         * Converts and copies a source texture to a destination texture with a different format or dimensions.
         * @param src Source texture.
         * @param dst Destination texture.
         * @param srcElement Source element (e.g. cubemap face). Set this to 0 for 2D source textures.
         * @param dstElement Destination element (e.g. cubemap face or texture array element).
         */
        public ConvertTexture($src: RenderTargetIdentifier, $srcElement: number, $dst: RenderTargetIdentifier, $dstElement: number):void;
        /**
         * Adds an "AsyncGPUReadback.WaitAllRequests" command to the CommandBuffer.
         */
        public WaitAllAsyncReadbackRequests():void;
        
        public RequestAsyncReadback($src: UnityEngine.ComputeBuffer, $callback: System.Action$1<AsyncGPUReadbackRequest>):void;
        
        public RequestAsyncReadback($src: UnityEngine.GraphicsBuffer, $callback: System.Action$1<AsyncGPUReadbackRequest>):void;
        
        public RequestAsyncReadback($src: UnityEngine.ComputeBuffer, $size: number, $offset: number, $callback: System.Action$1<AsyncGPUReadbackRequest>):void;
        
        public RequestAsyncReadback($src: UnityEngine.GraphicsBuffer, $size: number, $offset: number, $callback: System.Action$1<AsyncGPUReadbackRequest>):void;
        
        public RequestAsyncReadback($src: UnityEngine.Texture, $callback: System.Action$1<AsyncGPUReadbackRequest>):void;
        
        public RequestAsyncReadback($src: UnityEngine.Texture, $mipIndex: number, $callback: System.Action$1<AsyncGPUReadbackRequest>):void;
        
        public RequestAsyncReadback($src: UnityEngine.Texture, $mipIndex: number, $dstFormat: UnityEngine.TextureFormat, $callback: System.Action$1<AsyncGPUReadbackRequest>):void;
        
        public RequestAsyncReadback($src: UnityEngine.Texture, $mipIndex: number, $dstFormat: UnityEngine_Experimental_Rendering.GraphicsFormat, $callback: System.Action$1<AsyncGPUReadbackRequest>):void;
        
        public RequestAsyncReadback($src: UnityEngine.Texture, $mipIndex: number, $x: number, $width: number, $y: number, $height: number, $z: number, $depth: number, $callback: System.Action$1<AsyncGPUReadbackRequest>):void;
        
        public RequestAsyncReadback($src: UnityEngine.Texture, $mipIndex: number, $x: number, $width: number, $y: number, $height: number, $z: number, $depth: number, $dstFormat: UnityEngine.TextureFormat, $callback: System.Action$1<AsyncGPUReadbackRequest>):void;
        
        public RequestAsyncReadback($src: UnityEngine.Texture, $mipIndex: number, $x: number, $width: number, $y: number, $height: number, $z: number, $depth: number, $dstFormat: UnityEngine_Experimental_Rendering.GraphicsFormat, $callback: System.Action$1<AsyncGPUReadbackRequest>):void;
        
        public RequestAsyncReadbackIntoNativeArray<T>($output: $Ref<Unity_Collections.NativeArray$1<T>>, $src: UnityEngine.ComputeBuffer, $callback: System.Action$1<AsyncGPUReadbackRequest>):void;
        
        public RequestAsyncReadbackIntoNativeArray<T>($output: $Ref<Unity_Collections.NativeArray$1<T>>, $src: UnityEngine.ComputeBuffer, $size: number, $offset: number, $callback: System.Action$1<AsyncGPUReadbackRequest>):void;
        
        public RequestAsyncReadbackIntoNativeArray<T>($output: $Ref<Unity_Collections.NativeArray$1<T>>, $src: UnityEngine.GraphicsBuffer, $callback: System.Action$1<AsyncGPUReadbackRequest>):void;
        
        public RequestAsyncReadbackIntoNativeArray<T>($output: $Ref<Unity_Collections.NativeArray$1<T>>, $src: UnityEngine.GraphicsBuffer, $size: number, $offset: number, $callback: System.Action$1<AsyncGPUReadbackRequest>):void;
        
        public RequestAsyncReadbackIntoNativeArray<T>($output: $Ref<Unity_Collections.NativeArray$1<T>>, $src: UnityEngine.Texture, $callback: System.Action$1<AsyncGPUReadbackRequest>):void;
        
        public RequestAsyncReadbackIntoNativeArray<T>($output: $Ref<Unity_Collections.NativeArray$1<T>>, $src: UnityEngine.Texture, $mipIndex: number, $callback: System.Action$1<AsyncGPUReadbackRequest>):void;
        
        public RequestAsyncReadbackIntoNativeArray<T>($output: $Ref<Unity_Collections.NativeArray$1<T>>, $src: UnityEngine.Texture, $mipIndex: number, $dstFormat: UnityEngine.TextureFormat, $callback: System.Action$1<AsyncGPUReadbackRequest>):void;
        
        public RequestAsyncReadbackIntoNativeArray<T>($output: $Ref<Unity_Collections.NativeArray$1<T>>, $src: UnityEngine.Texture, $mipIndex: number, $dstFormat: UnityEngine_Experimental_Rendering.GraphicsFormat, $callback: System.Action$1<AsyncGPUReadbackRequest>):void;
        
        public RequestAsyncReadbackIntoNativeArray<T>($output: $Ref<Unity_Collections.NativeArray$1<T>>, $src: UnityEngine.Texture, $mipIndex: number, $x: number, $width: number, $y: number, $height: number, $z: number, $depth: number, $callback: System.Action$1<AsyncGPUReadbackRequest>):void;
        
        public RequestAsyncReadbackIntoNativeArray<T>($output: $Ref<Unity_Collections.NativeArray$1<T>>, $src: UnityEngine.Texture, $mipIndex: number, $x: number, $width: number, $y: number, $height: number, $z: number, $depth: number, $dstFormat: UnityEngine.TextureFormat, $callback: System.Action$1<AsyncGPUReadbackRequest>):void;
        
        public RequestAsyncReadbackIntoNativeArray<T>($output: $Ref<Unity_Collections.NativeArray$1<T>>, $src: UnityEngine.Texture, $mipIndex: number, $x: number, $width: number, $y: number, $height: number, $z: number, $depth: number, $dstFormat: UnityEngine_Experimental_Rendering.GraphicsFormat, $callback: System.Action$1<AsyncGPUReadbackRequest>):void;
        
        public RequestAsyncReadbackIntoNativeSlice<T>($output: $Ref<Unity_Collections.NativeSlice$1<T>>, $src: UnityEngine.ComputeBuffer, $callback: System.Action$1<AsyncGPUReadbackRequest>):void;
        
        public RequestAsyncReadbackIntoNativeSlice<T>($output: $Ref<Unity_Collections.NativeSlice$1<T>>, $src: UnityEngine.ComputeBuffer, $size: number, $offset: number, $callback: System.Action$1<AsyncGPUReadbackRequest>):void;
        
        public RequestAsyncReadbackIntoNativeSlice<T>($output: $Ref<Unity_Collections.NativeSlice$1<T>>, $src: UnityEngine.GraphicsBuffer, $callback: System.Action$1<AsyncGPUReadbackRequest>):void;
        
        public RequestAsyncReadbackIntoNativeSlice<T>($output: $Ref<Unity_Collections.NativeSlice$1<T>>, $src: UnityEngine.GraphicsBuffer, $size: number, $offset: number, $callback: System.Action$1<AsyncGPUReadbackRequest>):void;
        
        public RequestAsyncReadbackIntoNativeSlice<T>($output: $Ref<Unity_Collections.NativeSlice$1<T>>, $src: UnityEngine.Texture, $callback: System.Action$1<AsyncGPUReadbackRequest>):void;
        
        public RequestAsyncReadbackIntoNativeSlice<T>($output: $Ref<Unity_Collections.NativeSlice$1<T>>, $src: UnityEngine.Texture, $mipIndex: number, $callback: System.Action$1<AsyncGPUReadbackRequest>):void;
        
        public RequestAsyncReadbackIntoNativeSlice<T>($output: $Ref<Unity_Collections.NativeSlice$1<T>>, $src: UnityEngine.Texture, $mipIndex: number, $dstFormat: UnityEngine.TextureFormat, $callback: System.Action$1<AsyncGPUReadbackRequest>):void;
        
        public RequestAsyncReadbackIntoNativeSlice<T>($output: $Ref<Unity_Collections.NativeSlice$1<T>>, $src: UnityEngine.Texture, $mipIndex: number, $dstFormat: UnityEngine_Experimental_Rendering.GraphicsFormat, $callback: System.Action$1<AsyncGPUReadbackRequest>):void;
        
        public RequestAsyncReadbackIntoNativeSlice<T>($output: $Ref<Unity_Collections.NativeSlice$1<T>>, $src: UnityEngine.Texture, $mipIndex: number, $x: number, $width: number, $y: number, $height: number, $z: number, $depth: number, $callback: System.Action$1<AsyncGPUReadbackRequest>):void;
        
        public RequestAsyncReadbackIntoNativeSlice<T>($output: $Ref<Unity_Collections.NativeSlice$1<T>>, $src: UnityEngine.Texture, $mipIndex: number, $x: number, $width: number, $y: number, $height: number, $z: number, $depth: number, $dstFormat: UnityEngine.TextureFormat, $callback: System.Action$1<AsyncGPUReadbackRequest>):void;
        
        public RequestAsyncReadbackIntoNativeSlice<T>($output: $Ref<Unity_Collections.NativeSlice$1<T>>, $src: UnityEngine.Texture, $mipIndex: number, $x: number, $width: number, $y: number, $height: number, $z: number, $depth: number, $dstFormat: UnityEngine_Experimental_Rendering.GraphicsFormat, $callback: System.Action$1<AsyncGPUReadbackRequest>):void;
        /**
         * Add a "set invert culling" command to the buffer.
         * @param invertCulling A boolean indicating whether to invert the backface culling (true) or not (false).
         */
        public SetInvertCulling($invertCulling: boolean):void;
        /**
         * Adds a command to set a float parameter on a ComputeShader.
         * @param computeShader ComputeShader to set parameter for.
         * @param name Name of the variable in shader code.
         * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
         * @param val Value to set.
         */
        public SetComputeFloatParam($computeShader: UnityEngine.ComputeShader, $nameID: number, $val: number):void;
        /**
         * Adds a command to set an integer parameter on a ComputeShader.
         * @param computeShader ComputeShader to set parameter for.
         * @param name Name of the variable in shader code.
         * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
         * @param val Value to set.
         */
        public SetComputeIntParam($computeShader: UnityEngine.ComputeShader, $nameID: number, $val: number):void;
        /**
         * Adds a command to set a vector parameter on a ComputeShader.
         * @param computeShader ComputeShader to set parameter for.
         * @param name Name of the variable in shader code.
         * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
         * @param val Value to set.
         */
        public SetComputeVectorParam($computeShader: UnityEngine.ComputeShader, $nameID: number, $val: UnityEngine.Vector4):void;
        /**
         * Adds a command to set a vector array parameter on a ComputeShader.
         * @param computeShader ComputeShader to set parameter for.
         * @param name Property name.
         * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
         * @param values Value to set.
         */
        public SetComputeVectorArrayParam($computeShader: UnityEngine.ComputeShader, $nameID: number, $values: UnityEngine.Vector4[]):void;
        /**
         * Adds a command to set a matrix parameter on a ComputeShader.
         * @param computeShader ComputeShader to set parameter for.
         * @param name Name of the variable in shader code.
         * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
         * @param val Value to set.
         */
        public SetComputeMatrixParam($computeShader: UnityEngine.ComputeShader, $nameID: number, $val: UnityEngine.Matrix4x4):void;
        /**
         * Adds a command to set a matrix array parameter on a ComputeShader.
         * @param computeShader ComputeShader to set parameter for.
         * @param name Name of the variable in shader code.
         * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
         * @param values Value to set.
         */
        public SetComputeMatrixArrayParam($computeShader: UnityEngine.ComputeShader, $nameID: number, $values: UnityEngine.Matrix4x4[]):void;
        /**
         * Adds a command to select which Shader Pass to use when executing ray/geometry intersection shaders.
         * @param rayTracingShader RayTracingShader to set parameter for.
         * @param passName The Shader Pass to use when executing ray tracing shaders.
         */
        public SetRayTracingShaderPass($rayTracingShader: UnityEngine_Experimental_Rendering.RayTracingShader, $passName: string):void;
        /**
         * Clear all commands in the buffer.
         */
        public Clear():void;
        /**
         * Clear random write targets for level pixel shaders.
         */
        public ClearRandomWriteTargets():void;
        /**
         * Add a command to set the rendering viewport.
         * @param pixelRect Viewport rectangle in pixel coordinates.
         */
        public SetViewport($pixelRect: UnityEngine.Rect):void;
        /**
         * Add a command to enable the hardware scissor rectangle.
         * @param scissor Viewport rectangle in pixel coordinates.
         */
        public EnableScissorRect($scissor: UnityEngine.Rect):void;
        /**
         * Add a command to disable the hardware scissor rectangle.
         */
        public DisableScissorRect():void;
        
        public GetTemporaryRT($nameID: number, $width: number, $height: number, $depthBuffer: number, $filter: UnityEngine.FilterMode, $format: UnityEngine_Experimental_Rendering.GraphicsFormat, $antiAliasing: number, $enableRandomWrite: boolean, $memorylessMode: UnityEngine.RenderTextureMemoryless, $useDynamicScale: boolean):void;
        
        public GetTemporaryRT($nameID: number, $width: number, $height: number, $depthBuffer: number, $filter: UnityEngine.FilterMode, $format: UnityEngine_Experimental_Rendering.GraphicsFormat, $antiAliasing: number, $enableRandomWrite: boolean, $memorylessMode: UnityEngine.RenderTextureMemoryless):void;
        
        public GetTemporaryRT($nameID: number, $width: number, $height: number, $depthBuffer: number, $filter: UnityEngine.FilterMode, $format: UnityEngine_Experimental_Rendering.GraphicsFormat, $antiAliasing: number, $enableRandomWrite: boolean):void;
        
        public GetTemporaryRT($nameID: number, $width: number, $height: number, $depthBuffer: number, $filter: UnityEngine.FilterMode, $format: UnityEngine_Experimental_Rendering.GraphicsFormat, $antiAliasing: number):void;
        
        public GetTemporaryRT($nameID: number, $width: number, $height: number, $depthBuffer: number, $filter: UnityEngine.FilterMode, $format: UnityEngine_Experimental_Rendering.GraphicsFormat):void;
        
        public GetTemporaryRT($nameID: number, $width: number, $height: number, $depthBuffer: number, $filter: UnityEngine.FilterMode, $format: UnityEngine.RenderTextureFormat, $readWrite: UnityEngine.RenderTextureReadWrite, $antiAliasing: number, $enableRandomWrite: boolean, $memorylessMode: UnityEngine.RenderTextureMemoryless, $useDynamicScale: boolean):void;
        
        public GetTemporaryRT($nameID: number, $width: number, $height: number, $depthBuffer: number, $filter: UnityEngine.FilterMode, $format: UnityEngine.RenderTextureFormat, $readWrite: UnityEngine.RenderTextureReadWrite, $antiAliasing: number, $enableRandomWrite: boolean, $memorylessMode: UnityEngine.RenderTextureMemoryless):void;
        /**
         * Add a "get a temporary render texture" command.
         * @param nameID Shader property name for this texture.
         * @param width Width in pixels, or -1 for "camera pixel width".
         * @param height Height in pixels, or -1 for "camera pixel height".
         * @param depthBuffer Depth buffer bits (0, 16 or 24).
         * @param filter Texture filtering mode (default is Point).
         * @param format Format of the render texture (default is ARGB32).
         * @param readWrite Color space conversion mode.
         * @param antiAliasing Anti-aliasing (default is no anti-aliasing).
         * @param enableRandomWrite Should random-write access into the texture be enabled (default is false).
         * @param desc Use this RenderTextureDescriptor for the settings when creating the temporary RenderTexture.
         * @param memorylessMode Render texture memoryless mode.
         */
        public GetTemporaryRT($nameID: number, $width: number, $height: number, $depthBuffer: number, $filter: UnityEngine.FilterMode, $format: UnityEngine.RenderTextureFormat, $readWrite: UnityEngine.RenderTextureReadWrite, $antiAliasing: number, $enableRandomWrite: boolean):void;
        
        public GetTemporaryRT($nameID: number, $width: number, $height: number, $depthBuffer: number, $filter: UnityEngine.FilterMode, $format: UnityEngine.RenderTextureFormat, $readWrite: UnityEngine.RenderTextureReadWrite, $antiAliasing: number):void;
        
        public GetTemporaryRT($nameID: number, $width: number, $height: number, $depthBuffer: number, $filter: UnityEngine.FilterMode, $format: UnityEngine.RenderTextureFormat, $readWrite: UnityEngine.RenderTextureReadWrite):void;
        
        public GetTemporaryRT($nameID: number, $width: number, $height: number, $depthBuffer: number, $filter: UnityEngine.FilterMode, $format: UnityEngine.RenderTextureFormat):void;
        
        public GetTemporaryRT($nameID: number, $width: number, $height: number, $depthBuffer: number, $filter: UnityEngine.FilterMode):void;
        
        public GetTemporaryRT($nameID: number, $width: number, $height: number, $depthBuffer: number):void;
        
        public GetTemporaryRT($nameID: number, $width: number, $height: number):void;
        /**
         * Add a "get a temporary render texture" command.
         * @param nameID Shader property name for this texture.
         * @param width Width in pixels, or -1 for "camera pixel width".
         * @param height Height in pixels, or -1 for "camera pixel height".
         * @param depthBuffer Depth buffer bits (0, 16 or 24).
         * @param filter Texture filtering mode (default is Point).
         * @param format Format of the render texture (default is ARGB32).
         * @param readWrite Color space conversion mode.
         * @param antiAliasing Anti-aliasing (default is no anti-aliasing).
         * @param enableRandomWrite Should random-write access into the texture be enabled (default is false).
         * @param desc Use this RenderTextureDescriptor for the settings when creating the temporary RenderTexture.
         * @param memorylessMode Render texture memoryless mode.
         */
        public GetTemporaryRT($nameID: number, $desc: UnityEngine.RenderTextureDescriptor, $filter: UnityEngine.FilterMode):void;
        
        public GetTemporaryRT($nameID: number, $desc: UnityEngine.RenderTextureDescriptor):void;
        
        public GetTemporaryRTArray($nameID: number, $width: number, $height: number, $slices: number, $depthBuffer: number, $filter: UnityEngine.FilterMode, $format: UnityEngine_Experimental_Rendering.GraphicsFormat, $antiAliasing: number, $enableRandomWrite: boolean, $useDynamicScale: boolean):void;
        
        public GetTemporaryRTArray($nameID: number, $width: number, $height: number, $slices: number, $depthBuffer: number, $filter: UnityEngine.FilterMode, $format: UnityEngine_Experimental_Rendering.GraphicsFormat, $antiAliasing: number, $enableRandomWrite: boolean):void;
        
        public GetTemporaryRTArray($nameID: number, $width: number, $height: number, $slices: number, $depthBuffer: number, $filter: UnityEngine.FilterMode, $format: UnityEngine_Experimental_Rendering.GraphicsFormat, $antiAliasing: number):void;
        
        public GetTemporaryRTArray($nameID: number, $width: number, $height: number, $slices: number, $depthBuffer: number, $filter: UnityEngine.FilterMode, $format: UnityEngine_Experimental_Rendering.GraphicsFormat):void;
        /**
         * Add a "get a temporary render texture array" command.
         * @param nameID Shader property name for this texture.
         * @param width Width in pixels, or -1 for "camera pixel width".
         * @param height Height in pixels, or -1 for "camera pixel height".
         * @param slices Number of slices in texture array.
         * @param depthBuffer Depth buffer bits (0, 16 or 24).
         * @param filter Texture filtering mode (default is Point).
         * @param format Format of the render texture (default is ARGB32).
         * @param readWrite Color space conversion mode.
         * @param antiAliasing Anti-aliasing (default is no anti-aliasing).
         * @param enableRandomWrite Should random-write access into the texture be enabled (default is false).
         */
        public GetTemporaryRTArray($nameID: number, $width: number, $height: number, $slices: number, $depthBuffer: number, $filter: UnityEngine.FilterMode, $format: UnityEngine.RenderTextureFormat, $readWrite: UnityEngine.RenderTextureReadWrite, $antiAliasing: number, $enableRandomWrite: boolean):void;
        
        public GetTemporaryRTArray($nameID: number, $width: number, $height: number, $slices: number, $depthBuffer: number, $filter: UnityEngine.FilterMode, $format: UnityEngine.RenderTextureFormat, $readWrite: UnityEngine.RenderTextureReadWrite, $antiAliasing: number):void;
        
        public GetTemporaryRTArray($nameID: number, $width: number, $height: number, $slices: number, $depthBuffer: number, $filter: UnityEngine.FilterMode, $format: UnityEngine.RenderTextureFormat, $readWrite: UnityEngine.RenderTextureReadWrite):void;
        
        public GetTemporaryRTArray($nameID: number, $width: number, $height: number, $slices: number, $depthBuffer: number, $filter: UnityEngine.FilterMode, $format: UnityEngine.RenderTextureFormat):void;
        
        public GetTemporaryRTArray($nameID: number, $width: number, $height: number, $slices: number, $depthBuffer: number, $filter: UnityEngine.FilterMode):void;
        
        public GetTemporaryRTArray($nameID: number, $width: number, $height: number, $slices: number, $depthBuffer: number):void;
        
        public GetTemporaryRTArray($nameID: number, $width: number, $height: number, $slices: number):void;
        /**
         * Add a "release a temporary render texture" command.
         * @param nameID Shader property name for this texture.
         */
        public ReleaseTemporaryRT($nameID: number):void;
        /**
         * Adds a "clear render target" command.
         * @param clearDepth Should clear depth buffer?
         * @param clearColor Should clear color buffer?
         * @param backgroundColor Color to clear with.
         * @param depth Depth to clear with (default is 1.0).
         */
        public ClearRenderTarget($clearDepth: boolean, $clearColor: boolean, $backgroundColor: UnityEngine.Color, $depth: number):void;
        
        public ClearRenderTarget($clearDepth: boolean, $clearColor: boolean, $backgroundColor: UnityEngine.Color):void;
        /**
         * Add a "set global shader float property" command.
         */
        public SetGlobalFloat($nameID: number, $value: number):void;
        /**
         * Sets the given global integer property for all shaders.
         */
        public SetGlobalInt($nameID: number, $value: number):void;
        /**
         * Add a "set global shader vector property" command.
         */
        public SetGlobalVector($nameID: number, $value: UnityEngine.Vector4):void;
        /**
         * Add a "set global shader color property" command.
         */
        public SetGlobalColor($nameID: number, $value: UnityEngine.Color):void;
        /**
         * Add a "set global shader matrix property" command.
         */
        public SetGlobalMatrix($nameID: number, $value: UnityEngine.Matrix4x4):void;
        /**
         * Adds a command to enable global shader keyword.
         * @param keyword Shader keyword to enable.
         */
        public EnableShaderKeyword($keyword: string):void;
        /**
         * Adds a command to disable global shader keyword.
         * @param keyword Shader keyword to disable.
         */
        public DisableShaderKeyword($keyword: string):void;
        /**
         * Add a command to set the view matrix.
         * @param view View (world to camera space) matrix.
         */
        public SetViewMatrix($view: UnityEngine.Matrix4x4):void;
        /**
         * Add a command to set the projection matrix.
         * @param proj Projection (camera to clip space) matrix.
         */
        public SetProjectionMatrix($proj: UnityEngine.Matrix4x4):void;
        /**
         * Add a command to set the view and projection matrices.
         * @param view View (world to camera space) matrix.
         * @param proj Projection (camera to clip space) matrix.
         */
        public SetViewProjectionMatrices($view: UnityEngine.Matrix4x4, $proj: UnityEngine.Matrix4x4):void;
        /**
         * Add a command to set global depth bias.
         * @param bias Constant depth bias.
         * @param slopeBias Slope-dependent depth bias.
         */
        public SetGlobalDepthBias($bias: number, $slopeBias: number):void;
        /**
         * Set flags describing the intention for how the command buffer will be executed.
         * @param flags The flags to set.
         */
        public SetExecutionFlags($flags: CommandBufferExecutionFlags):void;
        /**
         * Add a "set global shader float array property" command.
         */
        public SetGlobalFloatArray($nameID: number, $values: number[]):void;
        /**
         * Add a "set global shader vector array property" command.
         */
        public SetGlobalVectorArray($nameID: number, $values: UnityEngine.Vector4[]):void;
        /**
         * Add a "set global shader matrix array property" command.
         */
        public SetGlobalMatrixArray($nameID: number, $values: UnityEngine.Matrix4x4[]):void;
        /**
         * Adds a command to begin profile sampling.
         * @param name Name of the profile information used for sampling.
         * @param sampler The CustomSampler that the CommandBuffer uses for sampling.
         */
        public BeginSample($name: string):void;
        /**
         * Adds a command to begin profile sampling.
         * @param name Name of the profile information used for sampling.
         * @param sampler The CustomSampler that the CommandBuffer uses for sampling.
         */
        public EndSample($name: string):void;
        /**
         * Adds a command to begin profile sampling.
         * @param name Name of the profile information used for sampling.
         * @param sampler The CustomSampler that the CommandBuffer uses for sampling.
         */
        public BeginSample($sampler: UnityEngine_Profiling.CustomSampler):void;
        /**
         * Adds a command to begin profile sampling.
         * @param name Name of the profile information used for sampling.
         * @param sampler The CustomSampler that the CommandBuffer uses for sampling.
         */
        public EndSample($sampler: UnityEngine_Profiling.CustomSampler):void;
        /**
         * Increments the updateCount property of a Texture.
         * @param dest Increments the updateCount for this Texture.
         */
        public IncrementUpdateCount($dest: RenderTargetIdentifier):void;
        /**
         * Adds a command to multiply the instance count of every draw call by a specific multiplier.
         */
        public SetInstanceMultiplier($multiplier: number):void;
        /**
         * Add a "set active render target" command.
         * @param rt Render target to set for both color & depth buffers.
         * @param color Render target to set as a color buffer.
         * @param colors Render targets to set as color buffers (MRT).
         * @param depth Render target to set as a depth buffer.
         * @param mipLevel The mip level of the render target to render into.
         * @param cubemapFace The cubemap face of a cubemap render target to render into.
         * @param depthSlice Slice of a 3D or array render target to set.
         * @param loadAction Load action that is used for color and depth/stencil buffers.
         * @param storeAction Store action that is used for color and depth/stencil buffers.
         * @param colorLoadAction Load action that is used for the color buffer.
         * @param colorStoreAction Store action that is used for the color buffer.
         * @param depthLoadAction Load action that is used for the depth/stencil buffer.
         * @param depthStoreAction Store action that is used for the depth/stencil buffer.
         */
        public SetRenderTarget($rt: RenderTargetIdentifier):void;
        /**
         * Add a "set active render target" command.
         * @param rt Render target to set for both color & depth buffers.
         * @param color Render target to set as a color buffer.
         * @param colors Render targets to set as color buffers (MRT).
         * @param depth Render target to set as a depth buffer.
         * @param mipLevel The mip level of the render target to render into.
         * @param cubemapFace The cubemap face of a cubemap render target to render into.
         * @param depthSlice Slice of a 3D or array render target to set.
         * @param loadAction Load action that is used for color and depth/stencil buffers.
         * @param storeAction Store action that is used for color and depth/stencil buffers.
         * @param colorLoadAction Load action that is used for the color buffer.
         * @param colorStoreAction Store action that is used for the color buffer.
         * @param depthLoadAction Load action that is used for the depth/stencil buffer.
         * @param depthStoreAction Store action that is used for the depth/stencil buffer.
         */
        public SetRenderTarget($rt: RenderTargetIdentifier, $loadAction: RenderBufferLoadAction, $storeAction: RenderBufferStoreAction):void;
        /**
         * Add a "set active render target" command.
         * @param rt Render target to set for both color & depth buffers.
         * @param color Render target to set as a color buffer.
         * @param colors Render targets to set as color buffers (MRT).
         * @param depth Render target to set as a depth buffer.
         * @param mipLevel The mip level of the render target to render into.
         * @param cubemapFace The cubemap face of a cubemap render target to render into.
         * @param depthSlice Slice of a 3D or array render target to set.
         * @param loadAction Load action that is used for color and depth/stencil buffers.
         * @param storeAction Store action that is used for color and depth/stencil buffers.
         * @param colorLoadAction Load action that is used for the color buffer.
         * @param colorStoreAction Store action that is used for the color buffer.
         * @param depthLoadAction Load action that is used for the depth/stencil buffer.
         * @param depthStoreAction Store action that is used for the depth/stencil buffer.
         */
        public SetRenderTarget($rt: RenderTargetIdentifier, $colorLoadAction: RenderBufferLoadAction, $colorStoreAction: RenderBufferStoreAction, $depthLoadAction: RenderBufferLoadAction, $depthStoreAction: RenderBufferStoreAction):void;
        /**
         * Add a "set active render target" command.
         * @param rt Render target to set for both color & depth buffers.
         * @param color Render target to set as a color buffer.
         * @param colors Render targets to set as color buffers (MRT).
         * @param depth Render target to set as a depth buffer.
         * @param mipLevel The mip level of the render target to render into.
         * @param cubemapFace The cubemap face of a cubemap render target to render into.
         * @param depthSlice Slice of a 3D or array render target to set.
         * @param loadAction Load action that is used for color and depth/stencil buffers.
         * @param storeAction Store action that is used for color and depth/stencil buffers.
         * @param colorLoadAction Load action that is used for the color buffer.
         * @param colorStoreAction Store action that is used for the color buffer.
         * @param depthLoadAction Load action that is used for the depth/stencil buffer.
         * @param depthStoreAction Store action that is used for the depth/stencil buffer.
         */
        public SetRenderTarget($rt: RenderTargetIdentifier, $mipLevel: number):void;
        /**
         * Add a "set active render target" command.
         * @param rt Render target to set for both color & depth buffers.
         * @param color Render target to set as a color buffer.
         * @param colors Render targets to set as color buffers (MRT).
         * @param depth Render target to set as a depth buffer.
         * @param mipLevel The mip level of the render target to render into.
         * @param cubemapFace The cubemap face of a cubemap render target to render into.
         * @param depthSlice Slice of a 3D or array render target to set.
         * @param loadAction Load action that is used for color and depth/stencil buffers.
         * @param storeAction Store action that is used for color and depth/stencil buffers.
         * @param colorLoadAction Load action that is used for the color buffer.
         * @param colorStoreAction Store action that is used for the color buffer.
         * @param depthLoadAction Load action that is used for the depth/stencil buffer.
         * @param depthStoreAction Store action that is used for the depth/stencil buffer.
         */
        public SetRenderTarget($rt: RenderTargetIdentifier, $mipLevel: number, $cubemapFace: UnityEngine.CubemapFace):void;
        /**
         * Add a "set active render target" command.
         * @param rt Render target to set for both color & depth buffers.
         * @param color Render target to set as a color buffer.
         * @param colors Render targets to set as color buffers (MRT).
         * @param depth Render target to set as a depth buffer.
         * @param mipLevel The mip level of the render target to render into.
         * @param cubemapFace The cubemap face of a cubemap render target to render into.
         * @param depthSlice Slice of a 3D or array render target to set.
         * @param loadAction Load action that is used for color and depth/stencil buffers.
         * @param storeAction Store action that is used for color and depth/stencil buffers.
         * @param colorLoadAction Load action that is used for the color buffer.
         * @param colorStoreAction Store action that is used for the color buffer.
         * @param depthLoadAction Load action that is used for the depth/stencil buffer.
         * @param depthStoreAction Store action that is used for the depth/stencil buffer.
         */
        public SetRenderTarget($rt: RenderTargetIdentifier, $mipLevel: number, $cubemapFace: UnityEngine.CubemapFace, $depthSlice: number):void;
        /**
         * Add a "set active render target" command.
         * @param rt Render target to set for both color & depth buffers.
         * @param color Render target to set as a color buffer.
         * @param colors Render targets to set as color buffers (MRT).
         * @param depth Render target to set as a depth buffer.
         * @param mipLevel The mip level of the render target to render into.
         * @param cubemapFace The cubemap face of a cubemap render target to render into.
         * @param depthSlice Slice of a 3D or array render target to set.
         * @param loadAction Load action that is used for color and depth/stencil buffers.
         * @param storeAction Store action that is used for color and depth/stencil buffers.
         * @param colorLoadAction Load action that is used for the color buffer.
         * @param colorStoreAction Store action that is used for the color buffer.
         * @param depthLoadAction Load action that is used for the depth/stencil buffer.
         * @param depthStoreAction Store action that is used for the depth/stencil buffer.
         */
        public SetRenderTarget($color: RenderTargetIdentifier, $depth: RenderTargetIdentifier):void;
        /**
         * Add a "set active render target" command.
         * @param rt Render target to set for both color & depth buffers.
         * @param color Render target to set as a color buffer.
         * @param colors Render targets to set as color buffers (MRT).
         * @param depth Render target to set as a depth buffer.
         * @param mipLevel The mip level of the render target to render into.
         * @param cubemapFace The cubemap face of a cubemap render target to render into.
         * @param depthSlice Slice of a 3D or array render target to set.
         * @param loadAction Load action that is used for color and depth/stencil buffers.
         * @param storeAction Store action that is used for color and depth/stencil buffers.
         * @param colorLoadAction Load action that is used for the color buffer.
         * @param colorStoreAction Store action that is used for the color buffer.
         * @param depthLoadAction Load action that is used for the depth/stencil buffer.
         * @param depthStoreAction Store action that is used for the depth/stencil buffer.
         */
        public SetRenderTarget($color: RenderTargetIdentifier, $depth: RenderTargetIdentifier, $mipLevel: number):void;
        /**
         * Add a "set active render target" command.
         * @param rt Render target to set for both color & depth buffers.
         * @param color Render target to set as a color buffer.
         * @param colors Render targets to set as color buffers (MRT).
         * @param depth Render target to set as a depth buffer.
         * @param mipLevel The mip level of the render target to render into.
         * @param cubemapFace The cubemap face of a cubemap render target to render into.
         * @param depthSlice Slice of a 3D or array render target to set.
         * @param loadAction Load action that is used for color and depth/stencil buffers.
         * @param storeAction Store action that is used for color and depth/stencil buffers.
         * @param colorLoadAction Load action that is used for the color buffer.
         * @param colorStoreAction Store action that is used for the color buffer.
         * @param depthLoadAction Load action that is used for the depth/stencil buffer.
         * @param depthStoreAction Store action that is used for the depth/stencil buffer.
         */
        public SetRenderTarget($color: RenderTargetIdentifier, $depth: RenderTargetIdentifier, $mipLevel: number, $cubemapFace: UnityEngine.CubemapFace):void;
        /**
         * Add a "set active render target" command.
         * @param rt Render target to set for both color & depth buffers.
         * @param color Render target to set as a color buffer.
         * @param colors Render targets to set as color buffers (MRT).
         * @param depth Render target to set as a depth buffer.
         * @param mipLevel The mip level of the render target to render into.
         * @param cubemapFace The cubemap face of a cubemap render target to render into.
         * @param depthSlice Slice of a 3D or array render target to set.
         * @param loadAction Load action that is used for color and depth/stencil buffers.
         * @param storeAction Store action that is used for color and depth/stencil buffers.
         * @param colorLoadAction Load action that is used for the color buffer.
         * @param colorStoreAction Store action that is used for the color buffer.
         * @param depthLoadAction Load action that is used for the depth/stencil buffer.
         * @param depthStoreAction Store action that is used for the depth/stencil buffer.
         */
        public SetRenderTarget($color: RenderTargetIdentifier, $depth: RenderTargetIdentifier, $mipLevel: number, $cubemapFace: UnityEngine.CubemapFace, $depthSlice: number):void;
        /**
         * Add a "set active render target" command.
         * @param rt Render target to set for both color & depth buffers.
         * @param color Render target to set as a color buffer.
         * @param colors Render targets to set as color buffers (MRT).
         * @param depth Render target to set as a depth buffer.
         * @param mipLevel The mip level of the render target to render into.
         * @param cubemapFace The cubemap face of a cubemap render target to render into.
         * @param depthSlice Slice of a 3D or array render target to set.
         * @param loadAction Load action that is used for color and depth/stencil buffers.
         * @param storeAction Store action that is used for color and depth/stencil buffers.
         * @param colorLoadAction Load action that is used for the color buffer.
         * @param colorStoreAction Store action that is used for the color buffer.
         * @param depthLoadAction Load action that is used for the depth/stencil buffer.
         * @param depthStoreAction Store action that is used for the depth/stencil buffer.
         */
        public SetRenderTarget($color: RenderTargetIdentifier, $colorLoadAction: RenderBufferLoadAction, $colorStoreAction: RenderBufferStoreAction, $depth: RenderTargetIdentifier, $depthLoadAction: RenderBufferLoadAction, $depthStoreAction: RenderBufferStoreAction):void;
        /**
         * Add a "set active render target" command.
         * @param rt Render target to set for both color & depth buffers.
         * @param color Render target to set as a color buffer.
         * @param colors Render targets to set as color buffers (MRT).
         * @param depth Render target to set as a depth buffer.
         * @param mipLevel The mip level of the render target to render into.
         * @param cubemapFace The cubemap face of a cubemap render target to render into.
         * @param depthSlice Slice of a 3D or array render target to set.
         * @param loadAction Load action that is used for color and depth/stencil buffers.
         * @param storeAction Store action that is used for color and depth/stencil buffers.
         * @param colorLoadAction Load action that is used for the color buffer.
         * @param colorStoreAction Store action that is used for the color buffer.
         * @param depthLoadAction Load action that is used for the depth/stencil buffer.
         * @param depthStoreAction Store action that is used for the depth/stencil buffer.
         */
        public SetRenderTarget($colors: RenderTargetIdentifier[], $depth: RenderTargetIdentifier):void;
        /**
         * Add a "set active render target" command.
         * @param rt Render target to set for both color & depth buffers.
         * @param color Render target to set as a color buffer.
         * @param colors Render targets to set as color buffers (MRT).
         * @param depth Render target to set as a depth buffer.
         * @param mipLevel The mip level of the render target to render into.
         * @param cubemapFace The cubemap face of a cubemap render target to render into.
         * @param depthSlice Slice of a 3D or array render target to set.
         * @param loadAction Load action that is used for color and depth/stencil buffers.
         * @param storeAction Store action that is used for color and depth/stencil buffers.
         * @param colorLoadAction Load action that is used for the color buffer.
         * @param colorStoreAction Store action that is used for the color buffer.
         * @param depthLoadAction Load action that is used for the depth/stencil buffer.
         * @param depthStoreAction Store action that is used for the depth/stencil buffer.
         */
        public SetRenderTarget($colors: RenderTargetIdentifier[], $depth: RenderTargetIdentifier, $mipLevel: number, $cubemapFace: UnityEngine.CubemapFace, $depthSlice: number):void;
        /**
         * Add a "set active render target" command.
         * @param rt Render target to set for both color & depth buffers.
         * @param color Render target to set as a color buffer.
         * @param colors Render targets to set as color buffers (MRT).
         * @param depth Render target to set as a depth buffer.
         * @param mipLevel The mip level of the render target to render into.
         * @param cubemapFace The cubemap face of a cubemap render target to render into.
         * @param depthSlice Slice of a 3D or array render target to set.
         * @param loadAction Load action that is used for color and depth/stencil buffers.
         * @param storeAction Store action that is used for color and depth/stencil buffers.
         * @param colorLoadAction Load action that is used for the color buffer.
         * @param colorStoreAction Store action that is used for the color buffer.
         * @param depthLoadAction Load action that is used for the depth/stencil buffer.
         * @param depthStoreAction Store action that is used for the depth/stencil buffer.
         */
        public SetRenderTarget($binding: RenderTargetBinding, $mipLevel: number, $cubemapFace: UnityEngine.CubemapFace, $depthSlice: number):void;
        /**
         * Add a "set active render target" command.
         * @param rt Render target to set for both color & depth buffers.
         * @param color Render target to set as a color buffer.
         * @param colors Render targets to set as color buffers (MRT).
         * @param depth Render target to set as a depth buffer.
         * @param mipLevel The mip level of the render target to render into.
         * @param cubemapFace The cubemap face of a cubemap render target to render into.
         * @param depthSlice Slice of a 3D or array render target to set.
         * @param loadAction Load action that is used for color and depth/stencil buffers.
         * @param storeAction Store action that is used for color and depth/stencil buffers.
         * @param colorLoadAction Load action that is used for the color buffer.
         * @param colorStoreAction Store action that is used for the color buffer.
         * @param depthLoadAction Load action that is used for the depth/stencil buffer.
         * @param depthStoreAction Store action that is used for the depth/stencil buffer.
         */
        public SetRenderTarget($binding: RenderTargetBinding):void;
        /**
         * Adds a command to set the buffer with values from an array.
         * @param buffer The destination buffer.
         * @param data Array of values to fill the buffer.
         */
        public SetComputeBufferData($buffer: UnityEngine.ComputeBuffer, $data: System.Array):void;
        
        public SetComputeBufferData<T>($buffer: UnityEngine.ComputeBuffer, $data: System_Collections_Generic.List$1<T>):void;
        
        public SetComputeBufferData<T>($buffer: UnityEngine.ComputeBuffer, $data: Unity_Collections.NativeArray$1<T>):void;
        /**
         * Adds a command to process a partial copy of data values from an array into the buffer.
         * @param buffer The destination buffer.
         * @param data Array of values to fill the buffer.
         * @param managedBufferStartIndex The first element index in data to copy to the compute buffer.
         * @param graphicsBufferStartIndex The first element index in compute buffer to receive the data.
         * @param count The number of elements to copy.
         * @param nativeBufferStartIndex The first element index in data to copy to the compute buffer.
         */
        public SetComputeBufferData($buffer: UnityEngine.ComputeBuffer, $data: System.Array, $managedBufferStartIndex: number, $graphicsBufferStartIndex: number, $count: number):void;
        
        public SetComputeBufferData<T>($buffer: UnityEngine.ComputeBuffer, $data: System_Collections_Generic.List$1<T>, $managedBufferStartIndex: number, $graphicsBufferStartIndex: number, $count: number):void;
        
        public SetComputeBufferData<T>($buffer: UnityEngine.ComputeBuffer, $data: Unity_Collections.NativeArray$1<T>, $nativeBufferStartIndex: number, $graphicsBufferStartIndex: number, $count: number):void;
        /**
         * Adds a command to set the counter value of append/consume buffer.
         * @param buffer The destination buffer.
         * @param counterValue Value of the append/consume counter.
         */
        public SetComputeBufferCounterValue($buffer: UnityEngine.ComputeBuffer, $counterValue: number):void;
        
        public Dispose():void;
        
        public Release():void;
        /**
         * Shortcut for calling GommandBuffer.CreateGraphicsFence with GraphicsFenceType.AsyncQueueSynchronization as the first parameter.
         * @param stage The synchronization stage. See Graphics.CreateGraphicsFence.
         * @returns Returns a new GraphicsFence.
         */
        public CreateAsyncGraphicsFence():GraphicsFence;
        /**
         * Shortcut for calling GommandBuffer.CreateGraphicsFence with GraphicsFenceType.AsyncQueueSynchronization as the first parameter.
         * @param stage The synchronization stage. See Graphics.CreateGraphicsFence.
         * @returns Returns a new GraphicsFence.
         */
        public CreateAsyncGraphicsFence($stage: SynchronisationStage):GraphicsFence;
        
        public CreateGraphicsFence($fenceType: GraphicsFenceType, $stage: SynchronisationStageFlags):GraphicsFence;
        /**
         * Instructs the GPU to wait until the given GraphicsFence is passed.
         * @param fence The GraphicsFence that the GPU will be instructed to wait upon before proceeding with its processing of the graphics queue.
         * @param stage On some platforms there is a significant gap between the vertex processing completing and the pixel processing beginning for a given draw call. This parameter allows for a requested wait to be made before the next item's vertex or pixel processing begins. If a compute shader dispatch is the next item to be submitted then this parameter is ignored.
         */
        public WaitOnAsyncGraphicsFence($fence: GraphicsFence):void;
        /**
         * Instructs the GPU to wait until the given GraphicsFence is passed.
         * @param fence The GraphicsFence that the GPU will be instructed to wait upon before proceeding with its processing of the graphics queue.
         * @param stage On some platforms there is a significant gap between the vertex processing completing and the pixel processing beginning for a given draw call. This parameter allows for a requested wait to be made before the next item's vertex or pixel processing begins. If a compute shader dispatch is the next item to be submitted then this parameter is ignored.
         */
        public WaitOnAsyncGraphicsFence($fence: GraphicsFence, $stage: SynchronisationStage):void;
        
        public WaitOnAsyncGraphicsFence($fence: GraphicsFence, $stage: SynchronisationStageFlags):void;
        /**
         * Adds a command to set a float parameter on a ComputeShader.
         * @param computeShader ComputeShader to set parameter for.
         * @param name Name of the variable in shader code.
         * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
         * @param val Value to set.
         */
        public SetComputeFloatParam($computeShader: UnityEngine.ComputeShader, $name: string, $val: number):void;
        /**
         * Adds a command to set an integer parameter on a ComputeShader.
         * @param computeShader ComputeShader to set parameter for.
         * @param name Name of the variable in shader code.
         * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
         * @param val Value to set.
         */
        public SetComputeIntParam($computeShader: UnityEngine.ComputeShader, $name: string, $val: number):void;
        /**
         * Adds a command to set a vector parameter on a ComputeShader.
         * @param computeShader ComputeShader to set parameter for.
         * @param name Name of the variable in shader code.
         * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
         * @param val Value to set.
         */
        public SetComputeVectorParam($computeShader: UnityEngine.ComputeShader, $name: string, $val: UnityEngine.Vector4):void;
        /**
         * Adds a command to set a vector array parameter on a ComputeShader.
         * @param computeShader ComputeShader to set parameter for.
         * @param name Property name.
         * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
         * @param values Value to set.
         */
        public SetComputeVectorArrayParam($computeShader: UnityEngine.ComputeShader, $name: string, $values: UnityEngine.Vector4[]):void;
        /**
         * Adds a command to set a matrix parameter on a ComputeShader.
         * @param computeShader ComputeShader to set parameter for.
         * @param name Name of the variable in shader code.
         * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
         * @param val Value to set.
         */
        public SetComputeMatrixParam($computeShader: UnityEngine.ComputeShader, $name: string, $val: UnityEngine.Matrix4x4):void;
        /**
         * Adds a command to set a matrix array parameter on a ComputeShader.
         * @param computeShader ComputeShader to set parameter for.
         * @param name Name of the variable in shader code.
         * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
         * @param values Value to set.
         */
        public SetComputeMatrixArrayParam($computeShader: UnityEngine.ComputeShader, $name: string, $values: UnityEngine.Matrix4x4[]):void;
        /**
         * Adds a command to set multiple consecutive float parameters on a ComputeShader.
         * @param computeShader ComputeShader to set parameter for.
         * @param name Name of the variable in shader code.
         * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
         * @param values Values to set.
         */
        public SetComputeFloatParams($computeShader: UnityEngine.ComputeShader, $name: string, ...values: number[]):void;
        /**
         * Adds a command to set multiple consecutive float parameters on a ComputeShader.
         * @param computeShader ComputeShader to set parameter for.
         * @param name Name of the variable in shader code.
         * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
         * @param values Values to set.
         */
        public SetComputeFloatParams($computeShader: UnityEngine.ComputeShader, $nameID: number, ...values: number[]):void;
        /**
         * Adds a command to set multiple consecutive integer parameters on a ComputeShader.
         * @param computeShader ComputeShader to set parameter for.
         * @param name Name of the variable in shader code.
         * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
         * @param values Values to set.
         */
        public SetComputeIntParams($computeShader: UnityEngine.ComputeShader, $name: string, ...values: number[]):void;
        /**
         * Adds a command to set multiple consecutive integer parameters on a ComputeShader.
         * @param computeShader ComputeShader to set parameter for.
         * @param name Name of the variable in shader code.
         * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
         * @param values Values to set.
         */
        public SetComputeIntParams($computeShader: UnityEngine.ComputeShader, $nameID: number, ...values: number[]):void;
        /**
         * Adds a command to set a texture parameter on a ComputeShader.
         * @param computeShader ComputeShader to set parameter for.
         * @param kernelIndex Which kernel the texture is being set for. See ComputeShader.FindKernel.
         * @param name Name of the texture variable in shader code.
         * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
         * @param rt Texture value or identifier to set, see RenderTargetIdentifier.
         * @param mipLevel Optional mipmap level of the read-write texture.
         * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
         */
        public SetComputeTextureParam($computeShader: UnityEngine.ComputeShader, $kernelIndex: number, $name: string, $rt: RenderTargetIdentifier):void;
        /**
         * Adds a command to set a texture parameter on a ComputeShader.
         * @param computeShader ComputeShader to set parameter for.
         * @param kernelIndex Which kernel the texture is being set for. See ComputeShader.FindKernel.
         * @param name Name of the texture variable in shader code.
         * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
         * @param rt Texture value or identifier to set, see RenderTargetIdentifier.
         * @param mipLevel Optional mipmap level of the read-write texture.
         * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
         */
        public SetComputeTextureParam($computeShader: UnityEngine.ComputeShader, $kernelIndex: number, $nameID: number, $rt: RenderTargetIdentifier):void;
        /**
         * Adds a command to set a texture parameter on a ComputeShader.
         * @param computeShader ComputeShader to set parameter for.
         * @param kernelIndex Which kernel the texture is being set for. See ComputeShader.FindKernel.
         * @param name Name of the texture variable in shader code.
         * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
         * @param rt Texture value or identifier to set, see RenderTargetIdentifier.
         * @param mipLevel Optional mipmap level of the read-write texture.
         * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
         */
        public SetComputeTextureParam($computeShader: UnityEngine.ComputeShader, $kernelIndex: number, $name: string, $rt: RenderTargetIdentifier, $mipLevel: number):void;
        /**
         * Adds a command to set a texture parameter on a ComputeShader.
         * @param computeShader ComputeShader to set parameter for.
         * @param kernelIndex Which kernel the texture is being set for. See ComputeShader.FindKernel.
         * @param name Name of the texture variable in shader code.
         * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
         * @param rt Texture value or identifier to set, see RenderTargetIdentifier.
         * @param mipLevel Optional mipmap level of the read-write texture.
         * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
         */
        public SetComputeTextureParam($computeShader: UnityEngine.ComputeShader, $kernelIndex: number, $nameID: number, $rt: RenderTargetIdentifier, $mipLevel: number):void;
        /**
         * Adds a command to set a texture parameter on a ComputeShader.
         * @param computeShader ComputeShader to set parameter for.
         * @param kernelIndex Which kernel the texture is being set for. See ComputeShader.FindKernel.
         * @param name Name of the texture variable in shader code.
         * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
         * @param rt Texture value or identifier to set, see RenderTargetIdentifier.
         * @param mipLevel Optional mipmap level of the read-write texture.
         * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
         */
        public SetComputeTextureParam($computeShader: UnityEngine.ComputeShader, $kernelIndex: number, $name: string, $rt: RenderTargetIdentifier, $mipLevel: number, $element: RenderTextureSubElement):void;
        /**
         * Adds a command to set a texture parameter on a ComputeShader.
         * @param computeShader ComputeShader to set parameter for.
         * @param kernelIndex Which kernel the texture is being set for. See ComputeShader.FindKernel.
         * @param name Name of the texture variable in shader code.
         * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
         * @param rt Texture value or identifier to set, see RenderTargetIdentifier.
         * @param mipLevel Optional mipmap level of the read-write texture.
         * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
         */
        public SetComputeTextureParam($computeShader: UnityEngine.ComputeShader, $kernelIndex: number, $nameID: number, $rt: RenderTargetIdentifier, $mipLevel: number, $element: RenderTextureSubElement):void;
        /**
         * Adds a command to set an input or output buffer parameter on a ComputeShader.
         * @param computeShader ComputeShader to set parameter for.
         * @param kernelIndex Which kernel the buffer is being set for. See ComputeShader.FindKernel.
         * @param name Name of the buffer variable in shader code.
         * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
         * @param buffer Buffer to set.
         */
        public SetComputeBufferParam($computeShader: UnityEngine.ComputeShader, $kernelIndex: number, $nameID: number, $buffer: UnityEngine.ComputeBuffer):void;
        /**
         * Adds a command to set an input or output buffer parameter on a ComputeShader.
         * @param computeShader ComputeShader to set parameter for.
         * @param kernelIndex Which kernel the buffer is being set for. See ComputeShader.FindKernel.
         * @param name Name of the buffer variable in shader code.
         * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
         * @param buffer Buffer to set.
         */
        public SetComputeBufferParam($computeShader: UnityEngine.ComputeShader, $kernelIndex: number, $name: string, $buffer: UnityEngine.ComputeBuffer):void;
        /**
         * Adds a command to set an input or output buffer parameter on a ComputeShader.
         * @param computeShader ComputeShader to set parameter for.
         * @param kernelIndex Which kernel the buffer is being set for. See ComputeShader.FindKernel.
         * @param name Name of the buffer variable in shader code.
         * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
         * @param buffer Buffer to set.
         */
        public SetComputeBufferParam($computeShader: UnityEngine.ComputeShader, $kernelIndex: number, $nameID: number, $buffer: UnityEngine.GraphicsBuffer):void;
        /**
         * Adds a command to set an input or output buffer parameter on a ComputeShader.
         * @param computeShader ComputeShader to set parameter for.
         * @param kernelIndex Which kernel the buffer is being set for. See ComputeShader.FindKernel.
         * @param name Name of the buffer variable in shader code.
         * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
         * @param buffer Buffer to set.
         */
        public SetComputeBufferParam($computeShader: UnityEngine.ComputeShader, $kernelIndex: number, $name: string, $buffer: UnityEngine.GraphicsBuffer):void;
        /**
         * Adds a command to set a constant buffer on a ComputeShader.
         * @param computeShader The ComputeShader to set parameter for.
         * @param nameID The ID of the property name for the constant buffer in shader code. Use Shader.PropertyToID to get this ID.
         * @param name The name of the constant buffer in shaders code.
         * @param buffer The buffer to bind as constant buffer.
         * @param offset The offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
         * @param size The number of bytes to bind.
         */
        public SetComputeConstantBufferParam($computeShader: UnityEngine.ComputeShader, $nameID: number, $buffer: UnityEngine.ComputeBuffer, $offset: number, $size: number):void;
        /**
         * Adds a command to set a constant buffer on a ComputeShader.
         * @param computeShader The ComputeShader to set parameter for.
         * @param nameID The ID of the property name for the constant buffer in shader code. Use Shader.PropertyToID to get this ID.
         * @param name The name of the constant buffer in shaders code.
         * @param buffer The buffer to bind as constant buffer.
         * @param offset The offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
         * @param size The number of bytes to bind.
         */
        public SetComputeConstantBufferParam($computeShader: UnityEngine.ComputeShader, $name: string, $buffer: UnityEngine.ComputeBuffer, $offset: number, $size: number):void;
        /**
         * Adds a command to set a constant buffer on a ComputeShader.
         * @param computeShader The ComputeShader to set parameter for.
         * @param nameID The ID of the property name for the constant buffer in shader code. Use Shader.PropertyToID to get this ID.
         * @param name The name of the constant buffer in shaders code.
         * @param buffer The buffer to bind as constant buffer.
         * @param offset The offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
         * @param size The number of bytes to bind.
         */
        public SetComputeConstantBufferParam($computeShader: UnityEngine.ComputeShader, $nameID: number, $buffer: UnityEngine.GraphicsBuffer, $offset: number, $size: number):void;
        /**
         * Adds a command to set a constant buffer on a ComputeShader.
         * @param computeShader The ComputeShader to set parameter for.
         * @param nameID The ID of the property name for the constant buffer in shader code. Use Shader.PropertyToID to get this ID.
         * @param name The name of the constant buffer in shaders code.
         * @param buffer The buffer to bind as constant buffer.
         * @param offset The offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
         * @param size The number of bytes to bind.
         */
        public SetComputeConstantBufferParam($computeShader: UnityEngine.ComputeShader, $name: string, $buffer: UnityEngine.GraphicsBuffer, $offset: number, $size: number):void;
        /**
         * Add a command to execute a ComputeShader.
         * @param computeShader ComputeShader to execute.
         * @param kernelIndex Kernel index to execute, see ComputeShader.FindKernel.
         * @param threadGroupsX Number of work groups in the X dimension.
         * @param threadGroupsY Number of work groups in the Y dimension.
         * @param threadGroupsZ Number of work groups in the Z dimension.
         * @param indirectBuffer ComputeBuffer with dispatch arguments.
         * @param argsOffset Byte offset indicating the location of the dispatch arguments in the buffer.
         */
        public DispatchCompute($computeShader: UnityEngine.ComputeShader, $kernelIndex: number, $threadGroupsX: number, $threadGroupsY: number, $threadGroupsZ: number):void;
        /**
         * Add a command to execute a ComputeShader.
         * @param computeShader ComputeShader to execute.
         * @param kernelIndex Kernel index to execute, see ComputeShader.FindKernel.
         * @param threadGroupsX Number of work groups in the X dimension.
         * @param threadGroupsY Number of work groups in the Y dimension.
         * @param threadGroupsZ Number of work groups in the Z dimension.
         * @param indirectBuffer ComputeBuffer with dispatch arguments.
         * @param argsOffset Byte offset indicating the location of the dispatch arguments in the buffer.
         */
        public DispatchCompute($computeShader: UnityEngine.ComputeShader, $kernelIndex: number, $indirectBuffer: UnityEngine.ComputeBuffer, $argsOffset: number):void;
        /**
         * Add a command to execute a ComputeShader.
         * @param computeShader ComputeShader to execute.
         * @param kernelIndex Kernel index to execute, see ComputeShader.FindKernel.
         * @param threadGroupsX Number of work groups in the X dimension.
         * @param threadGroupsY Number of work groups in the Y dimension.
         * @param threadGroupsZ Number of work groups in the Z dimension.
         * @param indirectBuffer ComputeBuffer with dispatch arguments.
         * @param argsOffset Byte offset indicating the location of the dispatch arguments in the buffer.
         */
        public DispatchCompute($computeShader: UnityEngine.ComputeShader, $kernelIndex: number, $indirectBuffer: UnityEngine.GraphicsBuffer, $argsOffset: number):void;
        /**
         * Adds a command to build the RayTracingAccelerationStructure to be used in a ray tracing dispatch.
         * @param accelerationStructure The RayTracingAccelerationStructure to be generated.
         */
        public BuildRayTracingAccelerationStructure($accelerationStructure: UnityEngine_Experimental_Rendering.RayTracingAccelerationStructure):void;
        
        public BuildRayTracingAccelerationStructure($accelerationStructure: UnityEngine_Experimental_Rendering.RayTracingAccelerationStructure, $relativeOrigin: UnityEngine.Vector3):void;
        /**
         * Adds a command to set the RayTracingAccelerationStructure to be used with the RayTracingShader.
         * @param rayTracingShader The RayTracingShader to set parameter for.
         * @param name Name of the RayTracingAccelerationStructure in shader coder.
         * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
         * @param rayTracingAccelerationStructure The RayTracingAccelerationStructure to be used.
         */
        public SetRayTracingAccelerationStructure($rayTracingShader: UnityEngine_Experimental_Rendering.RayTracingShader, $name: string, $rayTracingAccelerationStructure: UnityEngine_Experimental_Rendering.RayTracingAccelerationStructure):void;
        /**
         * Adds a command to set the RayTracingAccelerationStructure to be used with the RayTracingShader.
         * @param rayTracingShader The RayTracingShader to set parameter for.
         * @param name Name of the RayTracingAccelerationStructure in shader coder.
         * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
         * @param rayTracingAccelerationStructure The RayTracingAccelerationStructure to be used.
         */
        public SetRayTracingAccelerationStructure($rayTracingShader: UnityEngine_Experimental_Rendering.RayTracingShader, $nameID: number, $rayTracingAccelerationStructure: UnityEngine_Experimental_Rendering.RayTracingAccelerationStructure):void;
        /**
         * Adds a command to set an input or output buffer parameter on a RayTracingShader.
         * @param rayTracingShader The RayTracingShader to set parameter for.
         * @param name The name of the constant buffer in shader code.
         * @param nameID The ID of the property name for the constant buffer in shader code. Use Shader.PropertyToID to get this ID.
         * @param buffer Buffer to set.
         */
        public SetRayTracingBufferParam($rayTracingShader: UnityEngine_Experimental_Rendering.RayTracingShader, $name: string, $buffer: UnityEngine.ComputeBuffer):void;
        /**
         * Adds a command to set an input or output buffer parameter on a RayTracingShader.
         * @param rayTracingShader The RayTracingShader to set parameter for.
         * @param name The name of the constant buffer in shader code.
         * @param nameID The ID of the property name for the constant buffer in shader code. Use Shader.PropertyToID to get this ID.
         * @param buffer Buffer to set.
         */
        public SetRayTracingBufferParam($rayTracingShader: UnityEngine_Experimental_Rendering.RayTracingShader, $nameID: number, $buffer: UnityEngine.ComputeBuffer):void;
        /**
         * Adds a command to set a constant buffer on a RayTracingShader.
         * @param rayTracingShader The RayTracingShader to set parameter for.
         * @param nameID The ID of the property name for the constant buffer in shader code. Use Shader.PropertyToID to get this ID.
         * @param name The name of the constant buffer in shader code.
         * @param buffer The buffer to bind as constant buffer.
         * @param offset The offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
         * @param size The number of bytes to bind.
         */
        public SetRayTracingConstantBufferParam($rayTracingShader: UnityEngine_Experimental_Rendering.RayTracingShader, $nameID: number, $buffer: UnityEngine.ComputeBuffer, $offset: number, $size: number):void;
        /**
         * Adds a command to set a constant buffer on a RayTracingShader.
         * @param rayTracingShader The RayTracingShader to set parameter for.
         * @param nameID The ID of the property name for the constant buffer in shader code. Use Shader.PropertyToID to get this ID.
         * @param name The name of the constant buffer in shader code.
         * @param buffer The buffer to bind as constant buffer.
         * @param offset The offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
         * @param size The number of bytes to bind.
         */
        public SetRayTracingConstantBufferParam($rayTracingShader: UnityEngine_Experimental_Rendering.RayTracingShader, $name: string, $buffer: UnityEngine.ComputeBuffer, $offset: number, $size: number):void;
        /**
         * Adds a command to set a constant buffer on a RayTracingShader.
         * @param rayTracingShader The RayTracingShader to set parameter for.
         * @param nameID The ID of the property name for the constant buffer in shader code. Use Shader.PropertyToID to get this ID.
         * @param name The name of the constant buffer in shader code.
         * @param buffer The buffer to bind as constant buffer.
         * @param offset The offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
         * @param size The number of bytes to bind.
         */
        public SetRayTracingConstantBufferParam($rayTracingShader: UnityEngine_Experimental_Rendering.RayTracingShader, $nameID: number, $buffer: UnityEngine.GraphicsBuffer, $offset: number, $size: number):void;
        /**
         * Adds a command to set a constant buffer on a RayTracingShader.
         * @param rayTracingShader The RayTracingShader to set parameter for.
         * @param nameID The ID of the property name for the constant buffer in shader code. Use Shader.PropertyToID to get this ID.
         * @param name The name of the constant buffer in shader code.
         * @param buffer The buffer to bind as constant buffer.
         * @param offset The offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
         * @param size The number of bytes to bind.
         */
        public SetRayTracingConstantBufferParam($rayTracingShader: UnityEngine_Experimental_Rendering.RayTracingShader, $name: string, $buffer: UnityEngine.GraphicsBuffer, $offset: number, $size: number):void;
        /**
         * Adds a command to set a texture parameter on a RayTracingShader.
         * @param rayTracingShader RayTracingShader to set parameter for.
         * @param name Name of the texture variable in shader code.
         * @param nameID The ID of the property name for the texture in shader code. Use Shader.PropertyToID to get this ID.
         * @param rt Texture value or identifier to set, see RenderTargetIdentifier.
         */
        public SetRayTracingTextureParam($rayTracingShader: UnityEngine_Experimental_Rendering.RayTracingShader, $name: string, $rt: RenderTargetIdentifier):void;
        /**
         * Adds a command to set a texture parameter on a RayTracingShader.
         * @param rayTracingShader RayTracingShader to set parameter for.
         * @param name Name of the texture variable in shader code.
         * @param nameID The ID of the property name for the texture in shader code. Use Shader.PropertyToID to get this ID.
         * @param rt Texture value or identifier to set, see RenderTargetIdentifier.
         */
        public SetRayTracingTextureParam($rayTracingShader: UnityEngine_Experimental_Rendering.RayTracingShader, $nameID: number, $rt: RenderTargetIdentifier):void;
        /**
         * Adds a command to set a float parameter on a RayTracingShader.
         * @param rayTracingShader RayTracingShader to set parameter for.
         * @param name Name of the variable in shader code.
         * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
         * @param val Value to set.
         */
        public SetRayTracingFloatParam($rayTracingShader: UnityEngine_Experimental_Rendering.RayTracingShader, $name: string, $val: number):void;
        /**
         * Adds a command to set a float parameter on a RayTracingShader.
         * @param rayTracingShader RayTracingShader to set parameter for.
         * @param name Name of the variable in shader code.
         * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
         * @param val Value to set.
         */
        public SetRayTracingFloatParam($rayTracingShader: UnityEngine_Experimental_Rendering.RayTracingShader, $nameID: number, $val: number):void;
        /**
         * Adds a command to set multiple consecutive float parameters on a RayTracingShader.
         * @param rayTracingShader RayTracingShader to set parameter for.
         * @param name Name of the variable in shader code.
         * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
         * @param values Values to set.
         */
        public SetRayTracingFloatParams($rayTracingShader: UnityEngine_Experimental_Rendering.RayTracingShader, $name: string, ...values: number[]):void;
        /**
         * Adds a command to set multiple consecutive float parameters on a RayTracingShader.
         * @param rayTracingShader RayTracingShader to set parameter for.
         * @param name Name of the variable in shader code.
         * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
         * @param values Values to set.
         */
        public SetRayTracingFloatParams($rayTracingShader: UnityEngine_Experimental_Rendering.RayTracingShader, $nameID: number, ...values: number[]):void;
        /**
         * Adds a command to set an integer parameter on a RayTracingShader.
         * @param rayTracingShader RayTracingShader to set parameter for.
         * @param name Name of the variable in shader code.
         * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
         * @param val Value to set.
         */
        public SetRayTracingIntParam($rayTracingShader: UnityEngine_Experimental_Rendering.RayTracingShader, $name: string, $val: number):void;
        /**
         * Adds a command to set an integer parameter on a RayTracingShader.
         * @param rayTracingShader RayTracingShader to set parameter for.
         * @param name Name of the variable in shader code.
         * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
         * @param val Value to set.
         */
        public SetRayTracingIntParam($rayTracingShader: UnityEngine_Experimental_Rendering.RayTracingShader, $nameID: number, $val: number):void;
        /**
         * Adds a command to set multiple consecutive integer parameters on a RayTracingShader.
         * @param rayTracingShader RayTracingShader to set parameter for.
         * @param name Name of the variable in shader code.
         * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
         * @param values Values to set.
         */
        public SetRayTracingIntParams($rayTracingShader: UnityEngine_Experimental_Rendering.RayTracingShader, $name: string, ...values: number[]):void;
        /**
         * Adds a command to set multiple consecutive integer parameters on a RayTracingShader.
         * @param rayTracingShader RayTracingShader to set parameter for.
         * @param name Name of the variable in shader code.
         * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
         * @param values Values to set.
         */
        public SetRayTracingIntParams($rayTracingShader: UnityEngine_Experimental_Rendering.RayTracingShader, $nameID: number, ...values: number[]):void;
        /**
         * Adds a command to set a vector parameter on a RayTracingShader.
         * @param rayTracingShader RayTracingShader to set parameter for.
         * @param name Name of the variable in shader code.
         * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
         * @param val Value to set.
         */
        public SetRayTracingVectorParam($rayTracingShader: UnityEngine_Experimental_Rendering.RayTracingShader, $name: string, $val: UnityEngine.Vector4):void;
        /**
         * Adds a command to set a vector parameter on a RayTracingShader.
         * @param rayTracingShader RayTracingShader to set parameter for.
         * @param name Name of the variable in shader code.
         * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
         * @param val Value to set.
         */
        public SetRayTracingVectorParam($rayTracingShader: UnityEngine_Experimental_Rendering.RayTracingShader, $nameID: number, $val: UnityEngine.Vector4):void;
        /**
         * Adds a command to set a vector array parameter on a RayTracingShader.
         * @param rayTracingShader RayTracingShader to set parameter for.
         * @param name Property name.
         * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
         * @param values Value to set.
         */
        public SetRayTracingVectorArrayParam($rayTracingShader: UnityEngine_Experimental_Rendering.RayTracingShader, $name: string, ...values: UnityEngine.Vector4[]):void;
        /**
         * Adds a command to set a vector array parameter on a RayTracingShader.
         * @param rayTracingShader RayTracingShader to set parameter for.
         * @param name Property name.
         * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
         * @param values Value to set.
         */
        public SetRayTracingVectorArrayParam($rayTracingShader: UnityEngine_Experimental_Rendering.RayTracingShader, $nameID: number, ...values: UnityEngine.Vector4[]):void;
        /**
         * Adds a command to set a matrix parameter on a RayTracingShader.
         * @param rayTracingShader RayTracingShader to set parameter for.
         * @param name Name of the variable in shader code.
         * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
         * @param val Value to set.
         */
        public SetRayTracingMatrixParam($rayTracingShader: UnityEngine_Experimental_Rendering.RayTracingShader, $name: string, $val: UnityEngine.Matrix4x4):void;
        /**
         * Adds a command to set a matrix parameter on a RayTracingShader.
         * @param rayTracingShader RayTracingShader to set parameter for.
         * @param name Name of the variable in shader code.
         * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
         * @param val Value to set.
         */
        public SetRayTracingMatrixParam($rayTracingShader: UnityEngine_Experimental_Rendering.RayTracingShader, $nameID: number, $val: UnityEngine.Matrix4x4):void;
        /**
         * Adds a command to set a matrix array parameter on a RayTracingShader.
         * @param rayTracingShader RayTracingShader to set parameter for.
         * @param name Name of the variable in shader code.
         * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
         * @param values Value to set.
         */
        public SetRayTracingMatrixArrayParam($rayTracingShader: UnityEngine_Experimental_Rendering.RayTracingShader, $name: string, ...values: UnityEngine.Matrix4x4[]):void;
        /**
         * Adds a command to set a matrix array parameter on a RayTracingShader.
         * @param rayTracingShader RayTracingShader to set parameter for.
         * @param name Name of the variable in shader code.
         * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
         * @param values Value to set.
         */
        public SetRayTracingMatrixArrayParam($rayTracingShader: UnityEngine_Experimental_Rendering.RayTracingShader, $nameID: number, ...values: UnityEngine.Matrix4x4[]):void;
        /**
         * Adds a command to execute a RayTracingShader.
         * @param rayTracingShader RayTracingShader to execute.
         * @param rayGenName The name of the ray generation shader.
         * @param width The width of the ray generation shader thread grid.
         * @param height The height of the ray generation shader thread grid.
         * @param depth The depth of the ray generation shader thread grid.
         * @param camera Optional parameter used to setup camera-related built-in shader variables.
         */
        public DispatchRays($rayTracingShader: UnityEngine_Experimental_Rendering.RayTracingShader, $rayGenName: string, $width: number, $height: number, $depth: number, $camera?: UnityEngine.Camera):void;
        /**
         * Generate mipmap levels of a render texture.
         * @param rt The render texture requiring mipmaps generation.
         */
        public GenerateMips($rt: RenderTargetIdentifier):void;
        /**
         * Generate mipmap levels of a render texture.
         * @param rt The render texture requiring mipmaps generation.
         */
        public GenerateMips($rt: UnityEngine.RenderTexture):void;
        /**
         * Force an antialiased render texture to be resolved.
         * @param rt The antialiased render texture to resolve.
         * @param target The render texture to resolve into.  If set, the target render texture must have the same dimensions and format as the source.
         */
        public ResolveAntiAliasedSurface($rt: UnityEngine.RenderTexture, $target?: UnityEngine.RenderTexture):void;
        /**
         * Add a "draw mesh" command.
         * @param mesh Mesh to draw.
         * @param matrix Transformation matrix to use.
         * @param material Material to use.
         * @param submeshIndex Which subset of the mesh to render.
         * @param shaderPass Which pass of the shader to use (default is -1, which renders all passes).
         * @param properties Additional Material properties to apply onto the Material just before this Mesh is drawn. See MaterialPropertyBlock.
         */
        public DrawMesh($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $submeshIndex: number, $shaderPass: number, $properties: UnityEngine.MaterialPropertyBlock):void;
        
        public DrawMesh($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $submeshIndex: number, $shaderPass: number):void;
        
        public DrawMesh($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $submeshIndex: number):void;
        
        public DrawMesh($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material):void;
        /**
         * Add a "draw renderer" command.
         * @param renderer Renderer to draw.
         * @param material Material to use.
         * @param submeshIndex Which subset of the mesh to render.
         * @param shaderPass Which pass of the shader to use (default is -1, which renders all passes).
         */
        public DrawRenderer($renderer: UnityEngine.Renderer, $material: UnityEngine.Material, $submeshIndex: number, $shaderPass: number):void;
        
        public DrawRenderer($renderer: UnityEngine.Renderer, $material: UnityEngine.Material, $submeshIndex: number):void;
        
        public DrawRenderer($renderer: UnityEngine.Renderer, $material: UnityEngine.Material):void;
        /**
         * Add a "draw procedural geometry" command.
         * @param matrix Transformation matrix to use.
         * @param material Material to use.
         * @param shaderPass Which pass of the shader to use (or -1 for all passes).
         * @param topology Topology of the procedural geometry.
         * @param vertexCount Vertex count to render.
         * @param instanceCount Instance count to render.
         * @param properties Additional material properties to apply just before rendering. See MaterialPropertyBlock.
         */
        public DrawProcedural($matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: number, $topology: UnityEngine.MeshTopology, $vertexCount: number, $instanceCount: number, $properties: UnityEngine.MaterialPropertyBlock):void;
        /**
         * Add a "draw procedural geometry" command.
         * @param matrix Transformation matrix to use.
         * @param material Material to use.
         * @param shaderPass Which pass of the shader to use (or -1 for all passes).
         * @param topology Topology of the procedural geometry.
         * @param vertexCount Vertex count to render.
         * @param instanceCount Instance count to render.
         * @param properties Additional material properties to apply just before rendering. See MaterialPropertyBlock.
         */
        public DrawProcedural($matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: number, $topology: UnityEngine.MeshTopology, $vertexCount: number, $instanceCount: number):void;
        /**
         * Add a "draw procedural geometry" command.
         * @param matrix Transformation matrix to use.
         * @param material Material to use.
         * @param shaderPass Which pass of the shader to use (or -1 for all passes).
         * @param topology Topology of the procedural geometry.
         * @param vertexCount Vertex count to render.
         * @param instanceCount Instance count to render.
         * @param properties Additional material properties to apply just before rendering. See MaterialPropertyBlock.
         */
        public DrawProcedural($matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: number, $topology: UnityEngine.MeshTopology, $vertexCount: number):void;
        /**
         * Add a "draw procedural geometry" command.
         * @param matrix Transformation matrix to use.
         * @param material Material to use.
         * @param shaderPass Which pass of the shader to use (or -1 for all passes).
         * @param topology Topology of the procedural geometry.
         * @param indexCount Index count to render.
         * @param instanceCount Instance count to render.
         * @param indexBuffer The index buffer used to submit vertices to the GPU.
         * @param properties Additional material properties to apply just before rendering. See MaterialPropertyBlock.
         */
        public DrawProcedural($indexBuffer: UnityEngine.GraphicsBuffer, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: number, $topology: UnityEngine.MeshTopology, $indexCount: number, $instanceCount: number, $properties: UnityEngine.MaterialPropertyBlock):void;
        /**
         * Add a "draw procedural geometry" command.
         * @param matrix Transformation matrix to use.
         * @param material Material to use.
         * @param shaderPass Which pass of the shader to use (or -1 for all passes).
         * @param topology Topology of the procedural geometry.
         * @param indexCount Index count to render.
         * @param instanceCount Instance count to render.
         * @param indexBuffer The index buffer used to submit vertices to the GPU.
         * @param properties Additional material properties to apply just before rendering. See MaterialPropertyBlock.
         */
        public DrawProcedural($indexBuffer: UnityEngine.GraphicsBuffer, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: number, $topology: UnityEngine.MeshTopology, $indexCount: number, $instanceCount: number):void;
        /**
         * Add a "draw procedural geometry" command.
         * @param matrix Transformation matrix to use.
         * @param material Material to use.
         * @param shaderPass Which pass of the shader to use (or -1 for all passes).
         * @param topology Topology of the procedural geometry.
         * @param indexCount Index count to render.
         * @param instanceCount Instance count to render.
         * @param indexBuffer The index buffer used to submit vertices to the GPU.
         * @param properties Additional material properties to apply just before rendering. See MaterialPropertyBlock.
         */
        public DrawProcedural($indexBuffer: UnityEngine.GraphicsBuffer, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: number, $topology: UnityEngine.MeshTopology, $indexCount: number):void;
        /**
         * Add a "draw procedural geometry" command.
         * @param matrix Transformation matrix to use.
         * @param material Material to use.
         * @param shaderPass Which pass of the shader to use (or -1 for all passes).
         * @param topology Topology of the procedural geometry.
         * @param properties Additional material properties to apply just before rendering. See MaterialPropertyBlock.
         * @param bufferWithArgs Buffer with draw arguments.
         * @param argsOffset Byte offset where in the buffer the draw arguments are.
         */
        public DrawProceduralIndirect($matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: number, $topology: UnityEngine.MeshTopology, $bufferWithArgs: UnityEngine.ComputeBuffer, $argsOffset: number, $properties: UnityEngine.MaterialPropertyBlock):void;
        /**
         * Add a "draw procedural geometry" command.
         * @param matrix Transformation matrix to use.
         * @param material Material to use.
         * @param shaderPass Which pass of the shader to use (or -1 for all passes).
         * @param topology Topology of the procedural geometry.
         * @param properties Additional material properties to apply just before rendering. See MaterialPropertyBlock.
         * @param bufferWithArgs Buffer with draw arguments.
         * @param argsOffset Byte offset where in the buffer the draw arguments are.
         */
        public DrawProceduralIndirect($matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: number, $topology: UnityEngine.MeshTopology, $bufferWithArgs: UnityEngine.ComputeBuffer, $argsOffset: number):void;
        /**
         * Add a "draw procedural geometry" command.
         * @param matrix Transformation matrix to use.
         * @param material Material to use.
         * @param shaderPass Which pass of the shader to use (or -1 for all passes).
         * @param topology Topology of the procedural geometry.
         * @param properties Additional material properties to apply just before rendering. See MaterialPropertyBlock.
         * @param bufferWithArgs Buffer with draw arguments.
         * @param argsOffset Byte offset where in the buffer the draw arguments are.
         */
        public DrawProceduralIndirect($matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: number, $topology: UnityEngine.MeshTopology, $bufferWithArgs: UnityEngine.ComputeBuffer):void;
        /**
         * Add a "draw procedural geometry" command.
         * @param indexBuffer Index buffer used to submit vertices to the GPU.
         * @param matrix Transformation matrix to use.
         * @param material Material to use.
         * @param shaderPass Which pass of the shader to use (or -1 for all passes).
         * @param topology Topology of the procedural geometry.
         * @param bufferWithArgs Buffer with draw arguments.
         * @param argsOffset Byte offset where in the buffer the draw arguments are.
         * @param properties Additional material properties to apply just before rendering. See MaterialPropertyBlock.
         */
        public DrawProceduralIndirect($indexBuffer: UnityEngine.GraphicsBuffer, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: number, $topology: UnityEngine.MeshTopology, $bufferWithArgs: UnityEngine.ComputeBuffer, $argsOffset: number, $properties: UnityEngine.MaterialPropertyBlock):void;
        /**
         * Add a "draw procedural geometry" command.
         * @param indexBuffer Index buffer used to submit vertices to the GPU.
         * @param matrix Transformation matrix to use.
         * @param material Material to use.
         * @param shaderPass Which pass of the shader to use (or -1 for all passes).
         * @param topology Topology of the procedural geometry.
         * @param bufferWithArgs Buffer with draw arguments.
         * @param argsOffset Byte offset where in the buffer the draw arguments are.
         * @param properties Additional material properties to apply just before rendering. See MaterialPropertyBlock.
         */
        public DrawProceduralIndirect($indexBuffer: UnityEngine.GraphicsBuffer, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: number, $topology: UnityEngine.MeshTopology, $bufferWithArgs: UnityEngine.ComputeBuffer, $argsOffset: number):void;
        /**
         * Add a "draw procedural geometry" command.
         * @param indexBuffer Index buffer used to submit vertices to the GPU.
         * @param matrix Transformation matrix to use.
         * @param material Material to use.
         * @param shaderPass Which pass of the shader to use (or -1 for all passes).
         * @param topology Topology of the procedural geometry.
         * @param bufferWithArgs Buffer with draw arguments.
         * @param argsOffset Byte offset where in the buffer the draw arguments are.
         * @param properties Additional material properties to apply just before rendering. See MaterialPropertyBlock.
         */
        public DrawProceduralIndirect($indexBuffer: UnityEngine.GraphicsBuffer, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: number, $topology: UnityEngine.MeshTopology, $bufferWithArgs: UnityEngine.ComputeBuffer):void;
        /**
         * Add a "draw procedural geometry" command.
         * @param matrix Transformation matrix to use.
         * @param material Material to use.
         * @param shaderPass Which pass of the shader to use (or -1 for all passes).
         * @param topology Topology of the procedural geometry.
         * @param properties Additional material properties to apply just before rendering. See MaterialPropertyBlock.
         * @param bufferWithArgs Buffer with draw arguments.
         * @param argsOffset Byte offset where in the buffer the draw arguments are.
         */
        public DrawProceduralIndirect($matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: number, $topology: UnityEngine.MeshTopology, $bufferWithArgs: UnityEngine.GraphicsBuffer, $argsOffset: number, $properties: UnityEngine.MaterialPropertyBlock):void;
        /**
         * Add a "draw procedural geometry" command.
         * @param matrix Transformation matrix to use.
         * @param material Material to use.
         * @param shaderPass Which pass of the shader to use (or -1 for all passes).
         * @param topology Topology of the procedural geometry.
         * @param properties Additional material properties to apply just before rendering. See MaterialPropertyBlock.
         * @param bufferWithArgs Buffer with draw arguments.
         * @param argsOffset Byte offset where in the buffer the draw arguments are.
         */
        public DrawProceduralIndirect($matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: number, $topology: UnityEngine.MeshTopology, $bufferWithArgs: UnityEngine.GraphicsBuffer, $argsOffset: number):void;
        /**
         * Add a "draw procedural geometry" command.
         * @param matrix Transformation matrix to use.
         * @param material Material to use.
         * @param shaderPass Which pass of the shader to use (or -1 for all passes).
         * @param topology Topology of the procedural geometry.
         * @param properties Additional material properties to apply just before rendering. See MaterialPropertyBlock.
         * @param bufferWithArgs Buffer with draw arguments.
         * @param argsOffset Byte offset where in the buffer the draw arguments are.
         */
        public DrawProceduralIndirect($matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: number, $topology: UnityEngine.MeshTopology, $bufferWithArgs: UnityEngine.GraphicsBuffer):void;
        /**
         * Add a "draw procedural geometry" command.
         * @param indexBuffer Index buffer used to submit vertices to the GPU.
         * @param matrix Transformation matrix to use.
         * @param material Material to use.
         * @param shaderPass Which pass of the shader to use (or -1 for all passes).
         * @param topology Topology of the procedural geometry.
         * @param bufferWithArgs Buffer with draw arguments.
         * @param argsOffset Byte offset where in the buffer the draw arguments are.
         * @param properties Additional material properties to apply just before rendering. See MaterialPropertyBlock.
         */
        public DrawProceduralIndirect($indexBuffer: UnityEngine.GraphicsBuffer, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: number, $topology: UnityEngine.MeshTopology, $bufferWithArgs: UnityEngine.GraphicsBuffer, $argsOffset: number, $properties: UnityEngine.MaterialPropertyBlock):void;
        /**
         * Add a "draw procedural geometry" command.
         * @param indexBuffer Index buffer used to submit vertices to the GPU.
         * @param matrix Transformation matrix to use.
         * @param material Material to use.
         * @param shaderPass Which pass of the shader to use (or -1 for all passes).
         * @param topology Topology of the procedural geometry.
         * @param bufferWithArgs Buffer with draw arguments.
         * @param argsOffset Byte offset where in the buffer the draw arguments are.
         * @param properties Additional material properties to apply just before rendering. See MaterialPropertyBlock.
         */
        public DrawProceduralIndirect($indexBuffer: UnityEngine.GraphicsBuffer, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: number, $topology: UnityEngine.MeshTopology, $bufferWithArgs: UnityEngine.GraphicsBuffer, $argsOffset: number):void;
        /**
         * Add a "draw procedural geometry" command.
         * @param indexBuffer Index buffer used to submit vertices to the GPU.
         * @param matrix Transformation matrix to use.
         * @param material Material to use.
         * @param shaderPass Which pass of the shader to use (or -1 for all passes).
         * @param topology Topology of the procedural geometry.
         * @param bufferWithArgs Buffer with draw arguments.
         * @param argsOffset Byte offset where in the buffer the draw arguments are.
         * @param properties Additional material properties to apply just before rendering. See MaterialPropertyBlock.
         */
        public DrawProceduralIndirect($indexBuffer: UnityEngine.GraphicsBuffer, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: number, $topology: UnityEngine.MeshTopology, $bufferWithArgs: UnityEngine.GraphicsBuffer):void;
        /**
         * Adds a "draw mesh with instancing" command.
         * The command will not immediately fail and throw an exception if Material.enableInstancing is false, but it will log an error and skips rendering each time the command is being executed if such a condition is detected.
         * InvalidOperationException will be thrown if the current platform doesn't support this API (i.e. if GPU instancing is not available). See SystemInfo.supportsInstancing.
         * @param mesh The Mesh to draw.
         * @param submeshIndex Which subset of the mesh to draw. This only applies to meshes that are composed of several materials.
         * @param material Material to use.
         * @param shaderPass Which pass of the shader to use, or -1 which renders all passes.
         * @param matrices The array of object transformation matrices.
         * @param count The number of instances to be drawn.
         * @param properties Additional Material properties to apply onto the Material just before this Mesh is drawn. See MaterialPropertyBlock.
         */
        public DrawMeshInstanced($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $shaderPass: number, $matrices: UnityEngine.Matrix4x4[], $count: number, $properties: UnityEngine.MaterialPropertyBlock):void;
        /**
         * Adds a "draw mesh with instancing" command.
         * The command will not immediately fail and throw an exception if Material.enableInstancing is false, but it will log an error and skips rendering each time the command is being executed if such a condition is detected.
         * InvalidOperationException will be thrown if the current platform doesn't support this API (i.e. if GPU instancing is not available). See SystemInfo.supportsInstancing.
         * @param mesh The Mesh to draw.
         * @param submeshIndex Which subset of the mesh to draw. This only applies to meshes that are composed of several materials.
         * @param material Material to use.
         * @param shaderPass Which pass of the shader to use, or -1 which renders all passes.
         * @param matrices The array of object transformation matrices.
         * @param count The number of instances to be drawn.
         * @param properties Additional Material properties to apply onto the Material just before this Mesh is drawn. See MaterialPropertyBlock.
         */
        public DrawMeshInstanced($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $shaderPass: number, $matrices: UnityEngine.Matrix4x4[], $count: number):void;
        /**
         * Adds a "draw mesh with instancing" command.
         * The command will not immediately fail and throw an exception if Material.enableInstancing is false, but it will log an error and skips rendering each time the command is being executed if such a condition is detected.
         * InvalidOperationException will be thrown if the current platform doesn't support this API (i.e. if GPU instancing is not available). See SystemInfo.supportsInstancing.
         * @param mesh The Mesh to draw.
         * @param submeshIndex Which subset of the mesh to draw. This only applies to meshes that are composed of several materials.
         * @param material Material to use.
         * @param shaderPass Which pass of the shader to use, or -1 which renders all passes.
         * @param matrices The array of object transformation matrices.
         * @param count The number of instances to be drawn.
         * @param properties Additional Material properties to apply onto the Material just before this Mesh is drawn. See MaterialPropertyBlock.
         */
        public DrawMeshInstanced($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $shaderPass: number, $matrices: UnityEngine.Matrix4x4[]):void;
        /**
         * Add a "draw mesh with instancing" command.
         * Draw a mesh using Procedural Instancing. This is similar to Graphics.DrawMeshInstancedIndirect, except that when the instance count is known from script, it can be supplied directly using this method, rather than via a ComputeBuffer.
         * If Material.enableInstancing is false, the command logs an error and skips rendering each time the command is executed; the command does not immediately fail and throw an exception.
         * InvalidOperationException will be thrown if the current platform doesn't support this API (for example, if GPU instancing is not available). See SystemInfo.supportsInstancing.
         * @param mesh The Mesh to draw.
         * @param submeshIndex Which subset of the mesh to draw. This only applies to meshes that are composed of several materials.
         * @param material Material to use.
         * @param shaderPass Which pass of the shader to use, or -1 which renders all passes.
         * @param count The number of instances to be drawn.
         * @param properties Additional Material properties to apply onto the Material just before this Mesh is drawn. See MaterialPropertyBlock.
         */
        public DrawMeshInstancedProcedural($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $shaderPass: number, $count: number, $properties?: UnityEngine.MaterialPropertyBlock):void;
        /**
         * Add a "draw mesh with indirect instancing" command.
         * @param mesh The Mesh to draw.
         * @param submeshIndex Which subset of the mesh to draw. This only applies to meshes that are composed of several materials.
         * @param material Material to use.
         * @param shaderPass Which pass of the shader to use, or -1 which renders all passes.
         * @param properties Additional Material properties to apply onto the Material just before this Mesh is drawn. See MaterialPropertyBlock.
         * @param bufferWithArgs The GPU buffer containing the arguments for how many instances of this mesh to draw.
         * @param argsOffset The byte offset into the buffer, where the draw arguments start.
         */
        public DrawMeshInstancedIndirect($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $shaderPass: number, $bufferWithArgs: UnityEngine.ComputeBuffer, $argsOffset: number, $properties: UnityEngine.MaterialPropertyBlock):void;
        /**
         * Add a "draw mesh with indirect instancing" command.
         * @param mesh The Mesh to draw.
         * @param submeshIndex Which subset of the mesh to draw. This only applies to meshes that are composed of several materials.
         * @param material Material to use.
         * @param shaderPass Which pass of the shader to use, or -1 which renders all passes.
         * @param properties Additional Material properties to apply onto the Material just before this Mesh is drawn. See MaterialPropertyBlock.
         * @param bufferWithArgs The GPU buffer containing the arguments for how many instances of this mesh to draw.
         * @param argsOffset The byte offset into the buffer, where the draw arguments start.
         */
        public DrawMeshInstancedIndirect($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $shaderPass: number, $bufferWithArgs: UnityEngine.ComputeBuffer, $argsOffset: number):void;
        /**
         * Add a "draw mesh with indirect instancing" command.
         * @param mesh The Mesh to draw.
         * @param submeshIndex Which subset of the mesh to draw. This only applies to meshes that are composed of several materials.
         * @param material Material to use.
         * @param shaderPass Which pass of the shader to use, or -1 which renders all passes.
         * @param properties Additional Material properties to apply onto the Material just before this Mesh is drawn. See MaterialPropertyBlock.
         * @param bufferWithArgs The GPU buffer containing the arguments for how many instances of this mesh to draw.
         * @param argsOffset The byte offset into the buffer, where the draw arguments start.
         */
        public DrawMeshInstancedIndirect($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $shaderPass: number, $bufferWithArgs: UnityEngine.ComputeBuffer):void;
        /**
         * Add a "draw mesh with indirect instancing" command.
         * @param mesh The Mesh to draw.
         * @param submeshIndex Which subset of the mesh to draw. This only applies to meshes that are composed of several materials.
         * @param material Material to use.
         * @param shaderPass Which pass of the shader to use, or -1 which renders all passes.
         * @param properties Additional Material properties to apply onto the Material just before this Mesh is drawn. See MaterialPropertyBlock.
         * @param bufferWithArgs The GPU buffer containing the arguments for how many instances of this mesh to draw.
         * @param argsOffset The byte offset into the buffer, where the draw arguments start.
         */
        public DrawMeshInstancedIndirect($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $shaderPass: number, $bufferWithArgs: UnityEngine.GraphicsBuffer, $argsOffset: number, $properties: UnityEngine.MaterialPropertyBlock):void;
        /**
         * Add a "draw mesh with indirect instancing" command.
         * @param mesh The Mesh to draw.
         * @param submeshIndex Which subset of the mesh to draw. This only applies to meshes that are composed of several materials.
         * @param material Material to use.
         * @param shaderPass Which pass of the shader to use, or -1 which renders all passes.
         * @param properties Additional Material properties to apply onto the Material just before this Mesh is drawn. See MaterialPropertyBlock.
         * @param bufferWithArgs The GPU buffer containing the arguments for how many instances of this mesh to draw.
         * @param argsOffset The byte offset into the buffer, where the draw arguments start.
         */
        public DrawMeshInstancedIndirect($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $shaderPass: number, $bufferWithArgs: UnityEngine.GraphicsBuffer, $argsOffset: number):void;
        /**
         * Add a "draw mesh with indirect instancing" command.
         * @param mesh The Mesh to draw.
         * @param submeshIndex Which subset of the mesh to draw. This only applies to meshes that are composed of several materials.
         * @param material Material to use.
         * @param shaderPass Which pass of the shader to use, or -1 which renders all passes.
         * @param properties Additional Material properties to apply onto the Material just before this Mesh is drawn. See MaterialPropertyBlock.
         * @param bufferWithArgs The GPU buffer containing the arguments for how many instances of this mesh to draw.
         * @param argsOffset The byte offset into the buffer, where the draw arguments start.
         */
        public DrawMeshInstancedIndirect($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $shaderPass: number, $bufferWithArgs: UnityEngine.GraphicsBuffer):void;
        /**
         * Adds a command onto the commandbuffer to draw the VR Device's occlusion mesh to the current render target.
         * @param normalizedCamViewport The viewport of the camera currently being rendered.
         */
        public DrawOcclusionMesh($normalizedCamViewport: UnityEngine.RectInt):void;
        /**
         * Set random write target for level pixel shaders.
         * @param index Index of the random write target in the shader.
         * @param buffer Buffer to set as the write target.
         * @param preserveCounterValue Whether to leave the append/consume counter value unchanged.
         * @param rt RenderTargetIdentifier to set as the write target.
         */
        public SetRandomWriteTarget($index: number, $rt: RenderTargetIdentifier):void;
        /**
         * Set random write target for level pixel shaders.
         * @param index Index of the random write target in the shader.
         * @param buffer Buffer to set as the write target.
         * @param preserveCounterValue Whether to leave the append/consume counter value unchanged.
         * @param rt RenderTargetIdentifier to set as the write target.
         */
        public SetRandomWriteTarget($index: number, $buffer: UnityEngine.ComputeBuffer, $preserveCounterValue: boolean):void;
        /**
         * Set random write target for level pixel shaders.
         * @param index Index of the random write target in the shader.
         * @param buffer Buffer to set as the write target.
         * @param preserveCounterValue Whether to leave the append/consume counter value unchanged.
         * @param rt RenderTargetIdentifier to set as the write target.
         */
        public SetRandomWriteTarget($index: number, $buffer: UnityEngine.ComputeBuffer):void;
        /**
         * Set random write target for level pixel shaders.
         * @param index Index of the random write target in the shader.
         * @param buffer Buffer to set as the write target.
         * @param preserveCounterValue Whether to leave the append/consume counter value unchanged.
         * @param rt RenderTargetIdentifier to set as the write target.
         */
        public SetRandomWriteTarget($index: number, $buffer: UnityEngine.GraphicsBuffer, $preserveCounterValue: boolean):void;
        /**
         * Set random write target for level pixel shaders.
         * @param index Index of the random write target in the shader.
         * @param buffer Buffer to set as the write target.
         * @param preserveCounterValue Whether to leave the append/consume counter value unchanged.
         * @param rt RenderTargetIdentifier to set as the write target.
         */
        public SetRandomWriteTarget($index: number, $buffer: UnityEngine.GraphicsBuffer):void;
        /**
         * Adds a command to copy ComputeBuffer or GraphicsBuffer counter value.
         * @param src Append/consume buffer to copy the counter from.
         * @param dst A buffer to copy the counter to.
         * @param dstOffsetBytes Target byte offset in dst buffer.
         */
        public CopyCounterValue($src: UnityEngine.ComputeBuffer, $dst: UnityEngine.ComputeBuffer, $dstOffsetBytes: number):void;
        /**
         * Adds a command to copy ComputeBuffer or GraphicsBuffer counter value.
         * @param src Append/consume buffer to copy the counter from.
         * @param dst A buffer to copy the counter to.
         * @param dstOffsetBytes Target byte offset in dst buffer.
         */
        public CopyCounterValue($src: UnityEngine.GraphicsBuffer, $dst: UnityEngine.ComputeBuffer, $dstOffsetBytes: number):void;
        /**
         * Adds a command to copy ComputeBuffer or GraphicsBuffer counter value.
         * @param src Append/consume buffer to copy the counter from.
         * @param dst A buffer to copy the counter to.
         * @param dstOffsetBytes Target byte offset in dst buffer.
         */
        public CopyCounterValue($src: UnityEngine.ComputeBuffer, $dst: UnityEngine.GraphicsBuffer, $dstOffsetBytes: number):void;
        /**
         * Adds a command to copy ComputeBuffer or GraphicsBuffer counter value.
         * @param src Append/consume buffer to copy the counter from.
         * @param dst A buffer to copy the counter to.
         * @param dstOffsetBytes Target byte offset in dst buffer.
         */
        public CopyCounterValue($src: UnityEngine.GraphicsBuffer, $dst: UnityEngine.GraphicsBuffer, $dstOffsetBytes: number):void;
        /**
         * Adds a command to copy a texture into another texture.
         * @param src Source texture or identifier, see RenderTargetIdentifier.
         * @param dst Destination texture or identifier, see RenderTargetIdentifier.
         * @param srcElement Source texture element (cubemap face, texture array layer or 3D texture depth slice).
         * @param srcMip Source texture mipmap level.
         * @param dstElement Destination texture element (cubemap face, texture array layer or 3D texture depth slice).
         * @param dstMip Destination texture mipmap level.
         * @param srcX X coordinate of source texture region to copy (left side is zero).
         * @param srcY Y coordinate of source texture region to copy (bottom is zero).
         * @param srcWidth Width of source texture region to copy.
         * @param srcHeight Height of source texture region to copy.
         * @param dstX X coordinate of where to copy region in destination texture (left side is zero).
         * @param dstY Y coordinate of where to copy region in destination texture (bottom is zero).
         */
        public CopyTexture($src: RenderTargetIdentifier, $dst: RenderTargetIdentifier):void;
        /**
         * Adds a command to copy a texture into another texture.
         * @param src Source texture or identifier, see RenderTargetIdentifier.
         * @param dst Destination texture or identifier, see RenderTargetIdentifier.
         * @param srcElement Source texture element (cubemap face, texture array layer or 3D texture depth slice).
         * @param srcMip Source texture mipmap level.
         * @param dstElement Destination texture element (cubemap face, texture array layer or 3D texture depth slice).
         * @param dstMip Destination texture mipmap level.
         * @param srcX X coordinate of source texture region to copy (left side is zero).
         * @param srcY Y coordinate of source texture region to copy (bottom is zero).
         * @param srcWidth Width of source texture region to copy.
         * @param srcHeight Height of source texture region to copy.
         * @param dstX X coordinate of where to copy region in destination texture (left side is zero).
         * @param dstY Y coordinate of where to copy region in destination texture (bottom is zero).
         */
        public CopyTexture($src: RenderTargetIdentifier, $srcElement: number, $dst: RenderTargetIdentifier, $dstElement: number):void;
        /**
         * Adds a command to copy a texture into another texture.
         * @param src Source texture or identifier, see RenderTargetIdentifier.
         * @param dst Destination texture or identifier, see RenderTargetIdentifier.
         * @param srcElement Source texture element (cubemap face, texture array layer or 3D texture depth slice).
         * @param srcMip Source texture mipmap level.
         * @param dstElement Destination texture element (cubemap face, texture array layer or 3D texture depth slice).
         * @param dstMip Destination texture mipmap level.
         * @param srcX X coordinate of source texture region to copy (left side is zero).
         * @param srcY Y coordinate of source texture region to copy (bottom is zero).
         * @param srcWidth Width of source texture region to copy.
         * @param srcHeight Height of source texture region to copy.
         * @param dstX X coordinate of where to copy region in destination texture (left side is zero).
         * @param dstY Y coordinate of where to copy region in destination texture (bottom is zero).
         */
        public CopyTexture($src: RenderTargetIdentifier, $srcElement: number, $srcMip: number, $dst: RenderTargetIdentifier, $dstElement: number, $dstMip: number):void;
        /**
         * Adds a command to copy a texture into another texture.
         * @param src Source texture or identifier, see RenderTargetIdentifier.
         * @param dst Destination texture or identifier, see RenderTargetIdentifier.
         * @param srcElement Source texture element (cubemap face, texture array layer or 3D texture depth slice).
         * @param srcMip Source texture mipmap level.
         * @param dstElement Destination texture element (cubemap face, texture array layer or 3D texture depth slice).
         * @param dstMip Destination texture mipmap level.
         * @param srcX X coordinate of source texture region to copy (left side is zero).
         * @param srcY Y coordinate of source texture region to copy (bottom is zero).
         * @param srcWidth Width of source texture region to copy.
         * @param srcHeight Height of source texture region to copy.
         * @param dstX X coordinate of where to copy region in destination texture (left side is zero).
         * @param dstY Y coordinate of where to copy region in destination texture (bottom is zero).
         */
        public CopyTexture($src: RenderTargetIdentifier, $srcElement: number, $srcMip: number, $srcX: number, $srcY: number, $srcWidth: number, $srcHeight: number, $dst: RenderTargetIdentifier, $dstElement: number, $dstMip: number, $dstX: number, $dstY: number):void;
        /**
         * Add a "blit into a render texture" command.
         * @param source Source texture or render target to blit from.
         * @param dest Destination to blit into.
         * @param mat Material to use.
         * @param pass Shader pass to use (default is -1, meaning "all passes").
         * @param scale Scale applied to the source texture coordinate.
         * @param offset Offset applied to the source texture coordinate.
         * @param sourceDepthSlice The texture array source slice to perform the blit from.
         * @param destDepthSlice The texture array destination slice to perform the blit to.
         */
        public Blit($source: UnityEngine.Texture, $dest: RenderTargetIdentifier):void;
        /**
         * Add a "blit into a render texture" command.
         * @param source Source texture or render target to blit from.
         * @param dest Destination to blit into.
         * @param mat Material to use.
         * @param pass Shader pass to use (default is -1, meaning "all passes").
         * @param scale Scale applied to the source texture coordinate.
         * @param offset Offset applied to the source texture coordinate.
         * @param sourceDepthSlice The texture array source slice to perform the blit from.
         * @param destDepthSlice The texture array destination slice to perform the blit to.
         */
        public Blit($source: UnityEngine.Texture, $dest: RenderTargetIdentifier, $scale: UnityEngine.Vector2, $offset: UnityEngine.Vector2):void;
        /**
         * Add a "blit into a render texture" command.
         * @param source Source texture or render target to blit from.
         * @param dest Destination to blit into.
         * @param mat Material to use.
         * @param pass Shader pass to use (default is -1, meaning "all passes").
         * @param scale Scale applied to the source texture coordinate.
         * @param offset Offset applied to the source texture coordinate.
         * @param sourceDepthSlice The texture array source slice to perform the blit from.
         * @param destDepthSlice The texture array destination slice to perform the blit to.
         */
        public Blit($source: UnityEngine.Texture, $dest: RenderTargetIdentifier, $mat: UnityEngine.Material):void;
        /**
         * Add a "blit into a render texture" command.
         * @param source Source texture or render target to blit from.
         * @param dest Destination to blit into.
         * @param mat Material to use.
         * @param pass Shader pass to use (default is -1, meaning "all passes").
         * @param scale Scale applied to the source texture coordinate.
         * @param offset Offset applied to the source texture coordinate.
         * @param sourceDepthSlice The texture array source slice to perform the blit from.
         * @param destDepthSlice The texture array destination slice to perform the blit to.
         */
        public Blit($source: UnityEngine.Texture, $dest: RenderTargetIdentifier, $mat: UnityEngine.Material, $pass: number):void;
        /**
         * Add a "blit into a render texture" command.
         * @param source Source texture or render target to blit from.
         * @param dest Destination to blit into.
         * @param mat Material to use.
         * @param pass Shader pass to use (default is -1, meaning "all passes").
         * @param scale Scale applied to the source texture coordinate.
         * @param offset Offset applied to the source texture coordinate.
         * @param sourceDepthSlice The texture array source slice to perform the blit from.
         * @param destDepthSlice The texture array destination slice to perform the blit to.
         */
        public Blit($source: RenderTargetIdentifier, $dest: RenderTargetIdentifier):void;
        /**
         * Add a "blit into a render texture" command.
         * @param source Source texture or render target to blit from.
         * @param dest Destination to blit into.
         * @param mat Material to use.
         * @param pass Shader pass to use (default is -1, meaning "all passes").
         * @param scale Scale applied to the source texture coordinate.
         * @param offset Offset applied to the source texture coordinate.
         * @param sourceDepthSlice The texture array source slice to perform the blit from.
         * @param destDepthSlice The texture array destination slice to perform the blit to.
         */
        public Blit($source: RenderTargetIdentifier, $dest: RenderTargetIdentifier, $scale: UnityEngine.Vector2, $offset: UnityEngine.Vector2):void;
        /**
         * Add a "blit into a render texture" command.
         * @param source Source texture or render target to blit from.
         * @param dest Destination to blit into.
         * @param mat Material to use.
         * @param pass Shader pass to use (default is -1, meaning "all passes").
         * @param scale Scale applied to the source texture coordinate.
         * @param offset Offset applied to the source texture coordinate.
         * @param sourceDepthSlice The texture array source slice to perform the blit from.
         * @param destDepthSlice The texture array destination slice to perform the blit to.
         */
        public Blit($source: RenderTargetIdentifier, $dest: RenderTargetIdentifier, $mat: UnityEngine.Material):void;
        /**
         * Add a "blit into a render texture" command.
         * @param source Source texture or render target to blit from.
         * @param dest Destination to blit into.
         * @param mat Material to use.
         * @param pass Shader pass to use (default is -1, meaning "all passes").
         * @param scale Scale applied to the source texture coordinate.
         * @param offset Offset applied to the source texture coordinate.
         * @param sourceDepthSlice The texture array source slice to perform the blit from.
         * @param destDepthSlice The texture array destination slice to perform the blit to.
         */
        public Blit($source: RenderTargetIdentifier, $dest: RenderTargetIdentifier, $mat: UnityEngine.Material, $pass: number):void;
        /**
         * Add a "blit into a render texture" command.
         * @param source Source texture or render target to blit from.
         * @param dest Destination to blit into.
         * @param mat Material to use.
         * @param pass Shader pass to use (default is -1, meaning "all passes").
         * @param scale Scale applied to the source texture coordinate.
         * @param offset Offset applied to the source texture coordinate.
         * @param sourceDepthSlice The texture array source slice to perform the blit from.
         * @param destDepthSlice The texture array destination slice to perform the blit to.
         */
        public Blit($source: RenderTargetIdentifier, $dest: RenderTargetIdentifier, $sourceDepthSlice: number, $destDepthSlice: number):void;
        /**
         * Add a "blit into a render texture" command.
         * @param source Source texture or render target to blit from.
         * @param dest Destination to blit into.
         * @param mat Material to use.
         * @param pass Shader pass to use (default is -1, meaning "all passes").
         * @param scale Scale applied to the source texture coordinate.
         * @param offset Offset applied to the source texture coordinate.
         * @param sourceDepthSlice The texture array source slice to perform the blit from.
         * @param destDepthSlice The texture array destination slice to perform the blit to.
         */
        public Blit($source: RenderTargetIdentifier, $dest: RenderTargetIdentifier, $scale: UnityEngine.Vector2, $offset: UnityEngine.Vector2, $sourceDepthSlice: number, $destDepthSlice: number):void;
        /**
         * Add a "blit into a render texture" command.
         * @param source Source texture or render target to blit from.
         * @param dest Destination to blit into.
         * @param mat Material to use.
         * @param pass Shader pass to use (default is -1, meaning "all passes").
         * @param scale Scale applied to the source texture coordinate.
         * @param offset Offset applied to the source texture coordinate.
         * @param sourceDepthSlice The texture array source slice to perform the blit from.
         * @param destDepthSlice The texture array destination slice to perform the blit to.
         */
        public Blit($source: RenderTargetIdentifier, $dest: RenderTargetIdentifier, $mat: UnityEngine.Material, $pass: number, $destDepthSlice: number):void;
        /**
         * Add a "set global shader float property" command.
         */
        public SetGlobalFloat($name: string, $value: number):void;
        /**
         * Sets the given global integer property for all shaders.
         */
        public SetGlobalInt($name: string, $value: number):void;
        /**
         * Add a "set global shader vector property" command.
         */
        public SetGlobalVector($name: string, $value: UnityEngine.Vector4):void;
        /**
         * Add a "set global shader color property" command.
         */
        public SetGlobalColor($name: string, $value: UnityEngine.Color):void;
        /**
         * Add a "set global shader matrix property" command.
         */
        public SetGlobalMatrix($name: string, $value: UnityEngine.Matrix4x4):void;
        
        public SetGlobalFloatArray($propertyName: string, $values: System_Collections_Generic.List$1<number>):void;
        
        public SetGlobalFloatArray($nameID: number, $values: System_Collections_Generic.List$1<number>):void;
        /**
         * Add a "set global shader float array property" command.
         */
        public SetGlobalFloatArray($propertyName: string, $values: number[]):void;
        
        public SetGlobalVectorArray($propertyName: string, $values: System_Collections_Generic.List$1<UnityEngine.Vector4>):void;
        
        public SetGlobalVectorArray($nameID: number, $values: System_Collections_Generic.List$1<UnityEngine.Vector4>):void;
        /**
         * Add a "set global shader vector array property" command.
         */
        public SetGlobalVectorArray($propertyName: string, $values: UnityEngine.Vector4[]):void;
        
        public SetGlobalMatrixArray($propertyName: string, $values: System_Collections_Generic.List$1<UnityEngine.Matrix4x4>):void;
        
        public SetGlobalMatrixArray($nameID: number, $values: System_Collections_Generic.List$1<UnityEngine.Matrix4x4>):void;
        /**
         * Add a "set global shader matrix array property" command.
         */
        public SetGlobalMatrixArray($propertyName: string, $values: UnityEngine.Matrix4x4[]):void;
        /**
         * Add a "set global shader texture property" command, referencing a RenderTexture.
         */
        public SetGlobalTexture($name: string, $value: RenderTargetIdentifier):void;
        /**
         * Add a "set global shader texture property" command, referencing a RenderTexture.
         */
        public SetGlobalTexture($nameID: number, $value: RenderTargetIdentifier):void;
        /**
         * Add a "set global shader texture property" command, referencing a RenderTexture.
         */
        public SetGlobalTexture($name: string, $value: RenderTargetIdentifier, $element: RenderTextureSubElement):void;
        /**
         * Add a "set global shader texture property" command, referencing a RenderTexture.
         */
        public SetGlobalTexture($nameID: number, $value: RenderTargetIdentifier, $element: RenderTextureSubElement):void;
        /**
         * Add a "set global shader buffer property" command.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         * @param value The buffer to set.
         */
        public SetGlobalBuffer($name: string, $value: UnityEngine.ComputeBuffer):void;
        /**
         * Add a "set global shader buffer property" command.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         * @param value The buffer to set.
         */
        public SetGlobalBuffer($nameID: number, $value: UnityEngine.ComputeBuffer):void;
        /**
         * Add a "set global shader buffer property" command.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         * @param value The buffer to set.
         */
        public SetGlobalBuffer($name: string, $value: UnityEngine.GraphicsBuffer):void;
        /**
         * Add a "set global shader buffer property" command.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         * @param value The buffer to set.
         */
        public SetGlobalBuffer($nameID: number, $value: UnityEngine.GraphicsBuffer):void;
        /**
         * Add a command to bind a global constant buffer.
         * @param nameID The name ID of the constant buffer retrieved by Shader.PropertyToID.
         * @param name The name of the constant buffer to override.
         * @param buffer The buffer to bind.
         * @param offset Offset from the start of the buffer in bytes.
         * @param size Size in bytes of the area to bind.
         */
        public SetGlobalConstantBuffer($buffer: UnityEngine.ComputeBuffer, $nameID: number, $offset: number, $size: number):void;
        /**
         * Add a command to bind a global constant buffer.
         * @param nameID The name ID of the constant buffer retrieved by Shader.PropertyToID.
         * @param name The name of the constant buffer to override.
         * @param buffer The buffer to bind.
         * @param offset Offset from the start of the buffer in bytes.
         * @param size Size in bytes of the area to bind.
         */
        public SetGlobalConstantBuffer($buffer: UnityEngine.ComputeBuffer, $name: string, $offset: number, $size: number):void;
        /**
         * Add a command to bind a global constant buffer.
         * @param nameID The name ID of the constant buffer retrieved by Shader.PropertyToID.
         * @param name The name of the constant buffer to override.
         * @param buffer The buffer to bind.
         * @param offset Offset from the start of the buffer in bytes.
         * @param size Size in bytes of the area to bind.
         */
        public SetGlobalConstantBuffer($buffer: UnityEngine.GraphicsBuffer, $nameID: number, $offset: number, $size: number):void;
        /**
         * Add a command to bind a global constant buffer.
         * @param nameID The name ID of the constant buffer retrieved by Shader.PropertyToID.
         * @param name The name of the constant buffer to override.
         * @param buffer The buffer to bind.
         * @param offset Offset from the start of the buffer in bytes.
         * @param size Size in bytes of the area to bind.
         */
        public SetGlobalConstantBuffer($buffer: UnityEngine.GraphicsBuffer, $name: string, $offset: number, $size: number):void;
        /**
         * Add a "set shadow sampling mode" command.
         * @param shadowmap Shadowmap render target to change the sampling mode on.
         * @param mode New sampling mode.
         */
        public SetShadowSamplingMode($shadowmap: RenderTargetIdentifier, $mode: ShadowSamplingMode):void;
        
        public SetSinglePassStereo($mode: SinglePassStereoMode):void;
        /**
         * Send a user-defined event to a native code plugin.
         * @param callback Native code callback to queue for Unity's renderer to invoke.
         * @param eventID User defined id to send to the callback.
         */
        public IssuePluginEvent($callback: System.IntPtr, $eventID: number):void;
        /**
         * Send a user-defined event to a native code plugin with custom data.
         * @param callback Native code callback to queue for Unity's renderer to invoke.
         * @param data Custom data to pass to the native plugin callback.
         * @param eventID Built in or user defined id to send to the callback.
         */
        public IssuePluginEventAndData($callback: System.IntPtr, $eventID: number, $data: System.IntPtr):void;
        /**
         * Send a user-defined blit event to a native code plugin.
         * @param callback Native code callback to queue for Unity's renderer to invoke.
         * @param command User defined command id to send to the callback.
         * @param source Source render target.
         * @param dest Destination render target.
         * @param commandParam User data command parameters.
         * @param commandFlags User data command flags.
         */
        public IssuePluginCustomBlit($callback: System.IntPtr, $command: number, $source: RenderTargetIdentifier, $dest: RenderTargetIdentifier, $commandParam: number, $commandFlags: number):void;
        /**
         * Send a texture update event to a native code plugin.
         * @param callback Native code callback to queue for Unity's renderer to invoke.
         * @param targetTexture Texture resource to be updated.
         * @param userData User data to send to the native plugin.
         */
        public IssuePluginCustomTextureUpdateV2($callback: System.IntPtr, $targetTexture: UnityEngine.Texture, $userData: number):void;
        
        public ProcessVTFeedback($rt: RenderTargetIdentifier, $resolver: System.IntPtr, $slice: number, $x: number, $width: number, $y: number, $height: number, $mip: number):void;
        
                    
    }
    /**
     * Describes the desired characteristics with respect to prioritisation and load balancing of the queue that a command buffer being submitted via Graphics.ExecuteCommandBufferAsync or [[ScriptableRenderContext.ExecuteCommandBufferAsync] should be sent to.
     */
    enum ComputeQueueType { Default = 0, Background = 1, Urgent = 2 }
    /**
     * Used to manage synchronisation between tasks on async compute queues and the graphics queue.
     */
    class GraphicsFence extends System.ValueType {
        /**
         * Determines whether the GraphicsFence has passed.
         * Allows the CPU to determine whether the GPU has passed the point in its processing represented by the GraphicsFence.
         */
        public get passed(): boolean;
        
        public get_Clone(): GraphicsFence;            
    }
    /**
     * Broadly describes the stages of processing a draw call on the GPU.
     */
    enum SynchronisationStage { VertexProcessing = 0, PixelProcessing = 1 }
    /**
     * The type of the GraphicsFence. Currently the only supported fence type is AsyncQueueSynchronization.
     */
    enum GraphicsFenceType { AsyncQueueSynchronisation = 0, CPUSynchronisation = 1 }
    /**
     * Describes the various stages of GPU processing against which the GraphicsFence can be set and waited against.
     */
    enum SynchronisationStageFlags { VertexProcessing = 1, PixelProcessing = 2, ComputeProcessing = 4, AllGPUOperations = 7 }
    /**
     * How shadows are cast from this object.
     */
    enum ShadowCastingMode { Off = 0, On = 1, TwoSided = 2, ShadowsOnly = 3 }
    /**
     * Light probe interpolation type.
     */
    enum LightProbeUsage { Off = 0, BlendProbes = 1, UseProxyVolume = 2, CustomProvided = 4 }
    /**
     * This functionality is deprecated, and should no longer be used. Please use GraphicsFence.
     */
    interface GPUFence extends System.ValueType {
        
                    
    }
    /**
     * Opaque object sorting mode of a Camera.
     */
    enum OpaqueSortMode { Default = 0, FrontToBack = 1, NoDistanceSort = 2 }
    /**
     * Defines a place in camera's rendering to attach Rendering.CommandBuffer objects to.
     */
    enum CameraEvent { BeforeDepthTexture = 0, AfterDepthTexture = 1, BeforeDepthNormalsTexture = 2, AfterDepthNormalsTexture = 3, BeforeGBuffer = 4, AfterGBuffer = 5, BeforeLighting = 6, AfterLighting = 7, BeforeFinalPass = 8, AfterFinalPass = 9, BeforeForwardOpaque = 10, AfterForwardOpaque = 11, BeforeImageEffectsOpaque = 12, AfterImageEffectsOpaque = 13, BeforeSkybox = 14, AfterSkybox = 15, BeforeForwardAlpha = 16, AfterForwardAlpha = 17, BeforeImageEffects = 18, AfterImageEffects = 19, AfterEverything = 20, BeforeReflections = 21, AfterReflections = 22, BeforeHaloAndLensFlares = 23, AfterHaloAndLensFlares = 24 }
    /**
     * Parameters that configure a culling operation in the Scriptable Render Pipeline.
     */
    class ScriptableCullingParameters extends System.ValueType {
        /**
         * Maximum amount of culling planes that can be specified.
         */
        public static maximumCullingPlaneCount: number;
        /**
         * The amount of layers available.
         */
        public static layerCount: number;
        /**
         * This parameter controls how many visible lights are allowed.
         */
        public get maximumVisibleLights(): number;
        public set maximumVisibleLights(value: number);
        /**
         * Number of culling planes to use.
         */
        public get cullingPlaneCount(): number;
        public set cullingPlaneCount(value: number);
        /**
         * Is the cull orthographic.
         */
        public get isOrthographic(): boolean;
        public set isOrthographic(value: boolean);
        /**
         * LODParameters for culling.
         */
        public get lodParameters(): LODParameters;
        public set lodParameters(value: LODParameters);
        /**
         * The mask for the culling operation.
         */
        public get cullingMask(): number;
        public set cullingMask(value: number);
        /**
         * The matrix for the culling operation.
         */
        public get cullingMatrix(): UnityEngine.Matrix4x4;
        public set cullingMatrix(value: UnityEngine.Matrix4x4);
        /**
         * Position for the origin of the cull.
         */
        public get origin(): UnityEngine.Vector3;
        public set origin(value: UnityEngine.Vector3);
        /**
         * Shadow distance to use for the cull.
         */
        public get shadowDistance(): number;
        public set shadowDistance(value: number);
        /**
         * Flags to configure a culling operation in the Scriptable Render Pipeline.
         */
        public get cullingOptions(): CullingOptions;
        public set cullingOptions(value: CullingOptions);
        /**
         * Reflection Probe Sort options for the cull.
         */
        public get reflectionProbeSortingCriteria(): ReflectionProbeSortingCriteria;
        public set reflectionProbeSortingCriteria(value: ReflectionProbeSortingCriteria);
        /**
         * Camera Properties used for culling.
         */
        public get cameraProperties(): CameraProperties;
        public set cameraProperties(value: CameraProperties);
        /**
         * The view matrix generated for single-pass stereo culling.
         */
        public get stereoViewMatrix(): UnityEngine.Matrix4x4;
        public set stereoViewMatrix(value: UnityEngine.Matrix4x4);
        /**
         * The projection matrix generated for single-pass stereo culling.
         */
        public get stereoProjectionMatrix(): UnityEngine.Matrix4x4;
        public set stereoProjectionMatrix(value: UnityEngine.Matrix4x4);
        /**
         * Distance between the virtual eyes.
         */
        public get stereoSeparationDistance(): number;
        public set stereoSeparationDistance(value: number);
        /**
         * This parameter determines query distance for occlusion culling.
         */
        public get accurateOcclusionThreshold(): number;
        public set accurateOcclusionThreshold(value: number);
        /**
         * This parameter controls how many active jobs contribute to occlusion culling.
         */
        public get maximumPortalCullingJobs(): number;
        public set maximumPortalCullingJobs(value: number);
        /**
         * The lower limit to the value ScriptableCullingParameters.maximumPortalCullingJobs.
         */
        public static get cullingJobsLowerLimit(): number;
        /**
         * The upper limit to the value ScriptableCullingParameters.maximumPortalCullingJobs.
         */
        public static get cullingJobsUpperLimit(): number;
        /**
         * Get the distance for the culling of a specific layer.
         */
        public GetLayerCullingDistance($layerIndex: number):number;
        /**
         * Set the distance for the culling of a specific layer.
         */
        public SetLayerCullingDistance($layerIndex: number, $distance: number):void;
        /**
         * Fetch the culling plane at the given index.
         */
        public GetCullingPlane($index: number):UnityEngine.Plane;
        /**
         * Set the culling plane at a given index.
         */
        public SetCullingPlane($index: number, $plane: UnityEngine.Plane):void;
        
        public Equals($other: ScriptableCullingParameters):boolean;
        
        public Equals($obj: any):boolean;
        
        public GetHashCode():number;
        
        public static op_Equality($left: ScriptableCullingParameters, $right: ScriptableCullingParameters):boolean;
        
        public static op_Inequality($left: ScriptableCullingParameters, $right: ScriptableCullingParameters):boolean;
        
        public get_Clone(): ScriptableCullingParameters;            
    }
    
    enum ReflectionProbeType { Cube = 0, Card = 1 }
    /**
     * Values for ReflectionProbe.clearFlags, determining what to clear when rendering a ReflectionProbe.
     */
    enum ReflectionProbeClearFlags { Skybox = 1, SolidColor = 2 }
    /**
     * Reflection probe's update mode.
     */
    enum ReflectionProbeMode { Baked = 0, Realtime = 1, Custom = 2 }
    /**
     * An enum describing the way a realtime reflection probe refreshes in the Player.
     */
    enum ReflectionProbeRefreshMode { OnAwake = 0, EveryFrame = 1, ViaScripting = 2 }
    /**
     * When a probe's ReflectionProbe.refreshMode is set to ReflectionProbeRefreshMode.EveryFrame, this enum specify whether or not Unity should update the probe's cubemap over several frames or update the whole cubemap in one frame.
     * Updating a probe's cubemap is a costly operation. Unity needs to render the entire Scene for each face of the cubemap, as well as perform special blurring in order to get glossy reflections. The impact on frame rate can be significant. Time-slicing helps maintaning a more constant frame rate during these updates by performing the rendering over several frames.
     */
    enum ReflectionProbeTimeSlicingMode { AllFacesAtOnce = 0, IndividualFaces = 1, NoTimeSlicing = 2 }
    /**
     * Spherical harmonics up to the second order (3 bands, 9 coefficients).
     */
    class SphericalHarmonicsL2 extends System.ValueType {
        /**
         * Clears SH probe to zero.
         */
        public Clear():void;
        /**
         * Add ambient lighting to probe data.
         */
        public AddAmbientLight($color: UnityEngine.Color):void;
        /**
         * Add directional light to probe data.
         */
        public AddDirectionalLight($direction: UnityEngine.Vector3, $color: UnityEngine.Color, $intensity: number):void;
        /**
         * Evaluates the Spherical Harmonics for each of the given directions. The result from the first direction is written into the first element of results, the result from the second direction is written into the second element of results, and so on. The array size of directions and results must match and directions must be normalized.
         * @param directions Normalized directions for which the spherical harmonics are to be evaluated.
         * @param results Output array for the evaluated values of the corresponding directions.
         */
        public Evaluate($directions: UnityEngine.Vector3[], $results: UnityEngine.Color[]):void;
        
        public GetHashCode():number;
        
        public Equals($other: any):boolean;
        
        public Equals($other: SphericalHarmonicsL2):boolean;
        /**
         * Scales SH by a given factor.
         */
        public static op_Multiply($lhs: SphericalHarmonicsL2, $rhs: number):SphericalHarmonicsL2;
        /**
         * Scales SH by a given factor.
         */
        public static op_Multiply($lhs: number, $rhs: SphericalHarmonicsL2):SphericalHarmonicsL2;
        
        public static op_Addition($lhs: SphericalHarmonicsL2, $rhs: SphericalHarmonicsL2):SphericalHarmonicsL2;
        
        public static op_Equality($lhs: SphericalHarmonicsL2, $rhs: SphericalHarmonicsL2):boolean;
        
        public static op_Inequality($lhs: SphericalHarmonicsL2, $rhs: SphericalHarmonicsL2):boolean;
        
        public get_Clone(): SphericalHarmonicsL2;            
    }
    /**
     * This enum describes what should be done on the render target when it is activated (loaded).
     */
    enum RenderBufferLoadAction { Load = 0, Clear = 1, DontCare = 2 }
    /**
     * This enum describes what should be done on the render target when the GPU is done rendering into it.
     */
    enum RenderBufferStoreAction { Store = 0, Resolve = 1, StoreAndResolve = 2, DontCare = 3 }
    /**
     * An asset that produces a specific IRenderPipeline.
     */
    class RenderPipelineAsset extends UnityEngine.ScriptableObject {
        /**
         * The render index for the terrain brush in the editor.
         * @returns Queue index.
         */
        public get terrainBrushPassIndex(): number;
        /**
         * Returns the list of names used to display Rendering Layer Mask UI for this pipeline.
         * @returns Array of 32 Rendering Layer Mask names.
         */
        public get renderingLayerMaskNames(): string[];
        /**
         * Return the default Material for this pipeline.
         * @returns Default material.
         */
        public get defaultMaterial(): UnityEngine.Material;
        /**
         * Retrieves the default Autodesk Interactive Shader for this pipeline.
         * @returns Returns the default shader.
         */
        public get autodeskInteractiveShader(): UnityEngine.Shader;
        /**
         * Retrieves the default Autodesk Interactive transparent Shader for this pipeline.
         * @returns Returns the default shader.
         */
        public get autodeskInteractiveTransparentShader(): UnityEngine.Shader;
        /**
         * Retrieves the default Autodesk Interactive masked Shader for this pipeline.
         * @returns Returns the default shader.
         */
        public get autodeskInteractiveMaskedShader(): UnityEngine.Shader;
        /**
         * Return the detail lit Shader for this pipeline.
         */
        public get terrainDetailLitShader(): UnityEngine.Shader;
        /**
         * Return the detail grass Shader for this pipeline.
         */
        public get terrainDetailGrassShader(): UnityEngine.Shader;
        /**
         * Return the detail grass billboard Shader for this pipeline.
         */
        public get terrainDetailGrassBillboardShader(): UnityEngine.Shader;
        /**
         * Return the default particle Material for this pipeline.
         * @returns Default material.
         */
        public get defaultParticleMaterial(): UnityEngine.Material;
        /**
         * Return the default Line Material for this pipeline.
         * @returns Default material.
         */
        public get defaultLineMaterial(): UnityEngine.Material;
        /**
         * Return the default Terrain  Material for this pipeline.
         * @returns Default material.
         */
        public get defaultTerrainMaterial(): UnityEngine.Material;
        /**
         * Return the default UI Material for this pipeline.
         * @returns Default material.
         */
        public get defaultUIMaterial(): UnityEngine.Material;
        /**
         * Return the default UI overdraw Material for this pipeline.
         * @returns Default material.
         */
        public get defaultUIOverdrawMaterial(): UnityEngine.Material;
        /**
         * Return the default UI ETC1  Material for this pipeline.
         * @returns Default material.
         */
        public get defaultUIETC1SupportedMaterial(): UnityEngine.Material;
        /**
         * Return the default 2D Material for this pipeline.
         * @returns Default material.
         */
        public get default2DMaterial(): UnityEngine.Material;
        /**
         * Return the default Shader for this pipeline.
         * @returns Default shader.
         */
        public get defaultShader(): UnityEngine.Shader;
        /**
         * Return the default SpeedTree v7 Shader for this pipeline.
         */
        public get defaultSpeedTree7Shader(): UnityEngine.Shader;
        /**
         * Return the default SpeedTree v8 Shader for this pipeline.
         */
        public get defaultSpeedTree8Shader(): UnityEngine.Shader;
        
                    
    }
    /**
     * Format of the mesh index buffer data.
     */
    enum IndexFormat { UInt16 = 0, UInt32 = 1 }
    /**
     * Information about a single VertexAttribute of a Mesh vertex.
     */
    class VertexAttributeDescriptor extends System.ValueType {
        /**
         * The vertex attribute.
         */
        public get attribute(): VertexAttribute;
        public set attribute(value: VertexAttribute);
        /**
         * Format of the vertex attribute.
         */
        public get format(): VertexAttributeFormat;
        public set format(value: VertexAttributeFormat);
        /**
         * Dimensionality of the vertex attribute.
         */
        public get dimension(): number;
        public set dimension(value: number);
        /**
         * Which vertex buffer stream the attribute should be in.
         */
        public get stream(): number;
        public set stream(value: number);
        /**
         * Create a VertexAttributeDescriptor structure.
         * @param attribute The VertexAttribute.
         * @param format Format of the vertex attribute. Default is VertexAttributeFormat.Float32.
         * @param dimension Dimensionality of the vertex attribute (1 to 4). Default is 3.
         * @param stream Vertex buffer stream that the attribute should be placed in. Default is 0.
         */
        public constructor($attribute?: VertexAttribute, $format?: VertexAttributeFormat, $dimension?: number, $stream?: number);
        
        public ToString():string;
        
        public GetHashCode():number;
        
        public Equals($other: any):boolean;
        
        public Equals($other: VertexAttributeDescriptor):boolean;
        
        public static op_Equality($lhs: VertexAttributeDescriptor, $rhs: VertexAttributeDescriptor):boolean;
        
        public static op_Inequality($lhs: VertexAttributeDescriptor, $rhs: VertexAttributeDescriptor):boolean;
        
        public get_Clone(): VertexAttributeDescriptor;            
    }
    /**
     * Possible attribute types that describe a vertex in a Mesh.
     */
    enum VertexAttribute { Position = 0, Normal = 1, Tangent = 2, Color = 3, TexCoord0 = 4, TexCoord1 = 5, TexCoord2 = 6, TexCoord3 = 7, TexCoord4 = 8, TexCoord5 = 9, TexCoord6 = 10, TexCoord7 = 11, BlendWeight = 12, BlendIndices = 13 }
    /**
     * Data type of a VertexAttribute.
     */
    enum VertexAttributeFormat { Float32 = 0, Float16 = 1, UNorm8 = 2, SNorm8 = 3, UNorm16 = 4, SNorm16 = 5, UInt8 = 6, SInt8 = 7, UInt16 = 8, SInt16 = 9, UInt32 = 10, SInt32 = 11 }
    /**
     * Contains information about a single sub-mesh of a Mesh.
     */
    class SubMeshDescriptor extends System.ValueType {
        /**
         * Bounding box of vertices in local space.
         */
        public get bounds(): UnityEngine.Bounds;
        public set bounds(value: UnityEngine.Bounds);
        /**
         * Face topology of this sub-mesh.
         */
        public get topology(): UnityEngine.MeshTopology;
        public set topology(value: UnityEngine.MeshTopology);
        /**
         * Starting point inside the whole Mesh index buffer where the face index data is found.
         */
        public get indexStart(): number;
        public set indexStart(value: number);
        /**
         * Index count for this sub-mesh face data.
         */
        public get indexCount(): number;
        public set indexCount(value: number);
        /**
         * Offset that is added to each value in the index buffer, to compute the final vertex index.
         */
        public get baseVertex(): number;
        public set baseVertex(value: number);
        /**
         * First vertex in the index buffer for this sub-mesh.
         */
        public get firstVertex(): number;
        public set firstVertex(value: number);
        /**
         * Number of vertices used by the index buffer of this sub-mesh.
         */
        public get vertexCount(): number;
        public set vertexCount(value: number);
        /**
         * Create a submesh descriptor.
         * @param indexStart Initial value for indexStart field.
         * @param indexCount Initial value for indexCount field.
         * @param topology Initial value for topology field.
         */
        public constructor($indexStart: number, $indexCount: number, $topology?: UnityEngine.MeshTopology);
        
        public ToString():string;
        
        public get_Clone(): SubMeshDescriptor;            
    }
    /**
     * Mesh data update flags.
     */
    enum MeshUpdateFlags { Default = 0, DontValidateIndices = 1, DontResetBoneBounds = 2, DontNotifyMeshUsers = 4, DontRecalculateBounds = 8 }
    /**
     * Reflection Probe usage.
     */
    enum ReflectionProbeUsage { Off = 0, BlendProbes = 1, BlendProbesAndSkybox = 2, Simple = 3 }
    /**
     * ReflectionProbeBlendInfo contains information required for blending probes.
     */
    class ReflectionProbeBlendInfo extends System.ValueType {
        /**
         * Reflection Probe used in blending.
         */
        public probe: UnityEngine.ReflectionProbe;
        /**
         * Specifies the weight used in the interpolation between two probes, value varies from 0.0 to 1.0.
         */
        public weight: number;
        
                    
    }
    
    enum ShaderHardwareTier { Tier1 = 0, Tier2 = 1, Tier3 = 2 }
    /**
     * Shader tag ids are used to refer to various names in shaders.
     */
    class ShaderTagId extends System.ValueType {
        /**
         * Describes a shader tag id not referring to any name.
         */
        public static none: ShaderTagId;
        /**
         * Gets the name of the tag referred to by the shader tag id.
         */
        public get name(): string;
        /**
         * Gets or creates a shader tag id representing the given name.
         * @param name The name to represent with the shader tag id.
         */
        public constructor($name: string);
        
        public Equals($obj: any):boolean;
        
        public Equals($other: ShaderTagId):boolean;
        
        public GetHashCode():number;
        
        public static op_Equality($tag1: ShaderTagId, $tag2: ShaderTagId):boolean;
        
        public static op_Inequality($tag1: ShaderTagId, $tag2: ShaderTagId):boolean;
        /**
         * Converts a string to a ShaderTagId.
         */
        public static op_Explicit($name: string):ShaderTagId;
        /**
         * Converts a ShaderTagId to a string.
         */
        public static op_Explicit($tagId: ShaderTagId):string;
        
        public get_Clone(): ShaderTagId;            
    }
    /**
     * Types of data that you can encapsulate within a render texture.
     */
    enum RenderTextureSubElement { Color = 0, Depth = 1, Stencil = 2, Default = 3 }
    /**
     * Type of a given shader property.
     */
    enum ShaderPropertyType { Color = 0, Vector = 1, Float = 2, Range = 3, Texture = 4 }
    /**
     * Flags that control how a shader property behaves.
     */
    enum ShaderPropertyFlags { None = 0, HideInInspector = 1, PerRendererData = 2, NoScaleOffset = 4, Normal = 8, HDR = 16, Gamma = 32, NonModifiableTextureData = 64, MainTexture = 128, MainColor = 256 }
    /**
     * Ambient lighting mode.
     */
    enum AmbientMode { Skybox = 0, Trilight = 1, Flat = 3, Custom = 4 }
    /**
     * Default reflection mode.
     */
    enum DefaultReflectionMode { Skybox = 0, Custom = 1 }
    /**
     * Shadow resolution options for a Light.
     */
    enum LightShadowResolution { FromQualitySettings = -1, Low = 0, Medium = 1, High = 2, VeryHigh = 3 }
    /**
     * Defines a place in light's rendering to attach Rendering.CommandBuffer objects to.
     */
    enum LightEvent { BeforeShadowMap = 0, AfterShadowMap = 1, BeforeScreenspaceMask = 2, AfterScreenspaceMask = 3, BeforeShadowMapPass = 4, AfterShadowMapPass = 5 }
    /**
     * Allows precise control over which shadow map passes to execute Rendering.CommandBuffer objects attached using Light.AddCommandBuffer.
     */
    enum ShadowMapPass { PointlightPositiveX = 1, PointlightNegativeX = 2, PointlightPositiveY = 4, PointlightNegativeY = 8, PointlightPositiveZ = 16, PointlightNegativeZ = 32, DirectionalCascade0 = 64, DirectionalCascade1 = 128, DirectionalCascade2 = 256, DirectionalCascade3 = 512, Spotlight = 1024, Pointlight = 63, Directional = 960, All = 2047 }
    /**
     * Used by CommandBuffer.SetShadowSamplingMode.
     */
    enum ShadowSamplingMode { CompareDepths = 0, RawDepth = 1, None = 2 }
    /**
     * Shader pass type for Unity's lighting pipeline.
     */
    enum PassType { Normal = 0, Vertex = 1, VertexLM = 2, VertexLMRGBM = 3, ForwardBase = 4, ForwardAdd = 5, LightPrePassBase = 6, LightPrePassFinal = 7, ShadowCaster = 8, Deferred = 10, Meta = 11, MotionVectors = 12, ScriptableRenderPipeline = 13, ScriptableRenderPipelineDefaultUnlit = 14 }
    /**
     * Graphics device API type.
     */
    enum GraphicsDeviceType { OpenGL2 = 0, Direct3D9 = 1, Direct3D11 = 2, PlayStation3 = 3, Null = 4, Xbox360 = 6, OpenGLES2 = 8, OpenGLES3 = 11, PlayStationVita = 12, PlayStation4 = 13, XboxOne = 14, PlayStationMobile = 15, Metal = 16, OpenGLCore = 17, Direct3D12 = 18, N3DS = 19, Vulkan = 21, Switch = 22, XboxOneD3D12 = 23, GameCoreXboxOne = 24, GameCoreScarlett = 25, GameCoreXboxSeries = 25, PlayStation5 = 26, PlayStation5NGGC = 27 }
    /**
     * Options for the application's actual rendering threading mode.
     */
    enum RenderingThreadingMode { Direct = 0, SingleThreaded = 1, MultiThreaded = 2, LegacyJobified = 3, NativeGraphicsJobs = 4, NativeGraphicsJobsWithoutRenderThread = 5 }
    /**
     * Support for various Graphics.CopyTexture cases.
     */
    enum CopyTextureSupport { None = 0, Basic = 1, Copy3D = 2, DifferentTypes = 4, TextureToRT = 8, RTToTexture = 16 }
    /**
     * Represents an asynchronous request for a GPU resource.
     */
    class AsyncGPUReadbackRequest extends System.ValueType {
        /**
         * Checks whether the request has been processed.
         */
        public get done(): boolean;
        /**
         * This property is true if the request has encountered an error.
         */
        public get hasError(): boolean;
        /**
         * Number of layers in the current request.
         */
        public get layerCount(): number;
        /**
         * The size in bytes of one layer of the readback data.
         */
        public get layerDataSize(): number;
        /**
         * The width of the requested GPU data.
         */
        public get width(): number;
        /**
         * When reading data from a ComputeBuffer, height is 1, otherwise, the property takes the value of the requested height from the texture.
         */
        public get height(): number;
        /**
         * When reading data from a ComputeBuffer, depth is 1, otherwise, the property takes the value of the requested depth from the texture.
         */
        public get depth(): number;
        /**
         * Triggers an update of the request.
         */
        public Update():void;
        /**
         * Waits for completion of the request.
         */
        public WaitForCompletion():void;
        /**
         * Fetches the data of a successful request.
         * @param layer The index of the layer to retrieve.
         */
        public GetData<T>($layer?: number):Unity_Collections.NativeArray$1<T>;
        
        public get_Clone(): AsyncGPUReadbackRequest;            
    }
    /**
     * Allows the asynchronous read back of GPU resources.
     */
    class AsyncGPUReadback extends System.Object {
        /**
         * Waits until the completion of every request.
         */
        public static WaitAllRequests():void;
        
        public static Request($src: UnityEngine.ComputeBuffer, $callback?: System.Action$1<AsyncGPUReadbackRequest>):AsyncGPUReadbackRequest;
        
        public static Request($src: UnityEngine.ComputeBuffer, $size: number, $offset: number, $callback?: System.Action$1<AsyncGPUReadbackRequest>):AsyncGPUReadbackRequest;
        
        public static Request($src: UnityEngine.GraphicsBuffer, $callback?: System.Action$1<AsyncGPUReadbackRequest>):AsyncGPUReadbackRequest;
        
        public static Request($src: UnityEngine.GraphicsBuffer, $size: number, $offset: number, $callback?: System.Action$1<AsyncGPUReadbackRequest>):AsyncGPUReadbackRequest;
        
        public static Request($src: UnityEngine.Texture, $mipIndex?: number, $callback?: System.Action$1<AsyncGPUReadbackRequest>):AsyncGPUReadbackRequest;
        
        public static Request($src: UnityEngine.Texture, $mipIndex: number, $dstFormat: UnityEngine.TextureFormat, $callback?: System.Action$1<AsyncGPUReadbackRequest>):AsyncGPUReadbackRequest;
        
        public static Request($src: UnityEngine.Texture, $mipIndex: number, $dstFormat: UnityEngine_Experimental_Rendering.GraphicsFormat, $callback?: System.Action$1<AsyncGPUReadbackRequest>):AsyncGPUReadbackRequest;
        
        public static Request($src: UnityEngine.Texture, $mipIndex: number, $x: number, $width: number, $y: number, $height: number, $z: number, $depth: number, $callback?: System.Action$1<AsyncGPUReadbackRequest>):AsyncGPUReadbackRequest;
        
        public static Request($src: UnityEngine.Texture, $mipIndex: number, $x: number, $width: number, $y: number, $height: number, $z: number, $depth: number, $dstFormat: UnityEngine.TextureFormat, $callback?: System.Action$1<AsyncGPUReadbackRequest>):AsyncGPUReadbackRequest;
        
        public static Request($src: UnityEngine.Texture, $mipIndex: number, $x: number, $width: number, $y: number, $height: number, $z: number, $depth: number, $dstFormat: UnityEngine_Experimental_Rendering.GraphicsFormat, $callback?: System.Action$1<AsyncGPUReadbackRequest>):AsyncGPUReadbackRequest;
        
        public static RequestIntoNativeArray<T>($output: $Ref<Unity_Collections.NativeArray$1<T>>, $src: UnityEngine.ComputeBuffer, $callback?: System.Action$1<AsyncGPUReadbackRequest>):AsyncGPUReadbackRequest;
        
        public static RequestIntoNativeArray<T>($output: $Ref<Unity_Collections.NativeArray$1<T>>, $src: UnityEngine.ComputeBuffer, $size: number, $offset: number, $callback?: System.Action$1<AsyncGPUReadbackRequest>):AsyncGPUReadbackRequest;
        
        public static RequestIntoNativeArray<T>($output: $Ref<Unity_Collections.NativeArray$1<T>>, $src: UnityEngine.GraphicsBuffer, $callback?: System.Action$1<AsyncGPUReadbackRequest>):AsyncGPUReadbackRequest;
        
        public static RequestIntoNativeArray<T>($output: $Ref<Unity_Collections.NativeArray$1<T>>, $src: UnityEngine.GraphicsBuffer, $size: number, $offset: number, $callback?: System.Action$1<AsyncGPUReadbackRequest>):AsyncGPUReadbackRequest;
        
        public static RequestIntoNativeArray<T>($output: $Ref<Unity_Collections.NativeArray$1<T>>, $src: UnityEngine.Texture, $mipIndex?: number, $callback?: System.Action$1<AsyncGPUReadbackRequest>):AsyncGPUReadbackRequest;
        
        public static RequestIntoNativeArray<T>($output: $Ref<Unity_Collections.NativeArray$1<T>>, $src: UnityEngine.Texture, $mipIndex: number, $dstFormat: UnityEngine.TextureFormat, $callback?: System.Action$1<AsyncGPUReadbackRequest>):AsyncGPUReadbackRequest;
        
        public static RequestIntoNativeArray<T>($output: $Ref<Unity_Collections.NativeArray$1<T>>, $src: UnityEngine.Texture, $mipIndex: number, $dstFormat: UnityEngine_Experimental_Rendering.GraphicsFormat, $callback?: System.Action$1<AsyncGPUReadbackRequest>):AsyncGPUReadbackRequest;
        
        public static RequestIntoNativeArray<T>($output: $Ref<Unity_Collections.NativeArray$1<T>>, $src: UnityEngine.Texture, $mipIndex: number, $x: number, $width: number, $y: number, $height: number, $z: number, $depth: number, $dstFormat: UnityEngine.TextureFormat, $callback?: System.Action$1<AsyncGPUReadbackRequest>):AsyncGPUReadbackRequest;
        
        public static RequestIntoNativeArray<T>($output: $Ref<Unity_Collections.NativeArray$1<T>>, $src: UnityEngine.Texture, $mipIndex: number, $x: number, $width: number, $y: number, $height: number, $z: number, $depth: number, $dstFormat: UnityEngine_Experimental_Rendering.GraphicsFormat, $callback?: System.Action$1<AsyncGPUReadbackRequest>):AsyncGPUReadbackRequest;
        
        public static RequestIntoNativeSlice<T>($output: $Ref<Unity_Collections.NativeSlice$1<T>>, $src: UnityEngine.ComputeBuffer, $callback?: System.Action$1<AsyncGPUReadbackRequest>):AsyncGPUReadbackRequest;
        
        public static RequestIntoNativeSlice<T>($output: $Ref<Unity_Collections.NativeSlice$1<T>>, $src: UnityEngine.ComputeBuffer, $size: number, $offset: number, $callback?: System.Action$1<AsyncGPUReadbackRequest>):AsyncGPUReadbackRequest;
        
        public static RequestIntoNativeSlice<T>($output: $Ref<Unity_Collections.NativeSlice$1<T>>, $src: UnityEngine.GraphicsBuffer, $callback?: System.Action$1<AsyncGPUReadbackRequest>):AsyncGPUReadbackRequest;
        
        public static RequestIntoNativeSlice<T>($output: $Ref<Unity_Collections.NativeSlice$1<T>>, $src: UnityEngine.GraphicsBuffer, $size: number, $offset: number, $callback?: System.Action$1<AsyncGPUReadbackRequest>):AsyncGPUReadbackRequest;
        
        public static RequestIntoNativeSlice<T>($output: $Ref<Unity_Collections.NativeSlice$1<T>>, $src: UnityEngine.Texture, $mipIndex?: number, $callback?: System.Action$1<AsyncGPUReadbackRequest>):AsyncGPUReadbackRequest;
        
        public static RequestIntoNativeSlice<T>($output: $Ref<Unity_Collections.NativeSlice$1<T>>, $src: UnityEngine.Texture, $mipIndex: number, $dstFormat: UnityEngine.TextureFormat, $callback?: System.Action$1<AsyncGPUReadbackRequest>):AsyncGPUReadbackRequest;
        
        public static RequestIntoNativeSlice<T>($output: $Ref<Unity_Collections.NativeSlice$1<T>>, $src: UnityEngine.Texture, $mipIndex: number, $dstFormat: UnityEngine_Experimental_Rendering.GraphicsFormat, $callback?: System.Action$1<AsyncGPUReadbackRequest>):AsyncGPUReadbackRequest;
        
        public static RequestIntoNativeSlice<T>($output: $Ref<Unity_Collections.NativeSlice$1<T>>, $src: UnityEngine.Texture, $mipIndex: number, $x: number, $width: number, $y: number, $height: number, $z: number, $depth: number, $dstFormat: UnityEngine.TextureFormat, $callback?: System.Action$1<AsyncGPUReadbackRequest>):AsyncGPUReadbackRequest;
        
        public static RequestIntoNativeSlice<T>($output: $Ref<Unity_Collections.NativeSlice$1<T>>, $src: UnityEngine.Texture, $mipIndex: number, $x: number, $width: number, $y: number, $height: number, $z: number, $depth: number, $dstFormat: UnityEngine_Experimental_Rendering.GraphicsFormat, $callback?: System.Action$1<AsyncGPUReadbackRequest>):AsyncGPUReadbackRequest;
        
                    
    }
    /**
     * Provides an interface to control GPU frame capture in Microsoft's PIX software.
     */
    class PIX extends System.Object {
        
        public constructor();
        /**
         * Begins a GPU frame capture in PIX. If not running via PIX, or as a development build, then it has no effect.
         */
        public static BeginGPUCapture():void;
        /**
         * Ends the current GPU frame capture in PIX. If not running via PIX, or as a development build, then it has no effect.
         */
        public static EndGPUCapture():void;
        /**
         * Returns true if running via PIX and in a development build.
         */
        public static IsAttached():boolean;
        
                    
    }
    /**
     * Determine in which order objects are renderered.
     */
    enum RenderQueue { Background = 1000, Geometry = 2000, AlphaTest = 2450, GeometryLast = 2500, Transparent = 3000, Overlay = 4000 }
    /**
     * Control Fast Memory render target layout.
     */
    enum FastMemoryFlags { None = 0, SpillTop = 1, SpillBottom = 2 }
    /**
     * Blend mode for controlling the blending.
     */
    enum BlendMode { Zero = 0, One = 1, DstColor = 2, SrcColor = 3, OneMinusDstColor = 4, SrcAlpha = 5, OneMinusSrcColor = 6, DstAlpha = 7, OneMinusDstAlpha = 8, SrcAlphaSaturate = 9, OneMinusSrcAlpha = 10 }
    /**
     * Blend operation.
     */
    enum BlendOp { Add = 0, Subtract = 1, ReverseSubtract = 2, Min = 3, Max = 4, LogicalClear = 5, LogicalSet = 6, LogicalCopy = 7, LogicalCopyInverted = 8, LogicalNoop = 9, LogicalInvert = 10, LogicalAnd = 11, LogicalNand = 12, LogicalOr = 13, LogicalNor = 14, LogicalXor = 15, LogicalEquivalence = 16, LogicalAndReverse = 17, LogicalAndInverted = 18, LogicalOrReverse = 19, LogicalOrInverted = 20, Multiply = 21, Screen = 22, Overlay = 23, Darken = 24, Lighten = 25, ColorDodge = 26, ColorBurn = 27, HardLight = 28, SoftLight = 29, Difference = 30, Exclusion = 31, HSLHue = 32, HSLSaturation = 33, HSLColor = 34, HSLLuminosity = 35 }
    /**
     * Depth or stencil comparison function.
     */
    enum CompareFunction { Disabled = 0, Never = 1, Less = 2, Equal = 3, LessEqual = 4, Greater = 5, NotEqual = 6, GreaterEqual = 7, Always = 8 }
    /**
     * Backface culling mode.
     */
    enum CullMode { Off = 0, Front = 1, Back = 2 }
    /**
     * Specifies which color components will get written into the target framebuffer.
     */
    enum ColorWriteMask { Alpha = 1, Blue = 2, Green = 4, Red = 8, All = 15 }
    /**
     * Specifies the operation that's performed on the stencil buffer when rendering.
     */
    enum StencilOp { Keep = 0, Zero = 1, Replace = 2, IncrementSaturate = 3, DecrementSaturate = 4, Invert = 5, IncrementWrap = 6, DecrementWrap = 7 }
    /**
     * Determines how Unity will compress baked reflection cubemap.
     */
    enum ReflectionCubemapCompression { Uncompressed = 0, Compressed = 1, Auto = 2 }
    /**
     * Built-in temporary render textures produced during camera's rendering.
     */
    enum BuiltinRenderTextureType { PropertyName = -4, BufferPtr = -3, RenderTexture = -2, BindableTexture = -1, None = 0, CurrentActive = 1, CameraTarget = 2, Depth = 3, DepthNormals = 4, ResolvedDepth = 5, PrepassNormalsSpec = 7, PrepassLight = 8, PrepassLightSpec = 9, GBuffer0 = 10, GBuffer1 = 11, GBuffer2 = 12, GBuffer3 = 13, Reflections = 14, MotionVectors = 15, GBuffer4 = 16, GBuffer5 = 17, GBuffer6 = 18, GBuffer7 = 19 }
    /**
     * Graphics Format Swizzle.
     */
    enum FormatSwizzle { FormatSwizzleR = 0, FormatSwizzleG = 1, FormatSwizzleB = 2, FormatSwizzleA = 3, FormatSwizzle0 = 4, FormatSwizzle1 = 5 }
    /**
     * Identifies a RenderTexture for a Rendering.CommandBuffer.
     */
    class RenderTargetIdentifier extends System.ValueType {
        /**
         * All depth-slices of the render resource are bound for rendering. For textures which are neither array nor 3D, the default slice is bound.
         */
        public static AllDepthSlices: number;
        /**
         * Creates a render target identifier.
         * @param type Built-in temporary render texture type.
         * @param name Temporary render texture name.
         * @param nameID Temporary render texture name (as integer, see Shader.PropertyToID).
         * @param tex RenderTexture or Texture object to use.
         * @param mipLevel MipLevel of the RenderTexture to use.
         * @param cubemapFace Cubemap face of the Cubemap RenderTexture to use.
         * @param depthSlice Depth slice of the Array RenderTexture to use. The symbolic constant RenderTargetIdentifier.AllDepthSlices indicates that all slices should be bound for rendering. The default value is 0.
         * @param renderTargetIdentifier An existing render target identifier.
         */
        public constructor($type: BuiltinRenderTextureType);
        
        public constructor($type: BuiltinRenderTextureType, $mipLevel?: number, $cubeFace?: UnityEngine.CubemapFace, $depthSlice?: number);
        /**
         * Creates a render target identifier.
         * @param type Built-in temporary render texture type.
         * @param name Temporary render texture name.
         * @param nameID Temporary render texture name (as integer, see Shader.PropertyToID).
         * @param tex RenderTexture or Texture object to use.
         * @param mipLevel MipLevel of the RenderTexture to use.
         * @param cubemapFace Cubemap face of the Cubemap RenderTexture to use.
         * @param depthSlice Depth slice of the Array RenderTexture to use. The symbolic constant RenderTargetIdentifier.AllDepthSlices indicates that all slices should be bound for rendering. The default value is 0.
         * @param renderTargetIdentifier An existing render target identifier.
         */
        public constructor($name: string);
        
        public constructor($name: string, $mipLevel?: number, $cubeFace?: UnityEngine.CubemapFace, $depthSlice?: number);
        /**
         * Creates a render target identifier.
         * @param type Built-in temporary render texture type.
         * @param name Temporary render texture name.
         * @param nameID Temporary render texture name (as integer, see Shader.PropertyToID).
         * @param tex RenderTexture or Texture object to use.
         * @param mipLevel MipLevel of the RenderTexture to use.
         * @param cubemapFace Cubemap face of the Cubemap RenderTexture to use.
         * @param depthSlice Depth slice of the Array RenderTexture to use. The symbolic constant RenderTargetIdentifier.AllDepthSlices indicates that all slices should be bound for rendering. The default value is 0.
         * @param renderTargetIdentifier An existing render target identifier.
         */
        public constructor($nameID: number);
        
        public constructor($nameID: number, $mipLevel?: number, $cubeFace?: UnityEngine.CubemapFace, $depthSlice?: number);
        /**
         * Creates a render target identifier.
         * @param type Built-in temporary render texture type.
         * @param name Temporary render texture name.
         * @param nameID Temporary render texture name (as integer, see Shader.PropertyToID).
         * @param tex RenderTexture or Texture object to use.
         * @param mipLevel MipLevel of the RenderTexture to use.
         * @param cubemapFace Cubemap face of the Cubemap RenderTexture to use.
         * @param depthSlice Depth slice of the Array RenderTexture to use. The symbolic constant RenderTargetIdentifier.AllDepthSlices indicates that all slices should be bound for rendering. The default value is 0.
         * @param renderTargetIdentifier An existing render target identifier.
         */
        public constructor($renderTargetIdentifier: RenderTargetIdentifier, $mipLevel: number, $cubeFace?: UnityEngine.CubemapFace, $depthSlice?: number);
        /**
         * Creates a render target identifier.
         * @param type Built-in temporary render texture type.
         * @param name Temporary render texture name.
         * @param nameID Temporary render texture name (as integer, see Shader.PropertyToID).
         * @param tex RenderTexture or Texture object to use.
         * @param mipLevel MipLevel of the RenderTexture to use.
         * @param cubemapFace Cubemap face of the Cubemap RenderTexture to use.
         * @param depthSlice Depth slice of the Array RenderTexture to use. The symbolic constant RenderTargetIdentifier.AllDepthSlices indicates that all slices should be bound for rendering. The default value is 0.
         * @param renderTargetIdentifier An existing render target identifier.
         */
        public constructor($tex: UnityEngine.Texture);
        
        public constructor($tex: UnityEngine.Texture, $mipLevel?: number, $cubeFace?: UnityEngine.CubemapFace, $depthSlice?: number);
        
        public constructor($buf: UnityEngine.RenderBuffer, $mipLevel?: number, $cubeFace?: UnityEngine.CubemapFace, $depthSlice?: number);
        
        public static op_Implicit($type: BuiltinRenderTextureType):RenderTargetIdentifier;
        
        public static op_Implicit($name: string):RenderTargetIdentifier;
        
        public static op_Implicit($nameID: number):RenderTargetIdentifier;
        
        public static op_Implicit($tex: UnityEngine.Texture):RenderTargetIdentifier;
        
        public static op_Implicit($buf: UnityEngine.RenderBuffer):RenderTargetIdentifier;
        
        public ToString():string;
        
        public GetHashCode():number;
        
        public Equals($rhs: RenderTargetIdentifier):boolean;
        
        public Equals($obj: any):boolean;
        
        public static op_Equality($lhs: RenderTargetIdentifier, $rhs: RenderTargetIdentifier):boolean;
        
        public static op_Inequality($lhs: RenderTargetIdentifier, $rhs: RenderTargetIdentifier):boolean;
        
        public get_Clone(): RenderTargetIdentifier;            
    }
    /**
     * This enum describes optional flags for the RenderTargetBinding structure.
     */
    enum RenderTargetFlags { None = 0, ReadOnlyDepth = 1, ReadOnlyStencil = 2, ReadOnlyDepthStencil = 3 }
    /**
     * Describes a render target with one or more color buffers, a depthstencil buffer and the associated loadstore-actions that are applied when the render target is active.
     */
    class RenderTargetBinding extends System.ValueType {
        /**
         * Color buffers to use as render targets.
         */
        public get colorRenderTargets(): RenderTargetIdentifier[];
        public set colorRenderTargets(value: RenderTargetIdentifier[]);
        /**
         * Depth/stencil buffer to use as render target.
         */
        public get depthRenderTarget(): RenderTargetIdentifier;
        public set depthRenderTarget(value: RenderTargetIdentifier);
        /**
         * Load actions for color buffers.
         */
        public get colorLoadActions(): RenderBufferLoadAction[];
        public set colorLoadActions(value: RenderBufferLoadAction[]);
        /**
         * Store actions for color buffers.
         */
        public get colorStoreActions(): RenderBufferStoreAction[];
        public set colorStoreActions(value: RenderBufferStoreAction[]);
        /**
         * Load action for the depth/stencil buffer.
         */
        public get depthLoadAction(): RenderBufferLoadAction;
        public set depthLoadAction(value: RenderBufferLoadAction);
        /**
         * Store action for the depth/stencil buffer.
         */
        public get depthStoreAction(): RenderBufferStoreAction;
        public set depthStoreAction(value: RenderBufferStoreAction);
        /**
         * Optional flags.
         */
        public get flags(): RenderTargetFlags;
        public set flags(value: RenderTargetFlags);
        /**
         * Constructs RenderTargetBinding.
         * @param color Color buffers to use as render targets.
         * @param depth Depth buffer to use as render target.
         * @param colorLoadAction Load actions for color buffers.
         * @param colorStoreAction Store actions for color buffers.
         * @param depthLoadAction Load action for the depth/stencil buffer.
         * @param depthStoreAction Store action for the depth/stencil buffer.
         */
        public constructor($colorRenderTargets: RenderTargetIdentifier[], $colorLoadActions: RenderBufferLoadAction[], $colorStoreActions: RenderBufferStoreAction[], $depthRenderTarget: RenderTargetIdentifier, $depthLoadAction: RenderBufferLoadAction, $depthStoreAction: RenderBufferStoreAction);
        /**
         * Constructs RenderTargetBinding.
         * @param color Color buffers to use as render targets.
         * @param depth Depth buffer to use as render target.
         * @param colorLoadAction Load actions for color buffers.
         * @param colorStoreAction Store actions for color buffers.
         * @param depthLoadAction Load action for the depth/stencil buffer.
         * @param depthStoreAction Store action for the depth/stencil buffer.
         */
        public constructor($colorRenderTarget: RenderTargetIdentifier, $colorLoadAction: RenderBufferLoadAction, $colorStoreAction: RenderBufferStoreAction, $depthRenderTarget: RenderTargetIdentifier, $depthLoadAction: RenderBufferLoadAction, $depthStoreAction: RenderBufferStoreAction);
        /**
         * Constructs RenderTargetBinding.
         * @param color Color buffers to use as render targets.
         * @param depth Depth buffer to use as render target.
         * @param colorLoadAction Load actions for color buffers.
         * @param colorStoreAction Store actions for color buffers.
         * @param depthLoadAction Load action for the depth/stencil buffer.
         * @param depthStoreAction Store action for the depth/stencil buffer.
         */
        public constructor($setup: UnityEngine.RenderTargetSetup);
        
                    
    }
    /**
     * Built-in shader types used by Rendering.GraphicsSettings.
     */
    enum BuiltinShaderType { DeferredShading = 0, DeferredReflections = 1, LegacyDeferredLighting = 2, ScreenSpaceShadows = 3, DepthNormals = 4, MotionVectors = 5, LightHalo = 6, LensFlare = 7 }
    /**
     * Built-in shader modes used by Rendering.GraphicsSettings.
     */
    enum BuiltinShaderMode { Disabled = 0, UseBuiltin = 1, UseCustom = 2 }
    /**
     * Defines set by editor when compiling shaders, depending on target platform and tier. You can only set a GraphicsTier in the Built-in Render Pipeline.
     */
    enum BuiltinShaderDefine { UNITY_NO_DXT5nm = 0, UNITY_NO_RGBM = 1, UNITY_USE_NATIVE_HDR = 2, UNITY_ENABLE_REFLECTION_BUFFERS = 3, UNITY_FRAMEBUFFER_FETCH_AVAILABLE = 4, UNITY_ENABLE_NATIVE_SHADOW_LOOKUPS = 5, UNITY_METAL_SHADOWS_USE_POINT_FILTERING = 6, UNITY_NO_CUBEMAP_ARRAY = 7, UNITY_NO_SCREENSPACE_SHADOWS = 8, UNITY_USE_DITHER_MASK_FOR_ALPHABLENDED_SHADOWS = 9, UNITY_PBS_USE_BRDF1 = 10, UNITY_PBS_USE_BRDF2 = 11, UNITY_PBS_USE_BRDF3 = 12, UNITY_NO_FULL_STANDARD_SHADER = 13, UNITY_SPECCUBE_BOX_PROJECTION = 14, UNITY_SPECCUBE_BLENDING = 15, UNITY_ENABLE_DETAIL_NORMALMAP = 16, SHADER_API_MOBILE = 17, SHADER_API_DESKTOP = 18, UNITY_HARDWARE_TIER1 = 19, UNITY_HARDWARE_TIER2 = 20, UNITY_HARDWARE_TIER3 = 21, UNITY_COLORSPACE_GAMMA = 22, UNITY_LIGHT_PROBE_PROXY_VOLUME = 23, UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS = 24, UNITY_LIGHTMAP_DLDR_ENCODING = 25, UNITY_LIGHTMAP_RGBM_ENCODING = 26, UNITY_LIGHTMAP_FULL_HDR = 27, UNITY_VIRTUAL_TEXTURING = 28, UNITY_PRETRANSFORM_TO_DISPLAY_ORIENTATION = 29, UNITY_ASTC_NORMALMAP_ENCODING = 30, SHADER_API_GLES30 = 31, UNITY_UNIFIED_SHADER_PRECISION_MODEL = 32 }
    /**
     * Video shaders mode used by Rendering.GraphicsSettings.
     */
    enum VideoShadersIncludeMode { Never = 0, Referenced = 1, Always = 2 }
    /**
     * The HDR mode to use for rendering.
     */
    enum CameraHDRMode { FP16 = 1, R11G11B10 = 2 }
    /**
     * How much CPU usage to assign to the final lighting calculations at runtime.
     */
    enum RealtimeGICPUUsage { Low = 25, Medium = 50, High = 75, Unlimited = 100 }
    /**
     * Enum type defines the different stereo rendering modes available.
     */
    enum SinglePassStereoMode { None = 0, SideBySide = 1, Instancing = 2, Multiview = 3 }
    /**
     * Flags describing the intention for how the command buffer will be executed. Set these via CommandBuffer.SetExecutionFlags.
     */
    enum CommandBufferExecutionFlags { None = 0, AsyncCompute = 2 }
    /**
     * Script interface for.
     */
    class GraphicsSettings extends UnityEngine.Object {
        /**
         * Transparent object sorting mode.
         */
        public static get transparencySortMode(): UnityEngine.TransparencySortMode;
        public static set transparencySortMode(value: UnityEngine.TransparencySortMode);
        /**
         * An axis that describes the direction along which the distances of objects are measured for the purpose of sorting.
         */
        public static get transparencySortAxis(): UnityEngine.Vector3;
        public static set transparencySortAxis(value: UnityEngine.Vector3);
        /**
         * Is the current render pipeline capable of rendering direct lighting for rectangular area Lights?
         */
        public static get realtimeDirectRectangularAreaLights(): boolean;
        public static set realtimeDirectRectangularAreaLights(value: boolean);
        /**
         * If this is true, Light intensity is multiplied against linear color values. If it is false, gamma color values are used.
         */
        public static get lightsUseLinearIntensity(): boolean;
        public static set lightsUseLinearIntensity(value: boolean);
        /**
         * Whether to use a Light's color temperature when calculating the final color of that Light."
         */
        public static get lightsUseColorTemperature(): boolean;
        public static set lightsUseColorTemperature(value: boolean);
        /**
         * Stores the default value for the RenderingLayerMask property of newly created Renderers.
         */
        public static get defaultRenderingLayerMask(): number;
        public static set defaultRenderingLayerMask(value: number);
        /**
         * Enable/Disable SRP batcher (experimental) at runtime.
         */
        public static get useScriptableRenderPipelineBatching(): boolean;
        public static set useScriptableRenderPipelineBatching(value: boolean);
        /**
         * If this is true, a log entry is made each time a shader is compiled at application runtime.
         */
        public static get logWhenShaderIsCompiled(): boolean;
        public static set logWhenShaderIsCompiled(value: boolean);
        /**
         * Disables the built-in update loop for Custom Render Textures, so that you can write your own update loop.
         */
        public static get disableBuiltinCustomRenderTextureUpdate(): boolean;
        public static set disableBuiltinCustomRenderTextureUpdate(value: boolean);
        /**
         * If and when to include video shaders in the build.
         */
        public static get videoShadersIncludeMode(): VideoShadersIncludeMode;
        public static set videoShadersIncludeMode(value: VideoShadersIncludeMode);
        /**
         * The current active RenderPipelineAsset taking into consideration the default and any active override.
         */
        public static get currentRenderPipeline(): RenderPipelineAsset;
        /**
         * The RenderPipelineAsset that describes how the Scene should be rendered.
         */
        public static get renderPipelineAsset(): RenderPipelineAsset;
        public static set renderPipelineAsset(value: RenderPipelineAsset);
        /**
         * The default RenderPipelineAsset that describes how the Scene should be rendered when no override is configured.
         */
        public static get defaultRenderPipeline(): RenderPipelineAsset;
        public static set defaultRenderPipeline(value: RenderPipelineAsset);
        /**
         * All RenderPipelineAssets that are configured
         */
        public static get allConfiguredRenderPipelines(): RenderPipelineAsset[];
        /**
         * Returns true if shader define was set when compiling shaders for current GraphicsTier. Graphics Tiers are only available in the Built-in Render Pipeline.
         */
        public static HasShaderDefine($tier: GraphicsTier, $defineHash: BuiltinShaderDefine):boolean;
        /**
         * Returns true if shader define was set when compiling shaders for a given GraphicsTier. Graphics Tiers are only available in the Built-in Render Pipeline.
         */
        public static HasShaderDefine($defineHash: BuiltinShaderDefine):boolean;
        /**
         * Provides a reference to the GraphicSettings object.
         * @returns Returns the GraphicsSettings object.
         */
        public static GetGraphicsSettings():UnityEngine.Object;
        /**
         * Set built-in shader mode.
         * @param type Built-in shader type to change.
         * @param mode Mode to use for built-in shader.
         */
        public static SetShaderMode($type: BuiltinShaderType, $mode: BuiltinShaderMode):void;
        /**
         * Get built-in shader mode.
         * @param type Built-in shader type to query.
         * @returns Mode used for built-in shader.
         */
        public static GetShaderMode($type: BuiltinShaderType):BuiltinShaderMode;
        /**
         * Set custom shader to use instead of a built-in shader.
         * @param type Built-in shader type to set custom shader to.
         * @param shader The shader to use.
         */
        public static SetCustomShader($type: BuiltinShaderType, $shader: UnityEngine.Shader):void;
        /**
         * Get custom shader used instead of a built-in shader.
         * @param type Built-in shader type to query custom shader for.
         * @returns The shader used.
         */
        public static GetCustomShader($type: BuiltinShaderType):UnityEngine.Shader;
        
                    
    }
    /**
     * Use the OnDemandRendering class to control and query information about your application's rendering speed independent from all other subsystems (such as physics, input, or animation).
     */
    class OnDemandRendering extends System.Object {
        /**
         * True if the current frame will be rendered.
         */
        public static get willCurrentFrameRender(): boolean;
        /**
         * Get or set the current frame rate interval. To restore rendering back to the value of Application.targetFrameRate or QualitySettings.vSyncCount set this to 0 or 1.
         */
        public static get renderFrameInterval(): number;
        public static set renderFrameInterval(value: number);
        /**
         * The current estimated rate of rendering in frames per second rounded to the nearest integer.
         */
        public static get effectiveRenderFrameRate(): number;
        
        public constructor();
        
                    
    }
    /**
     * Static class providing extension methods for CommandBuffer.
     */
    class CommandBufferExtensions extends System.Object {
        /**
         * Adds a command to put a given render target into fast GPU memory.
         * @param rid The render target to put into fast GPU memory.
         * @param fastMemoryFlags The memory layout to use if only part of the render target is put into fast GPU memory, either because of the residency parameter or because of fast GPU memory availability.
         * @param residency The amount of the render target to put into fast GPU memory. Valid values are 0.0f - 1.0f inclusive.
        A value of 0.0f is equal to none of the render target, and a value of 1.0f is equal to the whole render target.
                        
         * @param copyContents When this value is true, Unity copies the existing contents of the render target into fast memory.
        When this value is false, Unity does not copy the existing contents of the render target into fast memory.
        Set this value to true if you plan to add to the existing contents, and set it to false if you plan to overwrite or clear the existing contents.
        Where possible, set this value to false for better performance.
                        
         */
        public static SwitchIntoFastMemory($cmd: CommandBuffer, $rid: RenderTargetIdentifier, $fastMemoryFlags: FastMemoryFlags, $residency: number, $copyContents: boolean):void;
        /**
         * Adds a command to remove a given render target from fast GPU memory.
         * @param rid The render target to remove from fast GPU memory.
         * @param copyContents When this value is true, Unity copies the existing contents of the render target when it removes it from fast GPU memory. When this value is false, Unity does not copy the existing contents of the render target when it removes it from fast GPU memory. Set this value to true if you plan to add to the existing contents, and set it to false if you plan to overwrite or clear the existing contents. Where possible, set this value to false for better performance.
         */
        public static SwitchOutOfFastMemory($cmd: CommandBuffer, $rid: RenderTargetIdentifier, $copyContents: boolean):void;
        
                    
    }
    /**
     * Provides an interface to the Unity splash screen.
     */
    class SplashScreen extends System.Object {
        /**
         * Returns true once the splash screen has finished. This is once all logos have been shown for their specified duration.
         */
        public static get isFinished(): boolean;
        
        public constructor();
        /**
         * Initializes the splash screen so it is ready to begin drawing. Call this before you start calling Rendering.SplashScreen.Draw. Internally this function resets the timer and prepares the logos for drawing.
         */
        public static Begin():void;
        /**
         * Stop the SplashScreen rendering.
         */
        public static Stop($stopBehavior: UnityEngine_Rendering_SplashScreen.StopBehavior):void;
        /**
         * Immediately draws the splash screen. Ensure you have called Rendering.SplashScreen.Begin before you start calling this.
         */
        public static Draw():void;
        
                    
    }
    /**
     * A declaration of a single color or depth rendering surface to be attached into a RenderPass.
     */
    class AttachmentDescriptor extends System.ValueType {
        /**
         * The load action to be used on this attachment when the RenderPass starts.
         */
        public get loadAction(): RenderBufferLoadAction;
        public set loadAction(value: RenderBufferLoadAction);
        /**
         * The store action to use with this attachment when the RenderPass ends. Only used when either ConfigureTarget or ConfigureResolveTarget has been called.
         */
        public get storeAction(): RenderBufferStoreAction;
        public set storeAction(value: RenderBufferStoreAction);
        /**
         * The GraphicsFormat of this attachment. To use in place of format.
         */
        public get graphicsFormat(): UnityEngine_Experimental_Rendering.GraphicsFormat;
        public set graphicsFormat(value: UnityEngine_Experimental_Rendering.GraphicsFormat);
        /**
         * The format of this attachment.
         */
        public get format(): UnityEngine.RenderTextureFormat;
        public set format(value: UnityEngine.RenderTextureFormat);
        /**
         * The surface to use as the backing storage for this AttachmentDescriptor.
         */
        public get loadStoreTarget(): RenderTargetIdentifier;
        public set loadStoreTarget(value: RenderTargetIdentifier);
        /**
         * When the renderpass that uses this attachment ends, resolve the MSAA surface into the given target.
         */
        public get resolveTarget(): RenderTargetIdentifier;
        public set resolveTarget(value: RenderTargetIdentifier);
        /**
         * The currently assigned clear color for this attachment. Default is black.
         */
        public get clearColor(): UnityEngine.Color;
        public set clearColor(value: UnityEngine.Color);
        /**
         * Currently assigned depth clear value for this attachment. Default value is 1.0.
         */
        public get clearDepth(): number;
        public set clearDepth(value: number);
        /**
         * Currently assigned stencil clear value for this attachment. Default is 0.
         */
        public get clearStencil(): number;
        public set clearStencil(value: number);
        
        public constructor($format: UnityEngine_Experimental_Rendering.GraphicsFormat);
        /**
         * Create a AttachmentDescriptor to be used with RenderPass.
         * @param fmt The format of this attachment.
         */
        public constructor($format: UnityEngine.RenderTextureFormat);
        
        public constructor($format: UnityEngine.RenderTextureFormat, $target: RenderTargetIdentifier, $loadExistingContents?: boolean, $storeResults?: boolean, $resolve?: boolean);
        /**
         * Binds this AttachmentDescriptor to the given target surface.
         * @param tgt The surface to use as the backing storage for this AttachmentDescriptor.
         * @param loadExistingContents Whether to read in the existing contents of the surface when the RenderPass starts.
         * @param storeResults Whether to store the rendering results of the attachment when the RenderPass ends.
         */
        public ConfigureTarget($target: RenderTargetIdentifier, $loadExistingContents: boolean, $storeResults: boolean):void;
        /**
         * When the renderpass that uses this attachment ends, resolve the MSAA surface into the given target.
         * @param tgt The target surface to receive the MSAA-resolved pixels.
         */
        public ConfigureResolveTarget($target: RenderTargetIdentifier):void;
        /**
         * When the RenderPass starts, clear this attachment into the color or depth/stencil values given (depending on the format of this attachment). Changes loadAction to RenderBufferLoadAction.Clear.
         * @param clearCol Color clear value. Ignored on depth/stencil attachments.
         * @param clearDep Depth clear value. Ignored on color surfaces.
         * @param clearStenc Stencil clear value. Ignored on color or depth-only surfaces.
         */
        public ConfigureClear($clearColor: UnityEngine.Color, $clearDepth?: number, $clearStencil?: number):void;
        
        public Equals($other: AttachmentDescriptor):boolean;
        
        public Equals($obj: any):boolean;
        
        public GetHashCode():number;
        
        public static op_Equality($left: AttachmentDescriptor, $right: AttachmentDescriptor):boolean;
        
        public static op_Inequality($left: AttachmentDescriptor, $right: AttachmentDescriptor):boolean;
        
        public get_Clone(): AttachmentDescriptor;            
    }
    /**
     * Values for the blend state.
     */
    class BlendState extends System.ValueType {
        /**
         * Default values for the blend state.
         */
        public static get defaultValue(): BlendState;
        /**
         * Determines whether each render target uses a separate blend state.
         */
        public get separateMRTBlendStates(): boolean;
        public set separateMRTBlendStates(value: boolean);
        /**
         * Turns on alpha-to-coverage.
         */
        public get alphaToMask(): boolean;
        public set alphaToMask(value: boolean);
        /**
         * Blend state for render target 0.
         */
        public get blendState0(): RenderTargetBlendState;
        public set blendState0(value: RenderTargetBlendState);
        /**
         * Blend state for render target 1.
         */
        public get blendState1(): RenderTargetBlendState;
        public set blendState1(value: RenderTargetBlendState);
        /**
         * Blend state for render target 2.
         */
        public get blendState2(): RenderTargetBlendState;
        public set blendState2(value: RenderTargetBlendState);
        /**
         * Blend state for render target 3.
         */
        public get blendState3(): RenderTargetBlendState;
        public set blendState3(value: RenderTargetBlendState);
        /**
         * Blend state for render target 4.
         */
        public get blendState4(): RenderTargetBlendState;
        public set blendState4(value: RenderTargetBlendState);
        /**
         * Blend state for render target 5.
         */
        public get blendState5(): RenderTargetBlendState;
        public set blendState5(value: RenderTargetBlendState);
        /**
         * Blend state for render target 6.
         */
        public get blendState6(): RenderTargetBlendState;
        public set blendState6(value: RenderTargetBlendState);
        /**
         * Blend state for render target 7.
         */
        public get blendState7(): RenderTargetBlendState;
        public set blendState7(value: RenderTargetBlendState);
        /**
         * Creates a new blend state with the specified values.
         * @param separateMRTBlend Determines whether each render target uses a separate blend state.
         * @param alphaToMask Turns on alpha-to-coverage.
         */
        public constructor($separateMRTBlend?: boolean, $alphaToMask?: boolean);
        
        public Equals($other: BlendState):boolean;
        
        public Equals($obj: any):boolean;
        
        public GetHashCode():number;
        
        public static op_Equality($left: BlendState, $right: BlendState):boolean;
        
        public static op_Inequality($left: BlendState, $right: BlendState):boolean;
        
        public get_Clone(): BlendState;            
    }
    /**
     * Values for the blend state.
     */
    class RenderTargetBlendState extends System.ValueType {
        /**
         * Default values for the blend state.
         */
        public static get defaultValue(): RenderTargetBlendState;
        /**
         * Specifies which color components will get written into the target framebuffer.
         */
        public get writeMask(): ColorWriteMask;
        public set writeMask(value: ColorWriteMask);
        /**
         * Blend factor used for the color (RGB) channel of the source.
         */
        public get sourceColorBlendMode(): BlendMode;
        public set sourceColorBlendMode(value: BlendMode);
        /**
         * Blend factor used for the color (RGB) channel of the destination.
         */
        public get destinationColorBlendMode(): BlendMode;
        public set destinationColorBlendMode(value: BlendMode);
        /**
         * Blend factor used for the alpha (A) channel of the source.
         */
        public get sourceAlphaBlendMode(): BlendMode;
        public set sourceAlphaBlendMode(value: BlendMode);
        /**
         * Blend factor used for the alpha (A) channel of the destination.
         */
        public get destinationAlphaBlendMode(): BlendMode;
        public set destinationAlphaBlendMode(value: BlendMode);
        /**
         * Operation used for blending the color (RGB) channel.
         */
        public get colorBlendOperation(): BlendOp;
        public set colorBlendOperation(value: BlendOp);
        /**
         * Operation used for blending the alpha (A) channel.
         */
        public get alphaBlendOperation(): BlendOp;
        public set alphaBlendOperation(value: BlendOp);
        /**
         * Creates a new blend state with the given values.
         * @param writeMask Specifies which color components will get written into the target framebuffer.
         * @param sourceColorBlendMode Blend factor used for the color (RGB) channel of the source.
         * @param destinationColorBlendMode Blend factor used for the color (RGB) channel of the destination.
         * @param sourceAlphaBlendMode Blend factor used for the alpha (A) channel of the source.
         * @param destinationAlphaBlendMode Blend factor used for the alpha (A) channel of the destination.
         * @param colorBlendOperation Operation used for blending the color (RGB) channel.
         * @param alphaBlendOperation Operation used for blending the alpha (A) channel.
         */
        public constructor($writeMask?: ColorWriteMask, $sourceColorBlendMode?: BlendMode, $destinationColorBlendMode?: BlendMode, $sourceAlphaBlendMode?: BlendMode, $destinationAlphaBlendMode?: BlendMode, $colorBlendOperation?: BlendOp, $alphaBlendOperation?: BlendOp);
        
        public Equals($other: RenderTargetBlendState):boolean;
        
        public Equals($obj: any):boolean;
        
        public GetHashCode():number;
        
        public static op_Equality($left: RenderTargetBlendState, $right: RenderTargetBlendState):boolean;
        
        public static op_Inequality($left: RenderTargetBlendState, $right: RenderTargetBlendState):boolean;
        
        public get_Clone(): RenderTargetBlendState;            
    }
    /**
     * Camera related properties in CullingParameters.
     */
    class CameraProperties extends System.ValueType {
        /**
         * Get a shadow culling plane.
         * @param index Plane index (up to 5).
         * @returns Shadow culling plane.
         */
        public GetShadowCullingPlane($index: number):UnityEngine.Plane;
        /**
         * Set a shadow culling plane.
         * @param index Plane index (up to 5).
         * @param plane Shadow culling plane.
         */
        public SetShadowCullingPlane($index: number, $plane: UnityEngine.Plane):void;
        /**
         * Get a camera culling plane.
         * @param index Plane index (up to 5).
         * @returns Camera culling plane.
         */
        public GetCameraCullingPlane($index: number):UnityEngine.Plane;
        /**
         * Set a camera culling plane.
         * @param index Plane index (up to 5).
         * @param plane Camera culling plane.
         */
        public SetCameraCullingPlane($index: number, $plane: UnityEngine.Plane):void;
        
        public Equals($other: CameraProperties):boolean;
        
        public Equals($obj: any):boolean;
        
        public GetHashCode():number;
        
        public static op_Equality($left: CameraProperties, $right: CameraProperties):boolean;
        
        public static op_Inequality($left: CameraProperties, $right: CameraProperties):boolean;
        
        public get_Clone(): CameraProperties;            
    }
    /**
     * Flags used by ScriptableCullingParameters.cullingOptions to configure a culling operation.
     */
    enum CullingOptions { None = 0, ForceEvenIfCameraIsNotActive = 1, OcclusionCull = 2, NeedsLighting = 4, NeedsReflectionProbes = 8, Stereo = 16, DisablePerObjectCulling = 32, ShadowCasters = 64 }
    /**
     * LODGroup culling parameters.
     */
    class LODParameters extends System.ValueType {
        /**
         * Indicates whether camera is orthographic.
         */
        public get isOrthographic(): boolean;
        public set isOrthographic(value: boolean);
        /**
         * Camera position.
         */
        public get cameraPosition(): UnityEngine.Vector3;
        public set cameraPosition(value: UnityEngine.Vector3);
        /**
         * Camera's field of view.
         */
        public get fieldOfView(): number;
        public set fieldOfView(value: number);
        /**
         * Orhographic camera size.
         */
        public get orthoSize(): number;
        public set orthoSize(value: number);
        /**
         * Rendering view height in pixels.
         */
        public get cameraPixelHeight(): number;
        public set cameraPixelHeight(value: number);
        
        public Equals($other: LODParameters):boolean;
        
        public Equals($obj: any):boolean;
        
        public GetHashCode():number;
        
        public static op_Equality($left: LODParameters, $right: LODParameters):boolean;
        
        public static op_Inequality($left: LODParameters, $right: LODParameters):boolean;
        
        public get_Clone(): LODParameters;            
    }
    /**
     * Visible reflection probes sorting options.
     */
    enum ReflectionProbeSortingCriteria { None = 0, Importance = 1, Size = 2, ImportanceThenSize = 3 }
    /**
     * Culling results (visible objects, lights, reflection probes).
     */
    class CullingResults extends System.ValueType {
        /**
         * Array of visible lights.
         */
        public get visibleLights(): Unity_Collections.NativeArray$1<VisibleLight>;
        /**
         * Off screen lights that still effect visible Scene vertices.
         */
        public get visibleOffscreenVertexLights(): Unity_Collections.NativeArray$1<VisibleLight>;
        /**
         * Array of visible reflection probes.
         */
        public get visibleReflectionProbes(): Unity_Collections.NativeArray$1<VisibleReflectionProbe>;
        /**
         * Gets the number of per-object light indices.
         * @returns The number of per-object light indices.
         */
        public get lightIndexCount(): number;
        /**
         * Gets the number of per-object reflection probe indices.
         * @returns The number of per-object reflection probe indices.
         */
        public get reflectionProbeIndexCount(): number;
        /**
         * Gets the number of per-object light and reflection probe indices.
         * @returns The number of per-object light and reflection probe indices.
         */
        public get lightAndReflectionProbeIndexCount(): number;
        /**
         * Fills a buffer with per-object light indices.
         * @param computeBuffer The compute buffer object to fill.
         * @param buffer The buffer object to fill.
         */
        public FillLightAndReflectionProbeIndices($computeBuffer: UnityEngine.ComputeBuffer):void;
        /**
         * Fills a buffer with per-object light indices.
         * @param computeBuffer The compute buffer object to fill.
         * @param buffer The buffer object to fill.
         */
        public FillLightAndReflectionProbeIndices($buffer: UnityEngine.GraphicsBuffer):void;
        
        public GetLightIndexMap($allocator: Unity_Collections.Allocator):Unity_Collections.NativeArray$1<number>;
        
        public SetLightIndexMap($lightIndexMap: Unity_Collections.NativeArray$1<number>):void;
        
        public GetReflectionProbeIndexMap($allocator: Unity_Collections.Allocator):Unity_Collections.NativeArray$1<number>;
        
        public SetReflectionProbeIndexMap($lightIndexMap: Unity_Collections.NativeArray$1<number>):void;
        /**
         * Returns the bounding box that encapsulates the visible shadow casters.  Can be used to, for instance, dynamically adjust cascade ranges.
         * @param lightIndex The index of the shadow-casting light.
         * @param outBounds The bounds to be computed.
         * @returns True if the light affects at least one shadow casting object in the Scene.
         */
        public GetShadowCasterBounds($lightIndex: number, $outBounds: $Ref<UnityEngine.Bounds>):boolean;
        /**
         * Calculates the view and projection matrices and shadow split data for a spot light.
         * @param activeLightIndex The index into the active light array.
         * @param viewMatrix The computed view matrix.
         * @param projMatrix The computed projection matrix.
         * @param shadowSplitData The computed split data.
         * @returns If false, the shadow map for this light does not need to be rendered this frame.
         */
        public ComputeSpotShadowMatricesAndCullingPrimitives($activeLightIndex: number, $viewMatrix: $Ref<UnityEngine.Matrix4x4>, $projMatrix: $Ref<UnityEngine.Matrix4x4>, $shadowSplitData: $Ref<ShadowSplitData>):boolean;
        /**
         * Calculates the view and projection matrices and shadow split data for a point light.
         * @param activeLightIndex The index into the active light array.
         * @param cubemapFace The cubemap face to be rendered.
         * @param fovBias The amount by which to increase the camera FOV above 90 degrees.
         * @param viewMatrix The computed view matrix.
         * @param projMatrix The computed projection matrix.
         * @param shadowSplitData The computed split data.
         * @returns If false, the shadow map for this light and cubemap face does not need to be rendered this frame.
         */
        public ComputePointShadowMatricesAndCullingPrimitives($activeLightIndex: number, $cubemapFace: UnityEngine.CubemapFace, $fovBias: number, $viewMatrix: $Ref<UnityEngine.Matrix4x4>, $projMatrix: $Ref<UnityEngine.Matrix4x4>, $shadowSplitData: $Ref<ShadowSplitData>):boolean;
        /**
         * Calculates the view and projection matrices and shadow split data for a directional light.
         * @param activeLightIndex The index into the active light array.
         * @param splitIndex The cascade index.
         * @param splitCount The number of cascades.
         * @param splitRatio The cascade ratios.
         * @param shadowResolution The resolution of the shadowmap.
         * @param shadowNearPlaneOffset The near plane offset for the light.
         * @param viewMatrix The computed view matrix.
         * @param projMatrix The computed projection matrix.
         * @param shadowSplitData The computed cascade data.
         * @returns If false, the shadow map for this cascade does not need to be rendered this frame.
         */
        public ComputeDirectionalShadowMatricesAndCullingPrimitives($activeLightIndex: number, $splitIndex: number, $splitCount: number, $splitRatio: UnityEngine.Vector3, $shadowResolution: number, $shadowNearPlaneOffset: number, $viewMatrix: $Ref<UnityEngine.Matrix4x4>, $projMatrix: $Ref<UnityEngine.Matrix4x4>, $shadowSplitData: $Ref<ShadowSplitData>):boolean;
        
        public Equals($other: CullingResults):boolean;
        
        public Equals($obj: any):boolean;
        
        public GetHashCode():number;
        
        public static op_Equality($left: CullingResults, $right: CullingResults):boolean;
        
        public static op_Inequality($left: CullingResults, $right: CullingResults):boolean;
        
                    
    }
    /**
     * Holds data of a visible light.
     */
    class VisibleLight extends System.ValueType {
        /**
         * Accessor to Light component.
         */
        public get light(): UnityEngine.Light;
        /**
         * Light type.
         */
        public get lightType(): UnityEngine.LightType;
        public set lightType(value: UnityEngine.LightType);
        /**
         * Light color multiplied by intensity.
         */
        public get finalColor(): UnityEngine.Color;
        public set finalColor(value: UnityEngine.Color);
        /**
         * Light's influence rectangle on screen.
         */
        public get screenRect(): UnityEngine.Rect;
        public set screenRect(value: UnityEngine.Rect);
        /**
         * Light transformation matrix.
         */
        public get localToWorldMatrix(): UnityEngine.Matrix4x4;
        public set localToWorldMatrix(value: UnityEngine.Matrix4x4);
        /**
         * Light range.
         */
        public get range(): number;
        public set range(value: number);
        /**
         * Spot light angle.
         */
        public get spotAngle(): number;
        public set spotAngle(value: number);
        /**
         * Light intersects near clipping plane.
         */
        public get intersectsNearPlane(): boolean;
        public set intersectsNearPlane(value: boolean);
        /**
         * Light intersects far clipping plane.
         */
        public get intersectsFarPlane(): boolean;
        public set intersectsFarPlane(value: boolean);
        
        public Equals($other: VisibleLight):boolean;
        
        public Equals($obj: any):boolean;
        
        public GetHashCode():number;
        
        public static op_Equality($left: VisibleLight, $right: VisibleLight):boolean;
        
        public static op_Inequality($left: VisibleLight, $right: VisibleLight):boolean;
        
        public get_Clone(): VisibleLight;            
    }
    /**
     * Holds data of a visible reflection reflectionProbe.
     */
    class VisibleReflectionProbe extends System.ValueType {
        /**
         * Probe texture.
         */
        public get texture(): UnityEngine.Texture;
        /**
         * Accessor to ReflectionProbe component.
         */
        public get reflectionProbe(): UnityEngine.ReflectionProbe;
        /**
         * Probe bounding box.
         */
        public get bounds(): UnityEngine.Bounds;
        public set bounds(value: UnityEngine.Bounds);
        /**
         * Probe transformation matrix.
         */
        public get localToWorldMatrix(): UnityEngine.Matrix4x4;
        public set localToWorldMatrix(value: UnityEngine.Matrix4x4);
        /**
         * Shader data for probe HDR texture decoding.
         */
        public get hdrData(): UnityEngine.Vector4;
        public set hdrData(value: UnityEngine.Vector4);
        /**
         * Probe projection center.
         */
        public get center(): UnityEngine.Vector3;
        public set center(value: UnityEngine.Vector3);
        /**
         * Probe blending distance.
         */
        public get blendDistance(): number;
        public set blendDistance(value: number);
        /**
         * Probe importance.
         */
        public get importance(): number;
        public set importance(value: number);
        /**
         * Should probe use box projection.
         */
        public get isBoxProjection(): boolean;
        public set isBoxProjection(value: boolean);
        
        public Equals($other: VisibleReflectionProbe):boolean;
        
        public Equals($obj: any):boolean;
        
        public GetHashCode():number;
        
        public static op_Equality($left: VisibleReflectionProbe, $right: VisibleReflectionProbe):boolean;
        
        public static op_Inequality($left: VisibleReflectionProbe, $right: VisibleReflectionProbe):boolean;
        
        public get_Clone(): VisibleReflectionProbe;            
    }
    /**
     * Describes the culling information for a given shadow split (e.g. directional cascade).
     */
    class ShadowSplitData extends System.ValueType {
        /**
         * The maximum number of culling planes.
         */
        public static maximumCullingPlaneCount: number;
        /**
         * The number of culling planes.
         */
        public get cullingPlaneCount(): number;
        public set cullingPlaneCount(value: number);
        /**
         * The culling sphere.  The first three components of the vector describe the sphere center, and the last component specifies the radius.
         */
        public get cullingSphere(): UnityEngine.Vector4;
        public set cullingSphere(value: UnityEngine.Vector4);
        /**
         * A multiplier applied to the radius of the culling sphere.
         * Values must be in the range 0 to 1. With higher values, Unity culls more objects. Lower makes the cascades share more rendered objects. Using lower values allows blending between different cascades as they then share objects.
         */
        public get shadowCascadeBlendCullingFactor(): number;
        public set shadowCascadeBlendCullingFactor(value: number);
        /**
         * Gets a culling plane.
         * @param index The culling plane index.
         * @returns The culling plane.
         */
        public GetCullingPlane($index: number):UnityEngine.Plane;
        /**
         * Sets a culling plane.
         * @param index The index of the culling plane to set.
         * @param plane The culling plane.
         */
        public SetCullingPlane($index: number, $plane: UnityEngine.Plane):void;
        
        public Equals($other: ShadowSplitData):boolean;
        
        public Equals($obj: any):boolean;
        
        public GetHashCode():number;
        
        public static op_Equality($left: ShadowSplitData, $right: ShadowSplitData):boolean;
        
        public static op_Inequality($left: ShadowSplitData, $right: ShadowSplitData):boolean;
        
        public get_Clone(): ShadowSplitData;            
    }
    /**
     * Values for the depth state.
     */
    class DepthState extends System.ValueType {
        /**
         * Default values for the depth state.
         */
        public static get defaultValue(): DepthState;
        /**
         * Controls whether pixels from this object are written to the depth buffer.
         */
        public get writeEnabled(): boolean;
        public set writeEnabled(value: boolean);
        /**
         * How should depth testing be performed.
         */
        public get compareFunction(): CompareFunction;
        public set compareFunction(value: CompareFunction);
        /**
         * Creates a new depth state with the given values.
         * @param writeEnabled Controls whether pixels from this object are written to the depth buffer.
         * @param compareFunction How should depth testing be performed.
         */
        public constructor($writeEnabled?: boolean, $compareFunction?: CompareFunction);
        
        public Equals($other: DepthState):boolean;
        
        public Equals($obj: any):boolean;
        
        public GetHashCode():number;
        
        public static op_Equality($left: DepthState, $right: DepthState):boolean;
        
        public static op_Inequality($left: DepthState, $right: DepthState):boolean;
        
        public get_Clone(): DepthState;            
    }
    /**
     * Settings for ScriptableRenderContext.DrawRenderers.
     */
    class DrawingSettings extends System.ValueType {
        /**
         * The maxiumum number of passes that can be rendered in 1 DrawRenderers call.
         */
        public static maxShaderPasses: number;
        /**
         * How to sort objects during rendering.
         */
        public get sortingSettings(): SortingSettings;
        public set sortingSettings(value: SortingSettings);
        /**
         * What kind of per-object data to setup during rendering.
         */
        public get perObjectData(): PerObjectData;
        public set perObjectData(value: PerObjectData);
        /**
         * Controls whether dynamic batching is enabled.
         */
        public get enableDynamicBatching(): boolean;
        public set enableDynamicBatching(value: boolean);
        /**
         * Controls whether instancing is enabled.
         */
        public get enableInstancing(): boolean;
        public set enableInstancing(value: boolean);
        /**
         * Sets the Material to use for all drawers that would render in this group.
         */
        public get overrideMaterial(): UnityEngine.Material;
        public set overrideMaterial(value: UnityEngine.Material);
        /**
         * Selects which pass of the override material to use.
         */
        public get overrideMaterialPassIndex(): number;
        public set overrideMaterialPassIndex(value: number);
        /**
         * Configures what light should be used as main light.
         */
        public get mainLightIndex(): number;
        public set mainLightIndex(value: number);
        /**
         * Create a draw settings struct.
         * @param shaderPassName Shader pass to use.
         * @param sortingSettings Describes the methods to sort objects during rendering.
         */
        public constructor($shaderPassName: ShaderTagId, $sortingSettings: SortingSettings);
        /**
         * Get the shader passes that this draw call can render.
         * @param index Index of the shader pass to use.
         */
        public GetShaderPassName($index: number):ShaderTagId;
        /**
         * Set the shader passes that this draw call can render.
         * @param index Index of the shader pass to use.
         * @param shaderPassName Name of the shader pass.
         */
        public SetShaderPassName($index: number, $shaderPassName: ShaderTagId):void;
        
        public Equals($other: DrawingSettings):boolean;
        
        public Equals($obj: any):boolean;
        
        public GetHashCode():number;
        
        public static op_Equality($left: DrawingSettings, $right: DrawingSettings):boolean;
        
        public static op_Inequality($left: DrawingSettings, $right: DrawingSettings):boolean;
        
        public get_Clone(): DrawingSettings;            
    }
    /**
     * This struct describes the methods to sort objects during rendering.
     */
    class SortingSettings extends System.ValueType {
        /**
         * Used to calculate the distance to objects.
         */
        public get worldToCameraMatrix(): UnityEngine.Matrix4x4;
        public set worldToCameraMatrix(value: UnityEngine.Matrix4x4);
        /**
         * Used to calculate the distance to objects.
         */
        public get cameraPosition(): UnityEngine.Vector3;
        public set cameraPosition(value: UnityEngine.Vector3);
        /**
         * Used to calculate distance to objects, by comparing the positions of objects to this axis.
         */
        public get customAxis(): UnityEngine.Vector3;
        public set customAxis(value: UnityEngine.Vector3);
        /**
         * What kind of sorting to do while rendering.
         */
        public get criteria(): SortingCriteria;
        public set criteria(value: SortingCriteria);
        /**
         * Type of sorting to use while rendering.
         */
        public get distanceMetric(): DistanceMetric;
        public set distanceMetric(value: DistanceMetric);
        /**
         * Create a sorting settings struct.
         * @param camera The camera's transparency sort mode is used to determine whether to use orthographic or distance based sorting.
         */
        public constructor($camera: UnityEngine.Camera);
        
        public Equals($other: SortingSettings):boolean;
        
        public Equals($obj: any):boolean;
        
        public GetHashCode():number;
        
        public static op_Equality($left: SortingSettings, $right: SortingSettings):boolean;
        
        public static op_Inequality($left: SortingSettings, $right: SortingSettings):boolean;
        
        public get_Clone(): SortingSettings;            
    }
    /**
     * What kind of per-object data to setup during rendering.
     */
    enum PerObjectData { None = 0, LightProbe = 1, ReflectionProbes = 2, LightProbeProxyVolume = 4, Lightmaps = 8, LightData = 16, MotionVectors = 32, LightIndices = 64, ReflectionProbeData = 128, OcclusionProbe = 256, OcclusionProbeProxyVolume = 512, ShadowMask = 1024 }
    /**
     * Filter settings for ScriptableRenderContext.DrawRenderers.
     */
    class FilteringSettings extends System.ValueType {
        /**
         * Provides a set of default values that causes no filtering to occur.
         */
        public static get defaultValue(): FilteringSettings;
        /**
         * Render objects whose material render queue in inside this range.
         */
        public get renderQueueRange(): RenderQueueRange;
        public set renderQueueRange(value: RenderQueueRange);
        /**
         * Only render objects in the given layer mask.
         */
        public get layerMask(): number;
        public set layerMask(value: number);
        /**
         * The rendering layer mask to use when filtering available renderers for drawing.
         */
        public get renderingLayerMask(): number;
        public set renderingLayerMask(value: number);
        /**
         * Set to true to exclude objects that are currently in motion from rendering. The default value is false.
         */
        public get excludeMotionVectorObjects(): boolean;
        public set excludeMotionVectorObjects(value: boolean);
        /**
         * Render objects whose sorting layer is inside this range.
         */
        public get sortingLayerRange(): SortingLayerRange;
        public set sortingLayerRange(value: SortingLayerRange);
        
        public constructor($renderQueueRange?: System.Nullable$1<RenderQueueRange>, $layerMask?: number, $renderingLayerMask?: number, $excludeMotionVectorObjects?: number);
        
        public Equals($other: FilteringSettings):boolean;
        
        public Equals($obj: any):boolean;
        
        public GetHashCode():number;
        
        public static op_Equality($left: FilteringSettings, $right: FilteringSettings):boolean;
        
        public static op_Inequality($left: FilteringSettings, $right: FilteringSettings):boolean;
        
        public get_Clone(): FilteringSettings;            
    }
    /**
     * Describes a material render queue range.
     */
    class RenderQueueRange extends System.ValueType {
        /**
         * Minimum value that can be used as a bound.
         */
        public static minimumBound: number;
        /**
         * Maximum value that can be used as a bound.
         */
        public static maximumBound: number;
        /**
         * A range that includes all objects.
         */
        public static get all(): RenderQueueRange;
        /**
         * A range that includes only opaque objects.
         */
        public static get opaque(): RenderQueueRange;
        /**
         * A range that includes only transparent objects.
         */
        public static get transparent(): RenderQueueRange;
        /**
         * Inclusive lower bound for the range.
         */
        public get lowerBound(): number;
        public set lowerBound(value: number);
        /**
         * Inclusive upper bound for the range.
         */
        public get upperBound(): number;
        public set upperBound(value: number);
        /**
         * Create a render queue range struct.
         * @param lowerBound Inclusive lower bound for the range.
         * @param upperBound Inclusive upper bound for the range.
         */
        public constructor($lowerBound: number, $upperBound: number);
        
        public Equals($other: RenderQueueRange):boolean;
        
        public Equals($obj: any):boolean;
        
        public GetHashCode():number;
        
        public static op_Equality($left: RenderQueueRange, $right: RenderQueueRange):boolean;
        
        public static op_Inequality($left: RenderQueueRange, $right: RenderQueueRange):boolean;
        
        public get_Clone(): RenderQueueRange;            
    }
    /**
     * Describes a renderer's sorting layer range.
     */
    class SortingLayerRange extends System.ValueType {
        /**
         * Inclusive lower bound for the range.
         */
        public get lowerBound(): number;
        public set lowerBound(value: number);
        /**
         * Inclusive upper bound for the range.
         */
        public get upperBound(): number;
        public set upperBound(value: number);
        /**
         * A range that includes all objects.
         */
        public static get all(): SortingLayerRange;
        /**
         * Sets the inclusive range for a sorting layer object.
         * @param lowerBound Lowest sorting layer value to include.
         * @param upperBound Highest sorting layer value to include.
         */
        public constructor($lowerBound: number, $upperBound: number);
        
        public Equals($other: SortingLayerRange):boolean;
        
        public Equals($obj: any):boolean;
        
        public static op_Inequality($lhs: SortingLayerRange, $rhs: SortingLayerRange):boolean;
        
        public static op_Equality($lhs: SortingLayerRange, $rhs: SortingLayerRange):boolean;
        
        public GetHashCode():number;
        
        public get_Clone(): SortingLayerRange;            
    }
    /**
     * Gizmo subsets.
     */
    enum GizmoSubset { PreImageEffects = 0, PostImageEffects = 1 }
    /**
     * Values for the raster state.
     */
    class RasterState extends System.ValueType {
        /**
         * Default values for the raster state.
         */
        public static defaultValue: RasterState;
        /**
         * Controls which sides of polygons should be culled (not drawn).
         */
        public get cullingMode(): CullMode;
        public set cullingMode(value: CullMode);
        /**
         * Enable clipping based on depth.
         */
        public get depthClip(): boolean;
        public set depthClip(value: boolean);
        /**
         * Enables conservative rasterization. Before using check for support via SystemInfo.supportsConservativeRaster property.
         */
        public get conservative(): boolean;
        public set conservative(value: boolean);
        /**
         * Scales the minimum resolvable depth buffer value.
         */
        public get offsetUnits(): number;
        public set offsetUnits(value: number);
        /**
         * Scales the maximum Z slope.
         */
        public get offsetFactor(): number;
        public set offsetFactor(value: number);
        
        public constructor($cullingMode?: CullMode, $offsetUnits?: number, $offsetFactor?: number, $depthClip?: boolean);
        
        public Equals($other: RasterState):boolean;
        
        public Equals($obj: any):boolean;
        
        public GetHashCode():number;
        
        public static op_Equality($left: RasterState, $right: RasterState):boolean;
        
        public static op_Inequality($left: RasterState, $right: RasterState):boolean;
        
        public get_Clone(): RasterState;            
    }
    /**
     * Defines a series of commands and settings that describes how Unity renders a frame.
     */
    class RenderPipeline extends System.Object {
        /**
         * Returns true when the RenderPipeline is invalid or destroyed.
         */
        public get disposed(): boolean;
        
                    
    }
    /**
     * Render Pipeline manager.
     */
    class RenderPipelineManager extends System.Object {
        /**
         * Returns the instance of the current RenderPipeline.
         */
        public static get currentPipeline(): RenderPipeline;
        
        public static add_beginFrameRendering($value: System.Action$2<ScriptableRenderContext, UnityEngine.Camera[]>):void;
        
        public static remove_beginFrameRendering($value: System.Action$2<ScriptableRenderContext, UnityEngine.Camera[]>):void;
        
        public static add_beginCameraRendering($value: System.Action$2<ScriptableRenderContext, UnityEngine.Camera>):void;
        
        public static remove_beginCameraRendering($value: System.Action$2<ScriptableRenderContext, UnityEngine.Camera>):void;
        
        public static add_endFrameRendering($value: System.Action$2<ScriptableRenderContext, UnityEngine.Camera[]>):void;
        
        public static remove_endFrameRendering($value: System.Action$2<ScriptableRenderContext, UnityEngine.Camera[]>):void;
        
        public static add_endCameraRendering($value: System.Action$2<ScriptableRenderContext, UnityEngine.Camera>):void;
        
        public static remove_endCameraRendering($value: System.Action$2<ScriptableRenderContext, UnityEngine.Camera>):void;
        
        public static beginFrameRendering;
        
        public static beginCameraRendering;
        
        public static endFrameRendering;
        
        public static endCameraRendering;
        
                    
    }
    /**
     * Defines state and drawing commands that custom render pipelines use.
     */
    class ScriptableRenderContext extends System.ValueType {
        /**
         * Emits UI geometry into the Scene view for rendering.
         * @param cullingCamera Camera to emit the geometry for.
         */
        public static EmitWorldGeometryForSceneView($cullingCamera: UnityEngine.Camera):void;
        /**
         * Emits UI geometry for rendering for the specified camera.
         * @param camera Camera to emit the geometry for.
         */
        public static EmitGeometryForCamera($camera: UnityEngine.Camera):void;
        
        public BeginRenderPass($width: number, $height: number, $samples: number, $attachments: Unity_Collections.NativeArray$1<AttachmentDescriptor>, $depthAttachmentIndex?: number):void;
        
        public BeginScopedRenderPass($width: number, $height: number, $samples: number, $attachments: Unity_Collections.NativeArray$1<AttachmentDescriptor>, $depthAttachmentIndex?: number):ScopedRenderPass;
        
        public BeginSubPass($colors: Unity_Collections.NativeArray$1<number>, $inputs: Unity_Collections.NativeArray$1<number>, $isDepthReadOnly: boolean, $isStencilReadOnly: boolean):void;
        
        public BeginSubPass($colors: Unity_Collections.NativeArray$1<number>, $inputs: Unity_Collections.NativeArray$1<number>, $isDepthStencilReadOnly?: boolean):void;
        
        public BeginSubPass($colors: Unity_Collections.NativeArray$1<number>, $isDepthReadOnly: boolean, $isStencilReadOnly: boolean):void;
        
        public BeginSubPass($colors: Unity_Collections.NativeArray$1<number>, $isDepthStencilReadOnly?: boolean):void;
        
        public BeginScopedSubPass($colors: Unity_Collections.NativeArray$1<number>, $inputs: Unity_Collections.NativeArray$1<number>, $isDepthReadOnly: boolean, $isStencilReadOnly: boolean):ScopedSubPass;
        
        public BeginScopedSubPass($colors: Unity_Collections.NativeArray$1<number>, $inputs: Unity_Collections.NativeArray$1<number>, $isDepthStencilReadOnly?: boolean):ScopedSubPass;
        
        public BeginScopedSubPass($colors: Unity_Collections.NativeArray$1<number>, $isDepthReadOnly: boolean, $isStencilReadOnly: boolean):ScopedSubPass;
        
        public BeginScopedSubPass($colors: Unity_Collections.NativeArray$1<number>, $isDepthStencilReadOnly?: boolean):ScopedSubPass;
        /**
         * Schedules the end of the currently active sub pass.
         */
        public EndSubPass():void;
        /**
         * Schedules the end of a currently active render pass.
         */
        public EndRenderPass():void;
        /**
         * Submits all the scheduled commands to the rendering loop for execution.
         */
        public Submit():void;
        /**
         * Schedules the drawing of a subset of visible GameObjects.
         * @param cullingResults Specifies which set of visible objects to draw, typically obtained from Cull.
         * @param drawingSettings Specifies how to draw GameObjects.
         * @param filteringSettings Specifies how the render pipeline should further filter the Renderers in the Scene.
         * @param stateBlock Specifies parts of the render state to override.
         * @param tagName Specifies the name of the Pass Tag or SubShader Tag that identifies renderers whose render state will be overridden. When this is not specified, the default value is "RenderType".
         * @param isPassTagName If set to true, tagName specifies a Pass Tag. If set to false, tagName specifies a SubShader Tag. When this is not specified, the default value is false.
         * @param tagValues Specifies the values of the Pass Tag or SubShader Tag that identifies renderers whose render state will be overridden.
         * @param renderTypes Specifies render types whose render states are overridden.
         * @param stateBlocks Specifies parts of the render state to override for specific render types.
         */
        public DrawRenderers($cullingResults: CullingResults, $drawingSettings: $Ref<DrawingSettings>, $filteringSettings: $Ref<FilteringSettings>):void;
        /**
         * Schedules the drawing of a subset of visible GameObjects.
         * @param cullingResults Specifies which set of visible objects to draw, typically obtained from Cull.
         * @param drawingSettings Specifies how to draw GameObjects.
         * @param filteringSettings Specifies how the render pipeline should further filter the Renderers in the Scene.
         * @param stateBlock Specifies parts of the render state to override.
         * @param tagName Specifies the name of the Pass Tag or SubShader Tag that identifies renderers whose render state will be overridden. When this is not specified, the default value is "RenderType".
         * @param isPassTagName If set to true, tagName specifies a Pass Tag. If set to false, tagName specifies a SubShader Tag. When this is not specified, the default value is false.
         * @param tagValues Specifies the values of the Pass Tag or SubShader Tag that identifies renderers whose render state will be overridden.
         * @param renderTypes Specifies render types whose render states are overridden.
         * @param stateBlocks Specifies parts of the render state to override for specific render types.
         */
        public DrawRenderers($cullingResults: CullingResults, $drawingSettings: $Ref<DrawingSettings>, $filteringSettings: $Ref<FilteringSettings>, $stateBlock: $Ref<RenderStateBlock>):void;
        
        public DrawRenderers($cullingResults: CullingResults, $drawingSettings: $Ref<DrawingSettings>, $filteringSettings: $Ref<FilteringSettings>, $renderTypes: Unity_Collections.NativeArray$1<ShaderTagId>, $stateBlocks: Unity_Collections.NativeArray$1<RenderStateBlock>):void;
        
        public DrawRenderers($cullingResults: CullingResults, $drawingSettings: $Ref<DrawingSettings>, $filteringSettings: $Ref<FilteringSettings>, $tagName: ShaderTagId, $isPassTagName: boolean, $tagValues: Unity_Collections.NativeArray$1<ShaderTagId>, $stateBlocks: Unity_Collections.NativeArray$1<RenderStateBlock>):void;
        /**
         * Schedules the drawing of shadow casters for a single Light.
         * @param settings Specifies which set of shadow casters to draw, and how to draw them.
         */
        public DrawShadows($settings: $Ref<ShadowDrawingSettings>):void;
        /**
         * Schedules the execution of a custom graphics Command Buffer.
         * @param commandBuffer Specifies the Command Buffer to execute.
         */
        public ExecuteCommandBuffer($commandBuffer: CommandBuffer):void;
        /**
         * Schedules the execution of a Command Buffer on an async compute queue. The ComputeQueueType that you pass in determines the queue order.
         * @param commandBuffer The CommandBuffer to be executed.
         * @param queueType Describes the desired async compute queue the supplied CommandBuffer should be executed on.
         */
        public ExecuteCommandBufferAsync($commandBuffer: CommandBuffer, $queueType: ComputeQueueType):void;
        /**
         * Schedules the setup of Camera specific global Shader variables.
         * @param camera Camera to setup shader variables for.
         * @param stereoSetup Set up the stereo shader variables and state.
         * @param eye The current eye to be rendered.
         */
        public SetupCameraProperties($camera: UnityEngine.Camera, $stereoSetup?: boolean):void;
        /**
         * Schedules the setup of Camera specific global Shader variables.
         * @param camera Camera to setup shader variables for.
         * @param stereoSetup Set up the stereo shader variables and state.
         * @param eye The current eye to be rendered.
         */
        public SetupCameraProperties($camera: UnityEngine.Camera, $stereoSetup: boolean, $eye: number):void;
        /**
         * Schedule notification of completion of stereo rendering on a single frame.
         * @param camera Camera to indicate completion of stereo rendering.
         * @param eye The current eye to be rendered.
         */
        public StereoEndRender($camera: UnityEngine.Camera):void;
        /**
         * Schedule notification of completion of stereo rendering on a single frame.
         * @param camera Camera to indicate completion of stereo rendering.
         * @param eye The current eye to be rendered.
         */
        public StereoEndRender($camera: UnityEngine.Camera, $eye: number):void;
        /**
         * Schedule notification of completion of stereo rendering on a single frame.
         * @param camera Camera to indicate completion of stereo rendering.
         * @param eye The current eye to be rendered.
         */
        public StereoEndRender($camera: UnityEngine.Camera, $eye: number, $isFinalPass: boolean):void;
        /**
         * Schedules a fine-grained beginning of stereo rendering on the ScriptableRenderContext.
         * @param camera Camera to enable stereo rendering on.
         * @param eye The current eye to be rendered.
         */
        public StartMultiEye($camera: UnityEngine.Camera):void;
        /**
         * Schedules a fine-grained beginning of stereo rendering on the ScriptableRenderContext.
         * @param camera Camera to enable stereo rendering on.
         * @param eye The current eye to be rendered.
         */
        public StartMultiEye($camera: UnityEngine.Camera, $eye: number):void;
        /**
         * Schedules a stop of stereo rendering on the ScriptableRenderContext.
         * @param camera Camera to disable stereo rendering on.
         */
        public StopMultiEye($camera: UnityEngine.Camera):void;
        /**
         * Schedules the drawing of the skybox.
         * @param camera Camera to draw the skybox for.
         */
        public DrawSkybox($camera: UnityEngine.Camera):void;
        /**
         * Schedules an invocation of the OnRenderObject callback for MonoBehaviour scripts.
         */
        public InvokeOnRenderObjectCallback():void;
        /**
         * Schedules the drawing of a subset of Gizmos (before or after post-processing) for the given Camera.
         * @param camera The camera of the current view.
         * @param gizmoSubset Set to GizmoSubset.PreImageEffects to draw Gizmos that should be affected by postprocessing, or GizmoSubset.PostImageEffects to draw Gizmos that should not be affected by postprocessing. See also: GizmoSubset.
         */
        public DrawGizmos($camera: UnityEngine.Camera, $gizmoSubset: GizmoSubset):void;
        /**
         * Schedules the drawing of a wireframe overlay for a given Scene view Camera.
         * @param camera The Scene view Camera to draw the overlay for.
         */
        public DrawWireOverlay($camera: UnityEngine.Camera):void;
        /**
         * Draw the UI overlay.
         * @param camera The camera of the current view.
         */
        public DrawUIOverlay($camera: UnityEngine.Camera):void;
        /**
         * Performs culling based on the ScriptableCullingParameters typically obtained from the Camera currently being rendered.
         * @param parameters Parameters for culling.
         * @returns Culling results.
         */
        public Cull($parameters: $Ref<ScriptableCullingParameters>):CullingResults;
        
        public Equals($other: ScriptableRenderContext):boolean;
        
        public Equals($obj: any):boolean;
        
        public GetHashCode():number;
        
        public static op_Equality($left: ScriptableRenderContext, $right: ScriptableRenderContext):boolean;
        
        public static op_Inequality($left: ScriptableRenderContext, $right: ScriptableRenderContext):boolean;
        
        public get_Clone(): ScriptableRenderContext;            
    }
    /**
     * A set of values used to override the render state. Note that it is not enough to set e.g. blendState, but that mask must also include RenderStateMask.Blend for the override to occur.
     */
    class RenderStateBlock extends System.ValueType {
        /**
         * Specifies the new blend state.
         */
        public get blendState(): BlendState;
        public set blendState(value: BlendState);
        /**
         * Specifies the new raster state.
         */
        public get rasterState(): RasterState;
        public set rasterState(value: RasterState);
        /**
         * Specifies the new depth state.
         */
        public get depthState(): DepthState;
        public set depthState(value: DepthState);
        /**
         * Specifies the new stencil state.
         */
        public get stencilState(): StencilState;
        public set stencilState(value: StencilState);
        /**
         * The value to be compared against and/or the value to be written to the buffer based on the stencil state.
         */
        public get stencilReference(): number;
        public set stencilReference(value: number);
        /**
         * Specifies which parts of the render state that is overriden.
         */
        public get mask(): RenderStateMask;
        public set mask(value: RenderStateMask);
        /**
         * Creates a new render state block with the specified mask.
         * @param mask Specifies which parts of the render state that is overriden.
         */
        public constructor($mask: RenderStateMask);
        
        public Equals($other: RenderStateBlock):boolean;
        
        public Equals($obj: any):boolean;
        
        public GetHashCode():number;
        
        public static op_Equality($left: RenderStateBlock, $right: RenderStateBlock):boolean;
        
        public static op_Inequality($left: RenderStateBlock, $right: RenderStateBlock):boolean;
        
        public get_Clone(): RenderStateBlock;            
    }
    /**
     * Values for the stencil state.
     */
    class StencilState extends System.ValueType {
        /**
         * Default values for the stencil state.
         */
        public static get defaultValue(): StencilState;
        /**
         * Controls whether the stencil buffer is enabled.
         */
        public get enabled(): boolean;
        public set enabled(value: boolean);
        /**
         * An 8 bit mask as an 0–255 integer, used when comparing the reference value with the contents of the buffer.
         */
        public get readMask(): number;
        public set readMask(value: number);
        /**
         * An 8 bit mask as an 0–255 integer, used when writing to the buffer.
         */
        public get writeMask(): number;
        public set writeMask(value: number);
        /**
         * The function used to compare the reference value to the current contents of the buffer for front-facing geometry.
         */
        public get compareFunctionFront(): CompareFunction;
        public set compareFunctionFront(value: CompareFunction);
        /**
         * What to do with the contents of the buffer if the stencil test (and the depth test) passes for front-facing geometry.
         */
        public get passOperationFront(): StencilOp;
        public set passOperationFront(value: StencilOp);
        /**
         * What to do with the contents of the buffer if the stencil test fails for front-facing geometry.
         */
        public get failOperationFront(): StencilOp;
        public set failOperationFront(value: StencilOp);
        /**
         * What to do with the contents of the buffer if the stencil test passes, but the depth test fails for front-facing geometry.
         */
        public get zFailOperationFront(): StencilOp;
        public set zFailOperationFront(value: StencilOp);
        /**
         * The function used to compare the reference value to the current contents of the buffer for back-facing geometry.
         */
        public get compareFunctionBack(): CompareFunction;
        public set compareFunctionBack(value: CompareFunction);
        /**
         * What to do with the contents of the buffer if the stencil test (and the depth test) passes for back-facing geometry.
         */
        public get passOperationBack(): StencilOp;
        public set passOperationBack(value: StencilOp);
        /**
         * What to do with the contents of the buffer if the stencil test fails for back-facing geometry.
         */
        public get failOperationBack(): StencilOp;
        public set failOperationBack(value: StencilOp);
        /**
         * What to do with the contents of the buffer if the stencil test passes, but the depth test fails for back-facing geometry.
         */
        public get zFailOperationBack(): StencilOp;
        public set zFailOperationBack(value: StencilOp);
        /**
         * Creates a new stencil state with the given values.
         * @param readMask An 8 bit mask as an 0–255 integer, used when comparing the reference value with the contents of the buffer.
         * @param writeMask An 8 bit mask as an 0–255 integer, used when writing to the buffer.
         * @param enabled Controls whether the stencil buffer is enabled.
         * @param compareFunctionFront The function used to compare the reference value to the current contents of the buffer for front-facing geometry.
         * @param passOperationFront What to do with the contents of the buffer if the stencil test (and the depth test) passes for front-facing geometry.
         * @param failOperationFront What to do with the contents of the buffer if the stencil test fails for front-facing geometry.
         * @param zFailOperationFront What to do with the contents of the buffer if the stencil test passes, but the depth test fails for front-facing geometry.
         * @param compareFunctionBack The function used to compare the reference value to the current contents of the buffer for back-facing geometry.
         * @param passOperationBack What to do with the contents of the buffer if the stencil test (and the depth test) passes for back-facing geometry.
         * @param failOperationBack What to do with the contents of the buffer if the stencil test fails for back-facing geometry.
         * @param zFailOperationBack What to do with the contents of the buffer if the stencil test passes, but the depth test fails for back-facing geometry.
         * @param compareFunction The function used to compare the reference value to the current contents of the buffer.
         * @param passOperation What to do with the contents of the buffer if the stencil test (and the depth test) passes.
         * @param failOperation What to do with the contents of the buffer if the stencil test fails.
         * @param zFailOperation What to do with the contents of the buffer if the stencil test passes, but the depth test.
         */
        public constructor($enabled?: boolean, $readMask?: number, $writeMask?: number, $compareFunction?: CompareFunction, $passOperation?: StencilOp, $failOperation?: StencilOp, $zFailOperation?: StencilOp);
        /**
         * Creates a new stencil state with the given values.
         * @param readMask An 8 bit mask as an 0–255 integer, used when comparing the reference value with the contents of the buffer.
         * @param writeMask An 8 bit mask as an 0–255 integer, used when writing to the buffer.
         * @param enabled Controls whether the stencil buffer is enabled.
         * @param compareFunctionFront The function used to compare the reference value to the current contents of the buffer for front-facing geometry.
         * @param passOperationFront What to do with the contents of the buffer if the stencil test (and the depth test) passes for front-facing geometry.
         * @param failOperationFront What to do with the contents of the buffer if the stencil test fails for front-facing geometry.
         * @param zFailOperationFront What to do with the contents of the buffer if the stencil test passes, but the depth test fails for front-facing geometry.
         * @param compareFunctionBack The function used to compare the reference value to the current contents of the buffer for back-facing geometry.
         * @param passOperationBack What to do with the contents of the buffer if the stencil test (and the depth test) passes for back-facing geometry.
         * @param failOperationBack What to do with the contents of the buffer if the stencil test fails for back-facing geometry.
         * @param zFailOperationBack What to do with the contents of the buffer if the stencil test passes, but the depth test fails for back-facing geometry.
         * @param compareFunction The function used to compare the reference value to the current contents of the buffer.
         * @param passOperation What to do with the contents of the buffer if the stencil test (and the depth test) passes.
         * @param failOperation What to do with the contents of the buffer if the stencil test fails.
         * @param zFailOperation What to do with the contents of the buffer if the stencil test passes, but the depth test.
         */
        public constructor($enabled: boolean, $readMask: number, $writeMask: number, $compareFunctionFront: CompareFunction, $passOperationFront: StencilOp, $failOperationFront: StencilOp, $zFailOperationFront: StencilOp, $compareFunctionBack: CompareFunction, $passOperationBack: StencilOp, $failOperationBack: StencilOp, $zFailOperationBack: StencilOp);
        /**
         * The function used to compare the reference value to the current contents of the buffer.
         * @param value The value to set.
         */
        public SetCompareFunction($value: CompareFunction):void;
        /**
         * What to do with the contents of the buffer if the stencil test (and the depth test) passes.
         * @param value The value to set.
         */
        public SetPassOperation($value: StencilOp):void;
        /**
         * What to do with the contents of the buffer if the stencil test fails.
         * @param value The value to set.
         */
        public SetFailOperation($value: StencilOp):void;
        /**
         * What to do with the contents of the buffer if the stencil test passes, but the depth test fails.
         * @param value The value to set.
         */
        public SetZFailOperation($value: StencilOp):void;
        
        public Equals($other: StencilState):boolean;
        
        public Equals($obj: any):boolean;
        
        public GetHashCode():number;
        
        public static op_Equality($left: StencilState, $right: StencilState):boolean;
        
        public static op_Inequality($left: StencilState, $right: StencilState):boolean;
        
        public get_Clone(): StencilState;            
    }
    /**
     * Specifies which parts of the render state that is overriden.
     */
    enum RenderStateMask { Nothing = 0, Blend = 1, Raster = 2, Depth = 4, Stencil = 8, Everything = 15 }
    /**
     * Represents an active render pass until disposed.
     */
    class ScopedRenderPass extends System.ValueType {
        /**
         * Ends the current render pass in the ScriptableRenderContext that was used to create the ScopedRenderPass.
         */
        public Dispose():void;
        
        public get_Clone(): ScopedRenderPass;            
    }
    /**
     * Represents an active sub pass until disposed.
     */
    class ScopedSubPass extends System.ValueType {
        /**
         * Ends the current sub pass in the ScriptableRenderContext that was used to create the ScopedSubPass.
         */
        public Dispose():void;
        
        public get_Clone(): ScopedSubPass;            
    }
    /**
     * Settings for ScriptableRenderContext.DrawShadows.
     */
    class ShadowDrawingSettings extends System.ValueType {
        /**
         * Culling results to use.
         */
        public get cullingResults(): CullingResults;
        public set cullingResults(value: CullingResults);
        /**
         * The index of the shadow-casting light to be rendered.
         */
        public get lightIndex(): number;
        public set lightIndex(value: number);
        /**
         * Set this to true to make Unity filter Renderers during shadow rendering. Unity filters Renderers based on the Rendering Layer Mask of the Renderer itself, and the Rendering Layer Mask of each shadow casting Light.
         */
        public get useRenderingLayerMaskTest(): boolean;
        public set useRenderingLayerMaskTest(value: boolean);
        /**
         * The split data.
         */
        public get splitData(): ShadowSplitData;
        public set splitData(value: ShadowSplitData);
        /**
         * Create a shadow settings object.
         * @param cullResults The cull results for this light.
         * @param lightIndex The light index.
         */
        public constructor($cullingResults: CullingResults, $lightIndex: number);
        
        public Equals($other: ShadowDrawingSettings):boolean;
        
        public Equals($obj: any):boolean;
        
        public GetHashCode():number;
        
        public static op_Equality($left: ShadowDrawingSettings, $right: ShadowDrawingSettings):boolean;
        
        public static op_Inequality($left: ShadowDrawingSettings, $right: ShadowDrawingSettings):boolean;
        
                    
    }
    /**
     * How to sort objects during rendering.
     */
    enum SortingCriteria { None = 0, SortingLayer = 1, RenderQueue = 2, BackToFront = 4, QuantizedFrontToBack = 8, OptimizeStateChanges = 16, CanvasOrder = 32, RendererPriority = 64, CommonOpaque = 59, CommonTransparent = 23 }
    /**
     * Type of sorting to use while rendering.
     */
    enum DistanceMetric { Perspective = 0, Orthographic = 1, CustomAxis = 2 }
    /**
     * Describes the rendering features supported by a given render pipeline.
     */
    class SupportedRenderingFeatures extends System.Object {
        /**
         * Get / Set a SupportedRenderingFeatures.
         */
        public static get active(): SupportedRenderingFeatures;
        public static set active(value: SupportedRenderingFeatures);
        /**
         * Flags for supported reflection probes.
         */
        public get reflectionProbeModes(): UnityEngine_Rendering_SupportedRenderingFeatures.ReflectionProbeModes;
        public set reflectionProbeModes(value: UnityEngine_Rendering_SupportedRenderingFeatures.ReflectionProbeModes);
        /**
         * This is the fallback mode if the mode the user had previously selected is no longer available. See SupportedRenderingFeatures.mixedLightingModes.
         */
        public get defaultMixedLightingModes(): UnityEngine_Rendering_SupportedRenderingFeatures.LightmapMixedBakeModes;
        public set defaultMixedLightingModes(value: UnityEngine_Rendering_SupportedRenderingFeatures.LightmapMixedBakeModes);
        /**
         * Specifies what LightmapMixedBakeModes that are supported. Please define a SupportedRenderingFeatures.defaultMixedLightingModes in case multiple modes are supported.
         */
        public get mixedLightingModes(): UnityEngine_Rendering_SupportedRenderingFeatures.LightmapMixedBakeModes;
        public set mixedLightingModes(value: UnityEngine_Rendering_SupportedRenderingFeatures.LightmapMixedBakeModes);
        /**
         * What baking types are supported. The unsupported ones will be hidden from the UI. See LightmapBakeType.
         */
        public get lightmapBakeTypes(): UnityEngine.LightmapBakeType;
        public set lightmapBakeTypes(value: UnityEngine.LightmapBakeType);
        /**
         * Specifies what modes are supported. Has to be at least one. See LightmapsMode.
         */
        public get lightmapsModes(): UnityEngine.LightmapsMode;
        public set lightmapsModes(value: UnityEngine.LightmapsMode);
        /**
         * Determines whether Enlighten is supported. When not supported, Enlighten-specific settings do not appear in the Editor (for both Baked and Realtime GI), unless the Project was upgraded from 2019.2 or earlier.
         */
        public get enlighten(): boolean;
        public set enlighten(value: boolean);
        /**
         * Are light probe proxy volumes supported?
         */
        public get lightProbeProxyVolumes(): boolean;
        public set lightProbeProxyVolumes(value: boolean);
        /**
         * Are motion vectors supported?
         */
        public get motionVectors(): boolean;
        public set motionVectors(value: boolean);
        /**
         * Can renderers support receiving shadows?
         */
        public get receiveShadows(): boolean;
        public set receiveShadows(value: boolean);
        /**
         * Are reflection probes supported?
         */
        public get reflectionProbes(): boolean;
        public set reflectionProbes(value: boolean);
        /**
         * Determines if the renderer supports renderer priority sorting.
         */
        public get rendererPriority(): boolean;
        public set rendererPriority(value: boolean);
        /**
         * Determines if the renderer supports terrain detail rendering.
         */
        public get terrainDetailUnsupported(): boolean;
        public set terrainDetailUnsupported(value: boolean);
        /**
         * Determines whether the function to render UI overlays is called by SRP and not by the engine.
         */
        public get rendersUIOverlay(): boolean;
        public set rendersUIOverlay(value: boolean);
        /**
         * Determines if the renderer will override the Environment Lighting and will no longer need the built-in UI for it.
         */
        public get overridesEnvironmentLighting(): boolean;
        public set overridesEnvironmentLighting(value: boolean);
        /**
         * Determines if the renderer will override the fog settings in the Lighting Panel and will no longer need the built-in UI for it.
         */
        public get overridesFog(): boolean;
        public set overridesFog(value: boolean);
        /**
         * Specifies whether the render pipeline overrides the Realtime Reflection Probes settings in the Quality settings. If It does, the render pipeline does not need the built-in UI for Realtime Reflection Probes settings.
         */
        public get overridesRealtimeReflectionProbes(): boolean;
        public set overridesRealtimeReflectionProbes(value: boolean);
        /**
         * Determines if the renderer will override halo and flare settings in the Lighting Panel and will no longer need the built-in UI for it.
         */
        public get overridesOtherLightingSettings(): boolean;
        public set overridesOtherLightingSettings(value: boolean);
        /**
         * Determines whether the Scriptable Render Pipeline will override the default Material’s Render Queue settings and, if true, hides the Render Queue property in the Inspector.
         */
        public get editableMaterialRenderQueue(): boolean;
        public set editableMaterialRenderQueue(value: boolean);
        /**
         * Specifies whether the renderer overrides the LOD bias settings in the Quality Settings Panel. If It does, the renderer does not need the built-in UI for LOD bias settings.
         */
        public get overridesLODBias(): boolean;
        public set overridesLODBias(value: boolean);
        /**
         * Specifies whether the renderer overrides the maximum LOD level settings in the Quality Settings Panel. If It does, the renderer does not need the built-in UI for maximum LOD level settings.
         */
        public get overridesMaximumLODLevel(): boolean;
        public set overridesMaximumLODLevel(value: boolean);
        /**
         * Determines whether the Renderer supports probe lighting.
         */
        public get rendererProbes(): boolean;
        public set rendererProbes(value: boolean);
        /**
         * Determines if the renderer supports Particle System GPU instancing.
         */
        public get particleSystemInstancing(): boolean;
        public set particleSystemInstancing(value: boolean);
        /**
         * Specifies whether the render pipeline overrides the Shadowmask settings in the Quality settings.
         */
        public get overridesShadowmask(): boolean;
        public set overridesShadowmask(value: boolean);
        /**
         * Describes where the Shadowmask settings are located if SupportedRenderingFeatures.overridesShadowmask is set to true.
         */
        public get overrideShadowmaskMessage(): string;
        public set overrideShadowmaskMessage(value: string);
        /**
         * A message that tells the user where the Shadowmask settings are located.
         */
        public get shadowmaskMessage(): string;
        
        public constructor();
        
                    
    }
    /**
     * Describes the visibility for a batch.
     */
    class BatchVisibility extends System.ValueType {
        /**
         * Input property specifying the offset into the BatchCullingContext.visibleIndices where the batch's visibile indices start. (readonly).
         */
        public offset: number;
        /**
         * Input property specifying the total number of instances in the batch. (readonly).
         */
        public instancesCount: number;
        /**
         * Output property that has to be set to the number of visible instances in the batch after culling.
         */
        public visibleCount: number;
        
        public get_Clone(): BatchVisibility;            
    }
    /**
     * Culling context for a batch.
     */
    class BatchCullingContext extends System.ValueType {
        /**
         * Planes to cull against.
         */
        public cullingPlanes: Unity_Collections.NativeArray$1<UnityEngine.Plane>;
        /**
         * Visibility information for the batch.
         */
        public batchVisibility: Unity_Collections.NativeArray$1<BatchVisibility>;
        /**
         * Array of visible indices for all the batches in the group.
         */
        public visibleIndices: Unity_Collections.NativeArray$1<number>;
        /**
         * Array of uints containing extra data for the visible indices for all the batches in the group. Elements in this array correspond to elements in Rendering.BatchCullingContext.visibleIndices.
         */
        public visibleIndicesY: Unity_Collections.NativeArray$1<number>;
        /**
         * See Also: LODParameters.
         */
        public lodParameters: LODParameters;
        /**
         * Culling matrix.
         */
        public cullingMatrix: UnityEngine.Matrix4x4;
        /**
         * The near frustum plane for this culling context.
         */
        public nearPlane: number;
        
                    
    }
    /**
     * A group of batches.
     */
    class BatchRendererGroup extends System.Object {
        /**
         * Creates a new Rendering.BatchRendererGroup.
         * @param cullingCallback The delegate to call for performing culling.
        See Also: BatchRendererGroup.OnPerformCulling.
         */
        public constructor($cullingCallback: UnityEngine_Rendering_BatchRendererGroup.OnPerformCulling);
        /**
         * Deletes a group.
         */
        public Dispose():void;
        /**
         * Adds a new batch to the group.
         * @param mesh The Mesh to draw.
         * @param subMeshIndex Specifies which subset of the mesh to draw. This applies only to meshes that are composed of several materials.
         * @param material Material to use.
         * @param layer  to use.
         * @param castShadows Whether the meshes cast shadows.
         * @param receiveShadows Whether the meshes receive shadows.
         * @param invertCulling Specify whether to invert the backface culling (true) or not (false). This flag can "flip" the culling mode of all rendered objects. Major use case: rendering reflections for mirrors, water etc. Since virtual camera for rendering the reflection is mirrored, the culling order has to be inverted. You can see how the Water script in Effects standard package does that.
         * @param bounds Bounds to use. Should specify the combined bounds of all the instances.
         * @param instanceCount The number of instances to draw.
         * @param customProps Additional material properties to apply. See MaterialPropertyBlock.
         * @param associatedSceneObject The GameObject to select when you pick an object that the batch renders.
         * @param sceneCullingMask Additional culling mask usually used for scene based culling. See Also: EditorSceneManager.GetSceneCullingMask.
         * @param renderingLayerMask Rendering layer this batch lives on. See Also: Renderer.renderingLayerMask.
         * @returns The batch's index in the BatchedRendererGroup.
         */
        public AddBatch($mesh: UnityEngine.Mesh, $subMeshIndex: number, $material: UnityEngine.Material, $layer: number, $castShadows: ShadowCastingMode, $receiveShadows: boolean, $invertCulling: boolean, $bounds: UnityEngine.Bounds, $instanceCount: number, $customProps: UnityEngine.MaterialPropertyBlock, $associatedSceneObject: UnityEngine.GameObject):number;
        /**
         * Adds a new batch to the group.
         * @param mesh The Mesh to draw.
         * @param subMeshIndex Specifies which subset of the mesh to draw. This applies only to meshes that are composed of several materials.
         * @param material Material to use.
         * @param layer  to use.
         * @param castShadows Whether the meshes cast shadows.
         * @param receiveShadows Whether the meshes receive shadows.
         * @param invertCulling Specify whether to invert the backface culling (true) or not (false). This flag can "flip" the culling mode of all rendered objects. Major use case: rendering reflections for mirrors, water etc. Since virtual camera for rendering the reflection is mirrored, the culling order has to be inverted. You can see how the Water script in Effects standard package does that.
         * @param bounds Bounds to use. Should specify the combined bounds of all the instances.
         * @param instanceCount The number of instances to draw.
         * @param customProps Additional material properties to apply. See MaterialPropertyBlock.
         * @param associatedSceneObject The GameObject to select when you pick an object that the batch renders.
         * @param sceneCullingMask Additional culling mask usually used for scene based culling. See Also: EditorSceneManager.GetSceneCullingMask.
         * @param renderingLayerMask Rendering layer this batch lives on. See Also: Renderer.renderingLayerMask.
         * @returns The batch's index in the BatchedRendererGroup.
         */
        public AddBatch($mesh: UnityEngine.Mesh, $subMeshIndex: number, $material: UnityEngine.Material, $layer: number, $castShadows: ShadowCastingMode, $receiveShadows: boolean, $invertCulling: boolean, $bounds: UnityEngine.Bounds, $instanceCount: number, $customProps: UnityEngine.MaterialPropertyBlock, $associatedSceneObject: UnityEngine.GameObject, $sceneCullingMask: bigint):number;
        
        public AddBatch($mesh: UnityEngine.Mesh, $subMeshIndex: number, $material: UnityEngine.Material, $layer: number, $castShadows: ShadowCastingMode, $receiveShadows: boolean, $invertCulling: boolean, $bounds: UnityEngine.Bounds, $instanceCount: number, $customProps: UnityEngine.MaterialPropertyBlock, $associatedSceneObject: UnityEngine.GameObject, $sceneCullingMask: bigint, $renderingLayerMask: number):number;
        /**
         * Sets flag bits that enable special behavior for this Hybrid Renderer V2 batch.
         * @param batchIndex Batch index. Must be a Hybrid Renderer V2 batch.
         * @param flags Flag bits to set for the batch.
         */
        public SetBatchFlags($batchIndex: number, $flags: bigint):void;
        
        public SetBatchPropertyMetadata($batchIndex: number, $cbufferLengths: Unity_Collections.NativeArray$1<number>, $cbufferMetadata: Unity_Collections.NativeArray$1<number>):void;
        /**
         * Updates a batch.
         * @param batchIndex Batch index.
         * @param instanceCount New number of instances in the batch.
         * @param customProps Additional material properties to apply. See MaterialPropertyBlock.
         */
        public SetInstancingData($batchIndex: number, $instanceCount: number, $customProps: UnityEngine.MaterialPropertyBlock):void;
        /**
         * Retrieves the matrices associated with one batch.
         * @param batchIndex Batch index.
         * @returns Matrices associated with the batch specified by batchIndex.
         */
        public GetBatchMatrices($batchIndex: number):Unity_Collections.NativeArray$1<UnityEngine.Matrix4x4>;
        /**
         * Retrieves an array of instanced int properties for a given batch.
         * @param batchIndex Batch index.
         * @param propertyName Property name.
         * @returns An array of writable int properties for the batch specified by batchIndex.
         */
        public GetBatchScalarArrayInt($batchIndex: number, $propertyName: string):Unity_Collections.NativeArray$1<number>;
        /**
         * Retrieves an array of instanced float properties for a given batch.
         * @param batchIndex Batch index.
         * @param propertyName Property name.
         * @returns An array of writable float properties for the batch specified by batchIndex.
         */
        public GetBatchScalarArray($batchIndex: number, $propertyName: string):Unity_Collections.NativeArray$1<number>;
        /**
         * Retrieves an array of instanced int vector properties for a given batch.
         * @param batchIndex Batch index.
         * @param propertyName Property name.
         * @returns An array of writable vector properties for the batch specified by batchIndex, arranged linearly as individual int elements.
         */
        public GetBatchVectorArrayInt($batchIndex: number, $propertyName: string):Unity_Collections.NativeArray$1<number>;
        /**
         * Retrieves an array of instanced vector properties for a given batch.
         * @param batchIndex Batch index.
         * @param propertyName Property name.
         * @returns An array of writable vector properties for the batch specified by batchIndex.
         */
        public GetBatchVectorArray($batchIndex: number, $propertyName: string):Unity_Collections.NativeArray$1<UnityEngine.Vector4>;
        /**
         * Retrieves an array of instanced vector properties for a given batch.
         * @param batchIndex Batch index.
         * @param propertyName Property name.
         * @returns An array of writable matrix properties for the batch specified by batchIndex.
         */
        public GetBatchMatrixArray($batchIndex: number, $propertyName: string):Unity_Collections.NativeArray$1<UnityEngine.Matrix4x4>;
        /**
         * Retrieves an array of instanced int properties for a given batch.
         * @param batchIndex Batch index.
         * @param propertyName Property name.
         * @returns An array of writable int properties for the batch specified by batchIndex.
         */
        public GetBatchScalarArrayInt($batchIndex: number, $propertyName: number):Unity_Collections.NativeArray$1<number>;
        /**
         * Retrieves an array of instanced float properties for a given batch.
         * @param batchIndex Batch index.
         * @param propertyName Property name.
         * @returns An array of writable float properties for the batch specified by batchIndex.
         */
        public GetBatchScalarArray($batchIndex: number, $propertyName: number):Unity_Collections.NativeArray$1<number>;
        /**
         * Retrieves an array of instanced int vector properties for a given batch.
         * @param batchIndex Batch index.
         * @param propertyName Property name.
         * @returns An array of writable vector properties for the batch specified by batchIndex, arranged linearly as individual int elements.
         */
        public GetBatchVectorArrayInt($batchIndex: number, $propertyName: number):Unity_Collections.NativeArray$1<number>;
        /**
         * Retrieves an array of instanced vector properties for a given batch.
         * @param batchIndex Batch index.
         * @param propertyName Property name.
         * @returns An array of writable vector properties for the batch specified by batchIndex.
         */
        public GetBatchVectorArray($batchIndex: number, $propertyName: number):Unity_Collections.NativeArray$1<UnityEngine.Vector4>;
        /**
         * Retrieves an array of instanced vector properties for a given batch.
         * @param batchIndex Batch index.
         * @param propertyName Property name.
         * @returns An array of writable matrix properties for the batch specified by batchIndex.
         */
        public GetBatchMatrixArray($batchIndex: number, $propertyName: number):Unity_Collections.NativeArray$1<UnityEngine.Matrix4x4>;
        /**
         * Sets the bounding box of the batch.
         * @param batchIndex Batch index.
         * @param bounds The new bounds for the batch specified by batchIndex.
         */
        public SetBatchBounds($batchIndex: number, $bounds: UnityEngine.Bounds):void;
        /**
         * Retrieves the number of batches added to the group.
         * @returns Number of batches inside the group.
         */
        public GetNumBatches():number;
        /**
         * Removes a batch from the group.
         * Note: For performance reasons, the removal is done via emplace_back() which will simply replace the removed batch index with the last index in the array and will decrement the size.
         * If you're holding your own array of batch indices, you'll have to either regenerate it or apply the same emplace_back() mechanism as RemoveBatch does.
         * @param index Batch index.
         */
        public RemoveBatch($index: number):void;
        /**
         * Enables or disables Rendering.BatchCullingContext.visibleIndicesY.
         * @param enabled Pass true to enable the array, or false to disable it.
         */
        public EnableVisibleIndicesYArray($enabled: boolean):void;
        
                    
    }
    /**
     * A collection of Rendering.ShaderKeyword that represents a specific platform variant.
     */
    class PlatformKeywordSet extends System.ValueType {
        /**
         * Check whether a specific shader keyword is enabled.
         */
        public IsEnabled($define: BuiltinShaderDefine):boolean;
        
        public Enable($define: BuiltinShaderDefine):void;
        
        public Disable($define: BuiltinShaderDefine):void;
        
        public get_Clone(): PlatformKeywordSet;            
    }
    /**
     * Type of a shader keyword, eg: built-in or user defined.
     */
    enum ShaderKeywordType { None = 0, BuiltinDefault = 2, BuiltinExtra = 6, BuiltinAutoStripped = 10, UserDefined = 16 }
    /**
     * Identifier of a specific code path in a shader.
     */
    class ShaderKeyword extends System.ValueType {
        /**
         * The index of the shader keyword.
         */
        public get index(): number;
        /**
         * Initializes a new instance of the ShaderKeyword class from a shader global keyword name.
         * @param keywordName The name of the keyword.
         */
        public constructor($keywordName: string);
        /**
         * Initializes a new instance of the ShaderKeyword class from a global or local shader keyword name.
         * @param shader The shader that declares the keyword.
         * @param keywordName The name of the keyword.
         */
        public constructor($shader: UnityEngine.Shader, $keywordName: string);
        /**
         * Initializes a new instance of the ShaderKeyword class from a local shader keyword name, and the compute shader that defines that local keyword.
         * @param shader The compute shader that declares the local keyword.
         * @param keywordName The name of the keyword.
         */
        public constructor($shader: UnityEngine.ComputeShader, $keywordName: string);
        /**
         * Returns the string name of the global keyword.
         */
        public static GetGlobalKeywordName($index: ShaderKeyword):string;
        /**
         * Returns the type of global keyword: built-in or user defined.
         */
        public static GetGlobalKeywordType($index: ShaderKeyword):ShaderKeywordType;
        /**
         * Returns true if the keyword is local.
         */
        public static IsKeywordLocal($index: ShaderKeyword):boolean;
        /**
         * Returns the string name of the keyword.
         */
        public static GetKeywordName($shader: UnityEngine.Shader, $index: ShaderKeyword):string;
        /**
         * Returns the type of keyword: built-in or user defined.
         */
        public static GetKeywordType($shader: UnityEngine.Shader, $index: ShaderKeyword):ShaderKeywordType;
        /**
         * Returns the string name of the keyword.
         */
        public static GetKeywordName($shader: UnityEngine.ComputeShader, $index: ShaderKeyword):string;
        /**
         * Returns the type of keyword: built-in or user defined.
         */
        public static GetKeywordType($shader: UnityEngine.ComputeShader, $index: ShaderKeyword):ShaderKeywordType;
        /**
         * Returns true if the keyword has been imported by Unity.
         */
        public IsValid():boolean;
        
        public get_Clone(): ShaderKeyword;            
    }
    /**
     * A collection of Rendering.ShaderKeyword that represents a specific shader variant.
     */
    class ShaderKeywordSet extends System.ValueType {
        /**
         * Check whether a specific shader keyword is enabled.
         */
        public IsEnabled($keyword: ShaderKeyword):boolean;
        /**
         * Enable a specific shader keyword.
         */
        public Enable($keyword: ShaderKeyword):void;
        /**
         * Disable a specific shader keyword.
         */
        public Disable($keyword: ShaderKeyword):void;
        /**
         * Return an array with all the enabled keywords in the ShaderKeywordSet.
         */
        public GetShaderKeywords():ShaderKeyword[];
        
        public get_Clone(): ShaderKeywordSet;            
    }
    /**
     * Adding a SortingGroup component to a GameObject will ensure that all Renderers within the GameObject's descendants will be sorted and rendered together.
     */
    class SortingGroup extends UnityEngine.Behaviour {
        /**
         * Name of the Renderer's sorting layer.
         */
        public get sortingLayerName(): string;
        public set sortingLayerName(value: string);
        /**
         * Unique ID of the Renderer's sorting layer.
         */
        public get sortingLayerID(): number;
        public set sortingLayerID(value: number);
        /**
         * Renderer's order within a sorting layer.
         */
        public get sortingOrder(): number;
        public set sortingOrder(value: number);
        
        public constructor();
        /**
         * Updates all Sorting Group immediately.
         */
        public static UpdateAllSortingGroups():void;
        
                    
    }
    
    interface CommandBuffer {
        /**
         * Adds a command to put a given render target into fast GPU memory.
         * @param rid The render target to put into fast GPU memory.
         * @param fastMemoryFlags The memory layout to use if only part of the render target is put into fast GPU memory, either because of the residency parameter or because of fast GPU memory availability.
         * @param residency The amount of the render target to put into fast GPU memory. Valid values are 0.0f - 1.0f inclusive.
        A value of 0.0f is equal to none of the render target, and a value of 1.0f is equal to the whole render target.
                        
         * @param copyContents When this value is true, Unity copies the existing contents of the render target into fast memory.
        When this value is false, Unity does not copy the existing contents of the render target into fast memory.
        Set this value to true if you plan to add to the existing contents, and set it to false if you plan to overwrite or clear the existing contents.
        Where possible, set this value to false for better performance.
                        
         * @extension UnityEngine.Rendering.CommandBufferExtensions
         */
        SwitchIntoFastMemory($rid: RenderTargetIdentifier, $fastMemoryFlags: FastMemoryFlags, $residency: number, $copyContents: boolean):void;
        /**
         * Adds a command to remove a given render target from fast GPU memory.
         * @param rid The render target to remove from fast GPU memory.
         * @param copyContents When this value is true, Unity copies the existing contents of the render target when it removes it from fast GPU memory. When this value is false, Unity does not copy the existing contents of the render target when it removes it from fast GPU memory. Set this value to true if you plan to add to the existing contents, and set it to false if you plan to overwrite or clear the existing contents. Where possible, set this value to false for better performance.
         * @extension UnityEngine.Rendering.CommandBufferExtensions
         */
        SwitchOutOfFastMemory($rid: RenderTargetIdentifier, $copyContents: boolean):void;
        
                    
    }
    
}
declare module 'Unity.Collections' {

    import * as System from 'System';
        
    /**
     * A NativeArray exposes a buffer of native memory to managed code, making it possible to share data between managed and native without marshalling costs.
     */
    interface NativeArray$1<T> extends System.ValueType {
        
                    
    }
    /**
     * Native Slice.
     */
    interface NativeSlice$1<T> extends System.ValueType {
        
                    
    }
    /**
     * The ReadOnly attribute lets you mark a member of a struct used in a job as read-only.
     */
    class ReadOnlyAttribute extends System.Attribute {
        
        public constructor();
        
                    
    }
    /**
     * The WriteOnly attribute lets you mark a member of a struct used in a job as write-only.
     */
    class WriteOnlyAttribute extends System.Attribute {
        
        public constructor();
        
                    
    }
    /**
     * DeallocateOnJobCompletionAttribute.
     */
    class DeallocateOnJobCompletionAttribute extends System.Attribute {
        
        public constructor();
        
                    
    }
    /**
     * The container has from start a size that will never change.
     */
    class NativeFixedLengthAttribute extends System.Attribute {
        /**
         * The fixed number of elements in the container.
         */
        public FixedLength: number;
        /**
         * The specified number of elements will never change.
         * @param fixedLength The fixed number of elements in the container.
         */
        public constructor($fixedLength: number);
        
                    
    }
    
    class NativeMatchesParallelForLengthAttribute extends System.Attribute {
        
        public constructor();
        
                    
    }
    /**
     * NativeDisableParallelForRestrictionAttribute.
     */
    class NativeDisableParallelForRestrictionAttribute extends System.Attribute {
        
        public constructor();
        
                    
    }
    /**
     * Used to specify allocation type for NativeArray.
     */
    enum Allocator { Invalid = 0, None = 1, Temp = 2, TempJob = 3, Persistent = 4, AudioKernel = 5 }
    /**
     * Native leak memory leak detection mode enum.
     */
    enum NativeLeakDetectionMode { EnabledWithStackTrace = 3, Enabled = 2, Disabled = 1 }
    /**
     * Static class for native leak detection settings.
     */
    class NativeLeakDetection extends System.Object {
        /**
         * Set whether native memory leak detection should be enabled or disabled.
         */
        public static get Mode(): NativeLeakDetectionMode;
        public static set Mode(value: NativeLeakDetectionMode);
        
                    
    }
    /**
     * NativeArrayOptions lets you control if memory should be cleared on allocation or left uninitialized.
     */
    enum NativeArrayOptions { UninitializedMemory = 0, ClearMemory = 1 }
    
    class NativeSliceExtensions extends System.Object {
        
        public static Slice<T>($thisArray: NativeArray$1<T>):NativeSlice$1<T>;
        
        public static Slice<T>($thisArray: NativeArray$1<T>, $start: number):NativeSlice$1<T>;
        
        public static Slice<T>($thisArray: NativeArray$1<T>, $start: number, $length: number):NativeSlice$1<T>;
        
        public static Slice<T>($thisSlice: NativeSlice$1<T>):NativeSlice$1<T>;
        
        public static Slice<T>($thisSlice: NativeSlice$1<T>, $start: number):NativeSlice$1<T>;
        
        public static Slice<T>($thisSlice: NativeSlice$1<T>, $start: number, $length: number):NativeSlice$1<T>;
        
                    
    }
    
    interface NativeArray$1 {
        /** @extension Unity.Collections.NativeSliceExtensions */
        Slice<T>():NativeSlice$1<T>;
        /** @extension Unity.Collections.NativeSliceExtensions */
        Slice<T>($start: number):NativeSlice$1<T>;
        /** @extension Unity.Collections.NativeSliceExtensions */
        Slice<T>($start: number, $length: number):NativeSlice$1<T>;
        
                    
    }
    
    interface NativeSlice$1 {
        /** @extension Unity.Collections.NativeSliceExtensions */
        Slice<T>():NativeSlice$1<T>;
        /** @extension Unity.Collections.NativeSliceExtensions */
        Slice<T>($start: number):NativeSlice$1<T>;
        /** @extension Unity.Collections.NativeSliceExtensions */
        Slice<T>($start: number, $length: number):NativeSlice$1<T>;
        
                    
    }
    
}
declare module 'UnityEngine.Events' {

    import * as System from 'System';
    import * as UnityEngine from 'UnityEngine';
    import * as System_Reflection from 'System.Reflection';
        
    /**
     * A zero argument persistent callback that can be saved with the Scene.
     */
    class UnityEvent extends UnityEventBase {
        /**
         * Constructor.
         */
        public constructor();
        /**
         * Add a non persistent listener to the UnityEvent.
         * @param call Callback function.
         */
        public AddListener($call: UnityAction):void;
        /**
         * Remove a non persistent listener from the UnityEvent.
         * @param call Callback function.
         */
        public RemoveListener($call: UnityAction):void;
        /**
         * Invoke all registered callbacks (runtime and persistent).
         */
        public Invoke():void;
        
                    
    }
    /**
     * Abstract base class for UnityEvents.
     */
    class UnityEventBase extends System.Object {
        /**
         * Get the number of registered persistent listeners.
         */
        public GetPersistentEventCount():number;
        /**
         * Get the target component of the listener at index index.
         * @param index Index of the listener to query.
         */
        public GetPersistentTarget($index: number):UnityEngine.Object;
        /**
         * Get the target method name of the listener at index index.
         * @param index Index of the listener to query.
         */
        public GetPersistentMethodName($index: number):string;
        /**
         * Modify the execution state of a persistent listener.
         * @param index Index of the listener to query.
         * @param state State to set.
         */
        public SetPersistentListenerState($index: number, $state: UnityEventCallState):void;
        /**
         * Remove all non-persisent (ie created from script) listeners  from the event.
         */
        public RemoveAllListeners():void;
        
        public ToString():string;
        /**
         * Given an object, function name, and a list of argument types; find the method that matches.
         * @param obj Object to search for the method.
         * @param functionName Function name to search for.
         * @param argumentTypes Argument types for the function.
         */
        public static GetValidMethodInfo($obj: any, $functionName: string, $argumentTypes: System.Type[]):System_Reflection.MethodInfo;
        /**
         * Given an object type, function name, and a list of argument types; find the method that matches.
         * @param objectType Object type to search for the method.
         * @param functionName Function name to search for.
         * @param argumentTypes Argument types for the function.
         */
        public static GetValidMethodInfo($objectType: System.Type, $functionName: string, $argumentTypes: System.Type[]):System_Reflection.MethodInfo;
        
                    
    }
    /**
     * Zero argument delegate used by UnityEvents.
     */
    type UnityAction = () => void;
    var UnityAction: {new (func: () => void): UnityAction;}
    /**
     * One argument version of UnityEvent.
     */
    class UnityEvent$1<T0> extends UnityEventBase {
        
        public constructor();
        
        public AddListener($call: UnityAction$1<T0>):void;
        
        public RemoveListener($call: UnityAction$1<T0>):void;
        
        public Invoke($arg0: T0):void;
        
                    
    }
    
    type UnityAction$1<T0> = (arg0: T0) => void;
    /**
     * THe mode that a listener is operating in.
     */
    enum PersistentListenerMode { EventDefined = 0, Void = 1, Object = 2, Int = 3, Float = 4, String = 5, Bool = 6 }
    /**
     * Controls the scope of UnityEvent callbacks.
     */
    enum UnityEventCallState { Off = 0, EditorAndRuntime = 1, RuntimeOnly = 2 }
    
    type UnityAction$2<T0,T1> = (arg0: T0, arg1: T1) => void;
    
}
declare module 'UnityEngine.Playables' {

    import * as UnityEngine from 'UnityEngine';
    import * as System from 'System';
    import * as System_Collections_Generic from 'System.Collections.Generic';
    import * as UnityEngine_Playables_FrameData from 'UnityEngine.Playables.FrameData';
        
    /**
     * A base class for assets that can be used to instantiate a Playable at runtime.
     */
    class PlayableAsset extends UnityEngine.ScriptableObject {
        /**
         * The playback duration in seconds of the instantiated Playable.
         */
        public get duration(): number;
        /**
         * A description of the outputs of the instantiated Playable.
         */
        public get outputs(): System_Collections_Generic.IEnumerable$1<PlayableBinding>;
        /**
         * Implement this method to have your asset inject playables into the given graph.
         * @param graph The graph to inject playables into.
         * @param owner The game object which initiated the build.
         * @returns The playable injected into the graph, or the root playable if multiple playables are injected.
         */
        public CreatePlayable($graph: PlayableGraph, $owner: UnityEngine.GameObject):Playable;
        
                    
    }
    /**
     * Playables are customizable runtime objects that can be connected together and are contained in a PlayableGraph to create complex behaviours.
     */
    class Playable extends System.ValueType {
        /**
         * Returns an invalid Playable.
         */
        public static get Null(): Playable;
        
        public static Create($graph: PlayableGraph, $inputCount?: number):Playable;
        
        public GetHandle():PlayableHandle;
        
        public IsPlayableOfType<T>():boolean;
        
        public GetPlayableType():System.Type;
        
        public Equals($other: Playable):boolean;
        
        public get_Clone(): Playable;            
    }
    /**
     * Use the PlayableGraph to manage Playable creations and destructions.
     */
    class PlayableGraph extends System.ValueType {
        /**
         * Returns the Playable with no output connections at the given index.
         * @param index The index of the root Playable.
         */
        public GetRootPlayable($index: number):Playable;
        
        public Connect<U,V>($source: U, $sourceOutputPort: number, $destination: V, $destinationInputPort: number):boolean;
        
        public Disconnect<U>($input: U, $inputPort: number):void;
        
        public DestroyPlayable<U>($playable: U):void;
        
        public DestroySubgraph<U>($playable: U):void;
        
        public DestroyOutput<U>($output: U):void;
        /**
         * Get the number of PlayableOutput of the requested type in the graph.
         * @returns The number of PlayableOutput of the same type T in the graph.
         */
        public GetOutputCountByType<T>():number;
        /**
         * Get PlayableOutput at the given index in the graph.
         * @param index The output index.
         * @returns The PlayableOutput at this given index, otherwise null.
         */
        public GetOutput($index: number):PlayableOutput;
        /**
         * Get PlayableOutput of the requested type at the given index in the graph.
         * @param index The output index.
         * @returns The PlayableOutput at the given index among all the PlayableOutput of the same type T.
         */
        public GetOutputByType<T>($index: number):PlayableOutput;
        /**
         * Evaluates all the PlayableOutputs in the graph, and updates all the connected Playables in the graph.
         * @param deltaTime The time in seconds by which to advance each Playable in the graph.
         */
        public Evaluate():void;
        /**
         * Creates a PlayableGraph.
         * @param name The name of the graph.
         * @returns The newly created PlayableGraph.
         */
        public static Create():PlayableGraph;
        /**
         * Creates a PlayableGraph.
         * @param name The name of the graph.
         * @returns The newly created PlayableGraph.
         */
        public static Create($name: string):PlayableGraph;
        /**
         * Destroys the graph.
         */
        public Destroy():void;
        /**
         * Returns true if the PlayableGraph has been properly constructed using PlayableGraph.CreateGraph and is not deleted.
         * @returns A boolean indicating if the graph is invalid or not.
         */
        public IsValid():boolean;
        /**
         * Indicates that a graph is presently running.
         * @returns A boolean indicating if the graph is playing or not.
         */
        public IsPlaying():boolean;
        /**
         * Indicates that a graph has completed its operations.
         * @returns A boolean indicating if the graph is done playing or not.
         */
        public IsDone():boolean;
        /**
         * Plays the graph.
         */
        public Play():void;
        /**
         * Stops the graph, if it is playing.
         */
        public Stop():void;
        /**
         * Evaluates all the PlayableOutputs in the graph, and updates all the connected Playables in the graph.
         * @param deltaTime The time in seconds by which to advance each Playable in the graph.
         */
        public Evaluate($deltaTime: number):void;
        /**
         * Returns how time is incremented when playing back.
         */
        public GetTimeUpdateMode():DirectorUpdateMode;
        /**
         * Changes how time is incremented when playing back.
         * @param value The new DirectorUpdateMode.
         */
        public SetTimeUpdateMode($value: DirectorUpdateMode):void;
        /**
         * Returns the table used by the graph to resolve ExposedReferences.
         */
        public GetResolver():UnityEngine.IExposedPropertyTable;
        /**
         * Changes the table used by the graph to resolve ExposedReferences.
         */
        public SetResolver($value: UnityEngine.IExposedPropertyTable):void;
        /**
         * Returns the number of Playable owned by the Graph.
         */
        public GetPlayableCount():number;
        /**
         * Returns the number of Playable owned by the Graph that have no connected outputs.
         */
        public GetRootPlayableCount():number;
        /**
         * Returns the number of PlayableOutput in the graph.
         * @returns The number of PlayableOutput in the graph.
         */
        public GetOutputCount():number;
        /**
         * Returns the name of the PlayableGraph.
         */
        public GetEditorName():string;
        
        public get_Clone(): PlayableGraph;            
    }
    /**
     * Struct that holds information regarding an output of a PlayableAsset.
     */
    class PlayableBinding extends System.ValueType {
        /**
         * A constant to represent a PlayableAsset has no bindings.
         */
        public static None: PlayableBinding[];
        /**
         * The default duration used when a PlayableOutput has no fixed duration.
         */
        public static DefaultDuration: number;
        /**
         * The name of the output or input stream.
         */
        public get streamName(): string;
        public set streamName(value: string);
        /**
         * A reference to a UnityEngine.Object that acts a key for this binding.
         */
        public get sourceObject(): UnityEngine.Object;
        public set sourceObject(value: UnityEngine.Object);
        /**
         * The type of target required by the PlayableOutput for this PlayableBinding.
         */
        public get outputTargetType(): System.Type;
        
                    
    }
    /**
     * This structure contains the frame information a Playable receives in Playable.PrepareFrame.
     */
    class FrameData extends System.ValueType {
        /**
         * The current frame identifier.
         */
        public get frameId(): bigint;
        /**
         * Time difference between this frame and the preceding frame.
         */
        public get deltaTime(): number;
        /**
         * The weight of the current Playable.
         */
        public get weight(): number;
        /**
         * The accumulated weight of the Playable during the PlayableGraph traversal.
         */
        public get effectiveWeight(): number;
        /**
         * The accumulated speed of the parent Playable during the PlayableGraph traversal.
         */
        public get effectiveParentSpeed(): number;
        /**
         * The accumulated speed of the Playable during the PlayableGraph traversal.
         */
        public get effectiveSpeed(): number;
        /**
         * Indicates the type of evaluation that caused PlayableGraph.PrepareFrame to be called.
         */
        public get evaluationType(): UnityEngine_Playables_FrameData.EvaluationType;
        /**
         * Indicates that the local time was explicitly set.
         */
        public get seekOccurred(): boolean;
        /**
         * Indicates the local time wrapped because it has reached the duration and the extrapolation mode is set to Loop.
         */
        public get timeLooped(): boolean;
        /**
         * Indicates the local time did not advance because it has reached the duration and the extrapolation mode is set to Hold.
         */
        public get timeHeld(): boolean;
        /**
         * The PlayableOutput that initiated this graph traversal.
         */
        public get output(): PlayableOutput;
        /**
         * The accumulated play state of this playable.
         */
        public get effectivePlayState(): PlayState;
        
        public get_Clone(): FrameData;            
    }
    /**
     * See: Playables.IPlayableOutput.
     */
    class PlayableOutput extends System.ValueType {
        /**
         * Returns an invalid PlayableOutput.
         */
        public static get Null(): PlayableOutput;
        
        public GetHandle():PlayableOutputHandle;
        
        public IsPlayableOutputOfType<T>():boolean;
        
        public GetPlayableOutputType():System.Type;
        
        public Equals($other: PlayableOutput):boolean;
        
        public get_Clone(): PlayableOutput;            
    }
    /**
     * Status of a Playable.
     */
    enum PlayState { Paused = 0, Playing = 1, Delayed = 2 }
    /**
     * The base interface for all notifications sent through the playable system.
     */
    interface INotification {
        /**
         * The identifier is a name that identifies this notifications, or class of notifications.
         */
        id: UnityEngine.PropertyName;
        
                    
    }
    /**
     * Implement this interface to create a class that will receives notifications from PlayableOutput.
     */
    interface INotificationReceiver {
        /**
         * The method called when a notification is raised.
         * @param origin The playable that sent the notification.
         * @param notification The received notification.
         * @param context User defined data that depends on the type of notification. Uses this to pass necessary information that can change with each invocation.
         */
        OnNotify($origin: Playable, $notification: INotification, $context: any):void;
        
                    
    }
    /**
     * Interface implemented by all C# Playable implementations.
     */
    interface IPlayable {
        
        GetHandle():PlayableHandle;
        
                    
    }
    
    class PlayableHandle extends System.ValueType {
        
        public static get Null(): PlayableHandle;
        
        public static op_Equality($x: PlayableHandle, $y: PlayableHandle):boolean;
        
        public static op_Inequality($x: PlayableHandle, $y: PlayableHandle):boolean;
        
        public Equals($p: any):boolean;
        
        public Equals($other: PlayableHandle):boolean;
        
        public GetHashCode():number;
        
        public get_Clone(): PlayableHandle;            
    }
    /**
     * Interface implemented by all C# Playable Behaviour implementations.
     */
    interface IPlayableBehaviour {
        
        OnGraphStart($playable: Playable):void;
        
        OnGraphStop($playable: Playable):void;
        
        OnPlayableCreate($playable: Playable):void;
        
        OnPlayableDestroy($playable: Playable):void;
        
        OnBehaviourPlay($playable: Playable, $info: FrameData):void;
        
        OnBehaviourPause($playable: Playable, $info: FrameData):void;
        
        PrepareFrame($playable: Playable, $info: FrameData):void;
        
        ProcessFrame($playable: Playable, $info: FrameData, $playerData: any):void;
        
                    
    }
    /**
     * Interface implemented by all C# Playable output implementations.
     */
    interface IPlayableOutput {
        
        GetHandle():PlayableOutputHandle;
        
                    
    }
    
    class PlayableOutputHandle extends System.ValueType {
        
        public static get Null(): PlayableOutputHandle;
        
        public GetHashCode():number;
        
        public static op_Equality($lhs: PlayableOutputHandle, $rhs: PlayableOutputHandle):boolean;
        
        public static op_Inequality($lhs: PlayableOutputHandle, $rhs: PlayableOutputHandle):boolean;
        
        public Equals($p: any):boolean;
        
        public Equals($other: PlayableOutputHandle):boolean;
        
        public get_Clone(): PlayableOutputHandle;            
    }
    /**
     * Default implementation for Playable notifications.
     */
    class Notification extends System.Object {
        /**
         * The name that identifies this notification.
         */
        public get id(): UnityEngine.PropertyName;
        /**
         * Creates a new notification with the name specified in the argument.
         * @param name The name that identifies this notifications.
         */
        public constructor($name: string);
        
                    
    }
    /**
     * Wrap mode for Playables.
     */
    enum DirectorWrapMode { Hold = 0, Loop = 1, None = 2 }
    /**
     * Interface that permits a class to inject playables into a graph.
     */
    interface IPlayableAsset {
        /**
         * Duration in seconds.
         */
        duration: number;
        /**
         * A description of the PlayableOutputs generated by this asset.
         */
        outputs: System_Collections_Generic.IEnumerable$1<PlayableBinding>;
        /**
         * Implement this method to have your asset inject playables into the given graph.
         * @param graph The graph to inject playables into.
         * @param owner The game object which initiated the build.
         * @returns The playable injected into the graph, or the root playable if multiple playables are injected.
         */
        CreatePlayable($graph: PlayableGraph, $owner: UnityEngine.GameObject):Playable;
        
                    
    }
    /**
     * PlayableBehaviour is the base class from which every custom playable script derives.
     */
    class PlayableBehaviour extends System.Object {
        /**
         * This function is called when the PlayableGraph that owns this PlayableBehaviour starts.
         * @param playable The Playable that owns the current PlayableBehaviour.
         */
        public OnGraphStart($playable: Playable):void;
        /**
         * This function is called when the PlayableGraph that owns this PlayableBehaviour stops.
         * @param playable The Playable that owns the current PlayableBehaviour.
         */
        public OnGraphStop($playable: Playable):void;
        /**
         * This function is called when the Playable that owns the PlayableBehaviour is created.
         * @param playable The Playable that owns the current PlayableBehaviour.
         */
        public OnPlayableCreate($playable: Playable):void;
        /**
         * This function is called when the Playable that owns the PlayableBehaviour is destroyed.
         * @param playable The Playable that owns the current PlayableBehaviour.
         */
        public OnPlayableDestroy($playable: Playable):void;
        /**
         * This function is called when the Playable play state is changed to Playables.PlayState.Playing.
         * @param playable The Playable that owns the current PlayableBehaviour.
         * @param info A FrameData structure that contains information about the current frame context.
         */
        public OnBehaviourPlay($playable: Playable, $info: FrameData):void;
        /**
         * This method is invoked when one of the following situations occurs:
         * <br><br>
         * The effective play state during traversal is changed to Playables.PlayState.Paused. This state is indicated by FrameData.effectivePlayState.<br><br>
         * The PlayableGraph is stopped while the playable play state is Playing. This state is indicated by PlayableGraph.IsPlaying returning true.
         * @param playable The Playable that owns the current PlayableBehaviour.
         * @param info A FrameData structure that contains information about the current frame context.
         */
        public OnBehaviourPause($playable: Playable, $info: FrameData):void;
        /**
         * This function is called during the PrepareData phase of the PlayableGraph.
         * @param playable The Playable that owns the current PlayableBehaviour.
         * @param info A FrameData structure that contains information about the current frame context.
         */
        public PrepareData($playable: Playable, $info: FrameData):void;
        /**
         * This function is called during the PrepareFrame phase of the PlayableGraph.
         * @param playable The Playable that owns the current PlayableBehaviour.
         * @param info A FrameData structure that contains information about the current frame context.
         */
        public PrepareFrame($playable: Playable, $info: FrameData):void;
        /**
         * This function is called during the ProcessFrame phase of the PlayableGraph.
         * @param playable The Playable that owns the current PlayableBehaviour.
         * @param info A FrameData structure that contains information about the current frame context.
         * @param playerData The user data of the ScriptPlayableOutput that initiated the process pass.
         */
        public ProcessFrame($playable: Playable, $info: FrameData, $playerData: any):void;
        
        public Clone():any;
        
                    
    }
    /**
     * Describes the type of information that flows in and out of a Playable. This also specifies that this Playable is connectable to others of the same type.
     */
    enum DataStreamType { Animation = 0, Audio = 1, Texture = 2, None = 3 }
    /**
     * Traversal mode for Playables.
     */
    enum PlayableTraversalMode { Mix = 0, Passthrough = 1 }
    /**
     * Extensions for all the types that implements IPlayable.
     */
    class PlayableExtensions extends System.Object {
        
        public static IsNull<U>($playable: U):boolean;
        
        public static IsValid<U>($playable: U):boolean;
        
        public static Destroy<U>($playable: U):void;
        
        public static GetGraph<U>($playable: U):PlayableGraph;
        
        public static GetPlayState<U>($playable: U):PlayState;
        
        public static Play<U>($playable: U):void;
        
        public static Pause<U>($playable: U):void;
        
        public static SetSpeed<U>($playable: U, $value: number):void;
        
        public static GetSpeed<U>($playable: U):number;
        
        public static SetDuration<U>($playable: U, $value: number):void;
        
        public static GetDuration<U>($playable: U):number;
        
        public static SetTime<U>($playable: U, $value: number):void;
        
        public static GetTime<U>($playable: U):number;
        
        public static GetPreviousTime<U>($playable: U):number;
        
        public static SetDone<U>($playable: U, $value: boolean):void;
        
        public static IsDone<U>($playable: U):boolean;
        
        public static SetPropagateSetTime<U>($playable: U, $value: boolean):void;
        
        public static GetPropagateSetTime<U>($playable: U):boolean;
        
        public static CanChangeInputs<U>($playable: U):boolean;
        
        public static CanSetWeights<U>($playable: U):boolean;
        
        public static CanDestroy<U>($playable: U):boolean;
        
        public static SetInputCount<U>($playable: U, $value: number):void;
        
        public static GetInputCount<U>($playable: U):number;
        
        public static SetOutputCount<U>($playable: U, $value: number):void;
        
        public static GetOutputCount<U>($playable: U):number;
        
        public static GetInput<U>($playable: U, $inputPort: number):Playable;
        
        public static GetOutput<U>($playable: U, $outputPort: number):Playable;
        
        public static SetInputWeight<U>($playable: U, $inputIndex: number, $weight: number):void;
        
        public static SetInputWeight<U,V>($playable: U, $input: V, $weight: number):void;
        
        public static GetInputWeight<U>($playable: U, $inputIndex: number):number;
        
        public static ConnectInput<U,V>($playable: U, $inputIndex: number, $sourcePlayable: V, $sourceOutputIndex: number):void;
        
        public static ConnectInput<U,V>($playable: U, $inputIndex: number, $sourcePlayable: V, $sourceOutputIndex: number, $weight: number):void;
        
        public static DisconnectInput<U>($playable: U, $inputPort: number):void;
        
        public static AddInput<U,V>($playable: U, $sourcePlayable: V, $sourceOutputIndex: number, $weight?: number):number;
        
        public static SetLeadTime<U>($playable: U, $value: number):void;
        
        public static GetLeadTime<U>($playable: U):number;
        
        public static GetTraversalMode<U>($playable: U):PlayableTraversalMode;
        
        public static SetTraversalMode<U>($playable: U, $mode: PlayableTraversalMode):void;
        
                    
    }
    /**
     * Defines what time source is used to update a Director graph.
     */
    enum DirectorUpdateMode { DSPClock = 0, GameTime = 1, UnscaledGameTime = 2, Manual = 3 }
    /**
     * Extensions for all the types that implements IPlayableOutput.
     */
    class PlayableOutputExtensions extends System.Object {
        
        public static IsOutputNull<U>($output: U):boolean;
        
        public static IsOutputValid<U>($output: U):boolean;
        
        public static GetReferenceObject<U>($output: U):UnityEngine.Object;
        
        public static SetReferenceObject<U>($output: U, $value: UnityEngine.Object):void;
        
        public static GetUserData<U>($output: U):UnityEngine.Object;
        
        public static SetUserData<U>($output: U, $value: UnityEngine.Object):void;
        
        public static GetSourcePlayable<U>($output: U):Playable;
        
        public static SetSourcePlayable<U,V>($output: U, $value: V):void;
        
        public static SetSourcePlayable<U,V>($output: U, $value: V, $port: number):void;
        
        public static GetSourceOutputPort<U>($output: U):number;
        
        public static GetWeight<U>($output: U):number;
        
        public static SetWeight<U>($output: U, $value: number):void;
        
        public static PushNotification<U>($output: U, $origin: Playable, $notification: INotification, $context?: any):void;
        
        public static GetNotificationReceivers<U>($output: U):INotificationReceiver[];
        
        public static AddNotificationReceiver<U>($output: U, $receiver: INotificationReceiver):void;
        
        public static RemoveNotificationReceiver<U>($output: U, $receiver: INotificationReceiver):void;
        
                    
    }
    /**
     * A PlayableBinding that contains information representing a ScriptingPlayableOutput.
     */
    class ScriptPlayableBinding extends System.Object {
        /**
         * Creates a PlayableBinding that contains information representing a ScriptPlayableOutput.
         * @param key A reference to a UnityEngine.Object that acts as a key for this binding.
         * @param type The type of object that will be bound to the ScriptPlayableOutput.
         * @param name The name of the ScriptPlayableOutput.
         * @returns Returns a PlayableBinding that contains information that is used to create a ScriptPlayableOutput.
         */
        public static Create($name: string, $key: UnityEngine.Object, $type: System.Type):PlayableBinding;
        
                    
    }
    /**
     * A IPlayableOutput implementation that contains a script output for the a PlayableGraph.
     */
    class ScriptPlayableOutput extends System.ValueType {
        /**
         * Returns an invalid ScriptPlayableOutput.
         */
        public static get Null(): ScriptPlayableOutput;
        /**
         * Creates a new ScriptPlayableOutput in the associated PlayableGraph.
         * @param graph The PlayableGraph that will contain the ScriptPlayableOutput.
         * @param name The name of this ScriptPlayableOutput.
         * @returns The created ScriptPlayableOutput.
         */
        public static Create($graph: PlayableGraph, $name: string):ScriptPlayableOutput;
        
        public GetHandle():PlayableOutputHandle;
        
        public static op_Implicit($output: ScriptPlayableOutput):PlayableOutput;
        
        public static op_Explicit($output: PlayableOutput):ScriptPlayableOutput;
        
        public get_Clone(): ScriptPlayableOutput;            
    }
    
    interface U {
        /** @extension UnityEngine.Playables.PlayableExtensions */
        IsNull<U>():boolean;
        /** @extension UnityEngine.Playables.PlayableExtensions */
        IsValid<U>():boolean;
        /** @extension UnityEngine.Playables.PlayableExtensions */
        Destroy<U>():void;
        /** @extension UnityEngine.Playables.PlayableExtensions */
        GetGraph<U>():PlayableGraph;
        /** @extension UnityEngine.Playables.PlayableExtensions */
        GetPlayState<U>():PlayState;
        /** @extension UnityEngine.Playables.PlayableExtensions */
        Play<U>():void;
        /** @extension UnityEngine.Playables.PlayableExtensions */
        Pause<U>():void;
        /** @extension UnityEngine.Playables.PlayableExtensions */
        SetSpeed<U>($value: number):void;
        /** @extension UnityEngine.Playables.PlayableExtensions */
        GetSpeed<U>():number;
        /** @extension UnityEngine.Playables.PlayableExtensions */
        SetDuration<U>($value: number):void;
        /** @extension UnityEngine.Playables.PlayableExtensions */
        GetDuration<U>():number;
        /** @extension UnityEngine.Playables.PlayableExtensions */
        SetTime<U>($value: number):void;
        /** @extension UnityEngine.Playables.PlayableExtensions */
        GetTime<U>():number;
        /** @extension UnityEngine.Playables.PlayableExtensions */
        GetPreviousTime<U>():number;
        /** @extension UnityEngine.Playables.PlayableExtensions */
        SetDone<U>($value: boolean):void;
        /** @extension UnityEngine.Playables.PlayableExtensions */
        IsDone<U>():boolean;
        /** @extension UnityEngine.Playables.PlayableExtensions */
        SetPropagateSetTime<U>($value: boolean):void;
        /** @extension UnityEngine.Playables.PlayableExtensions */
        GetPropagateSetTime<U>():boolean;
        /** @extension UnityEngine.Playables.PlayableExtensions */
        CanChangeInputs<U>():boolean;
        /** @extension UnityEngine.Playables.PlayableExtensions */
        CanSetWeights<U>():boolean;
        /** @extension UnityEngine.Playables.PlayableExtensions */
        CanDestroy<U>():boolean;
        /** @extension UnityEngine.Playables.PlayableExtensions */
        SetInputCount<U>($value: number):void;
        /** @extension UnityEngine.Playables.PlayableExtensions */
        GetInputCount<U>():number;
        /** @extension UnityEngine.Playables.PlayableExtensions */
        SetOutputCount<U>($value: number):void;
        /** @extension UnityEngine.Playables.PlayableExtensions */
        GetOutputCount<U>():number;
        /** @extension UnityEngine.Playables.PlayableExtensions */
        GetInput<U>($inputPort: number):Playable;
        /** @extension UnityEngine.Playables.PlayableExtensions */
        GetOutput<U>($outputPort: number):Playable;
        /** @extension UnityEngine.Playables.PlayableExtensions */
        SetInputWeight<U>($inputIndex: number, $weight: number):void;
        /** @extension UnityEngine.Playables.PlayableExtensions */
        SetInputWeight<U,V>($input: V, $weight: number):void;
        /** @extension UnityEngine.Playables.PlayableExtensions */
        GetInputWeight<U>($inputIndex: number):number;
        /** @extension UnityEngine.Playables.PlayableExtensions */
        ConnectInput<U,V>($inputIndex: number, $sourcePlayable: V, $sourceOutputIndex: number):void;
        /** @extension UnityEngine.Playables.PlayableExtensions */
        ConnectInput<U,V>($inputIndex: number, $sourcePlayable: V, $sourceOutputIndex: number, $weight: number):void;
        /** @extension UnityEngine.Playables.PlayableExtensions */
        DisconnectInput<U>($inputPort: number):void;
        /** @extension UnityEngine.Playables.PlayableExtensions */
        AddInput<U,V>($sourcePlayable: V, $sourceOutputIndex: number, $weight?: number):number;
        /** @extension UnityEngine.Playables.PlayableExtensions */
        SetLeadTime<U>($value: number):void;
        /** @extension UnityEngine.Playables.PlayableExtensions */
        GetLeadTime<U>():number;
        /** @extension UnityEngine.Playables.PlayableExtensions */
        GetTraversalMode<U>():PlayableTraversalMode;
        /** @extension UnityEngine.Playables.PlayableExtensions */
        SetTraversalMode<U>($mode: PlayableTraversalMode):void;
        /** @extension UnityEngine.Playables.PlayableOutputExtensions */
        IsOutputNull<U>():boolean;
        /** @extension UnityEngine.Playables.PlayableOutputExtensions */
        IsOutputValid<U>():boolean;
        /** @extension UnityEngine.Playables.PlayableOutputExtensions */
        GetReferenceObject<U>():UnityEngine.Object;
        /** @extension UnityEngine.Playables.PlayableOutputExtensions */
        SetReferenceObject<U>($value: UnityEngine.Object):void;
        /** @extension UnityEngine.Playables.PlayableOutputExtensions */
        GetUserData<U>():UnityEngine.Object;
        /** @extension UnityEngine.Playables.PlayableOutputExtensions */
        SetUserData<U>($value: UnityEngine.Object):void;
        /** @extension UnityEngine.Playables.PlayableOutputExtensions */
        GetSourcePlayable<U>():Playable;
        /** @extension UnityEngine.Playables.PlayableOutputExtensions */
        SetSourcePlayable<U,V>($value: V):void;
        /** @extension UnityEngine.Playables.PlayableOutputExtensions */
        SetSourcePlayable<U,V>($value: V, $port: number):void;
        /** @extension UnityEngine.Playables.PlayableOutputExtensions */
        GetSourceOutputPort<U>():number;
        /** @extension UnityEngine.Playables.PlayableOutputExtensions */
        GetWeight<U>():number;
        /** @extension UnityEngine.Playables.PlayableOutputExtensions */
        SetWeight<U>($value: number):void;
        /** @extension UnityEngine.Playables.PlayableOutputExtensions */
        PushNotification<U>($origin: Playable, $notification: INotification, $context?: any):void;
        /** @extension UnityEngine.Playables.PlayableOutputExtensions */
        GetNotificationReceivers<U>():INotificationReceiver[];
        /** @extension UnityEngine.Playables.PlayableOutputExtensions */
        AddNotificationReceiver<U>($receiver: INotificationReceiver):void;
        /** @extension UnityEngine.Playables.PlayableOutputExtensions */
        RemoveNotificationReceiver<U>($receiver: INotificationReceiver):void;
        
                    
    }
    
}
declare module 'AOT' {

    import * as System from 'System';
        
    
    class MonoPInvokeCallbackAttribute extends System.Attribute {
        
        public constructor($type: System.Type);
        
                    
    }
    
}
declare module 'UnityEditor.Experimental' {

    import * as System from 'System';
        
    /**
     * Experimental render settings features.
     */
    class RenderSettings extends System.Object {
        
        public constructor();
        
                    
    }
    
}
declare module 'UnityEngineInternal' {

    import * as System from 'System';
    import * as System_Collections from 'System.Collections';
        
    
    enum GITextureType { Charting = 0, Albedo = 1, Emissive = 2, Irradiance = 3, Directionality = 4, Baked = 5, BakedDirectional = 6, InputWorkspace = 7, BakedShadowMask = 8, BakedAlbedo = 9, BakedEmissive = 10, BakedCharting = 11, BakedTexelValidity = 12, BakedUVOverlap = 13, BakedLightmapCulling = 14 }
    
    class GIDebugVisualisation extends System.Object {
        
        public static get cycleMode(): boolean;
        
        public static get pauseCycleMode(): boolean;
        
        public static get texType(): GITextureType;
        public static set texType(value: GITextureType);
        
        public static ResetRuntimeInputTextures():void;
        
        public static PlayCycleMode():void;
        
        public static PauseCycleMode():void;
        
        public static StopCycleMode():void;
        
        public static CycleSkipSystems($skip: number):void;
        
        public static CycleSkipInstances($skip: number):void;
        
                    
    }
    
    enum MemorylessMode { Unused = 0, Forced = 1, Automatic = 2 }
    
    class MemorylessManager extends System.Object {
        
        public static get depthMemorylessMode(): MemorylessMode;
        public static set depthMemorylessMode(value: MemorylessMode);
        
        public constructor();
        
                    
    }
    
    class MathfInternal extends System.ValueType {
        
        public static FloatMinNormal: number;
        
        public static FloatMinDenormal: number;
        
        public static IsFlushToZeroEnabled: boolean;
        
        public get_Clone(): MathfInternal;            
    }
    
    class APIUpdaterRuntimeServices extends System.Object {
        
        public constructor();
        
                    
    }
    
    enum TypeInferenceRules { TypeReferencedByFirstArgument = 0, TypeReferencedBySecondArgument = 1, ArrayOfTypeReferencedByFirstArgument = 2, TypeOfFirstArgument = 3 }
    
    class TypeInferenceRuleAttribute extends System.Attribute {
        
        public constructor($rule: TypeInferenceRules);
        
        public constructor($rule: string);
        
        public ToString():string;
        
                    
    }
    
    class GenericStack extends System_Collections.Stack {
        
        public constructor();
        
                    
    }
    
}
declare module 'Unity.Profiling' {

    import * as System from 'System';
    import * as UnityEngine from 'UnityEngine';
    import * as Unity_Profiling_ProfilerMarker from 'Unity.Profiling.ProfilerMarker';
    import * as System_Collections_Generic from 'System.Collections.Generic';
    import * as Unity_Profiling_LowLevel from 'Unity.Profiling.LowLevel';
        
    /**
     * Use to specify category for instrumentation Profiler markers.
     */
    class ProfilerCategory extends System.ValueType {
        /**
         * Gets Profiler category name.
         */
        public get Name(): string;
        /**
         * Gets Profiler category color.
         */
        public get Color(): UnityEngine.Color32;
        /**
         * Rendering system Profiler category.
         */
        public static get Render(): ProfilerCategory;
        /**
         * Generic C# code Profiler category.
         */
        public static get Scripts(): ProfilerCategory;
        /**
         * UI Profiler category.
         */
        public static get Gui(): ProfilerCategory;
        /**
         * Physics system Profiler category.
         */
        public static get Physics(): ProfilerCategory;
        /**
         * Animation Profiler category.
         */
        public static get Animation(): ProfilerCategory;
        /**
         * AI and NavMesh Profiler category.
         */
        public static get Ai(): ProfilerCategory;
        /**
         * Audio system Profiler category.
         */
        public static get Audio(): ProfilerCategory;
        /**
         * Video system Profiler category.
         */
        public static get Video(): ProfilerCategory;
        /**
         * Particle system Profiler category.
         */
        public static get Particles(): ProfilerCategory;
        /**
         * Global Illumination Profiler category.
         */
        public static get Lighting(): ProfilerCategory;
        /**
         * Networking system Profiler category.
         */
        public static get Network(): ProfilerCategory;
        /**
         * Loading system Profiler category.
         */
        public static get Loading(): ProfilerCategory;
        /**
         * VR systen Profiler category.
         */
        public static get Vr(): ProfilerCategory;
        /**
         * Input system Profiler category.
         */
        public static get Input(): ProfilerCategory;
        /**
         * Memory allocation Profiler category.
         */
        public static get Memory(): ProfilerCategory;
        /**
         * Virtual Texturing system Profiler category.
         */
        public static get VirtualTexturing(): ProfilerCategory;
        /**
         * Internal Unity systems Profiler category.
         */
        public static get Internal(): ProfilerCategory;
        /**
         * Use to construct ProfilerCategory by category name.
         * @param categoryName Profiler category name.
         */
        public constructor($categoryName: string);
        
        public ToString():string;
        
        public static op_Implicit($category: ProfilerCategory):number;
        
        public get_Clone(): ProfilerCategory;            
    }
    /**
     * Options for determining if a Profiler category is built into Unity by default.
     */
    enum ProfilerCategoryFlags { None = 0, Builtin = 1 }
    /**
     * Performance marker used for profiling arbitrary code blocks.
     */
    class ProfilerMarker extends System.ValueType {
        /**
         * Gets native handle of the ProfilerMarker.
         */
        public get Handle(): System.IntPtr;
        /**
         * Constructs a new performance marker for code instrumentation.
         * @param name Marker name.
         * @param category Profiler category.
         * @param nameLen Marker name length.
         */
        public constructor($name: string);
        /**
         * Constructs a new performance marker for code instrumentation.
         * @param name Marker name.
         * @param category Profiler category.
         * @param nameLen Marker name length.
         */
        public constructor($category: ProfilerCategory, $name: string);
        /**
         * Begin profiling a piece of code marked with a custom name defined by this instance of ProfilerMarker.
         * @param contextUnityObject Object associated with the operation.
         */
        public Begin():void;
        /**
         * Begin profiling a piece of code marked with a custom name defined by this instance of ProfilerMarker.
         * @param contextUnityObject Object associated with the operation.
         */
        public Begin($contextUnityObject: UnityEngine.Object):void;
        /**
         * End profiling a piece of code marked with a custom name defined by this instance of ProfilerMarker.
         */
        public End():void;
        /**
         * Creates a helper struct for the scoped using blocks.
         * @returns IDisposable struct which calls Begin and End automatically.
         */
        public Auto():Unity_Profiling_ProfilerMarker.AutoScope;
        
        public get_Clone(): ProfilerMarker;            
    }
    /**
     * Defines Profiler flow event type.
     */
    enum ProfilerFlowEventType { Begin = 0, ParallelNext = 1, End = 2, Next = 3 }
    /**
     * Options for Profiler marker data unit types.
     */
    enum ProfilerMarkerDataUnit { Undefined = 0, TimeNanoseconds = 1, Bytes = 2, Count = 3, Percent = 4, FrequencyHz = 5 }
    
    enum ProfilerCounterOptions { None = 0, FlushOnEndOfFrame = 2, ResetToZeroOnFlush = 4 }
    /**
     * ProfilerRecorder lifecycle and collection options.
     */
    enum ProfilerRecorderOptions { None = 0, StartImmediately = 1, KeepAliveDuringDomainReload = 2, CollectOnlyOnCurrentThread = 4, WrapAroundWhenCapacityReached = 8, SumAllSamplesInFrame = 16, Default = 24 }
    /**
     * Sample value structure.
     */
    class ProfilerRecorderSample extends System.ValueType {
        /**
         * Raw sample value.
         */
        public get Value(): bigint;
        /**
         * Sample count.
         */
        public get Count(): bigint;
        
        public get_Clone(): ProfilerRecorderSample;            
    }
    /**
     * Records the Profiler metric data that a Profiler marker or counter produces.
     */
    class ProfilerRecorder extends System.ValueType {
        /**
         * Indicates whether ProfilerRecorder is associated with a valid Profiler marker or counter.
         */
        public get Valid(): boolean;
        /**
         * Value data type of the Profiler metric.
         */
        public get DataType(): Unity_Profiling_LowLevel.ProfilerMarkerDataType;
        /**
         * Unit type.
         */
        public get UnitType(): ProfilerMarkerDataUnit;
        /**
         * Gets current value of the Profiler metric.
         */
        public get CurrentValue(): bigint;
        /**
         * Gets current value of the Profiler metric as double value.
         */
        public get CurrentValueAsDouble(): number;
        /**
         * Gets the last value collected by the ProfilerRecorder.
         */
        public get LastValue(): bigint;
        /**
         * Gets the last value collected by the ProfilerRecorder as double.
         */
        public get LastValueAsDouble(): number;
        /**
         * Maximum amount of samples ProfilerRecorder can capture.
         */
        public get Capacity(): number;
        /**
         * Collected samples count.
         */
        public get Count(): number;
        /**
         * Indicates if ProfilerRecorder is attached to the Profiler metric.
         */
        public get IsRunning(): boolean;
        /**
         * Indicates if ProfilerRecorder capacity has been exceeded.
         */
        public get WrappedAround(): boolean;
        /**
         * Constructs ProfilerRecorder instance with a Profiler metric name.
         * @param statName Profiler marker or counter name.
         * @param capacity Maximum amount of samples to be collected.
         * @param options Profiler recorder options.
         */
        public constructor($statName: string, $capacity?: number, $options?: ProfilerRecorderOptions);
        /**
         * Constructs ProfilerRecorder instance with a Profiler metric name and category.
         * @param categoryName Profiler category name.
         * @param statName Profiler marker or counter name.
         * @param capacity Maximum amount of samples to be collected.
         * @param options Profiler recorder options.
         * @param category Profiler category identifier.
         */
        public constructor($categoryName: string, $statName: string, $capacity?: number, $options?: ProfilerRecorderOptions);
        /**
         * Constructs ProfilerRecorder instance with a Profiler metric name and category.
         * @param categoryName Profiler category name.
         * @param statName Profiler marker or counter name.
         * @param capacity Maximum amount of samples to be collected.
         * @param options Profiler recorder options.
         * @param category Profiler category identifier.
         */
        public constructor($category: ProfilerCategory, $statName: string, $capacity?: number, $options?: ProfilerRecorderOptions);
        /**
         * Constructs ProfilerRecorder instance with a Profiler metric name pointer or other unsafe handles.
         * @param category Profiler category identifier.
         * @param statName Profiler marker or counter name pointer.
         * @param statNameLen Profiler marker or counter name length.
         * @param capacity Maximum amount of samples to be collected.
         * @param options Profiler recorder options.
         * @param marker Profiler marker instance.
         * @param statHandle Profiler recorder handle.
         */
        public constructor($marker: ProfilerMarker, $capacity?: number, $options?: ProfilerRecorderOptions);
        /**
         * Constructs ProfilerRecorder instance with a Profiler metric name pointer or other unsafe handles.
         * @param category Profiler category identifier.
         * @param statName Profiler marker or counter name pointer.
         * @param statNameLen Profiler marker or counter name length.
         * @param capacity Maximum amount of samples to be collected.
         * @param options Profiler recorder options.
         * @param marker Profiler marker instance.
         * @param statHandle Profiler recorder handle.
         */
        public constructor($statHandle: Unity_Profiling_LowLevel_Unsafe.ProfilerRecorderHandle, $capacity?: number, $options?: ProfilerRecorderOptions);
        /**
         * Initialize a new instance of ProfilerRecorder and start data collection.
         * @param category Profiler category.
         * @param statName Profiler marker or counter name.
         * @param capacity Maximum amount of samples to collect.
         * @param options ProfilerRecorder options.
         * @returns Returns new enabled recorder instance.
         */
        public static StartNew($category: ProfilerCategory, $statName: string, $capacity?: number, $options?: ProfilerRecorderOptions):ProfilerRecorder;
        /**
         * Initialize a new instance of ProfilerRecorder for ProfilerMarker and start data collection.
         * @param capacity Maximum amount of samples to be collected.
         * @param options Profiler recorder options.
         * @param marker Profiler marker instance.
         * @returns Returns new enabled recorder instance.
         */
        public static StartNew($marker: ProfilerMarker, $capacity?: number, $options?: ProfilerRecorderOptions):ProfilerRecorder;
        /**
         * Start data collection.
         */
        public Start():void;
        /**
         * Stops data collection.
         */
        public Stop():void;
        /**
         * Clears collected samples.
         */
        public Reset():void;
        /**
         * Gets sample data.
         */
        public GetSample($index: number):ProfilerRecorderSample;
        
        public CopyTo($outSamples: System_Collections_Generic.List$1<ProfilerRecorderSample>, $reset?: boolean):void;
        /**
         * Use to convert collected samples to an array.
         */
        public ToArray():ProfilerRecorderSample[];
        /**
         * Releases unmanaged instance of the ProfilerRecorder.
         */
        public Dispose():void;
        
        public get_Clone(): ProfilerRecorder;            
    }
    
}
declare module 'Unity.Profiling.ProfilerMarker' {

    import * as System from 'System';
        
    /**
     * Helper IDisposable struct for use with ProfilerMarker.Auto.
     */
    class AutoScope extends System.ValueType {
        
        public Dispose():void;
        
        public get_Clone(): AutoScope;            
    }
    
}
declare module 'Unity.Profiling.LowLevel' {

    import * as System from 'System';
        
    /**
     * Options for the Profiler metadata type.
     */
    enum ProfilerMarkerDataType { Int32 = 2, UInt32 = 3, Int64 = 4, UInt64 = 5, Float = 6, Double = 7, String16 = 9, Blob8 = 11 }
    /**
     * Profiler marker usage flags.
     */
    enum MarkerFlags { Default = 0, Script = 2, ScriptInvoke = 32, ScriptDeepProfiler = 64, AvailabilityEditor = 4, Warning = 16, Counter = 128 }
    
}
declare module 'Unity.Profiling.LowLevel.Unsafe' {

    import * as System from 'System';
    import * as System_Collections_Generic from 'System.Collections.Generic';
    import * as Unity_Profiling from 'Unity.Profiling';
    import * as Unity_Profiling_LowLevel from 'Unity.Profiling.LowLevel';
    import * as UnityEngine from 'UnityEngine';
    import * as Unity_Profiling_LowLevel_Unsafe_ProfilerUnsafeUtility from 'Unity.Profiling.LowLevel.Unsafe.ProfilerUnsafeUtility';
        
    /**
     * Gets the handle of a Profiler metric.
     */
    class ProfilerRecorderHandle extends System.ValueType {
        /**
         * Indicates if a handle is valid and can be used with ProfilerRecorder.
         */
        public get Valid(): boolean;
        /**
         * Gets description of Profiler marker or counter handle.
         */
        public static GetDescription($handle: ProfilerRecorderHandle):ProfilerRecorderDescription;
        
        public static GetAvailable($outRecorderHandleList: System_Collections_Generic.List$1<ProfilerRecorderHandle>):void;
        
        public get_Clone(): ProfilerRecorderHandle;            
    }
    /**
     * Gets the description of a Profiler metric.
     */
    class ProfilerRecorderDescription extends System.ValueType {
        /**
         * Gets the ProfilerCategory value of the Profiler metric.
         */
        public get Category(): Unity_Profiling.ProfilerCategory;
        /**
         * Profiler marker flags of the metric.
         */
        public get Flags(): Unity_Profiling_LowLevel.MarkerFlags;
        /**
         * Gets the data value type of the Profiler metric.
         */
        public get DataType(): Unity_Profiling_LowLevel.ProfilerMarkerDataType;
        /**
         * Gets the data unit type of the Profiler metric.
         */
        public get UnitType(): Unity_Profiling.ProfilerMarkerDataUnit;
        /**
         * Name length excluding null terminator.
         */
        public get NameUtf8Len(): number;
        /**
         * The name of the Profiler metric.
         */
        public get Name(): string;
        
                    
    }
    /**
     * Describes Profiler metadata parameter that can be associated with a sample.
     */
    class ProfilerMarkerData extends System.ValueType {
        /**
         * Metadata type.
         */
        public Type: number;
        /**
         * Size of the metadata value in bytes.
         */
        public Size: number;
        
                    
    }
    /**
     * Provides information about Profiler category.
     */
    class ProfilerCategoryDescription extends System.ValueType {
        /**
         * Profiler category identifier.
         */
        public Id: number;
        /**
         * Profiler category color.
         */
        public Color: UnityEngine.Color32;
        /**
         * Profiler category name length.
         */
        public NameUtf8Len: number;
        /**
         * Gets Profiler category name as string.
         */
        public get Name(): string;
        
                    
    }
    /**
     * Utility class which provides access to low level Profiler API.
     */
    class ProfilerUnsafeUtility extends System.Object {
        /**
         * Rendering system Profiler category.
         */
        public static CategoryRender: number;
        /**
         * Generic C# code Profiler category.
         */
        public static CategoryScripts: number;
        /**
         * UI Profiler category.
         */
        public static CategoryGUI: number;
        /**
         * Physics system Profiler category.
         */
        public static CategoryPhysics: number;
        /**
         * Animation Profiler category.
         */
        public static CategoryAnimation: number;
        /**
         * AI and NavMesh Profiler category.
         */
        public static CategoryAi: number;
        /**
         * Audio system Profiler category.
         */
        public static CategoryAudio: number;
        /**
         * Video system Profiler category.
         */
        public static CategoryVideo: number;
        /**
         * Particle system Profiler category.
         */
        public static CategoryParticles: number;
        /**
         * Global Illumination Profiler category.
         */
        public static CategoryLighting: number;
        /**
         * Networking system Profiler category.
         */
        public static CategoryNetwork: number;
        /**
         * Loading system Profiler category.
         */
        public static CategoryLoading: number;
        /**
         * Uncategorized Profiler category.
         */
        public static CategoryOther: number;
        /**
         * VR systen Profiler category.
         */
        public static CategoryVr: number;
        /**
         * Memory allocation Profiler category.
         */
        public static CategoryAllocation: number;
        /**
         * Internal Unity systems Profiler category.
         */
        public static CategoryInternal: number;
        /**
         * Input system Profiler category.
         */
        public static CategoryInput: number;
        /**
         * Virtual Texturing system Profiler category.
         */
        public static CategoryVirtualTexturing: number;
        /**
         * Gets Profiler timestamp.
         */
        public static get Timestamp(): bigint;
        /**
         * Gets conversion ratio from Profiler timestamp to nanoseconds.
         */
        public static get TimestampToNanosecondsConversionRatio(): Unity_Profiling_LowLevel_Unsafe_ProfilerUnsafeUtility.TimestampConversionRatio;
        /**
         * Retrieves Profiler category information such as name or color.
         * @param categoryId Profiler category identifier.
         * @returns Returns description of the category.
         */
        public static GetCategoryDescription($categoryId: number):ProfilerCategoryDescription;
        /**
         * Constructs a new Profiler marker handle for code instrumentation.
         * @param name A marker name.
         * @param categoryId A profiler category identifier.
         * @param flags The marker flags.
         * @param metadataCount The metadata parameters count, or 0 if no parameters are expected.
         * @param nameLen Marker name string length.
         * @returns Returns the marker native handle.
         */
        public static CreateMarker($name: string, $categoryId: number, $flags: Unity_Profiling_LowLevel.MarkerFlags, $metadataCount: number):System.IntPtr;
        /**
         * Set Profiler marker metadata name and type.
         * @param markerPtr Profiler marker handle.
         * @param index Metadata parameter index.
         * @param name Metadata parameter name.
         * @param type Metadata type. Must be one of ProfilerMarkerDataType values.
         * @param unit Metadata unit. Must be one of ProfilerMarkerDataUnit values.
         * @param nameLen Metadata parameter name length.
         */
        public static SetMarkerMetadata($markerPtr: System.IntPtr, $index: number, $name: string, $type: number, $unit: number):void;
        /**
         * Starts profiling a piece of code marked with a custom name that the markerPtr handle has defined.
         * @param markerPtr Profiler marker handle.
         */
        public static BeginSample($markerPtr: System.IntPtr):void;
        /**
         * End profiling a piece of code marked with a custom name defined by this instance of ProfilerMarker.
         * @param markerPtr Marker handle.
         */
        public static EndSample($markerPtr: System.IntPtr):void;
        /**
         * Create a new Profiler flow identifier.
         * @returns Returns flow identifier.
         */
        public static CreateFlow($categoryId: number):number;
        /**
         * Add flow event to a Profiler sample.
         * @param flowId Profiler flow identifier.
         * @param flowEventType Flow event type.
         */
        public static FlowEvent($flowId: number, $flowEventType: Unity_Profiling.ProfilerFlowEventType):void;
        
                    
    }
    
}
declare module 'Unity.Profiling.LowLevel.Unsafe.ProfilerUnsafeUtility' {

    import * as System from 'System';
        
    /**
     * Fraction that converts the Profiler timestamp to nanoseconds.
     */
    class TimestampConversionRatio extends System.ValueType {
        
        public Numerator: bigint;
        
        public Denominator: bigint;
        
        public get_Clone(): TimestampConversionRatio;            
    }
    
}
declare module 'Unity.Jobs' {

    import * as System from 'System';
    import * as Unity_Collections from 'Unity.Collections';
    import * as UnityEngine_Jobs from 'UnityEngine.Jobs';
        
    /**
     * Use IJob to schedule a single job that runs in parallel to other jobs and the main thread.
     */
    interface IJob {
        /**
         * Implement this method to perform work on a worker thread.
         */
        Execute():void;
        
                    
    }
    /**
     * Extension methods for Jobs using the IJob interface.
     */
    class IJobExtensions extends System.Object {
        
        public static Schedule<T>($jobData: T, $dependsOn?: JobHandle):JobHandle;
        
        public static Run<T>($jobData: T):void;
        
                    
    }
    /**
     * JobHandle.
     */
    class JobHandle extends System.ValueType {
        /**
         * Returns false if the task is currently running. Returns true if the task has completed.
         */
        public get IsCompleted(): boolean;
        /**
         * Ensures that the job has completed.
         */
        public Complete():void;
        /**
         * Ensures that all jobs have completed.
         */
        public static CompleteAll($job0: $Ref<JobHandle>, $job1: $Ref<JobHandle>):void;
        /**
         * Ensures that all jobs have completed.
         */
        public static CompleteAll($job0: $Ref<JobHandle>, $job1: $Ref<JobHandle>, $job2: $Ref<JobHandle>):void;
        
        public static CompleteAll($jobs: Unity_Collections.NativeArray$1<JobHandle>):void;
        /**
         * By default jobs are only put on a local queue when using Job Schedule functions, this actually makes them available to the worker threads to execute them.
         */
        public static ScheduleBatchedJobs():void;
        /**
         * Combines multiple dependencies into a single one.
         */
        public static CombineDependencies($job0: JobHandle, $job1: JobHandle):JobHandle;
        /**
         * Combines multiple dependencies into a single one.
         */
        public static CombineDependencies($job0: JobHandle, $job1: JobHandle, $job2: JobHandle):JobHandle;
        
        public static CombineDependencies($jobs: Unity_Collections.NativeArray$1<JobHandle>):JobHandle;
        
        public static CombineDependencies($jobs: Unity_Collections.NativeSlice$1<JobHandle>):JobHandle;
        /**
         * CheckFenceIsDependencyOrDidSyncFence.
         * @param jobHandle Job handle.
         * @param dependsOn Job handle dependency.
         * @returns Return value.
         */
        public static CheckFenceIsDependencyOrDidSyncFence($jobHandle: JobHandle, $dependsOn: JobHandle):boolean;
        
        public get_Clone(): JobHandle;            
    }
    /**
     * For jobs allow you to perform the same independent operation for each element of a native container or for a fixed number of iterations.
     * This Job type gives you the most flexibility over how you want your job scheduled.
     */
    interface IJobFor {
        /**
         * Implement this method to perform work against a specific iteration index.
         * @param index The index of the for loop at which to perform work.
         */
        Execute($index: number):void;
        
                    
    }
    /**
     * Extension methods for Jobs using the IJobFor.
     */
    class IJobForExtensions extends System.Object {
        
        public static Schedule<T>($jobData: T, $arrayLength: number, $dependency: JobHandle):JobHandle;
        
        public static ScheduleParallel<T>($jobData: T, $arrayLength: number, $innerloopBatchCount: number, $dependency: JobHandle):JobHandle;
        
        public static Run<T>($jobData: T, $arrayLength: number):void;
        
                    
    }
    /**
     * Parallel-for jobs allow you to perform the same independent operation for each element of a native container or for a fixed number of iterations.
     */
    interface IJobParallelFor {
        /**
         * Implement this method to perform work against a specific iteration index.
         * @param index The index of the Parallel for loop at which to perform work.
         */
        Execute($index: number):void;
        
                    
    }
    /**
     * Extension methods for Jobs using the IJobParallelFor.
     */
    class IJobParallelForExtensions extends System.Object {
        
        public static Schedule<T>($jobData: T, $arrayLength: number, $innerloopBatchCount: number, $dependsOn?: JobHandle):JobHandle;
        
        public static Run<T>($jobData: T, $arrayLength: number):void;
        
                    
    }
    
    interface T {
        /** @extension Unity.Jobs.IJobExtensions */
        Schedule<T>($dependsOn?: JobHandle):JobHandle;
        /** @extension Unity.Jobs.IJobExtensions */
        Run<T>():void;
        /** @extension Unity.Jobs.IJobForExtensions */
        Schedule<T>($arrayLength: number, $dependency: JobHandle):JobHandle;
        /** @extension Unity.Jobs.IJobForExtensions */
        ScheduleParallel<T>($arrayLength: number, $innerloopBatchCount: number, $dependency: JobHandle):JobHandle;
        /** @extension Unity.Jobs.IJobForExtensions */
        Run<T>($arrayLength: number):void;
        /** @extension Unity.Jobs.IJobParallelForExtensions */
        Schedule<T>($arrayLength: number, $innerloopBatchCount: number, $dependsOn?: JobHandle):JobHandle;
        /** @extension Unity.Jobs.IJobParallelForExtensions */
        Run<T>($arrayLength: number):void;
        /** @extension UnityEngine.Jobs.IJobParallelForTransformExtensions */
        Schedule<T>($transforms: TransformAccessArray, $dependsOn?: Unity_Jobs.JobHandle):Unity_Jobs.JobHandle;
        /** @extension UnityEngine.Jobs.IJobParallelForTransformExtensions */
        ScheduleReadOnly<T>($transforms: TransformAccessArray, $batchSize: number, $dependsOn?: Unity_Jobs.JobHandle):Unity_Jobs.JobHandle;
        /** @extension UnityEngine.Jobs.IJobParallelForTransformExtensions */
        RunReadOnly<T>($transforms: TransformAccessArray):void;
        
                    
    }
    
}
declare module 'Unity.Jobs.LowLevel.Unsafe' {

    import * as System from 'System';
    import * as Unity_Jobs from 'Unity.Jobs';
    import * as Unity_Jobs_LowLevel_Unsafe_JobsUtility from 'Unity.Jobs.LowLevel.Unsafe.JobsUtility';
        
    /**
     * JobHandle Unsafe Utilities.
     */
    class JobHandleUnsafeUtility extends System.Object {
        
                    
    }
    /**
     * All job interface types must be marked with the JobProducerType. This is used to compile the Execute method by the Burst ASM inspector.
     */
    class JobProducerTypeAttribute extends System.Attribute {
        /**
         * ProducerType is the type containing a static method named "Execute" method which is the method invokes by the job system.
         */
        public get ProducerType(): System.Type;
        /**
         * @param producerType The type containing a static method named "Execute" method which is the method invokes by the job system.
         */
        public constructor($producerType: System.Type);
        
                    
    }
    /**
     * Struct containing information about a range the job is allowed to work on.
     */
    class JobRanges extends System.ValueType {
        /**
         * Total iteration count.
         */
        public TotalIterationCount: number;
        
        public get_Clone(): JobRanges;            
    }
    /**
     * ScheduleMode options for scheduling a manage job.
     */
    enum ScheduleMode { Run = 0, Batched = 1, Parallel = 1, Single = 2 }
    /**
     * Static class containing functionality to create, run and debug jobs.
     */
    class JobsUtility extends System.Object {
        /**
         * Maximum job thread count.
         */
        public static MaxJobThreadCount: number;
        /**
         * Size of a cache line.
         */
        public static CacheLineSize: number;
        /**
         * Returns true if we this is called from inside of a C# job.
         */
        public static get IsExecutingJob(): boolean;
        /**
         * Enables and disables the job debugger at runtime. Note that currently the job debugger is only supported in the Editor. Thus this only has effect in the editor.
         */
        public static get JobDebuggerEnabled(): boolean;
        public static set JobDebuggerEnabled(value: boolean);
        /**
         * When disabled, forces jobs that have already been compiled with burst to run in mono instead. For example if you want to debug the C# jobs or just want to compare behaviour or performance.
         */
        public static get JobCompilerEnabled(): boolean;
        public static set JobCompilerEnabled(value: boolean);
        /**
         * Maximum number of worker threads available to the Unity JobQueue (Read Only).
         */
        public static get JobWorkerMaximumCount(): number;
        /**
         * Current number of worker threads available to the Unity JobQueue.
         */
        public static get JobWorkerCount(): number;
        public static set JobWorkerCount(value: number);
        /**
         * Returns the begin index and end index of the range.
         */
        public static GetJobRange($ranges: $Ref<JobRanges>, $jobIndex: number, $beginIndex: $Ref<number>, $endIndex: $Ref<number>):void;
        /**
         * Returns the work stealing range.
         * @returns Returns true if successful.
         */
        public static GetWorkStealingRange($ranges: $Ref<JobRanges>, $jobIndex: number, $beginIndex: $Ref<number>, $endIndex: $Ref<number>):boolean;
        /**
         * Schedule a single IJob.
         * @returns Returns a JobHandle to the newly created Job.
         */
        public static Schedule($parameters: $Ref<Unity_Jobs_LowLevel_Unsafe_JobsUtility.JobScheduleParameters>):Unity_Jobs.JobHandle;
        /**
         * Schedule a IJobParallelFor job.
         * @returns Returns a JobHandle to the newly created Job.
         */
        public static ScheduleParallelFor($parameters: $Ref<Unity_Jobs_LowLevel_Unsafe_JobsUtility.JobScheduleParameters>, $arrayLength: number, $innerloopBatchCount: number):Unity_Jobs.JobHandle;
        /**
         * Schedule an IJobParallelForTransform job.
         * @returns Returns a JobHandle to the newly created Job.
         */
        public static ScheduleParallelForTransform($parameters: $Ref<Unity_Jobs_LowLevel_Unsafe_JobsUtility.JobScheduleParameters>, $transfromAccesssArray: System.IntPtr):Unity_Jobs.JobHandle;
        /**
         * Schedule an IJobParallelForTransform job with read-only access to the transform data. This method provides better parallelization because it can read all transforms in parallel instead of just parallelizing across transforms in different hierarchies.
         * @returns Returns a JobHandle to the newly created Job.
         */
        public static ScheduleParallelForTransformReadOnly($parameters: $Ref<Unity_Jobs_LowLevel_Unsafe_JobsUtility.JobScheduleParameters>, $transfromAccesssArray: System.IntPtr, $innerloopBatchCount: number):Unity_Jobs.JobHandle;
        /**
         * Creates job reflection data.
         * @returns Returns pointer to internal JobReflectionData.
         */
        public static CreateJobReflectionData($type: System.Type, $managedJobFunction0: any, $managedJobFunction1?: any, $managedJobFunction2?: any):System.IntPtr;
        /**
         * Creates job reflection data.
         * @returns Returns pointer to internal JobReflectionData.
         */
        public static CreateJobReflectionData($wrapperJobType: System.Type, $userJobType: System.Type, $managedJobFunction0: any):System.IntPtr;
        /**
         * Reset JobWorkerCount to the Unity adjusted value.
         */
        public static ResetJobWorkerCount():void;
        
                    
    }
    /**
     * Determines what the job is used for (ParallelFor or a single job).
     */
    enum JobType { Single = 0, ParallelFor = 1 }
    
}
declare module 'Unity.Jobs.LowLevel.Unsafe.JobsUtility' {

    import * as System from 'System';
    import * as Unity_Jobs from 'Unity.Jobs';
        
    /**
     * Struct containing job parameters for scheduling.
     */
    class JobScheduleParameters extends System.ValueType {
        
        public Dependency: Unity_Jobs.JobHandle;
        
        public ScheduleMode: number;
        
        public ReflectionData: System.IntPtr;
        
        public JobDataPtr: System.IntPtr;
        
        public get_Clone(): JobScheduleParameters;            
    }
    
}
declare module 'Unity.Rendering.HybridV2' {

    import * as System from 'System';
    import * as Unity_Collections from 'Unity.Collections';
    import * as UnityEngine from 'UnityEngine';
        
    /**
     * Reflection data for a DOTS instancing constant buffer.
     */
    class DOTSInstancingCbuffer extends System.ValueType {
        /**
         * The value returned by Shader.PropertyToID for the name of this constant buffer.
         */
        public NameID: number;
        /**
         * The index of this constant buffer in the list of constant buffers returned by HybridV2ShaderReflection.GetDOTSInstancingCbuffers.
         */
        public CbufferIndex: number;
        /**
         * The size of this constant buffer in bytes.
         */
        public SizeBytes: number;
        
        public get_Clone(): DOTSInstancingCbuffer;            
    }
    /**
     * Describes the type of a DOTS instancing property.
     */
    enum DOTSInstancingPropertyType { Unknown = 0, Float = 1, Half = 2, Int = 3, Short = 4, Uint = 5, Bool = 6, Struct = 7 }
    /**
     * Reflection data for a DOTS instancing property.
     */
    class DOTSInstancingProperty extends System.ValueType {
        /**
         * The value returned by Shader.PropertyToID for the DOTS instancing metadata constant of this property.
         */
        public MetadataNameID: number;
        /**
         * The value returned by Shader.PropertyToID for the name of this property.
         */
        public ConstantNameID: number;
        /**
         * The index of the constant buffer that contains this property in the list of constant buffers returned by HybridV2ShaderReflection.GetDOTSInstancingCbuffers.
         */
        public CbufferIndex: number;
        /**
         * The offset of the metadata constant of this property in its DOTS instancing metadata constant buffer.
         */
        public MetadataOffset: number;
        /**
         * The size of this property in bytes.
         */
        public SizeBytes: number;
        /**
         * The type of this property.
         */
        public ConstantType: DOTSInstancingPropertyType;
        /**
         * The amount of columns or elements of this property if it's a matrix or a vector, respectively.
         */
        public Cols: number;
        /**
         * The amount of rows of this property if it's a matrix.
         */
        public Rows: number;
        
        public get_Clone(): DOTSInstancingProperty;            
    }
    /**
     * Contains methods for reading Hybrid Renderer specific reflection data from shaders.
     */
    class HybridV2ShaderReflection extends System.Object {
        
        public constructor();
        /**
         * Returns a monotonically increasing DOTS reflection data version number, which is incremented whenever a shader is loaded that contains DOTS instancing properties.
         * @returns DOTS reflection data version number.
         */
        public static GetDOTSReflectionVersionNumber():number;
        /**
         * Returns the list of detected Hybrid Renderer DOTS instancing constant buffers for the given shader.
         * @param shader Shader to get reflection data from.
         * @returns List of detected DOTS instancing constant buffers.
         */
        public static GetDOTSInstancingCbuffers($shader: UnityEngine.Shader):Unity_Collections.NativeArray$1<DOTSInstancingCbuffer>;
        /**
         * Returns the list of detected DOTS instancing properties for the given shader.
         * @param shader Shader to get reflection data from.
         * @returns List of detected DOTS instancing properties.
         */
        public static GetDOTSInstancingProperties($shader: UnityEngine.Shader):Unity_Collections.NativeArray$1<DOTSInstancingProperty>;
        
                    
    }
    
}
declare module 'Unity.IO.LowLevel.Unsafe' {

    import * as System from 'System';
    import * as Unity_Jobs from 'Unity.Jobs';
    import * as Unity_IO_LowLevel_Unsafe_AsyncReadManagerMetrics from 'Unity.IO.LowLevel.Unsafe.AsyncReadManagerMetrics';
    import * as System_Collections_Generic from 'System.Collections.Generic';
        
    /**
     * Describes the offset, size, and destination buffer of a single read operation.
     */
    class ReadCommand extends System.ValueType {
        /**
         * The offset where the read begins, within the file.
         */
        public Offset: bigint;
        /**
         * The size of the read in bytes.
         */
        public Size: bigint;
        
                    
    }
    /**
     * Subsystem tags for the read request, describing broad asset type or subsystem that triggered the read request.
     */
    enum AssetLoadingSubsystem { Other = 0, Texture = 1, VirtualTexture = 2, Mesh = 3, Audio = 4, Scripts = 5, EntitiesScene = 6, EntitiesStreamBinaryReader = 7 }
    /**
     * State of the read operation.
     */
    enum ReadStatus { Complete = 0, InProgress = 1, Failed = 2 }
    /**
     * The priority level attached to the AsyncReadManager read request.
     */
    enum Priority { PriorityLow = 0, PriorityHigh = 1 }
    /**
     * You can use this handle to query the status of an asynchronous read operation. Note: To avoid a memory leak, you must call Dispose.
     */
    class ReadHandle extends System.ValueType {
        /**
         * JobHandle that completes when the read operation completes.
         */
        public get JobHandle(): Unity_Jobs.JobHandle;
        /**
         * Current state of the read operation.
         */
        public get Status(): ReadStatus;
        /**
         * Check if the ReadHandle is valid.
         * @returns True if the ReadHandle is valid.
         */
        public IsValid():boolean;
        /**
         * Disposes the ReadHandle. Use this to free up internal resources for reuse.
         */
        public Dispose():void;
        
        public get_Clone(): ReadHandle;            
    }
    /**
     * With the AsyncReadManager, you can perform asynchronous I/O operations through Unity's virtual file system. You can perform these operations on any thread or job.
     */
    class AsyncReadManager extends System.Object {
        
                    
    }
    /**
     * The state of the read request at the time of retrieval of AsyncReadManagerMetrics.
     */
    enum ProcessingState { Unknown = 0, InQueue = 1, Reading = 2, Completed = 3, Failed = 4, Canceled = 5 }
    /**
     * The type of FileReadType|file read requested from the AsyncReadManager.
     */
    enum FileReadType { Sync = 0, Async = 1 }
    /**
     * Metrics for an individual read request.
     */
    class AsyncReadManagerRequestMetric extends System.ValueType {
        /**
         * The name of the asset being read.
         */
        public get AssetName(): string;
        /**
         * The filename the read request is reading from.
         */
        public get FileName(): string;
        /**
         * The offset of the read request from the start of the file, in bytes.
         */
        public get OffsetBytes(): bigint;
        /**
         * The size of the read request, in bytes.
         */
        public get SizeBytes(): bigint;
        /**
         * The of the asset being read in the read request.
         */
        public get AssetTypeId(): bigint;
        /**
         * Total number of bytes of the read request read so far.
         */
        public get CurrentBytesRead(): bigint;
        /**
         * The number of batch read commands contained in the read request.
         */
        public get BatchReadCount(): number;
        /**
         * Returns whether this read request contained batch read commands.
         */
        public get IsBatchRead(): boolean;
        /**
         * The ProcessingState|state of the read request at the time of retrieving the metrics.
         */
        public get State(): ProcessingState;
        /**
         * The FileReadType|read type (sync or async) of the read request.
         */
        public get ReadType(): FileReadType;
        /**
         * The Priority|priority level of the read request.
         */
        public get PriorityLevel(): Priority;
        /**
         * The AssetLoadingSubsystem|Subsystem tag assigned to the read operation.
         */
        public get Subsystem(): AssetLoadingSubsystem;
        /**
         * The time at which the read request was made, in microseconds elapsed since application startup.
         */
        public get RequestTimeMicroseconds(): number;
        /**
         * The amount of time the read request waited in the AsyncReadManager queue, in microseconds.
         */
        public get TimeInQueueMicroseconds(): number;
        /**
         * The total time in microseconds from the read request being added until its completion, or the time of metrics retrieval, depending whether the read has completed or not.
         */
        public get TotalTimeMicroseconds(): number;
        
                    
    }
    /**
     * Manages the recording and retrieval of metrics from the AsyncReadManager.
     */
    class AsyncReadManagerMetrics extends System.Object {
        /**
         * Reports whether the metrics system for the AsyncReadManager is currently recording data.
         * @returns True, if the metrics system of the AsyncReadManager is currently recording data; false, otherwise.
         */
        public static IsEnabled():boolean;
        /**
         * Clears the metrics for all completed requests, including failed and canceled requests.
         */
        public static ClearCompletedMetrics():void;
        /**
         * Returns the current AsyncReadManager metrics.
         * @param flags Flags to control the behaviour, including clearing the underlying completed metrics after reading.
         * @param filters (Optional) The AsyncReadManagerMetricsFilters|filters to control the data returned.
         * @returns Array of AsyncReadManagerRequestMetric|read request metrics currently stored in the AsyncReadManager, which can be filtered by passing AsyncReadManagerMetricsFilters.
         */
        public static GetMetrics($filters: AsyncReadManagerMetricsFilters, $flags: Unity_IO_LowLevel_Unsafe_AsyncReadManagerMetrics.Flags):AsyncReadManagerRequestMetric[];
        
        public static GetMetrics($outMetrics: System_Collections_Generic.List$1<AsyncReadManagerRequestMetric>, $filters: AsyncReadManagerMetricsFilters, $flags: Unity_IO_LowLevel_Unsafe_AsyncReadManagerMetrics.Flags):void;
        /**
         * Returns the current AsyncReadManager metrics.
         * @param flags Flags to control the behaviour, including clearing the underlying completed metrics after reading.
         * @param filters (Optional) The AsyncReadManagerMetricsFilters|filters to control the data returned.
         * @returns Array of AsyncReadManagerRequestMetric|read request metrics currently stored in the AsyncReadManager, which can be filtered by passing AsyncReadManagerMetricsFilters.
         */
        public static GetMetrics($flags: Unity_IO_LowLevel_Unsafe_AsyncReadManagerMetrics.Flags):AsyncReadManagerRequestMetric[];
        
        public static GetMetrics($outMetrics: System_Collections_Generic.List$1<AsyncReadManagerRequestMetric>, $flags: Unity_IO_LowLevel_Unsafe_AsyncReadManagerMetrics.Flags):void;
        /**
         * Begin recording metrics data for AsyncReadManager read operations.
         */
        public static StartCollectingMetrics():void;
        /**
         * Stop recording metrics data for AsyncReadManager read operations.
         */
        public static StopCollectingMetrics():void;
        /**
         * Gets a summary of the metrics collected for AsyncReadManager read operations since you started data collection or last cleared the metrics data.
         * @param flags Flags to control the behavior, including clearing the underlying completed metrics after reading.
         * @returns A summary of the current metrics data.
         */
        public static GetCurrentSummaryMetrics($flags: Unity_IO_LowLevel_Unsafe_AsyncReadManagerMetrics.Flags):AsyncReadManagerSummaryMetrics;
        /**
         * Gets a filtered summary of the metrics collected for AsyncReadManager read operations since you started data collection or last cleared the metrics data.
         * @param metricsFilters The filters to apply to the metrics before calculating the summary.
         * @param flags Flags to control the behavior, including clearing the underlying completed metrics after reading.
         * @returns A summary of the current metric data, filtered by the specified metricsFilters.
         */
        public static GetCurrentSummaryMetrics($metricsFilters: AsyncReadManagerMetricsFilters, $flags: Unity_IO_LowLevel_Unsafe_AsyncReadManagerMetrics.Flags):AsyncReadManagerSummaryMetrics;
        /**
         * Summarizes an array containing AsyncReadManagerRequestMetric records.
         * @param metrics Array of previously collected AsyncReadManagerRequestMetrics.
         * @returns Calculated summary of the given metrics.
         */
        public static GetSummaryOfMetrics($metrics: AsyncReadManagerRequestMetric[]):AsyncReadManagerSummaryMetrics;
        
        public static GetSummaryOfMetrics($metrics: System_Collections_Generic.List$1<AsyncReadManagerRequestMetric>):AsyncReadManagerSummaryMetrics;
        /**
         * Summarizes AsyncReadManagerRequestMetric records that match the specified filter.
         * @param metrics List of previously collected AsyncReadManagerRequestMetrics.
         * @param metricsFilters AsyncReadManagerMetricsFilters|Filters to apply to the data used in calculating the summary.
         * @returns Calculated summary of given metrics that match the filters.
         */
        public static GetSummaryOfMetrics($metrics: AsyncReadManagerRequestMetric[], $metricsFilters: AsyncReadManagerMetricsFilters):AsyncReadManagerSummaryMetrics;
        
        public static GetSummaryOfMetrics($metrics: System_Collections_Generic.List$1<AsyncReadManagerRequestMetric>, $metricsFilters: AsyncReadManagerMetricsFilters):AsyncReadManagerSummaryMetrics;
        /**
         * Returns the amount of data (in bytes) read through systems other than the AsyncReadManager.
         * @param emptyAfterRead Set to true to reset the underlying data counter to zero after calling this function. Set to false if you want each call to this function to return the running, cumulative total.
         * @returns Number of bytes of data read through systems other than the AsyncReadManager since you started metrics collection or you cleared this data counter by setting emptyAfterRead to true.
         */
        public static GetTotalSizeOfNonASRMReadsBytes($emptyAfterRead: boolean):bigint;
        
                    
    }
    /**
     * Defines a filter for selecting specific categories of data when summarizing AsyncReadManager metrics.
     */
    class AsyncReadManagerMetricsFilters extends System.Object {
        /**
         * Constructor for an instance of the Summary Metrics Filters, used to filter the metrics data that is included in the calculation of a summary.
         * @param typeID The YAML Class ID for the asset type to include in the summary calculations. See the page.
         * @param state The Processing State to include in the summary calculations.
         * @param readType The type of file read (async or sync) to include in the summary calculations.
         * @param priorityLevel The priority level to include in the summary calculations.
         * @param subsystem The Subsystem 'tag' to include in the summary calculations.
         */
        public constructor();
        /**
         * Constructor for an instance of the Summary Metrics Filters, used to filter the metrics data that is included in the calculation of a summary.
         * @param typeID The YAML Class ID for the asset type to include in the summary calculations. See the page.
         * @param state The Processing State to include in the summary calculations.
         * @param readType The type of file read (async or sync) to include in the summary calculations.
         * @param priorityLevel The priority level to include in the summary calculations.
         * @param subsystem The Subsystem 'tag' to include in the summary calculations.
         */
        public constructor($typeID: bigint);
        /**
         * Constructor for an instance of the Summary Metrics Filters, used to filter the metrics data that is included in the calculation of a summary.
         * @param typeID The YAML Class ID for the asset type to include in the summary calculations. See the page.
         * @param state The Processing State to include in the summary calculations.
         * @param readType The type of file read (async or sync) to include in the summary calculations.
         * @param priorityLevel The priority level to include in the summary calculations.
         * @param subsystem The Subsystem 'tag' to include in the summary calculations.
         */
        public constructor($state: ProcessingState);
        /**
         * Constructor for an instance of the Summary Metrics Filters, used to filter the metrics data that is included in the calculation of a summary.
         * @param typeID The YAML Class ID for the asset type to include in the summary calculations. See the page.
         * @param state The Processing State to include in the summary calculations.
         * @param readType The type of file read (async or sync) to include in the summary calculations.
         * @param priorityLevel The priority level to include in the summary calculations.
         * @param subsystem The Subsystem 'tag' to include in the summary calculations.
         */
        public constructor($readType: FileReadType);
        /**
         * Constructor for an instance of the Summary Metrics Filters, used to filter the metrics data that is included in the calculation of a summary.
         * @param typeID The YAML Class ID for the asset type to include in the summary calculations. See the page.
         * @param state The Processing State to include in the summary calculations.
         * @param readType The type of file read (async or sync) to include in the summary calculations.
         * @param priorityLevel The priority level to include in the summary calculations.
         * @param subsystem The Subsystem 'tag' to include in the summary calculations.
         */
        public constructor($priorityLevel: Priority);
        /**
         * Constructor for an instance of the Summary Metrics Filters, used to filter the metrics data that is included in the calculation of a summary.
         * @param typeID The YAML Class ID for the asset type to include in the summary calculations. See the page.
         * @param state The Processing State to include in the summary calculations.
         * @param readType The type of file read (async or sync) to include in the summary calculations.
         * @param priorityLevel The priority level to include in the summary calculations.
         * @param subsystem The Subsystem 'tag' to include in the summary calculations.
         */
        public constructor($subsystem: AssetLoadingSubsystem);
        /**
         * Constructor for an instance of the Summary Metrics Filters, used to filter the metrics data that is included in the calculation of a summary.
         * @param typeIDs An array of all the to include in the summary calculations.
         * @param states An array of all the ProcessingStates to include in the summary calculations.
         * @param readTypes An array of all the FileReadTypes to include in the summary calculations. As there are only two options, this is generally unnecesary.
         * @param priorityLevels An array of all the Priority levels to include in the summary calculations. As there are only two options, this is generally unnecesary.
         * @param subsystems An array of all the Subsystem 'tags' to include in the summary calculations.
         */
        public constructor($typeIDs: bigint[]);
        /**
         * Constructor for an instance of the Summary Metrics Filters, used to filter the metrics data that is included in the calculation of a summary.
         * @param typeIDs An array of all the to include in the summary calculations.
         * @param states An array of all the ProcessingStates to include in the summary calculations.
         * @param readTypes An array of all the FileReadTypes to include in the summary calculations. As there are only two options, this is generally unnecesary.
         * @param priorityLevels An array of all the Priority levels to include in the summary calculations. As there are only two options, this is generally unnecesary.
         * @param subsystems An array of all the Subsystem 'tags' to include in the summary calculations.
         */
        public constructor($states: ProcessingState[]);
        /**
         * Constructor for an instance of the Summary Metrics Filters, used to filter the metrics data that is included in the calculation of a summary.
         * @param typeIDs An array of all the to include in the summary calculations.
         * @param states An array of all the ProcessingStates to include in the summary calculations.
         * @param readTypes An array of all the FileReadTypes to include in the summary calculations. As there are only two options, this is generally unnecesary.
         * @param priorityLevels An array of all the Priority levels to include in the summary calculations. As there are only two options, this is generally unnecesary.
         * @param subsystems An array of all the Subsystem 'tags' to include in the summary calculations.
         */
        public constructor($readTypes: FileReadType[]);
        /**
         * Constructor for an instance of the Summary Metrics Filters, used to filter the metrics data that is included in the calculation of a summary.
         * @param typeIDs An array of all the to include in the summary calculations.
         * @param states An array of all the ProcessingStates to include in the summary calculations.
         * @param readTypes An array of all the FileReadTypes to include in the summary calculations. As there are only two options, this is generally unnecesary.
         * @param priorityLevels An array of all the Priority levels to include in the summary calculations. As there are only two options, this is generally unnecesary.
         * @param subsystems An array of all the Subsystem 'tags' to include in the summary calculations.
         */
        public constructor($priorityLevels: Priority[]);
        /**
         * Constructor for an instance of the Summary Metrics Filters, used to filter the metrics data that is included in the calculation of a summary.
         * @param typeIDs An array of all the to include in the summary calculations.
         * @param states An array of all the ProcessingStates to include in the summary calculations.
         * @param readTypes An array of all the FileReadTypes to include in the summary calculations. As there are only two options, this is generally unnecesary.
         * @param priorityLevels An array of all the Priority levels to include in the summary calculations. As there are only two options, this is generally unnecesary.
         * @param subsystems An array of all the Subsystem 'tags' to include in the summary calculations.
         */
        public constructor($subsystems: AssetLoadingSubsystem[]);
        /**
         * Constructor for an instance of the Summary Metrics Filters, used to filter the metrics data that is included in the calculation of a summary.
         * @param typeIDs An array of all the to include in the summary calculations.
         * @param states An array of all the ProcessingStates to include in the summary calculations.
         * @param readTypes An array of all the FileReadTypes to include in the summary calculations. As there are only two options, this is generally unnecesary.
         * @param priorityLevels An array of all the Priority levels to include in the summary calculations. As there are only two options, this is generally unnecesary.
         * @param subsystems An array of all the Subsystem 'tags' to include in the summary calculations.
         */
        public constructor($typeIDs: bigint[], $states: ProcessingState[], $readTypes: FileReadType[], $priorityLevels: Priority[], $subsystems: AssetLoadingSubsystem[]);
        /**
         * Set TypeID filters on an existing SummaryMetricsFilters instance.
         * @param _typeID  to filter by. Summary will include reads that have this type ID only.
         * @param _typeIDs Array of to filter by. Summary will include reads that have any of these Type IDs.
         */
        public SetTypeIDFilter($_typeIDs: bigint[]):void;
        /**
         * Set ProcessingState filters on an existing SummaryMetricsFilters instance.
         * @param _state ProcessingState to filter by. Summary will include reads that have this state only.
         * @param _states Array of ProcessingState|ProcessingStates to filter by. Summary will include reads that have any of these states.
         */
        public SetStateFilter($_states: ProcessingState[]):void;
        /**
         * Set FileReadType filters on an existing SummaryMetricsFilters instance.
         * @param _readType FileReadType to filter by. Summary will include reads that had this read type only.
         * @param _readTypes Array of FileReadType|FileReadTypes to filter by. Summary will include reads that have any of these read types.
         */
        public SetReadTypeFilter($_readTypes: FileReadType[]):void;
        /**
         * Set Priority filters on an existing SummaryMetricsFilters instance.
         * @param _priorityLevel Priority level to filter by. Summary will include reads that had this priority level only.
         * @param _priorityLevels Array of priority levels to filter by. Summary will include reads that have any of these priority levels.
         */
        public SetPriorityFilter($_priorityLevels: Priority[]):void;
        /**
         * Set AssetLoadingSubsystem filters on an existing SummaryMetricsFilters instance.
         * @param _subsystem AssetLoadingSubsystem to filter by. Summary will include reads that have this subsystem tag only.
         * @param _subsystems Array of AssetLoadingSubsystem|AssetLoadingSubsystems to filter by. Summary will include reads that have any of these subsystem tags.
         */
        public SetSubsystemFilter($_subsystems: AssetLoadingSubsystem[]):void;
        /**
         * Set TypeID filters on an existing SummaryMetricsFilters instance.
         * @param _typeID  to filter by. Summary will include reads that have this type ID only.
         * @param _typeIDs Array of to filter by. Summary will include reads that have any of these Type IDs.
         */
        public SetTypeIDFilter($_typeID: bigint):void;
        /**
         * Set ProcessingState filters on an existing SummaryMetricsFilters instance.
         * @param _state ProcessingState to filter by. Summary will include reads that have this state only.
         * @param _states Array of ProcessingState|ProcessingStates to filter by. Summary will include reads that have any of these states.
         */
        public SetStateFilter($_state: ProcessingState):void;
        /**
         * Set FileReadType filters on an existing SummaryMetricsFilters instance.
         * @param _readType FileReadType to filter by. Summary will include reads that had this read type only.
         * @param _readTypes Array of FileReadType|FileReadTypes to filter by. Summary will include reads that have any of these read types.
         */
        public SetReadTypeFilter($_readType: FileReadType):void;
        /**
         * Set Priority filters on an existing SummaryMetricsFilters instance.
         * @param _priorityLevel Priority level to filter by. Summary will include reads that had this priority level only.
         * @param _priorityLevels Array of priority levels to filter by. Summary will include reads that have any of these priority levels.
         */
        public SetPriorityFilter($_priorityLevel: Priority):void;
        /**
         * Set AssetLoadingSubsystem filters on an existing SummaryMetricsFilters instance.
         * @param _subsystem AssetLoadingSubsystem to filter by. Summary will include reads that have this subsystem tag only.
         * @param _subsystems Array of AssetLoadingSubsystem|AssetLoadingSubsystems to filter by. Summary will include reads that have any of these subsystem tags.
         */
        public SetSubsystemFilter($_subsystem: AssetLoadingSubsystem):void;
        /**
         * Remove the TypeID filters from an existing SummaryMetricsFilters instance.
         */
        public RemoveTypeIDFilter():void;
        /**
         * Remove the State filters from an existing SummaryMetricsFilters instance.
         */
        public RemoveStateFilter():void;
        /**
         * Remove the ReadType filters from an existing SummaryMetricsFilters instance.
         */
        public RemoveReadTypeFilter():void;
        /**
         * Remove the Priority filters from an existing SummaryMetricsFilters instance.
         */
        public RemovePriorityFilter():void;
        /**
         * Remove the Subsystem filters from an existing SummaryMetricsFilters instance.
         */
        public RemoveSubsystemFilter():void;
        /**
         * Clears all the filters on an existing AsyncReadManagerMetricsFilters instance.
         */
        public ClearFilters():void;
        
                    
    }
    /**
     * A summary of the metrics collected for AsyncReadManager read operations.
     */
    class AsyncReadManagerSummaryMetrics extends System.Object {
        /**
         * The total number of bytes read in the metrics included in the summary calculation.
         */
        public get TotalBytesRead(): bigint;
        /**
         * The mean rate of reading of data (bandwidth), in Mbps, for read request metrics included in the summary calculation.
         */
        public get AverageBandwidthMBPerSecond(): number;
        /**
         * The mean size of data read, in bytes, for read request metrics included in the summary calculation.
         */
        public get AverageReadSizeInBytes(): number;
        /**
         * The mean time taken from request to the start of reading, in microseconds, for read request metrics included in the summary calculation.
         */
        public get AverageWaitTimeMicroseconds(): number;
        /**
         * The mean time taken for reading (excluding queue time), in microseconds, for read request metrics included in the summary calculation.
         */
        public get AverageReadTimeMicroseconds(): number;
        /**
         * The mean time taken from request to completion, in microseconds, for completed read request metrics included in the summary calculation.
         */
        public get AverageTotalRequestTimeMicroseconds(): number;
        /**
         * The mean rate of request throughput, in Mbps, for read request metrics included in the summary calculation.
         */
        public get AverageThroughputMBPerSecond(): number;
        /**
         * The longest time spent waiting of metrics included in the summary calculation, in microseconds.
         */
        public get LongestWaitTimeMicroseconds(): number;
        /**
         * The longest read time (not including time in queue) included in the summary calculation in microseconds.
         */
        public get LongestReadTimeMicroseconds(): number;
        /**
         * The for the longest read included in the summary calculation.
         */
        public get LongestReadAssetType(): bigint;
        /**
         * The for the longest wait time included in the summary calculation.
         */
        public get LongestWaitAssetType(): bigint;
        /**
         * The Subsystem tag for the longest read included in the summary calculation.
         */
        public get LongestReadSubsystem(): AssetLoadingSubsystem;
        /**
         * The Subsystem tag for the longest wait time included in the summary calculation.
         */
        public get LongestWaitSubsystem(): AssetLoadingSubsystem;
        /**
         * The total number of in progress requests in the metrics included in the summary calculation.
         */
        public get NumberOfInProgressRequests(): number;
        /**
         * The total number of completed requests in the metrics included in the summary calculation.
         */
        public get NumberOfCompletedRequests(): number;
        /**
         * The total number of failed requests in the metrics included in the summary calculation.
         */
        public get NumberOfFailedRequests(): number;
        /**
         * The total number of waiting requests in the metrics included in the summary calculation.
         */
        public get NumberOfWaitingRequests(): number;
        /**
         * The total number of canceled requests in the metrics included in the summary calculation.
         */
        public get NumberOfCanceledRequests(): number;
        /**
         * The total number of read requests included in the summary calculation.
         */
        public get TotalNumberOfRequests(): number;
        /**
         * The total number of cached reads (so read time was zero) in the metrics included in the summary calculation.
         */
        public get NumberOfCachedReads(): number;
        /**
         * The total number of Async reads in the metrics included in the summary calculation.
         */
        public get NumberOfAsyncReads(): number;
        /**
         * The total number of Sync reads in the metrics included in the summary calculation.
         */
        public get NumberOfSyncReads(): number;
        
        public constructor();
        
                    
    }
    /**
     * Class that provides access to some of the Unity low level virtual file system APIs.
     */
    class VirtualFileSystem extends System.Object {
        /**
         * This method looks up the virtual file entry specified, and returns the details of that file within the file on the local filesystem.
         * @param vfsFileName Virtual file entry to find.
         * @param localFileName Out parameter containing the file on the local filesystem.
         * @param localFileOffset Out parameter containing the offset inside of file on the local filesystem.
         * @param localFileSize Out parameter containing the size inside of file on the local filesystem.
         * @returns Details were successfully found.
         */
        public static GetLocalFileSystemName($vfsFileName: string, $localFileName: $Ref<string>, $localFileOffset: $Ref<bigint>, $localFileSize: $Ref<bigint>):boolean;
        
                    
    }
    
}
declare module 'Unity.IO.LowLevel.Unsafe.AsyncReadManagerMetrics' {

    import * as System from 'System';
        
    /**
     * Flags controlling the behaviour of AsyncReadManagerMetrics.GetMetrics and AsyncReadManagerMetrics.GetCurrentSummaryMetrics.
     */
    enum Flags { None = 0, ClearOnRead = 1 }
    
}
declare module 'Unity.Collections.LowLevel.Unsafe' {

    import * as System from 'System';
    import * as Unity_Jobs from 'Unity.Jobs';
    import * as Unity_Collections from 'Unity.Collections';
    import * as System_Reflection from 'System.Reflection';
    import * as RootNamespace from 'RootNamespace';
        
    /**
     * Allows you to create your own custom native container.
     */
    class NativeContainerAttribute extends System.Attribute {
        
        public constructor();
        
                    
    }
    /**
     * NativeContainerIsReadOnlyAttribute.
     */
    class NativeContainerIsReadOnlyAttribute extends System.Attribute {
        
        public constructor();
        
                    
    }
    /**
     * NativeContainerIsAtomicWriteOnlyAttribute.
     */
    class NativeContainerIsAtomicWriteOnlyAttribute extends System.Attribute {
        
        public constructor();
        
                    
    }
    /**
     * NativeContainerSupportsMinMaxWriteRestrictionAttribute.
     */
    class NativeContainerSupportsMinMaxWriteRestrictionAttribute extends System.Attribute {
        
        public constructor();
        
                    
    }
    /**
     * NativeContainerSupportsDeallocateOnJobCompletionAttribute.
     */
    class NativeContainerSupportsDeallocateOnJobCompletionAttribute extends System.Attribute {
        
        public constructor();
        
                    
    }
    /**
     * NativeContainerSupportsDeferredConvertListToArray.
     */
    class NativeContainerSupportsDeferredConvertListToArray extends System.Attribute {
        
        public constructor();
        
                    
    }
    /**
     * This attribute can inject a worker thread index into an int on the job struct. This is usually used in the implementation of atomic containers. The index is guaranteed to be unique to any other job that might be running in parallel.
     */
    class NativeSetThreadIndexAttribute extends System.Attribute {
        
        public constructor();
        
                    
    }
    /**
     * Used in conjunction with the ReadOnlyAttribute, WriteAccessRequiredAttribute lets you specify which struct method and property require write access to be invoked.
     */
    class WriteAccessRequiredAttribute extends System.Attribute {
        
        public constructor();
        
                    
    }
    /**
     * By default unsafe Pointers are not allowed to be used in a job since it is not possible for the Job Debugger to gurantee race condition free behaviour. This attribute lets you explicitly disable the restriction on a job.
     */
    class NativeDisableUnsafePtrRestrictionAttribute extends System.Attribute {
        
        public constructor();
        
                    
    }
    /**
     * By default native containers are tracked by the safety system to avoid race conditions. The safety system encapsulates the best practices and catches many race condition bugs from the start.
     */
    class NativeDisableContainerSafetyRestrictionAttribute extends System.Attribute {
        
        public constructor();
        
                    
    }
    /**
     * When this attribute is applied to a field in a job struct, the managed reference to the class will be set to null on the copy of the job struct that is passed to the job.
     */
    class NativeSetClassTypeToNullOnScheduleAttribute extends System.Attribute {
        
        public constructor();
        
                    
    }
    /**
     * EnforceJobResult.
     */
    enum EnforceJobResult { AllJobsAlreadySynced = 0, DidSyncRunningJobs = 1, HandleWasAlreadyDeallocated = 2 }
    /**
     * Enumeration of AtomicSafetyHandle errors.
     */
    enum AtomicSafetyErrorType { Deallocated = 0, DeallocatedFromJob = 1, NotAllocatedFromJob = 2 }
    /**
     * AtomicSafetyHandle is used by the job system to provide validation and full safety.
     */
    class AtomicSafetyHandle extends System.ValueType {
        /**
         * Creates a new AtomicSafetyHandle that is valid until AtomicSafetyHandle.Release is called.
         * @returns Safety handle.
         */
        public static Create():AtomicSafetyHandle;
        /**
         * Returns a single shared handle, that can be shared by for example NativeSlice pointing to stack memory.
         * @returns Safety handle.
         */
        public static GetTempUnsafePtrSliceHandle():AtomicSafetyHandle;
        /**
         * Returns the safety handle which should be used for all temp memory allocations in this temp memory scope. All temp memory allocations share the same safety handle since they are automatically disposed of at the same time.
         * @returns The safety handle for temp memory allocations in the current scope.
         */
        public static GetTempMemoryHandle():AtomicSafetyHandle;
        /**
         * Checks if an AtomicSafetyHandle is the temp memory safety handle for the currently active temp memory scope.
         * @param handle Safety handle.
         * @returns True if the safety handle is the temp memory handle for the current scope.
         */
        public static IsTempMemoryHandle($handle: AtomicSafetyHandle):boolean;
        /**
         * Releases a previously created AtomicSafetyHandle.
         * @param handle Safety handle.
         */
        public static Release($handle: AtomicSafetyHandle):void;
        /**
         * Marks the AtomicSafetyHandle so that it cannot be disposed of.
         * @param handle Safety handle.
         */
        public static PrepareUndisposable($handle: $Ref<AtomicSafetyHandle>):void;
        /**
         * Switches the AtomicSafetyHandle to the secondary version number.
         * @param handle Safety handle.
         */
        public static UseSecondaryVersion($handle: $Ref<AtomicSafetyHandle>):void;
        /**
         * Switches the AtomicSafetyHandle to the secondary version number.
         * @param handle Safety handle.
         * @param allowWriting Allow writing.
         */
        public static SetAllowSecondaryVersionWriting($handle: AtomicSafetyHandle, $allowWriting: boolean):void;
        /**
         * Lets you bump the secondary version when scheduling a job that has write access to the atomic safety handle.
         * @param handle Safety handle.
         * @param value Use true to bump secondary version on schedule.
         */
        public static SetBumpSecondaryVersionOnScheduleWrite($handle: AtomicSafetyHandle, $value: boolean):void;
        /**
         * Lets you prevent read or write access on the atomic safety handle.
         * @param handle Safety handle.
         * @param allowReadWriteAccess Use false to disallow read or write access, or true otherwise.
         */
        public static SetAllowReadOrWriteAccess($handle: AtomicSafetyHandle, $allowReadWriteAccess: boolean):void;
        /**
         * Returns true if the AtomicSafetyHandle is configured to allow reading or writing.
         * @param handle Safety handle.
         * @returns True if the AtomicSafetyHandle is configured to allow reading or writing, false otherwise.
         */
        public static GetAllowReadOrWriteAccess($handle: AtomicSafetyHandle):boolean;
        /**
         * Performs CheckWriteAndThrow and then bumps the secondary version.
         * @param handle Safety handle.
         */
        public static CheckWriteAndBumpSecondaryVersion($handle: AtomicSafetyHandle):void;
        /**
         * Waits for all jobs running against this AtomicSafetyHandle to complete.
         * @param handle Safety handle.
         * @returns Result.
         */
        public static EnforceAllBufferJobsHaveCompleted($handle: AtomicSafetyHandle):EnforceJobResult;
        /**
         * Waits for all jobs running against this AtomicSafetyHandle to complete and then releases the atomic safety handle.
         * @param handle Safety handle.
         * @returns Result.
         */
        public static EnforceAllBufferJobsHaveCompletedAndRelease($handle: AtomicSafetyHandle):EnforceJobResult;
        /**
         * Waits for all jobs running against this AtomicSafetyHandle to complete and then disables the read and write access on this atomic safety handle.
         * @param handle Safety handle.
         * @returns Result.
         */
        public static EnforceAllBufferJobsHaveCompletedAndDisableReadWrite($handle: AtomicSafetyHandle):EnforceJobResult;
        /**
         * Checks if the handle can be deallocated. Throws an exception if it has already been destroyed or a job is currently accessing the data.
         * @param handle Safety handle.
         */
        public static CheckDeallocateAndThrow($handle: AtomicSafetyHandle):void;
        /**
         * CheckGetSecondaryDataPointerAndThrow.
         * @param handle Safety handle.
         */
        public static CheckGetSecondaryDataPointerAndThrow($handle: AtomicSafetyHandle):void;
        /**
         * Fetch the job handles of all jobs reading from the safety handle.
         * @param handle The atomic safety handle to return readers for.
         * @param maxCount The maximum number of handles to be written to the output array.
         * @param output A buffer where the job handles will be written.
         * @returns The actual number of readers on the handle, which can be greater than the maximum count provided.
         */
        public static GetReaderArray($handle: AtomicSafetyHandle, $maxCount: number, $output: System.IntPtr):number;
        /**
         * Return the writer (if any) on an atomic safety handle.
         * @param handle Safety handle.
         * @returns The job handle of the writer.
         */
        public static GetWriter($handle: AtomicSafetyHandle):Unity_Jobs.JobHandle;
        /**
         * Checks if the handle can be read from. Throws an exception if already destroyed or a job is currently writing to the data.
         * @param handle Safety handle.
         */
        public static CheckReadAndThrow($handle: AtomicSafetyHandle):void;
        /**
         * Checks if the handle can be written to. Throws an exception if already destroyed or a job is currently reading or writing to the data.
         * @param handle Safety handle.
         */
        public static CheckWriteAndThrow($handle: AtomicSafetyHandle):void;
        /**
         * Checks if the handle is still valid and throws an exception if it is already destroyed.
         * @param handle Safety handle.
         */
        public static CheckExistsAndThrow($handle: AtomicSafetyHandle):void;
        /**
         * Return the name of the specified reading job.
         * @param handle Safety handle.
         * @param readerIndex Index of the reader.
         * @returns The debug name of the reader.
         */
        public static GetReaderName($handle: AtomicSafetyHandle, $readerIndex: number):string;
        /**
         * Return the debug name of the current writer on an atomic safety handle.
         * @param handle Safety handle.
         * @returns Name of the writer, if any.
         */
        public static GetWriterName($handle: AtomicSafetyHandle):string;
        /**
         * Allocates a new static safety ID, to store information for the provided type T.
         */
        public static NewStaticSafetyId<T>():number;
        /**
         * Assigns the provided static safety ID to an AtomicSafetyHandle. The ID's owner type name and any custom error messages are used by the job debugger when reporting errors involving the target handle.
         * @param handle The AtomicSafetyHandle to modify.
         * @param staticSafetyId The static safety ID to associate with the provided handle. This ID must have been allocated with NewStaticSafetyId.
         */
        public static SetStaticSafetyId($handle: $Ref<AtomicSafetyHandle>, $staticSafetyId: number):void;
        
        public get_Clone(): AtomicSafetyHandle;            
    }
    /**
     * DisposeSentinel is used to automatically detect memory leaks.
     */
    class DisposeSentinel extends System.Object {
        /**
         * Releases the AtomicSafetyHandle and clears the DisposeSentinel.
         * @param safety The AtomicSafetyHandle returned when invoking Create.
         * @param sentinel The DisposeSentinel.
         */
        public static Dispose($safety: $Ref<AtomicSafetyHandle>, $sentinel: $Ref<DisposeSentinel>):void;
        
        public static Create($safety: $Ref<AtomicSafetyHandle>, $sentinel: $Ref<DisposeSentinel>, $callSiteStackDepth: number, $allocator: Unity_Collections.Allocator):void;
        /**
         * Clears the DisposeSentinel.
         * @param sentinel The DisposeSentinel to clear.
         */
        public static Clear($sentinel: $Ref<DisposeSentinel>):void;
        
                    
    }
    /**
     * NativeArray Unsafe Utility.
     */
    class NativeArrayUnsafeUtility extends System.Object {
        
        public static GetAtomicSafetyHandle<T>($array: Unity_Collections.NativeArray$1<T>):AtomicSafetyHandle;
        
        public static SetAtomicSafetyHandle<T>($array: $Ref<Unity_Collections.NativeArray$1<T>>, $safety: AtomicSafetyHandle):void;
        
                    
    }
    /**
     * NativeSlice unsafe utility class.
     */
    class NativeSliceUnsafeUtility extends System.Object {
        
        public static GetAtomicSafetyHandle<T>($slice: Unity_Collections.NativeSlice$1<T>):AtomicSafetyHandle;
        
        public static SetAtomicSafetyHandle<T>($slice: $Ref<Unity_Collections.NativeSlice$1<T>>, $safety: AtomicSafetyHandle):void;
        
                    
    }
    /**
     * Unsafe utility class.
     */
    class UnsafeUtility extends System.Object {
        /**
         * Returns the offset of the field relative struct or class it is contained in.
         */
        public static GetFieldOffset($field: System_Reflection.FieldInfo):number;
        /**
         * Releases a GC Object Handle, previously aquired by UnsafeUtility.PinGCObjectAndGetAddress.
         */
        public static ReleaseGCObject($gcHandle: bigint):void;
        /**
         * Returns whether the struct is blittable.
         * @param type The System.Type of a struct.
         * @returns True if struct is blittable, otherwise false.
         */
        public static IsBlittable<T>():boolean;
        /**
         * Returns true if the allocator label is valid and can be used to allocate or deallocate memory.
         */
        public static IsValidAllocator($allocator: Unity_Collections.Allocator):boolean;
        
        public static SizeOf($type: System.Type):number;
        /**
         * Returns whether the struct is blittable.
         * @param type The System.Type of a struct.
         * @returns True if struct is blittable, otherwise false.
         */
        public static IsBlittable($type: System.Type):boolean;
        /**
         * Returns whether the struct or type is unmanaged. An unmanaged type contains no managed fields, and can be freely copied in memory.
         * @param type The System.Type of a struct.
         * @returns True if struct is unmanaged, otherwise false.
         */
        public static IsUnmanaged($type: System.Type):boolean;
        /**
         * Returns whether the type is acceptable as an element type in native containers.
         * @param type The System.Type to check.
         * @returns True if type is acceptable as a native container element.
         */
        public static IsValidNativeContainerElementType($type: System.Type):boolean;
        /**
         * Returns whether the struct or type is unmanaged. An unmanaged type contains no managed fields, and can be freely copied in memory.
         * @param type The System.Type of a struct.
         * @returns True if struct is unmanaged, otherwise false.
         */
        public static IsUnmanaged<T>():boolean;
        /**
         * Returns whether the type is acceptable as an element type in native containers.
         * @param type The System.Type to check.
         * @returns True if type is acceptable as a native container element.
         */
        public static IsValidNativeContainerElementType<T>():boolean;
        /**
         * Minimum alignment of a struct.
         * @returns Memory pointer.
         */
        public static AlignOf<T>():number;
        /**
         * Size of struct.
         * @returns Size of struct.
         */
        public static SizeOf<T>():number;
        /**
         * Reinterprets the reference as a reference of a different type.
         * @param from The reference to reinterpret.
         * @returns A reference to a value of type T.
         */
        public static As<U,T>($from: $Ref<U>):$Ref<T>;
        
        public static EnumToInt<T>($enumValue: T):number;
        
        public static EnumEquals<T>($lhs: T, $rhs: T):boolean;
        
                    
    }
    
}
declare module 'Unity.Collections.NativeArray$1' {

    import * as System from 'System';
        
    /**
     * NativeArray interface constrained to read-only operation.
     */
    interface ReadOnly<T> extends System.ValueType {
        
                    
    }
    
}
declare module 'Unity.Burst' {

    import * as System from 'System';
        
    /**
     * The BurstDiscard attribute lets you remove a method or property from being compiled to native code by the burst compiler.
     */
    class BurstDiscardAttribute extends System.Attribute {
        
        public constructor();
        
                    
    }
    
}
declare module 'JetBrains.Annotations' {

    import * as System from 'System';
        
    
    class CanBeNullAttribute extends System.Attribute {
        
        public constructor();
        
                    
    }
    
    class NotNullAttribute extends System.Attribute {
        
        public constructor();
        
                    
    }
    
    class ItemNotNullAttribute extends System.Attribute {
        
        public constructor();
        
                    
    }
    
    class ItemCanBeNullAttribute extends System.Attribute {
        
        public constructor();
        
                    
    }
    
    class StringFormatMethodAttribute extends System.Attribute {
        
        public get FormatParameterName(): string;
        
        public constructor($formatParameterName: string);
        
                    
    }
    
    class ValueProviderAttribute extends System.Attribute {
        
        public get Name(): string;
        
        public constructor($name: string);
        
                    
    }
    
    class InvokerParameterNameAttribute extends System.Attribute {
        
        public constructor();
        
                    
    }
    
    class NotifyPropertyChangedInvocatorAttribute extends System.Attribute {
        
        public get ParameterName(): string;
        
        public constructor();
        
        public constructor($parameterName: string);
        
                    
    }
    
    class ContractAnnotationAttribute extends System.Attribute {
        
        public get Contract(): string;
        
        public get ForceFullStates(): boolean;
        
        public constructor($contract: string);
        
        public constructor($contract: string, $forceFullStates: boolean);
        
                    
    }
    
    class LocalizationRequiredAttribute extends System.Attribute {
        
        public get Required(): boolean;
        
        public constructor();
        
        public constructor($required: boolean);
        
                    
    }
    
    class CannotApplyEqualityOperatorAttribute extends System.Attribute {
        
        public constructor();
        
                    
    }
    
    class BaseTypeRequiredAttribute extends System.Attribute {
        
        public get BaseType(): System.Type;
        
        public constructor($baseType: System.Type);
        
                    
    }
    
    class UsedImplicitlyAttribute extends System.Attribute {
        
        public get UseKindFlags(): ImplicitUseKindFlags;
        
        public get TargetFlags(): ImplicitUseTargetFlags;
        
        public constructor();
        
        public constructor($useKindFlags: ImplicitUseKindFlags);
        
        public constructor($targetFlags: ImplicitUseTargetFlags);
        
        public constructor($useKindFlags: ImplicitUseKindFlags, $targetFlags: ImplicitUseTargetFlags);
        
                    
    }
    
    enum ImplicitUseKindFlags { Default = 7, Access = 1, Assign = 2, InstantiatedWithFixedConstructorSignature = 4, InstantiatedNoFixedConstructorSignature = 8 }
    
    enum ImplicitUseTargetFlags { Default = 1, Itself = 1, Members = 2, WithMembers = 3 }
    
    class MeansImplicitUseAttribute extends System.Attribute {
        
        public get UseKindFlags(): ImplicitUseKindFlags;
        
        public get TargetFlags(): ImplicitUseTargetFlags;
        
        public constructor();
        
        public constructor($useKindFlags: ImplicitUseKindFlags);
        
        public constructor($targetFlags: ImplicitUseTargetFlags);
        
        public constructor($useKindFlags: ImplicitUseKindFlags, $targetFlags: ImplicitUseTargetFlags);
        
                    
    }
    
    class PublicAPIAttribute extends System.Attribute {
        
        public get Comment(): string;
        
        public constructor();
        
        public constructor($comment: string);
        
                    
    }
    
    class InstantHandleAttribute extends System.Attribute {
        
        public constructor();
        
                    
    }
    
    class PureAttribute extends System.Attribute {
        
        public constructor();
        
                    
    }
    
    class MustUseReturnValueAttribute extends System.Attribute {
        
        public get Justification(): string;
        
        public constructor();
        
        public constructor($justification: string);
        
                    
    }
    
    class ProvidesContextAttribute extends System.Attribute {
        
        public constructor();
        
                    
    }
    
    class PathReferenceAttribute extends System.Attribute {
        
        public get BasePath(): string;
        
        public constructor();
        
        public constructor($basePath: string);
        
                    
    }
    
    class SourceTemplateAttribute extends System.Attribute {
        
        public constructor();
        
                    
    }
    
    class MacroAttribute extends System.Attribute {
        
        public get Expression(): string;
        public set Expression(value: string);
        
        public get Editable(): number;
        public set Editable(value: number);
        
        public get Target(): string;
        public set Target(value: string);
        
        public constructor();
        
                    
    }
    
    class CollectionAccessAttribute extends System.Attribute {
        
        public get CollectionAccessType(): CollectionAccessType;
        
        public constructor($collectionAccessType: CollectionAccessType);
        
                    
    }
    
    enum CollectionAccessType { None = 0, Read = 1, ModifyExistingContent = 2, UpdatedContent = 6 }
    
    class AssertionMethodAttribute extends System.Attribute {
        
        public constructor();
        
                    
    }
    
    class AssertionConditionAttribute extends System.Attribute {
        
        public get ConditionType(): AssertionConditionType;
        
        public constructor($conditionType: AssertionConditionType);
        
                    
    }
    
    enum AssertionConditionType { IS_TRUE = 0, IS_FALSE = 1, IS_NULL = 2, IS_NOT_NULL = 3 }
    
    class LinqTunnelAttribute extends System.Attribute {
        
        public constructor();
        
                    
    }
    
    class NoEnumerationAttribute extends System.Attribute {
        
        public constructor();
        
                    
    }
    
    class RegexPatternAttribute extends System.Attribute {
        
        public constructor();
        
                    
    }
    
    class NoReorderAttribute extends System.Attribute {
        
        public constructor();
        
                    
    }
    
}
declare module 'UnityEngine.Application' {

    import * as System from 'System';
    import * as UnityEngine from 'UnityEngine';
        
    /**
     * Delegate method for fetching advertising ID.
     * @param advertisingId Advertising ID.
     * @param trackingEnabled Indicates whether user has chosen to limit ad tracking.
     * @param errorMsg Error message.
     */
    type AdvertisingIdentifierCallback = (advertisingId: string, trackingEnabled: boolean, errorMsg: string) => void;
    var AdvertisingIdentifierCallback: {new (func: (advertisingId: string, trackingEnabled: boolean, errorMsg: string) => void): AdvertisingIdentifierCallback;}
    /**
     * This is the delegate function when a mobile device notifies of low memory.
     */
    type LowMemoryCallback = () => void;
    var LowMemoryCallback: {new (func: () => void): LowMemoryCallback;}
    /**
     * Use this delegate type with Application.logMessageReceived or Application.logMessageReceivedThreaded to monitor what gets logged.
     */
    type LogCallback = (condition: string, stackTrace: string, type: UnityEngine.LogType) => void;
    var LogCallback: {new (func: (condition: string, stackTrace: string, type: UnityEngine.LogType) => void): LogCallback;}
    
}
declare module 'UnityEngine.Camera' {

    import * as UnityEngine from 'UnityEngine';
    import * as System from 'System';
        
    /**
     * Delegate type for camera callbacks.
     */
    type CameraCallback = (cam: UnityEngine.Camera) => void;
    var CameraCallback: {new (func: (cam: UnityEngine.Camera) => void): CameraCallback;}
    /**
     * Enum used to specify how the sensor gate (sensor frame) defined by Camera.sensorSize fits into the resolution gate (render frame).
     */
    enum GateFitMode { Vertical = 1, Horizontal = 2, Fill = 3, Overscan = 4, None = 0 }
    /**
     * A Camera eye corresponding to the left or right human eye for stereoscopic rendering, or neither for non-stereoscopic rendering.
     * A single Camera can render both left and right views in a single frame. Therefore, this enum describes which eye the Camera is currently rendering when returned by Camera.stereoActiveEye during a rendering callback (such as Camera.OnRenderImage), or which eye to act on when passed into a function.
     * The default value is Camera.MonoOrStereoscopicEye.Left, so Camera.MonoOrStereoscopicEye.Left may be returned by some methods or properties when called outside of rendering if stereoscopic rendering is enabled.
     */
    enum MonoOrStereoscopicEye { Left = 0, Right = 1, Mono = 2 }
    /**
     * Wrapper for gate fit parameters
     */
    class GateFitParameters extends System.ValueType {
        
        public get mode(): GateFitMode;
        public set mode(value: GateFitMode);
        
        public get aspect(): number;
        public set aspect(value: number);
        
        public constructor($mode: GateFitMode, $aspect: number);
        
        public get_Clone(): GateFitParameters;            
    }
    /**
     * Enum used to specify either the left or the right eye of a stereoscopic camera.
     */
    enum StereoscopicEye { Left = 0, Right = 1 }
    /**
     * A request that can be used for making specific rendering requests.
     */
    class RenderRequest extends System.ValueType {
        
        public get isValid(): boolean;
        
        public get mode(): RenderRequestMode;
        
        public get result(): UnityEngine.RenderTexture;
        
        public get outputSpace(): RenderRequestOutputSpace;
        
        public constructor($mode: RenderRequestMode, $rt: UnityEngine.RenderTexture);
        
        public constructor($mode: RenderRequestMode, $space: RenderRequestOutputSpace, $rt: UnityEngine.RenderTexture);
        
                    
    }
    /**
     * Enumerates which axis to use when expressing the value for the field of view.
     * The default value is Camera.FieldOfViewAxis.Vertical.
     */
    enum FieldOfViewAxis { Vertical = 0, Horizontal = 1 }
    /**
     * Modes available for submitting when making a render request.
     */
    enum RenderRequestMode { None = 0, ObjectId = 1, Depth = 2, VertexNormal = 3, WorldPosition = 4, EntityId = 5, BaseColor = 6, SpecularColor = 7, Metallic = 8, Emission = 9, Normal = 10, Smoothness = 11, Occlusion = 12, DiffuseColor = 13 }
    /**
     * Defines in which space render requests will be be outputted.
     */
    enum RenderRequestOutputSpace { ScreenSpace = -1, UV0 = 0, UV1 = 1, UV2 = 2, UV3 = 3, UV4 = 4, UV5 = 5, UV6 = 6, UV7 = 7, UV8 = 8 }
    
}
declare module 'UnityEngine.CullingGroup' {

    import * as UnityEngine from 'UnityEngine';
    import * as System from 'System';
        
    /**
     * This delegate is used for recieving a callback when a sphere's distance or visibility state has changed.
     * @param sphere A CullingGroupEvent that provides information about the sphere that has changed.
     */
    type StateChanged = (sphere: UnityEngine.CullingGroupEvent) => void;
    var StateChanged: {new (func: (sphere: UnityEngine.CullingGroupEvent) => void): StateChanged;}
    
}
declare module 'UnityEngine.ReflectionProbe' {

    import * as System from 'System';
        
    /**
     * Types of events that occur when ReflectionProbe components are used in a Scene.
     */
    enum ReflectionProbeEvent { ReflectionProbeAdded = 0, ReflectionProbeRemoved = 1 }
    
}
declare module 'UnityEngine.LightingSettings' {

    import * as System from 'System';
        
    /**
     * Backends available for baking lighting.
     */
    enum Lightmapper { Enlighten = 0, ProgressiveCPU = 1, ProgressiveGPU = 2 }
    /**
     * Available sampling strategies for baking lightmaps with the Progressive Lightmapper.
     */
    enum Sampling { Auto = 0, Fixed = 1 }
    /**
     * The available filtering modes for the Progressive Lightmapper.
     */
    enum FilterMode { None = 0, Auto = 1, Advanced = 2 }
    /**
     * The available denoisers for the Progressive Lightmapper.
     */
    enum DenoiserType { None = 0, Optix = 1, OpenImage = 2, RadeonPro = 3 }
    /**
     * The available filter kernels for the Progressive Lightmapper.
     */
    enum FilterType { Gaussian = 0, ATrous = 1, None = 2 }
    
}
declare module 'UnityEngine.BoundsInt' {

    import * as System from 'System';
    import * as UnityEngine from 'UnityEngine';
        
    /**
     * A struct that iterates through all positions in BoundsInt.
     */
    class PositionEnumerator extends System.ValueType {
        
        public get Current(): UnityEngine.Vector3Int;
        
        public constructor($min: UnityEngine.Vector3Int, $max: UnityEngine.Vector3Int);
        
        public GetEnumerator():PositionEnumerator;
        
        public MoveNext():boolean;
        
        public Reset():void;
        
        public get_Clone(): PositionEnumerator;            
    }
    
}
declare module 'UnityEngine.RectInt' {

    import * as System from 'System';
    import * as UnityEngine from 'UnityEngine';
        
    /**
     * An iterator that allows you to iterate over all positions within the RectInt.
     */
    class PositionEnumerator extends System.ValueType {
        
        public get Current(): UnityEngine.Vector2Int;
        
        public constructor($min: UnityEngine.Vector2Int, $max: UnityEngine.Vector2Int);
        
        public GetEnumerator():PositionEnumerator;
        
        public MoveNext():boolean;
        
        public Reset():void;
        
        public get_Clone(): PositionEnumerator;            
    }
    
}
declare module 'UnityEngine.Display' {

    import * as System from 'System';
        
    
    type DisplaysUpdatedDelegate = () => void;
    var DisplaysUpdatedDelegate: {new (func: () => void): DisplaysUpdatedDelegate;}
    
}
declare module 'UnityEngine.Mesh' {

    import * as System from 'System';
    import * as UnityEngine_Rendering from 'UnityEngine.Rendering';
    import * as Unity_Collections from 'Unity.Collections';
        
    /**
     * An array of Mesh data snapshots for C# Job System access.
     */
    class MeshDataArray extends System.ValueType {
        
        public get Length(): number;
        
        public get_Item($index: number):MeshData;
        
        public Dispose():void;
        
                    
    }
    /**
     * A struct containing Mesh data for C# Job System access.
     */
    class MeshData extends System.ValueType {
        
        public get vertexCount(): number;
        
        public get vertexBufferCount(): number;
        
        public get indexFormat(): UnityEngine_Rendering.IndexFormat;
        
        public get subMeshCount(): number;
        public set subMeshCount(value: number);
        
        public HasVertexAttribute($attr: UnityEngine_Rendering.VertexAttribute):boolean;
        
        public GetVertexAttributeDimension($attr: UnityEngine_Rendering.VertexAttribute):number;
        
        public GetVertexAttributeFormat($attr: UnityEngine_Rendering.VertexAttribute):UnityEngine_Rendering.VertexAttributeFormat;
        
        public GetVertices($outVertices: Unity_Collections.NativeArray$1<UnityEngine.Vector3>):void;
        
        public GetNormals($outNormals: Unity_Collections.NativeArray$1<UnityEngine.Vector3>):void;
        
        public GetTangents($outTangents: Unity_Collections.NativeArray$1<UnityEngine.Vector4>):void;
        
        public GetColors($outColors: Unity_Collections.NativeArray$1<UnityEngine.Color>):void;
        
        public GetColors($outColors: Unity_Collections.NativeArray$1<UnityEngine.Color32>):void;
        
        public GetUVs($channel: number, $outUVs: Unity_Collections.NativeArray$1<UnityEngine.Vector2>):void;
        
        public GetUVs($channel: number, $outUVs: Unity_Collections.NativeArray$1<UnityEngine.Vector3>):void;
        
        public GetUVs($channel: number, $outUVs: Unity_Collections.NativeArray$1<UnityEngine.Vector4>):void;
        
        public GetVertexData<T>($stream?: number):Unity_Collections.NativeArray$1<T>;
        
        public SetVertexBufferParams($vertexCount: number, ...attributes: UnityEngine_Rendering.VertexAttributeDescriptor[]):void;
        
        public SetVertexBufferParams($vertexCount: number, $attributes: Unity_Collections.NativeArray$1<UnityEngine_Rendering.VertexAttributeDescriptor>):void;
        
        public SetIndexBufferParams($indexCount: number, $format: UnityEngine_Rendering.IndexFormat):void;
        
        public GetIndices($outIndices: Unity_Collections.NativeArray$1<number>, $submesh: number, $applyBaseVertex?: boolean):void;
        
        public GetIndices($outIndices: Unity_Collections.NativeArray$1<number>, $submesh: number, $applyBaseVertex?: boolean):void;
        
        public GetIndexData<T>():Unity_Collections.NativeArray$1<T>;
        
        public GetSubMesh($index: number):UnityEngine_Rendering.SubMeshDescriptor;
        
        public SetSubMesh($index: number, $desc: UnityEngine_Rendering.SubMeshDescriptor, $flags?: UnityEngine_Rendering.MeshUpdateFlags):void;
        
        public get_Clone(): MeshData;            
    }
    
}
declare module 'UnityEngine.GraphicsBuffer' {

    import * as System from 'System';
        
    /**
     * The type of graphics buffer.
     */
    enum Target { Vertex = 1, Index = 2, Structured = 16, Raw = 32, Append = 64, Counter = 128, IndirectArguments = 256, Constant = 512 }
    
}
declare module 'UnityEngine.LightProbeProxyVolume' {

    import * as System from 'System';
        
    /**
     * The bounding box mode for generating a grid of interpolated Light Probes.
     */
    enum BoundingBoxMode { AutomaticLocal = 0, AutomaticWorld = 1, Custom = 2 }
    /**
     * The resolution mode for generating a grid of interpolated Light Probes.
     */
    enum ResolutionMode { Automatic = 0, Custom = 1 }
    /**
     * The mode in which the interpolated Light Probe positions are generated.
     */
    enum ProbePositionMode { CellCorner = 0, CellCenter = 1 }
    /**
     * An enum describing the way a Light Probe Proxy Volume refreshes in the Player.
     */
    enum RefreshMode { Automatic = 0, EveryFrame = 1, ViaScripting = 2 }
    /**
     * An enum describing the Quality option used by the Light Probe Proxy Volume component.
     */
    enum QualityMode { Low = 0, Normal = 1 }
    /**
     * The texture data format used by the Light Probe Proxy Volume 3D texture.
     */
    enum DataFormat { HalfFloat = 0, Float = 1 }
    
}
declare module 'UnityEngine.Texture2D' {

    import * as System from 'System';
        
    /**
     * Flags used to control the encoding to an EXR file.
     */
    enum EXRFlags { None = 0, OutputAsFloat = 1, CompressZIP = 2, CompressRLE = 4, CompressPIZ = 8 }
    
}
declare module 'UnityEngine.iOS' {

    import * as System from 'System';
    import * as UnityEngine from 'UnityEngine';
        
    /**
     * ActivityIndicator Style (iOS Specific).
     */
    enum ActivityIndicatorStyle { DontShow = -1, WhiteLarge = 0, White = 1, Gray = 2 }
    /**
     * Represents a request for On Demand Resources (ODR). It's an AsyncOperation and can be yielded in a coroutine.
     */
    class OnDemandResourcesRequest extends UnityEngine.AsyncOperation {
        /**
         * Returns an error after operation is complete.
         */
        public get error(): string;
        /**
         * Sets the priority for request.
         */
        public get loadingPriority(): number;
        public set loadingPriority(value: number);
        /**
         * Gets file system's path to the resource available in On Demand Resources (ODR) request.
         * @param resourceName Resource name.
         */
        public GetResourcePath($resourceName: string):string;
        /**
         * Release all resources kept alive by On Demand Resources (ODR) request.
         */
        public Dispose():void;
        
                    
    }
    /**
     * On Demand Resources API.
     */
    class OnDemandResources extends System.Object {
        /**
         * Indicates whether player was built with "Use On Demand Resources" player setting enabled.
         */
        public static get enabled(): boolean;
        /**
         * Creates an On Demand Resources (ODR) request.
         * @param tags Tags for On Demand Resources that should be included in the request.
         * @returns Object representing ODR request.
         */
        public static PreloadAsync($tags: string[]):OnDemandResourcesRequest;
        
                    
    }
    /**
     * ADBannerView is a wrapper around the ADBannerView class found in the Apple iAd framework and is only available on iOS.
     */
    interface ADBannerView extends System.Object {
        
                    
    }
    /**
     * ADInterstitialAd is a wrapper around the ADInterstitialAd class found in the Apple iAd framework and is only available on iPad.
     */
    interface ADInterstitialAd extends System.Object {
        
                    
    }
    /**
     * iOS device generation.
     */
    enum DeviceGeneration { Unknown = 0, iPhone = 1, iPhone3G = 2, iPhone3GS = 3, iPodTouch1Gen = 4, iPodTouch2Gen = 5, iPodTouch3Gen = 6, iPad1Gen = 7, iPhone4 = 8, iPodTouch4Gen = 9, iPad2Gen = 10, iPhone4S = 11, iPad3Gen = 12, iPhone5 = 13, iPodTouch5Gen = 14, iPadMini1Gen = 15, iPad4Gen = 16, iPhone5C = 17, iPhone5S = 18, iPadAir1 = 19, iPadMini2Gen = 20, iPhone6 = 21, iPhone6Plus = 22, iPadMini3Gen = 23, iPadAir2 = 24, iPhone6S = 25, iPhone6SPlus = 26, iPadPro1Gen = 27, iPadMini4Gen = 28, iPhoneSE1Gen = 29, iPadPro10Inch1Gen = 30, iPhone7 = 31, iPhone7Plus = 32, iPodTouch6Gen = 33, iPad5Gen = 34, iPadPro2Gen = 35, iPadPro10Inch2Gen = 36, iPhone8 = 37, iPhone8Plus = 38, iPhoneX = 39, iPhoneXS = 40, iPhoneXSMax = 41, iPhoneXR = 42, iPadPro11Inch = 43, iPadPro3Gen = 44, iPad6Gen = 45, iPadAir3Gen = 46, iPadMini5Gen = 47, iPhone11 = 48, iPhone11Pro = 49, iPhone11ProMax = 50, iPodTouch7Gen = 51, iPad7Gen = 52, iPhoneSE2Gen = 53, iPadPro11Inch2Gen = 54, iPadPro4Gen = 55, iPhone12Mini = 56, iPhone12 = 57, iPhone12Pro = 58, iPhone12ProMax = 59, iPad8Gen = 60, iPadAir4Gen = 61, iPhoneUnknown = 10001, iPadUnknown = 10002, iPodTouchUnknown = 10003 }
    /**
     * Interface into iOS specific functionality.
     */
    class Device extends System.Object {
        /**
         * iOS version.
         */
        public static get systemVersion(): string;
        /**
         * The generation of the device. (Read Only)
         */
        public static get generation(): DeviceGeneration;
        /**
         * Vendor ID.
         */
        public static get vendorIdentifier(): string;
        /**
         * Advertising ID.
         */
        public static get advertisingIdentifier(): string;
        /**
         * Is advertising tracking enabled.
         */
        public static get advertisingTrackingEnabled(): boolean;
        /**
         * Specifies whether the home button should be hidden in the iOS build of this application.
         */
        public static get hideHomeButton(): boolean;
        public static set hideHomeButton(value: boolean);
        /**
         * Indicates whether Low Power Mode is enabled on the device.
         */
        public static get lowPowerModeEnabled(): boolean;
        /**
         * Indicates whether the screen may be dimmed lower than the hardware is normally capable of by emulating it in software.
         */
        public static get wantsSoftwareDimming(): boolean;
        public static set wantsSoftwareDimming(value: boolean);
        /**
         * Specifies whether app built for iOS is running on Mac.
         */
        public static get iosAppOnMac(): boolean;
        /**
         * Defer system gestures until the second swipe on specific edges.
         */
        public static get deferSystemGesturesMode(): SystemGestureDeferMode;
        public static set deferSystemGesturesMode(value: SystemGestureDeferMode);
        
        public constructor();
        /**
         * Set file flag to be excluded from iCloud/iTunes backup.
         */
        public static SetNoBackupFlag($path: string):void;
        /**
         * Reset "no backup" file flag: file will be synced with iCloud/iTunes backup and can be deleted by OS in low storage situations.
         */
        public static ResetNoBackupFlag($path: string):void;
        /**
         * Request App Store rating and review from the user.
         * @returns Value indicating whether the underlying API is available or not. False indicates that the iOS version isn't recent enough or that the StoreKit framework is not linked with the app.
         */
        public static RequestStoreReview():boolean;
        
                    
    }
    /**
     * Bit-mask used to control the deferring of system gestures on iOS.
     */
    enum SystemGestureDeferMode { None = 0, TopEdge = 1, LeftEdge = 2, BottomEdge = 4, RightEdge = 8, All = 15 }
    
}
declare module 'UnityEngine.Scripting' {

    import * as System from 'System';
    import * as UnityEngine_Scripting_GarbageCollector from 'UnityEngine.Scripting.GarbageCollector';
        
    /**
     * PreserveAttribute prevents byte code stripping from removing a class, method, field, or property.
     */
    class PreserveAttribute extends System.Attribute {
        
        public constructor();
        
                    
    }
    /**
     * Ensure an assembly is always processed during managed code stripping.
     */
    class AlwaysLinkAssemblyAttribute extends System.Attribute {
        
        public constructor();
        
                    
    }
    /**
     * API to control the garbage collector on the Mono and IL2CPP scripting backends.
     */
    class GarbageCollector extends System.Object {
        /**
         * Set and get global garbage collector operation mode.
         */
        public static get GCMode(): UnityEngine_Scripting_GarbageCollector.Mode;
        public static set GCMode(value: UnityEngine_Scripting_GarbageCollector.Mode);
        /**
         * Reports whether incremental garbage collection is enabled.
         */
        public static get isIncremental(): boolean;
        /**
         * The target duration of a collection step when performing incremental garbage collection.
         */
        public static get incrementalTimeSliceNanoseconds(): bigint;
        public static set incrementalTimeSliceNanoseconds(value: bigint);
        
        public static add_GCModeChanged($value: System.Action$1<UnityEngine_Scripting_GarbageCollector.Mode>):void;
        
        public static remove_GCModeChanged($value: System.Action$1<UnityEngine_Scripting_GarbageCollector.Mode>):void;
        /**
         * Perform incremental garbage collection for the duration specified by the nanoseconds parameter.
         * @param nanoseconds The maximum number of nanoseconds to spend in garbage collection.
         * @returns Returns true if additional garbage collection work remains when the method returns and false if garbage collection is complete. Also returns false if incremental garbage collection is not enabled or is not supported on the current platform.
         */
        public static CollectIncremental($nanoseconds?: bigint):boolean;
        
        public static GCModeChanged;
        
                    
    }
    /**
     * Only allowed on attribute types. If the attribute type is marked, then so too will all CustomAttributes of that type.
     */
    class RequireAttributeUsagesAttribute extends System.Attribute {
        
        public constructor();
        
                    
    }
    /**
     * When the type is marked, all types derived from that type will also be marked.
     */
    class RequireDerivedAttribute extends System.Attribute {
        
        public constructor();
        
                    
    }
    /**
     * When the interface type is marked, all types implementing that interface will be marked.
     */
    class RequireImplementorsAttribute extends System.Attribute {
        
        public constructor();
        
                    
    }
    /**
     * When a type is marked, all interface implementations of the specified types will be marked.
     */
    class RequiredInterfaceAttribute extends System.Attribute {
        
        public constructor($interfaceType: System.Type);
        
                    
    }
    /**
     * When a type is marked, all of it's members with [RequiredMember] will be marked.
     */
    class RequiredMemberAttribute extends System.Attribute {
        
        public constructor();
        
                    
    }
    
}
declare module 'UnityEngine.ShaderVariantCollection' {

    import * as System from 'System';
    import * as UnityEngine from 'UnityEngine';
    import * as UnityEngine_Rendering from 'UnityEngine.Rendering';
        
    /**
     * Identifies a specific variant of a shader.
     */
    class ShaderVariant extends System.ValueType {
        
        public shader: UnityEngine.Shader;
        
        public passType: UnityEngine_Rendering.PassType;
        
        public keywords: string[];
        
        public constructor($shader: UnityEngine.Shader, $passType: UnityEngine_Rendering.PassType, ...keywords: string[]);
        
                    
    }
    
}
declare module 'UnityEngine.TouchScreenKeyboard' {

    import * as System from 'System';
        
    /**
     * The status of the on-screen keyboard.
     */
    enum Status { Visible = 0, Done = 1, Canceled = 2, LostFocus = 3 }
    
}
declare module 'UnityEngine.ADBannerView' {

    import * as System from 'System';
        
    
    enum Layout { Top = 0, Bottom = 1, TopLeft = 0, TopRight = 4, TopCenter = 8, BottomLeft = 1, BottomRight = 5, BottomCenter = 9, CenterLeft = 2, CenterRight = 6, Center = 10, Manual = -1 }
    
    enum Type { Banner = 0, MediumRect = 1 }
    
    type BannerWasClickedDelegate = () => void;
    var BannerWasClickedDelegate: {new (func: () => void): BannerWasClickedDelegate;}
    
    type BannerWasLoadedDelegate = () => void;
    var BannerWasLoadedDelegate: {new (func: () => void): BannerWasLoadedDelegate;}
    
}
declare module 'UnityEngine.ADInterstitialAd' {

    import * as System from 'System';
        
    
    type InterstitialWasLoadedDelegate = () => void;
    var InterstitialWasLoadedDelegate: {new (func: () => void): InterstitialWasLoadedDelegate;}
    
}
declare module 'UnityEngine.Sprites' {

    import * as System from 'System';
    import * as UnityEngine from 'UnityEngine';
        
    /**
     * Helper utilities for accessing Sprite data.
     */
    class DataUtility extends System.Object {
        
        public constructor();
        /**
         * Inner UV's of the Sprite.
         */
        public static GetInnerUV($sprite: UnityEngine.Sprite):UnityEngine.Vector4;
        /**
         * Outer UV's of the Sprite.
         */
        public static GetOuterUV($sprite: UnityEngine.Sprite):UnityEngine.Vector4;
        /**
         * Return the padding on the sprite.
         */
        public static GetPadding($sprite: UnityEngine.Sprite):UnityEngine.Vector4;
        /**
         * Minimum width and height of the Sprite.
         */
        public static GetMinSize($sprite: UnityEngine.Sprite):UnityEngine.Vector2;
        
                    
    }
    
}
declare module 'UnityEngine.U2D' {

    import * as System from 'System';
    import * as UnityEngine from 'UnityEngine';
    import * as Unity_Collections from 'Unity.Collections';
    import * as UnityEngine_Rendering from 'UnityEngine.Rendering';
        
    /**
     * A collection of APIs that facilitate pixel perfect rendering of sprite-based renderers.
     */
    class PixelPerfectRendering extends System.Object {
        /**
         * To achieve a pixel perfect render, Sprites must be displaced to discrete positions at render time. This value defines the minimum distance between these positions. This doesn’t affect the GameObject's transform position.
         */
        public static get pixelSnapSpacing(): number;
        public static set pixelSnapSpacing(value: number);
        
                    
    }
    /**
     * A struct that holds a rich set of information that describes the bind pose of this Sprite.
     */
    class SpriteBone extends System.ValueType {
        /**
         * The name of the bone. This is useful when recreating bone hierarchy at editor or runtime. You can also use this as a way of resolving the bone path when a Sprite is bound to a more complex or richer hierarchy.
         */
        public get name(): string;
        public set name(value: string);
        /**
         * The position in local space of this bone.
         */
        public get position(): UnityEngine.Vector3;
        public set position(value: UnityEngine.Vector3);
        /**
         * The rotation of this bone in local space.
         */
        public get rotation(): UnityEngine.Quaternion;
        public set rotation(value: UnityEngine.Quaternion);
        /**
         * The length of the bone. This is important for the leaf bones to describe their length without needing another bone as the terminal bone.
         */
        public get length(): number;
        public set length(value: number);
        /**
         * The ID of the parent of this bone.
         */
        public get parentId(): number;
        public set parentId(value: number);
        
                    
    }
    /**
     * A list of methods designed for reading and writing to the rich internal data of a Sprite.
     */
    class SpriteDataAccessExtensions extends System.Object {
        /**
         * Retrieves a strided accessor to the internal vertex attributes.
         * @returns A read-only list of.
         */
        public static GetVertexAttribute<T>($sprite: UnityEngine.Sprite, $channel: UnityEngine_Rendering.VertexAttribute):Unity_Collections.NativeSlice$1<T>;
        
        public static SetVertexAttribute<T>($sprite: UnityEngine.Sprite, $channel: UnityEngine_Rendering.VertexAttribute, $src: Unity_Collections.NativeArray$1<T>):void;
        /**
         * Returns an array of BindPoses.
         * @param sprite The sprite to retrieve the bind pose from.
         * @returns A list of bind poses for this sprite. There is no need to dispose the returned NativeArray.
         */
        public static GetBindPoses($sprite: UnityEngine.Sprite):Unity_Collections.NativeArray$1<UnityEngine.Matrix4x4>;
        
        public static SetBindPoses($sprite: UnityEngine.Sprite, $src: Unity_Collections.NativeArray$1<UnityEngine.Matrix4x4>):void;
        /**
         * Returns a list of indices. This is the same as Sprite.triangle.
         * @returns A read-only list of indices indicating how the triangles are formed between the vertices. The array is marked as undisposable.
         */
        public static GetIndices($sprite: UnityEngine.Sprite):Unity_Collections.NativeArray$1<number>;
        
        public static SetIndices($sprite: UnityEngine.Sprite, $src: Unity_Collections.NativeArray$1<number>):void;
        /**
         * Returns a list of SpriteBone in this Sprite.
         * @param sprite The sprite to get the list of SpriteBone from.
         * @returns An array of SpriteBone that belongs to this Sprite.
         */
        public static GetBones($sprite: UnityEngine.Sprite):SpriteBone[];
        /**
         * Sets the SpriteBones for this Sprite.
         */
        public static SetBones($sprite: UnityEngine.Sprite, $src: SpriteBone[]):void;
        /**
         * Checks if a specific channel exists for this Sprite.
         * @returns True if the channel exists.
         */
        public static HasVertexAttribute($sprite: UnityEngine.Sprite, $channel: UnityEngine_Rendering.VertexAttribute):boolean;
        /**
         * Sets the vertex count. This resizes the internal buffer. It also preserves any configurations of VertexAttributes.
         */
        public static SetVertexCount($sprite: UnityEngine.Sprite, $count: number):void;
        /**
         * Returns the number of vertices in this Sprite.
         */
        public static GetVertexCount($sprite: UnityEngine.Sprite):number;
        
                    
    }
    /**
     * A list of methods that allow the caller to override what the SpriteRenderer renders.
     */
    class SpriteRendererDataAccessExtensions extends System.Object {
        /**
         * Stop using the deformable buffer to render the Sprite and use the original mesh instead.
         */
        public static DeactivateDeformableBuffer($renderer: UnityEngine.SpriteRenderer):void;
        
                    
    }
    /**
     * Manages SpriteAtlas during runtime.
     */
    class SpriteAtlasManager extends System.Object {
        
        public constructor();
        
        public static add_atlasRequested($value: System.Action$2<string, System.Action$1<SpriteAtlas>>):void;
        
        public static remove_atlasRequested($value: System.Action$2<string, System.Action$1<SpriteAtlas>>):void;
        
        public static add_atlasRegistered($value: System.Action$1<SpriteAtlas>):void;
        
        public static remove_atlasRegistered($value: System.Action$1<SpriteAtlas>):void;
        
        public static atlasRequested;
        
        public static atlasRegistered;
        
                    
    }
    /**
     * Sprite Atlas is an asset created within Unity. It is part of the built-in sprite packing solution.
     */
    class SpriteAtlas extends UnityEngine.Object {
        /**
         * Return true if this SpriteAtlas is a variant.
         */
        public get isVariant(): boolean;
        /**
         * Get the tag of this SpriteAtlas.
         */
        public get tag(): string;
        /**
         * Get the total number of Sprite packed into this atlas.
         */
        public get spriteCount(): number;
        
        public constructor();
        /**
         * Return true if Sprite is packed into this SpriteAtlas.
         */
        public CanBindTo($sprite: UnityEngine.Sprite):boolean;
        /**
         * Clone the first Sprite in this atlas that matches the name packed in this atlas and return it.
         * @param name The name of the Sprite.
         */
        public GetSprite($name: string):UnityEngine.Sprite;
        /**
         * Clone all the Sprite in this atlas and fill them into the supplied array.
         * @param sprites Array of Sprite that will be filled.
         * @returns The size of the returned array.
         */
        public GetSprites($sprites: UnityEngine.Sprite[]):number;
        /**
         * Clone all the Sprite matching the name in this atlas and fill them into the supplied array.
         * @param sprites Array of Sprite that will be filled.
         * @param name The name of the Sprite.
         */
        public GetSprites($sprites: UnityEngine.Sprite[], $name: string):number;
        
                    
    }
    
}
declare module 'UnityEngine.Profiling' {

    import * as System from 'System';
    import * as UnityEngine from 'UnityEngine';
    import * as Unity_Collections from 'Unity.Collections';
    import * as System_Collections_Generic from 'System.Collections.Generic';
        
    /**
     * The different areas of profiling, corresponding to the charts in ProfilerWindow.
     */
    enum ProfilerArea { CPU = 0, GPU = 1, Rendering = 2, Memory = 3, Audio = 4, Video = 5, Physics = 6, Physics2D = 7, NetworkMessages = 8, NetworkOperations = 9, UI = 10, UIDetails = 11, GlobalIllumination = 12, VirtualTexturing = 13 }
    /**
     * Controls the from script.
     */
    class Profiler extends System.Object {
        
        public static get supported(): boolean;
        /**
         * Specifies the file to use when writing profiling data.
         */
        public static get logFile(): string;
        public static set logFile(value: string);
        /**
         * Enables the logging of profiling data to a file.
         */
        public static get enableBinaryLog(): boolean;
        public static set enableBinaryLog(value: boolean);
        /**
         * Sets the maximum amount of memory that Profiler uses for buffering data. This property is expressed in bytes.
         */
        public static get maxUsedMemory(): number;
        public static set maxUsedMemory(value: number);
        /**
         * Enables the Profiler.
         */
        public static get enabled(): boolean;
        public static set enabled(value: boolean);
        /**
         * Enables the recording of callstacks for managed allocations.
         */
        public static get enableAllocationCallstacks(): boolean;
        public static set enableAllocationCallstacks(value: boolean);
        /**
         * The number of ProfilerArea|Profiler Areas that you can profile.
         */
        public static get areaCount(): number;
        /**
         * Returns the number of bytes that Unity has allocated. This does not include bytes allocated by external libraries or drivers.
         * @returns Size of the memory allocated by Unity (or 0 if the profiler is disabled).
         */
        public static get usedHeapSizeLong(): bigint;
        /**
         * Enable or disable a given ProfilerArea.
         * @param area The area you want to enable or disable.
         * @param enabled Enable or disable the collection of data for this area.
         */
        public static SetAreaEnabled($area: ProfilerArea, $enabled: boolean):void;
        /**
         * Returns whether or not a given ProfilerArea is currently enabled.
         * @param area Which area you want to check the state of.
         * @returns Returns whether or not a given ProfilerArea is currently enabled.
         */
        public static GetAreaEnabled($area: ProfilerArea):boolean;
        /**
         * Displays the recorded profile data in the profiler.
         * @param file The name of the file containing the frame data, including extension.
         */
        public static AddFramesFromFile($file: string):void;
        /**
         * Enables profiling on the thread from which you call this method.
         * @param threadGroupName The name of the thread group to which the thread belongs.
         * @param threadName The name of the thread.
         */
        public static BeginThreadProfiling($threadGroupName: string, $threadName: string):void;
        /**
         * Frees the internal resources used by the Profiler for the thread.
         */
        public static EndThreadProfiling():void;
        /**
         * Begin profiling a piece of code with a custom label.
         * @param name A string to identify the sample in the Profiler window.
         * @param targetObject An object that provides context to the sample,.
         */
        public static BeginSample($name: string):void;
        /**
         * Begin profiling a piece of code with a custom label.
         * @param name A string to identify the sample in the Profiler window.
         * @param targetObject An object that provides context to the sample,.
         */
        public static BeginSample($name: string, $targetObject: UnityEngine.Object):void;
        /**
         * Ends the current profiling sample.
         */
        public static EndSample():void;
        /**
         * Gathers the native-memory used by a Unity object.
         * @param o The target Unity object.
         * @returns The amount of native-memory used by a Unity object. This returns 0 if the Profiler is not available.
         */
        public static GetRuntimeMemorySizeLong($o: UnityEngine.Object):bigint;
        /**
         * Returns the size of the reserved space for managed-memory.
         * @returns The size of the managed heap.
         */
        public static GetMonoHeapSizeLong():bigint;
        /**
         * Gets the allocated managed memory for live objects and non-collected objects.
         * @returns Returns a long integer value of the memory in use.
         */
        public static GetMonoUsedSizeLong():bigint;
        /**
         * Sets the size of the temp allocator.
         * @param size Size in bytes.
         * @returns Returns true if requested size was successfully set. Will return false if value is disallowed (too small).
         */
        public static SetTempAllocatorRequestedSize($size: number):boolean;
        /**
         * Returns the size of the temp allocator.
         * @returns Size in bytes.
         */
        public static GetTempAllocatorSize():number;
        /**
         * The total memory allocated by the internal allocators in Unity. Unity reserves large pools of memory from the system. This function returns the amount of used memory in those pools.
         * @returns The amount of memory allocated by Unity. This returns 0 if the Profiler is not available.
         */
        public static GetTotalAllocatedMemoryLong():bigint;
        /**
         * Unity allocates memory in pools for usage when unity needs to allocate memory. This function returns the amount of unused memory in these pools.
         * @returns The amount of unused memory in the reserved pools. This returns 0 if the Profiler is not available.
         */
        public static GetTotalUnusedReservedMemoryLong():bigint;
        /**
         * The total memory Unity has reserved.
         * @returns Memory reserved by Unity in bytes. This returns 0 if the Profiler is not available.
         */
        public static GetTotalReservedMemoryLong():bigint;
        
        public static GetTotalFragmentationInfo($stats: Unity_Collections.NativeArray$1<number>):bigint;
        /**
         * Returns the amount of allocated memory for the graphics driver, in bytes.
         * Only available in development players and editor.
         */
        public static GetAllocatedMemoryForGraphicsDriver():bigint;
        /**
         * Write metadata associated with the current frame to the Profiler stream.
         * @param id Module identifier. Used to distinguish metadata streams between different plugins, packages or modules.
         * @param tag Data stream index.
         * @param data Binary data.
         */
        public static EmitFrameMetaData($id: System.Guid, $tag: number, $data: System.Array):void;
        
        public static EmitFrameMetaData<T>($id: System.Guid, $tag: number, $data: System_Collections_Generic.List$1<T>):void;
        
        public static EmitFrameMetaData<T>($id: System.Guid, $tag: number, $data: Unity_Collections.NativeArray$1<T>):void;
        
                    
    }
    /**
     * Records profiling data produced by a specific Sampler.
     */
    class Recorder extends System.Object {
        /**
         * Returns true if Recorder is valid and can collect data. (Read Only)
         */
        public get isValid(): boolean;
        /**
         * Enables recording.
         */
        public get enabled(): boolean;
        public set enabled(value: boolean);
        /**
         * Accumulated time of Begin/End pairs for the previous frame in nanoseconds. (Read Only)
         */
        public get elapsedNanoseconds(): bigint;
        /**
         * Gets the accumulated GPU time, in nanoseconds, for a frame. The Recorder has a three frame delay so this gives the timings for the frame that was three frames before the one that you access this property on. (Read Only).
         */
        public get gpuElapsedNanoseconds(): bigint;
        /**
         * Number of time Begin/End pairs was called during the previous frame. (Read Only)
         */
        public get sampleBlockCount(): number;
        /**
         * Gets the number of Begin/End time pairs that the GPU executed during a frame. The Recorder has a three frame delay so this gives the timings for the frame that was three frames before the one that you access this property on. (Read Only).
         */
        public get gpuSampleBlockCount(): number;
        /**
         * Use this function to get a Recorder for the specific Profiler label.
         * @param samplerName Sampler name.
         * @returns Recorder object for the specified Sampler.
         */
        public static Get($samplerName: string):Recorder;
        /**
         * Configures the recorder to only collect data from the current thread.
         */
        public FilterToCurrentThread():void;
        /**
         * Configures the recorder to collect samples from all threads.
         */
        public CollectFromAllThreads():void;
        
                    
    }
    /**
     * Provides control over a CPU Profiler label.
     */
    class Sampler extends System.Object {
        /**
         * Returns true if Sampler is valid. (Read Only)
         */
        public get isValid(): boolean;
        /**
         * Sampler name. (Read Only)
         */
        public get name(): string;
        /**
         * Returns Recorder associated with the Sampler.
         * @returns Recorder object associated with the Sampler.
         */
        public GetRecorder():Recorder;
        /**
         * Returns Sampler object for the specific CPU Profiler label.
         * @param name Profiler Sampler name.
         * @returns Sampler object which represents specific profiler label.
         */
        public static Get($name: string):Sampler;
        
        public static GetNames($names: System_Collections_Generic.List$1<string>):number;
        
                    
    }
    /**
     * Custom CPU Profiler label used for profiling arbitrary code blocks.
     */
    class CustomSampler extends Sampler {
        /**
         * Creates a new CustomSampler for profiling parts of your code.
         * @param name Name of the Sampler.
         * @param collectGpuData Specifies whether this Sampler records GPU timings. If you want the Sampler to record GPU timings, set this to true.
         * @returns CustomSampler object or null if a built-in Sampler with the same name exists.
         */
        public static Create($name: string, $collectGpuData?: boolean):CustomSampler;
        /**
         * Begin profiling a piece of code with a custom label defined by this instance of CustomSampler.
         */
        public Begin():void;
        /**
         * Begin profiling a piece of code with a custom label defined by this instance of CustomSampler.
         */
        public Begin($targetObject: UnityEngine.Object):void;
        /**
         * End profiling a piece of code with a custom label.
         */
        public End():void;
        
                    
    }
    
}
declare module 'UnityEngine.Profiling.Experimental' {

    import * as System from 'System';
    import * as Unity_Collections from 'Unity.Collections';
    import * as UnityEngine from 'UnityEngine';
        
    /**
     * A raw data representation of a screenshot.
     */
    class DebugScreenCapture extends System.ValueType {
        /**
         * A non-owning reference to the image data.
         */
        public get rawImageDataReference(): Unity_Collections.NativeArray$1<number>;
        public set rawImageDataReference(value: Unity_Collections.NativeArray$1<number>);
        /**
         * The format in which the image was captured.
         */
        public get imageFormat(): UnityEngine.TextureFormat;
        public set imageFormat(value: UnityEngine.TextureFormat);
        /**
         * Width of the image.
         */
        public get width(): number;
        public set width(value: number);
        /**
         * Height of the image.
         */
        public get height(): number;
        public set height(value: number);
        
                    
    }
    
}
declare module 'UnityEngine.Profiling.Memory.Experimental' {

    import * as System from 'System';
        
    /**
     * Flags that specify which fields to capture in a snapshot.
     */
    enum CaptureFlags { ManagedObjects = 1, NativeObjects = 2, NativeAllocations = 4, NativeAllocationSites = 8, NativeStackTraces = 16 }
    /**
     * Container for memory snapshot meta data.
     */
    class MetaData extends System.Object {
        /**
         * User defined meta data.
         */
        public content: string;
        /**
         * Memory snapshot meta data containing platform information.
         */
        public platform: string;
        
        public constructor();
        
                    
    }
    /**
     * Memory profiling API container class.
     */
    class MemoryProfiler extends System.Object {
        
        public constructor();
        
        public static add_createMetaData($value: System.Action$1<MetaData>):void;
        
        public static remove_createMetaData($value: System.Action$1<MetaData>):void;
        
        public static TakeSnapshot($path: string, $finishCallback: System.Action$2<string, boolean>, $captureFlags?: CaptureFlags):void;
        
        public static TakeSnapshot($path: string, $finishCallback: System.Action$2<string, boolean>, $screenshotCallback: System.Action$3<string, boolean, UnityEngine_Profiling_Experimental.DebugScreenCapture>, $captureFlags?: CaptureFlags):void;
        
        public static TakeTempSnapshot($finishCallback: System.Action$2<string, boolean>, $captureFlags?: CaptureFlags):void;
        
        public static createMetaData;
        
                    
    }
    
}
declare module 'UnityEngine.Jobs' {

    import * as System from 'System';
    import * as UnityEngine from 'UnityEngine';
    import * as Unity_Jobs from 'Unity.Jobs';
        
    /**
     * IJobParallelForTransform.
     */
    interface IJobParallelForTransform {
        /**
         * Execute.
         * @param index Index.
         * @param transform TransformAccessArray.
         */
        Execute($index: number, $transform: TransformAccess):void;
        
                    
    }
    /**
     * Position, rotation and scale of an object.
     */
    class TransformAccess extends System.ValueType {
        /**
         * The position of the transform in world space.
         */
        public get position(): UnityEngine.Vector3;
        public set position(value: UnityEngine.Vector3);
        /**
         * The rotation of the transform in world space stored as a Quaternion.
         */
        public get rotation(): UnityEngine.Quaternion;
        public set rotation(value: UnityEngine.Quaternion);
        /**
         * The position of the transform relative to the parent.
         */
        public get localPosition(): UnityEngine.Vector3;
        public set localPosition(value: UnityEngine.Vector3);
        /**
         * The rotation of the transform relative to the parent transform's rotation.
         */
        public get localRotation(): UnityEngine.Quaternion;
        public set localRotation(value: UnityEngine.Quaternion);
        /**
         * The scale of the transform relative to the parent.
         */
        public get localScale(): UnityEngine.Vector3;
        public set localScale(value: UnityEngine.Vector3);
        /**
         * Matrix that transforms a point from local space into world space (Read Only).
         */
        public get localToWorldMatrix(): UnityEngine.Matrix4x4;
        /**
         * Matrix that transforms a point from world space into local space (Read Only).
         */
        public get worldToLocalMatrix(): UnityEngine.Matrix4x4;
        /**
         * Use this to determine whether this instance refers to a valid Transform.
         */
        public get isValid(): boolean;
        
                    
    }
    /**
     * Extension methods for IJobParallelForTransform.
     */
    class IJobParallelForTransformExtensions extends System.Object {
        
        public static Schedule<T>($jobData: T, $transforms: TransformAccessArray, $dependsOn?: Unity_Jobs.JobHandle):Unity_Jobs.JobHandle;
        
        public static ScheduleReadOnly<T>($jobData: T, $transforms: TransformAccessArray, $batchSize: number, $dependsOn?: Unity_Jobs.JobHandle):Unity_Jobs.JobHandle;
        
        public static RunReadOnly<T>($jobData: T, $transforms: TransformAccessArray):void;
        
                    
    }
    /**
     * TransformAccessArray.
     */
    class TransformAccessArray extends System.ValueType {
        /**
         * isCreated.
         */
        public get isCreated(): boolean;
        /**
         * Returns array capacity.
         */
        public get capacity(): number;
        public set capacity(value: number);
        /**
         * Length.
         */
        public get length(): number;
        /**
         * Constructor.
         * @param transforms Transforms.
         * @param desiredJobCount Desired job count.
         * @param capacity Capacity.
         */
        public constructor($transforms: UnityEngine.Transform[], $desiredJobCount?: number);
        /**
         * Constructor.
         * @param transforms Transforms.
         * @param desiredJobCount Desired job count.
         * @param capacity Capacity.
         */
        public constructor($capacity: number, $desiredJobCount?: number);
        /**
         * Allocate.
         * @param capacity Capacity.
         * @param desiredJobCount Desired job count.
         * @param array TransformAccessArray.
         */
        public static Allocate($capacity: number, $desiredJobCount: number, $array: $Ref<TransformAccessArray>):void;
        /**
         * Dispose.
         */
        public Dispose():void;
        
        public get_Item($index: number):UnityEngine.Transform;
        
        public set_Item($index: number, $value: UnityEngine.Transform):void;
        /**
         * Add.
         * @param transform Transform.
         */
        public Add($transform: UnityEngine.Transform):void;
        /**
         * Remove item at index.
         * @param index Index.
         */
        public RemoveAtSwapBack($index: number):void;
        /**
         * Set transforms.
         * @param transforms Transforms.
         */
        public SetTransforms($transforms: UnityEngine.Transform[]):void;
        
                    
    }
    
}
declare module 'UnityEngine.tvOS' {

    import * as System from 'System';
        
    /**
     * A class for Apple TV remote input configuration.
     */
    class Remote extends System.Object {
        /**
         * Configures how "Menu" button behaves on Apple TV Remote. If this property is set to true hitting "Menu" on Remote will exit to system home screen. When this property is false current application is responsible for handling "Menu" button. It is recommended to set this property to true on top level menus of your application.
         */
        public static get allowExitToHome(): boolean;
        public static set allowExitToHome(value: boolean);
        /**
         * Configures if Apple TV Remote should autorotate all the inputs when Remote is being held in horizontal orientation. Default is false.
         */
        public static get allowRemoteRotation(): boolean;
        public static set allowRemoteRotation(value: boolean);
        /**
         * Configures how touches are mapped to analog joystick axes in relative or absolute values. If set to true it will return +1 on Horizontal axis when very far right is being touched on Remote touch aread (and -1 when very left area is touched correspondingly). The same applies for Vertical axis too. When this property is set to false player should swipe instead of touching specific area of remote to generate Horizontal or Vertical input.
         */
        public static get reportAbsoluteDpadValues(): boolean;
        public static set reportAbsoluteDpadValues(value: boolean);
        /**
         * Disables Apple TV Remote touch propagation to Unity Input.touches API. Useful for 3rd party frameworks, which do not respect Touch.type == Indirect.
         * Default is false.
         */
        public static get touchesEnabled(): boolean;
        public static set touchesEnabled(value: boolean);
        
        public constructor();
        
                    
    }
    /**
     * iOS device generation.
     */
    enum DeviceGeneration { Unknown = 0, AppleTV1Gen = 1001, AppleTV2Gen = 1002 }
    /**
     * Interface into tvOS specific functionality.
     */
    class Device extends System.Object {
        /**
         * iOS version.
         */
        public static get systemVersion(): string;
        /**
         * The generation of the device. (Read Only)
         */
        public static get generation(): DeviceGeneration;
        /**
         * Vendor ID.
         */
        public static get vendorIdentifier(): string;
        /**
         * Advertising ID.
         */
        public static get advertisingIdentifier(): string;
        /**
         * Is advertising tracking enabled.
         */
        public static get advertisingTrackingEnabled(): boolean;
        
        public constructor();
        /**
         * Set file flag to be excluded from iCloud/iTunes backup.
         */
        public static SetNoBackupFlag($path: string):void;
        /**
         * Reset "no backup" file flag: file will be synced with iCloud/iTunes backup and can be deleted by OS in low storage situations.
         */
        public static ResetNoBackupFlag($path: string):void;
        
                    
    }
    
}
declare module 'UnityEngine.iOS.ADBannerView' {

    import * as System from 'System';
        
    /**
     * Specifies how banner should be layed out on screen.
     */
    enum Layout { Top = 0, Bottom = 1, TopLeft = 0, TopRight = 4, TopCenter = 8, BottomLeft = 1, BottomRight = 5, BottomCenter = 9, CenterLeft = 2, CenterRight = 6, Center = 10, Manual = -1 }
    /**
     * The type of the banner view.
     */
    enum Type { Banner = 0, MediumRect = 1 }
    /**
     * Will be fired when banner was clicked.
     */
    type BannerWasClickedDelegate = () => void;
    var BannerWasClickedDelegate: {new (func: () => void): BannerWasClickedDelegate;}
    /**
     * Will be fired when banner loaded new ad.
     */
    type BannerWasLoadedDelegate = () => void;
    var BannerWasLoadedDelegate: {new (func: () => void): BannerWasLoadedDelegate;}
    /**
     * Will be fired when banner ad failed to load.
     */
    type BannerFailedToLoadDelegate = () => void;
    var BannerFailedToLoadDelegate: {new (func: () => void): BannerFailedToLoadDelegate;}
    
}
declare module 'UnityEngine.iOS.ADInterstitialAd' {

    import * as System from 'System';
        
    /**
     * Will be called when ad is ready to be shown.
     */
    type InterstitialWasLoadedDelegate = () => void;
    var InterstitialWasLoadedDelegate: {new (func: () => void): InterstitialWasLoadedDelegate;}
    /**
     * Will be called when user viewed ad contents: i.e. they went past the initial screen. Please note that it is impossible to determine if they clicked on any links in ad sequences that follows the initial screen.
     */
    type InterstitialWasViewedDelegate = () => void;
    var InterstitialWasViewedDelegate: {new (func: () => void): InterstitialWasViewedDelegate;}
    
}
declare module 'UnityEngine.Windows' {

    import * as System from 'System';
        
    /**
     * This class provides information regarding application's trial status and allows initiating application purchase.
     */
    class LicenseInformation extends System.Object {
        /**
         * Checks whether the application is installed in trial mode.
         */
        public static get isOnAppTrial(): boolean;
        /**
         * Attempts to purchase the app if it is in installed in trial mode.
         * @returns Purchase receipt.
         */
        public static PurchaseApp():string;
        
                    
    }
    /**
     * Exposes useful information related to crash reporting on Windows platforms.
     */
    class CrashReporting extends System.Object {
        /**
         * Returns the path to the crash report folder on Windows.
         */
        public static get crashReportFolder(): string;
        
                    
    }
    /**
     * Class representing cryptography algorithms.
     */
    class Crypto extends System.Object {
        /**
         * Computes MD5 hash value for the specified byte array.
         * @param buffer The input to compute the hash code for.
         */
        public static ComputeMD5Hash($buffer: number[]):number[];
        /**
         * Computes SHA1 hash value for the specified byte array.
         * @param buffer The input to compute the hash code for.
         */
        public static ComputeSHA1Hash($buffer: number[]):number[];
        
                    
    }
    /**
     * Exposes static methods for directory operations.
     */
    class Directory extends System.Object {
        /**
         * Returns a path to temporary folder.
         */
        public static get temporaryFolder(): string;
        /**
         * Returns a path to local folder.
         */
        public static get localFolder(): string;
        /**
         * Returns a path to roaming folder.
         */
        public static get roamingFolder(): string;
        /**
         * Creates directory in the specified path.
         * @param path The directory path to create.
         */
        public static CreateDirectory($path: string):void;
        /**
         * Determines whether the given path refers to an existing directory.
         * @param path The path to test.
         */
        public static Exists($path: string):boolean;
        /**
         * Deletes a directory from a specified path.
         * @param path The name of the directory to remove.
         */
        public static Delete($path: string):void;
        
                    
    }
    /**
     * Provides static methods for file operations.
     */
    class File extends System.Object {
        /**
         * Opens a binary file, reads the contents of the file into a byte array, and then closes the file.
         * @param path The file to open for reading.
         */
        public static ReadAllBytes($path: string):number[];
        /**
         * Creates a new file, writes the specified byte array to the file, and then closes the file. If the target file already exists, it is overwritten.
         * @param path The file to write to.
         * @param bytes The bytes to write to the file.
         */
        public static WriteAllBytes($path: string, $bytes: number[]):void;
        /**
         * Determines whether the specified file exists.
         * @param path The file to check.
         */
        public static Exists($path: string):boolean;
        /**
         * Deletes the specified file.
         * @param path The name of the file to be deleted.
         */
        public static Delete($path: string):void;
        
                    
    }
    
}
declare module 'UnityEngine.Windows.Speech' {

    import * as System from 'System';
    import * as UnityEngine_Windows_Speech_PhraseRecognitionSystem from 'UnityEngine.Windows.Speech.PhraseRecognitionSystem';
    import * as UnityEngine_Windows_Speech_PhraseRecognizer from 'UnityEngine.Windows.Speech.PhraseRecognizer';
    import * as UnityEngine_Windows_Speech_DictationRecognizer from 'UnityEngine.Windows.Speech.DictationRecognizer';
    import * as System_Collections_Generic from 'System.Collections.Generic';
        
    /**
     * Phrase recognition system is responsible for managing phrase recognizers and dispatching recognition events to them.
     */
    class PhraseRecognitionSystem extends System.Object {
        /**
         * Returns whether speech recognition is supported on the machine that the application is running on.
         */
        public static get isSupported(): boolean;
        /**
         * Returns the current status of the phrase recognition system.
         */
        public static get Status(): SpeechSystemStatus;
        /**
         * Attempts to restart the phrase recognition system.
         */
        public static Restart():void;
        /**
         * Shuts phrase recognition system down.
         */
        public static Shutdown():void;
        
        public static add_OnError($value: UnityEngine_Windows_Speech_PhraseRecognitionSystem.ErrorDelegate):void;
        
        public static remove_OnError($value: UnityEngine_Windows_Speech_PhraseRecognitionSystem.ErrorDelegate):void;
        
        public static add_OnStatusChanged($value: UnityEngine_Windows_Speech_PhraseRecognitionSystem.StatusDelegate):void;
        
        public static remove_OnStatusChanged($value: UnityEngine_Windows_Speech_PhraseRecognitionSystem.StatusDelegate):void;
        /**
         * Event that gets invoked when phrase recognition system encounters an error.
         * @param value Delegate that will be invoked when the event occurs.
         */
        public static OnError;
        /**
         * Event which occurs when the status of the phrase recognition system changes.
         * @param value Delegate that will be invoked when the event occurs.
         */
        public static OnStatusChanged;
        
                    
    }
    /**
     * Represents the current status of the speech recognition system or a dictation recognizer.
     */
    enum SpeechSystemStatus { Stopped = 0, Running = 1, Failed = 2 }
    /**
     * Represents an error in a speech recognition system.
     */
    enum SpeechError { NoError = 0, TopicLanguageNotSupported = 1, GrammarLanguageMismatch = 2, GrammarCompilationFailure = 3, AudioQualityFailure = 4, PauseLimitExceeded = 5, TimeoutExceeded = 6, NetworkFailure = 7, MicrophoneUnavailable = 8, UnknownError = 9 }
    /**
     * A common base class for both keyword recognizer and grammar recognizer.
     */
    class PhraseRecognizer extends System.Object {
        /**
         * Tells whether the phrase recognizer is listening for phrases.
         */
        public get IsRunning(): boolean;
        
        public add_OnPhraseRecognized($value: UnityEngine_Windows_Speech_PhraseRecognizer.PhraseRecognizedDelegate):void;
        
        public remove_OnPhraseRecognized($value: UnityEngine_Windows_Speech_PhraseRecognizer.PhraseRecognizedDelegate):void;
        /**
         * Makes the phrase recognizer start listening to phrases.
         */
        public Start():void;
        /**
         * Stops the phrase recognizer from listening to phrases.
         */
        public Stop():void;
        /**
         * Disposes the resources used by phrase recognizer.
         */
        public Dispose():void;
        /**
         * Event that gets fired when the phrase recognizer recognizes a phrase.
         * @param value Delegate that will be invoked when the event occurs.
         */
        public OnPhraseRecognized;
        
                    
    }
    /**
     * Provides information about a phrase recognized event.
     */
    class PhraseRecognizedEventArgs extends System.ValueType {
        /**
         * A measure of correct recognition certainty.
         */
        public confidence: ConfidenceLevel;
        /**
         * A semantic meaning of recognized phrase.
         */
        public semanticMeanings: SemanticMeaning[];
        /**
         * The text that was recognized.
         */
        public text: string;
        /**
         * The moment in time when uttering of the phrase began.
         */
        public phraseStartTime: Date;
        /**
         * The time it took for the phrase to be uttered.
         */
        public phraseDuration: System.TimeSpan;
        
                    
    }
    /**
     * DictationRecognizer listens to speech input and attempts to determine what phrase was uttered.
     */
    class DictationRecognizer extends System.Object {
        /**
         * Indicates the status of dictation recognizer.
         */
        public get Status(): SpeechSystemStatus;
        /**
         * The time length in seconds before dictation recognizer session ends due to lack of audio input.
         */
        public get AutoSilenceTimeoutSeconds(): number;
        public set AutoSilenceTimeoutSeconds(value: number);
        /**
         * The time length in seconds before dictation recognizer session ends due to lack of audio input in case there was no audio heard in the current session.
         */
        public get InitialSilenceTimeoutSeconds(): number;
        public set InitialSilenceTimeoutSeconds(value: number);
        /**
         * Create a DictationRecognizer with the specified minimum confidence and dictation topic constraint. Phrases under the specified minimum level will be ignored.
         * @param minimumConfidence The confidence level at which the recognizer will begin accepting phrases.
         * @param topic The dictation topic that this dictation recognizer should optimize its recognition for.
         */
        public constructor();
        /**
         * Create a DictationRecognizer with the specified minimum confidence and dictation topic constraint. Phrases under the specified minimum level will be ignored.
         * @param minimumConfidence The confidence level at which the recognizer will begin accepting phrases.
         * @param topic The dictation topic that this dictation recognizer should optimize its recognition for.
         */
        public constructor($confidenceLevel: ConfidenceLevel);
        /**
         * Create a DictationRecognizer with the specified minimum confidence and dictation topic constraint. Phrases under the specified minimum level will be ignored.
         * @param minimumConfidence The confidence level at which the recognizer will begin accepting phrases.
         * @param topic The dictation topic that this dictation recognizer should optimize its recognition for.
         */
        public constructor($topic: DictationTopicConstraint);
        /**
         * Create a DictationRecognizer with the specified minimum confidence and dictation topic constraint. Phrases under the specified minimum level will be ignored.
         * @param minimumConfidence The confidence level at which the recognizer will begin accepting phrases.
         * @param topic The dictation topic that this dictation recognizer should optimize its recognition for.
         */
        public constructor($minimumConfidence: ConfidenceLevel, $topic: DictationTopicConstraint);
        
        public add_DictationHypothesis($value: UnityEngine_Windows_Speech_DictationRecognizer.DictationHypothesisDelegate):void;
        
        public remove_DictationHypothesis($value: UnityEngine_Windows_Speech_DictationRecognizer.DictationHypothesisDelegate):void;
        
        public add_DictationResult($value: UnityEngine_Windows_Speech_DictationRecognizer.DictationResultDelegate):void;
        
        public remove_DictationResult($value: UnityEngine_Windows_Speech_DictationRecognizer.DictationResultDelegate):void;
        
        public add_DictationComplete($value: UnityEngine_Windows_Speech_DictationRecognizer.DictationCompletedDelegate):void;
        
        public remove_DictationComplete($value: UnityEngine_Windows_Speech_DictationRecognizer.DictationCompletedDelegate):void;
        
        public add_DictationError($value: UnityEngine_Windows_Speech_DictationRecognizer.DictationErrorHandler):void;
        
        public remove_DictationError($value: UnityEngine_Windows_Speech_DictationRecognizer.DictationErrorHandler):void;
        /**
         * Starts the dictation recognization session. Dictation recognizer can only be started if PhraseRecognitionSystem is not running.
         */
        public Start():void;
        /**
         * Stops the dictation recognization session.
         */
        public Stop():void;
        /**
         * Disposes the resources this dictation recognizer uses.
         */
        public Dispose():void;
        /**
         * Event that is triggered when the recognizer changes its hypothesis for the current fragment.
         * @param value Delegate to be triggered in the event of a hypothesis changed event.
         */
        public DictationHypothesis;
        /**
         * Event indicating a phrase has been recognized with the specified confidence level.
         * @param value The delegate to be triggered when this event is triggered.
         */
        public DictationResult;
        /**
         * Event that is triggered when the recognizer session completes.
         * @param value Delegate that is to be invoked on DictationComplete event.
         */
        public DictationComplete;
        /**
         * Event that is triggered when the recognizer session encouters an error.
         * @param value Delegate that is to be invoked on DictationError event.
         */
        public DictationError;
        
                    
    }
    /**
     * Used by KeywordRecognizer, GrammarRecognizer, DictationRecognizer. Phrases under the specified minimum level will be ignored.
     */
    enum ConfidenceLevel { High = 0, Medium = 1, Low = 2, Rejected = 3 }
    /**
     * Represents the reason why dictation session has completed.
     */
    enum DictationCompletionCause { Complete = 0, AudioQualityFailure = 1, Canceled = 2, TimeoutExceeded = 3, PauseLimitExceeded = 4, NetworkFailure = 5, MicrophoneUnavailable = 6, UnknownError = 7 }
    /**
     * DictationTopicConstraint enum specifies the scenario for which a specific dictation recognizer should optimize.
     */
    enum DictationTopicConstraint { WebSearch = 0, Form = 1, Dictation = 2 }
    /**
     * Semantic meaning is a collection of semantic properties of a recognized phrase. These semantic properties can be specified in SRGS grammar files.
     */
    class SemanticMeaning extends System.ValueType {
        /**
         * A key of semantic meaning.
         */
        public key: string;
        /**
         * Values of semantic property that the correspond to the semantic meaning key.
         */
        public values: string[];
        
                    
    }
    /**
     * KeywordRecognizer listens to speech input and attempts to match uttered phrases to a list of registered keywords.
     */
    class KeywordRecognizer extends PhraseRecognizer {
        /**
         * Returns the list of keywords which was supplied when the keyword recognizer was created.
         */
        public get Keywords(): System_Collections_Generic.IEnumerable$1<string>;
        /**
         * Create a KeywordRecognizer which listens to specified keywords with the specified minimum confidence.  Phrases under the specified minimum level will be ignored.
         * @param keywords The keywords that the recognizer will listen to.
         * @param minimumConfidence The minimum confidence level of speech recognition that the recognizer will accept.
         */
        public constructor($keywords: string[]);
        /**
         * Create a KeywordRecognizer which listens to specified keywords with the specified minimum confidence.  Phrases under the specified minimum level will be ignored.
         * @param keywords The keywords that the recognizer will listen to.
         * @param minimumConfidence The minimum confidence level of speech recognition that the recognizer will accept.
         */
        public constructor($keywords: string[], $minimumConfidence: ConfidenceLevel);
        
                    
    }
    /**
     * The GrammarRecognizer is a complement to the KeywordRecognizer. In many cases developers will find the KeywordRecognizer fills all their development needs. However, in some cases, more complex grammars will be better expressed in the form of an xml file on disk.
     * The GrammarRecognizer uses Extensible Markup Language (XML) elements and attributes, as specified in the World Wide Web Consortium (W3C) Speech Recognition Grammar Specification (SRGS) Version 1.0. These XML elements and attributes represent the rule structures that define the words or phrases (commands) recognized by speech recognition engines.
     */
    class GrammarRecognizer extends PhraseRecognizer {
        /**
         * Returns the grammar file path which was supplied when the grammar recognizer was created.
         */
        public get GrammarFilePath(): string;
        /**
         * Creates a grammar recognizer using specified file path and minimum confidence.
         * @param grammarFilePath Path of the grammar file.
         * @param minimumConfidence The confidence level at which the recognizer will begin accepting phrases.
         */
        public constructor($grammarFilePath: string);
        /**
         * Creates a grammar recognizer using specified file path and minimum confidence.
         * @param grammarFilePath Path of the grammar file.
         * @param minimumConfidence The confidence level at which the recognizer will begin accepting phrases.
         */
        public constructor($grammarFilePath: string, $minimumConfidence: ConfidenceLevel);
        
                    
    }
    
}
declare module 'UnityEngine.Windows.Speech.PhraseRecognitionSystem' {

    import * as UnityEngine_Windows_Speech from 'UnityEngine.Windows.Speech';
    import * as System from 'System';
        
    /**
     * Delegate for OnError event.
     * @param errorCode Error code for the error that occurred.
     */
    type ErrorDelegate = (errorCode: UnityEngine_Windows_Speech.SpeechError) => void;
    var ErrorDelegate: {new (func: (errorCode: UnityEngine_Windows_Speech.SpeechError) => void): ErrorDelegate;}
    /**
     * Delegate for OnStatusChanged event.
     * @param status The new status of the phrase recognition system.
     */
    type StatusDelegate = (status: UnityEngine_Windows_Speech.SpeechSystemStatus) => void;
    var StatusDelegate: {new (func: (status: UnityEngine_Windows_Speech.SpeechSystemStatus) => void): StatusDelegate;}
    
}
declare module 'UnityEngine.Windows.Speech.PhraseRecognizer' {

    import * as UnityEngine_Windows_Speech from 'UnityEngine.Windows.Speech';
    import * as System from 'System';
        
    /**
     * Delegate for OnPhraseRecognized event.
     * @param args Information about a phrase recognized event.
     */
    type PhraseRecognizedDelegate = (args: UnityEngine_Windows_Speech.PhraseRecognizedEventArgs) => void;
    var PhraseRecognizedDelegate: {new (func: (args: UnityEngine_Windows_Speech.PhraseRecognizedEventArgs) => void): PhraseRecognizedDelegate;}
    
}
declare module 'UnityEngine.Windows.Speech.DictationRecognizer' {

    import * as System from 'System';
    import * as UnityEngine_Windows_Speech from 'UnityEngine.Windows.Speech';
        
    /**
     * Callback indicating a hypothesis change event. You should register with DictationHypothesis event.
     * @param text The text that the recognizer believes may have been recognized.
     */
    type DictationHypothesisDelegate = (text: string) => void;
    var DictationHypothesisDelegate: {new (func: (text: string) => void): DictationHypothesisDelegate;}
    /**
     * Callback indicating a phrase has been recognized with the specified confidence level. You should register with DictationResult event.
     * @param text The recognized text.
     * @param confidence The confidence level at which the text was recognized.
     */
    type DictationResultDelegate = (text: string, confidence: UnityEngine_Windows_Speech.ConfidenceLevel) => void;
    var DictationResultDelegate: {new (func: (text: string, confidence: UnityEngine_Windows_Speech.ConfidenceLevel) => void): DictationResultDelegate;}
    /**
     * Delegate for DictationComplete event.
     * @param cause The cause of dictation session completion.
     */
    type DictationCompletedDelegate = (cause: UnityEngine_Windows_Speech.DictationCompletionCause) => void;
    var DictationCompletedDelegate: {new (func: (cause: UnityEngine_Windows_Speech.DictationCompletionCause) => void): DictationCompletedDelegate;}
    /**
     * Delegate for DictationError event.
     * @param error The error mesage.
     * @param hresult HRESULT code that corresponds to the error.
     */
    type DictationErrorHandler = (error: string, hresult: number) => void;
    var DictationErrorHandler: {new (func: (error: string, hresult: number) => void): DictationErrorHandler;}
    
}
declare module 'UnityEngine.Windows.WebCam' {

    import * as System from 'System';
    import * as UnityEngine_Windows_WebCam_PhotoCapture from 'UnityEngine.Windows.WebCam.PhotoCapture';
    import * as System_Collections_Generic from 'System.Collections.Generic';
    import * as UnityEngine from 'UnityEngine';
    import * as UnityEngine_Windows_WebCam_VideoCapture from 'UnityEngine.Windows.WebCam.VideoCapture';
        
    /**
     * Image Encoding Format.
     */
    enum PhotoCaptureFileOutputFormat { PNG = 0, JPG = 1 }
    /**
     * Captures a photo from the web camera and stores it in memory or on disk.
     */
    class PhotoCapture extends System.Object {
        /**
         * A list of all the supported device resolutions for taking pictures.
         */
        public static get SupportedResolutions(): System_Collections_Generic.IEnumerable$1<UnityEngine.Resolution>;
        /**
         * Asynchronously creates an instance of a PhotoCapture object that can be used to capture photos.
         * @param showHolograms Will allow you to capture holograms in your photo.
         * @param onCreatedCallback This callback will be invoked when the PhotoCapture instance is created and ready to be used.
         */
        public static CreateAsync($showHolograms: boolean, $onCreatedCallback: UnityEngine_Windows_WebCam_PhotoCapture.OnCaptureResourceCreatedCallback):void;
        /**
         * Asynchronously creates an instance of a PhotoCapture object that can be used to capture photos.
         * @param showHolograms Will allow you to capture holograms in your photo.
         * @param onCreatedCallback This callback will be invoked when the PhotoCapture instance is created and ready to be used.
         */
        public static CreateAsync($onCreatedCallback: UnityEngine_Windows_WebCam_PhotoCapture.OnCaptureResourceCreatedCallback):void;
        /**
         * Asynchronously starts photo mode.
         * @param setupParams The various settings that should be applied to the web camera.
         * @param onPhotoModeStartedCallback This callback will be invoked once photo mode has been activated.
         */
        public StartPhotoModeAsync($setupParams: CameraParameters, $onPhotoModeStartedCallback: UnityEngine_Windows_WebCam_PhotoCapture.OnPhotoModeStartedCallback):void;
        /**
         * Asynchronously stops photo mode.
         * @param onPhotoModeStoppedCallback This callback will be invoked once photo mode has been deactivated.
         */
        public StopPhotoModeAsync($onPhotoModeStoppedCallback: UnityEngine_Windows_WebCam_PhotoCapture.OnPhotoModeStoppedCallback):void;
        /**
         * Asynchronously captures a photo from the web camera and saves it to disk.
         * @param filename The location where the photo should be saved.  The filename must end with a png or jpg file extension.
         * @param fileOutputFormat The encoding format that should be used.
         * @param onCapturedPhotoToDiskCallback Invoked once the photo has been saved to disk.
         * @param onCapturedPhotoToMemoryCallback Invoked once the photo has been copied to the target texture.
         */
        public TakePhotoAsync($filename: string, $fileOutputFormat: PhotoCaptureFileOutputFormat, $onCapturedPhotoToDiskCallback: UnityEngine_Windows_WebCam_PhotoCapture.OnCapturedToDiskCallback):void;
        /**
         * Asynchronously captures a photo from the web camera and saves it to disk.
         * @param filename The location where the photo should be saved.  The filename must end with a png or jpg file extension.
         * @param fileOutputFormat The encoding format that should be used.
         * @param onCapturedPhotoToDiskCallback Invoked once the photo has been saved to disk.
         * @param onCapturedPhotoToMemoryCallback Invoked once the photo has been copied to the target texture.
         */
        public TakePhotoAsync($onCapturedPhotoToMemoryCallback: UnityEngine_Windows_WebCam_PhotoCapture.OnCapturedToMemoryCallback):void;
        /**
         * Provides a COM pointer to the native IVideoDeviceController.
         * @returns A native COM pointer to the IVideoDeviceController.
         */
        public GetUnsafePointerToVideoDeviceController():System.IntPtr;
        /**
         * Dispose must be called to shutdown the PhotoCapture instance.
         */
        public Dispose():void;
        
                    
    }
    /**
     * When calling PhotoCapture.StartPhotoModeAsync, you must pass in a CameraParameters object that contains the various settings that the web camera will use.
     */
    class CameraParameters extends System.ValueType {
        /**
         * The opacity of captured holograms.
         */
        public get hologramOpacity(): number;
        public set hologramOpacity(value: number);
        /**
         * The framerate at which to capture video.  This is only for use with VideoCapture.
         */
        public get frameRate(): number;
        public set frameRate(value: number);
        /**
         * A valid width resolution for use with the web camera.
         */
        public get cameraResolutionWidth(): number;
        public set cameraResolutionWidth(value: number);
        /**
         * A valid height resolution for use with the web camera.
         */
        public get cameraResolutionHeight(): number;
        public set cameraResolutionHeight(value: number);
        /**
         * The pixel format used to capture and record your image data.
         */
        public get pixelFormat(): CapturePixelFormat;
        public set pixelFormat(value: CapturePixelFormat);
        
        public constructor($webCamMode: WebCamMode);
        
        public get_Clone(): CameraParameters;            
    }
    /**
     * Contains information captured from the web camera.
     */
    class PhotoCaptureFrame extends System.Object {
        /**
         * The length of the raw IMFMediaBuffer which contains the image captured.
         */
        public get dataLength(): number;
        /**
         * Specifies whether or not spatial data was captured.
         */
        public get hasLocationData(): boolean;
        /**
         * The raw image data pixel format.
         */
        public get pixelFormat(): CapturePixelFormat;
        /**
         * This method will return the camera to world matrix at the time the photo was captured if location data if available.
         * @param cameraToWorldMatrix A matrix to be populated by the Camera to world Matrix.
         * @returns True if a valid matrix is returned or false otherwise.  This will be false if the frame has no location data.
         */
        public TryGetCameraToWorldMatrix($cameraToWorldMatrix: $Ref<UnityEngine.Matrix4x4>):boolean;
        /**
         * This method will return the projection matrix at the time the photo was captured if location data if available.
         * @param nearClipPlane The near clip plane distance.
         * @param farClipPlane The far clip plane distance.
         * @param projectionMatrix A matrix to be populated by the Projection Matrix.
         * @returns True if a valid matrix is returned or false otherwise.  This will be false if the frame has no location data.
         */
        public TryGetProjectionMatrix($projectionMatrix: $Ref<UnityEngine.Matrix4x4>):boolean;
        /**
         * This method will return the projection matrix at the time the photo was captured if location data if available.
         * @param nearClipPlane The near clip plane distance.
         * @param farClipPlane The far clip plane distance.
         * @param projectionMatrix A matrix to be populated by the Projection Matrix.
         * @returns True if a valid matrix is returned or false otherwise.  This will be false if the frame has no location data.
         */
        public TryGetProjectionMatrix($nearClipPlane: number, $farClipPlane: number, $projectionMatrix: $Ref<UnityEngine.Matrix4x4>):boolean;
        /**
         * This method will copy the captured image data into a user supplied texture for use in Unity.
         * @param targetTexture The target texture that the captured image data will be copied to.
         */
        public UploadImageDataToTexture($targetTexture: UnityEngine.Texture2D):void;
        /**
         * Provides a COM pointer to the native IMFMediaBuffer that contains the image data.
         * @returns A native COM pointer to the IMFMediaBuffer which contains the image data.
         */
        public GetUnsafePointerToBuffer():System.IntPtr;
        
        public CopyRawImageDataIntoBuffer($byteBuffer: System_Collections_Generic.List$1<number>):void;
        /**
         * Disposes the PhotoCaptureFrame and any resources it uses.
         */
        public Dispose():void;
        
                    
    }
    /**
     * The encoded image or video pixel format to use for PhotoCapture and VideoCapture.
     */
    enum CapturePixelFormat { BGRA32 = 0, NV12 = 1, JPEG = 2, PNG = 3 }
    /**
     * Records a video from the web camera directly to disk.
     */
    class VideoCapture extends System.Object {
        /**
         * A list of all the supported device resolutions for recording videos.
         */
        public static get SupportedResolutions(): System_Collections_Generic.IEnumerable$1<UnityEngine.Resolution>;
        /**
         * Indicates whether or not the VideoCapture instance is currently recording video.
         */
        public get IsRecording(): boolean;
        /**
         * Returns the supported frame rates at which a video can be recorded given a resolution.
         * @param resolution A recording resolution.
         * @returns The frame rates at which the video can be recorded.
         */
        public static GetSupportedFrameRatesForResolution($resolution: UnityEngine.Resolution):System_Collections_Generic.IEnumerable$1<number>;
        /**
         * Asynchronously creates an instance of a VideoCapture object that can be used to record videos from the web camera to disk.
         * @param showHolograms Allows capturing holograms in your video.
        Note: Capturing holograms is currently disabled and this parameter is ignored.
         * @param onCreatedCallback This callback will be invoked when the VideoCapture instance is created and ready to be used.
         */
        public static CreateAsync($showHolograms: boolean, $onCreatedCallback: UnityEngine_Windows_WebCam_VideoCapture.OnVideoCaptureResourceCreatedCallback):void;
        /**
         * Asynchronously creates an instance of a VideoCapture object that can be used to record videos from the web camera to disk.
         * @param showHolograms Allows capturing holograms in your video.
        Note: Capturing holograms is currently disabled and this parameter is ignored.
         * @param onCreatedCallback This callback will be invoked when the VideoCapture instance is created and ready to be used.
         */
        public static CreateAsync($onCreatedCallback: UnityEngine_Windows_WebCam_VideoCapture.OnVideoCaptureResourceCreatedCallback):void;
        /**
         * Asynchronously starts video mode.
         * @param setupParams The various settings that should be applied to the web camera.
         * @param audioState Indicates how audio should be recorded.
         * @param onVideoModeStartedCallback This callback will be invoked once video mode has been activated.
         */
        public StartVideoModeAsync($setupParams: CameraParameters, $audioState: UnityEngine_Windows_WebCam_VideoCapture.AudioState, $onVideoModeStartedCallback: UnityEngine_Windows_WebCam_VideoCapture.OnVideoModeStartedCallback):void;
        /**
         * Asynchronously stops video mode.
         * @param onVideoModeStoppedCallback This callback will be invoked once video mode has been deactivated.
         */
        public StopVideoModeAsync($onVideoModeStoppedCallback: UnityEngine_Windows_WebCam_VideoCapture.OnVideoModeStoppedCallback):void;
        /**
         * Asynchronously records a video from the web camera to the file system.
         * @param filename The name of the video to be recorded to.
         * @param onStartedRecordingVideoCallback Invoked as soon as the video recording begins.
         */
        public StartRecordingAsync($filename: string, $onStartedRecordingVideoCallback: UnityEngine_Windows_WebCam_VideoCapture.OnStartedRecordingVideoCallback):void;
        /**
         * Asynchronously stops recording a video from the web camera to the file system.
         * @param onStoppedRecordingVideoCallback Invoked as soon as video recording has finished.
         */
        public StopRecordingAsync($onStoppedRecordingVideoCallback: UnityEngine_Windows_WebCam_VideoCapture.OnStoppedRecordingVideoCallback):void;
        /**
         * Provides a COM pointer to the native IVideoDeviceController.
         * @returns A native COM pointer to the IVideoDeviceController.
         */
        public GetUnsafePointerToVideoDeviceController():System.IntPtr;
        /**
         * You must call Dispose to shutdown the VideoCapture instance and release the native WinRT objects.
         */
        public Dispose():void;
        
                    
    }
    /**
     * Describes the active mode of the Web Camera resource.
     */
    enum WebCamMode { None = 0, PhotoMode = 1, VideoMode = 2 }
    /**
     * Contains general information about the current state of the web camera.
     */
    class WebCam extends System.Object {
        /**
         * Specifies what mode the Web Camera is currently in.
         */
        public static get Mode(): WebCamMode;
        
        public constructor();
        
                    
    }
    
}
declare module 'UnityEngine.Windows.WebCam.PhotoCapture' {

    import * as UnityEngine_Windows_WebCam from 'UnityEngine.Windows.WebCam';
    import * as System from 'System';
        
    /**
     * Called when a PhotoCapture resource has been created.
     * @param captureObject The PhotoCapture instance.
     */
    type OnCaptureResourceCreatedCallback = (captureObject: UnityEngine_Windows_WebCam.PhotoCapture) => void;
    var OnCaptureResourceCreatedCallback: {new (func: (captureObject: UnityEngine_Windows_WebCam.PhotoCapture) => void): OnCaptureResourceCreatedCallback;}
    /**
     * Called when photo mode has been started.
     * @param result Indicates whether or not photo mode was successfully activated.
     */
    type OnPhotoModeStartedCallback = (result: PhotoCaptureResult) => void;
    var OnPhotoModeStartedCallback: {new (func: (result: PhotoCaptureResult) => void): OnPhotoModeStartedCallback;}
    /**
     * A data container that contains the result information of a photo capture operation.
     */
    class PhotoCaptureResult extends System.ValueType {
        
        public resultType: CaptureResultType;
        
        public hResult: bigint;
        
        public get success(): boolean;
        
        public get_Clone(): PhotoCaptureResult;            
    }
    /**
     * Called when photo mode has been stopped.
     * @param result Indicates whether or not photo mode was successfully deactivated.
     */
    type OnPhotoModeStoppedCallback = (result: PhotoCaptureResult) => void;
    var OnPhotoModeStoppedCallback: {new (func: (result: PhotoCaptureResult) => void): OnPhotoModeStoppedCallback;}
    /**
     * Called when a photo has been saved to the file system.
     * @param result Indicates whether or not the photo was successfully saved to the file system.
     */
    type OnCapturedToDiskCallback = (result: PhotoCaptureResult) => void;
    var OnCapturedToDiskCallback: {new (func: (result: PhotoCaptureResult) => void): OnCapturedToDiskCallback;}
    /**
     * Called when a photo has been captured to memory.
     * @param result Indicates whether or not the photo was successfully captured to memory.
     * @param photoCaptureFrame Contains the target texture.  If available, the spatial information will be accessible through this structure as well.
     */
    type OnCapturedToMemoryCallback = (result: PhotoCaptureResult, photoCaptureFrame: UnityEngine_Windows_WebCam.PhotoCaptureFrame) => void;
    var OnCapturedToMemoryCallback: {new (func: (result: PhotoCaptureResult, photoCaptureFrame: UnityEngine_Windows_WebCam.PhotoCaptureFrame) => void): OnCapturedToMemoryCallback;}
    /**
     * Contains the result of the capture request.
     */
    enum CaptureResultType { Success = 0, UnknownError = 1 }
    
}
declare module 'UnityEngine.Windows.WebCam.VideoCapture' {

    import * as UnityEngine_Windows_WebCam from 'UnityEngine.Windows.WebCam';
    import * as System from 'System';
        
    /**
     * Called when a VideoCapture resource has been created.
     * @param captureObject The VideoCapture instance.
     */
    type OnVideoCaptureResourceCreatedCallback = (captureObject: UnityEngine_Windows_WebCam.VideoCapture) => void;
    var OnVideoCaptureResourceCreatedCallback: {new (func: (captureObject: UnityEngine_Windows_WebCam.VideoCapture) => void): OnVideoCaptureResourceCreatedCallback;}
    /**
     * Specifies what audio sources should be recorded while recording the video.
     */
    enum AudioState { MicAudio = 0, ApplicationAudio = 1, ApplicationAndMicAudio = 2, None = 3 }
    /**
     * Called when video mode has been started.
     * @param result Indicates whether or not video mode was successfully activated.
     */
    type OnVideoModeStartedCallback = (result: VideoCaptureResult) => void;
    var OnVideoModeStartedCallback: {new (func: (result: VideoCaptureResult) => void): OnVideoModeStartedCallback;}
    /**
     * A data container that contains the result information of a video recording operation.
     */
    class VideoCaptureResult extends System.ValueType {
        
        public resultType: CaptureResultType;
        
        public hResult: bigint;
        
        public get success(): boolean;
        
        public get_Clone(): VideoCaptureResult;            
    }
    /**
     * Called when video mode has been stopped.
     * @param result Indicates whether or not video mode was successfully deactivated.
     */
    type OnVideoModeStoppedCallback = (result: VideoCaptureResult) => void;
    var OnVideoModeStoppedCallback: {new (func: (result: VideoCaptureResult) => void): OnVideoModeStoppedCallback;}
    /**
     * Called when the web camera begins recording the video.
     * @param result Indicates whether or not video recording started successfully.
     */
    type OnStartedRecordingVideoCallback = (result: VideoCaptureResult) => void;
    var OnStartedRecordingVideoCallback: {new (func: (result: VideoCaptureResult) => void): OnStartedRecordingVideoCallback;}
    /**
     * Called when the video recording has been saved to the file system.
     * @param result Indicates whether or not video recording was saved successfully to the file system.
     */
    type OnStoppedRecordingVideoCallback = (result: VideoCaptureResult) => void;
    var OnStoppedRecordingVideoCallback: {new (func: (result: VideoCaptureResult) => void): OnStoppedRecordingVideoCallback;}
    /**
     * Contains the result of the capture request.
     */
    enum CaptureResultType { Success = 0, UnknownError = 1 }
    
}
declare module 'UnityEngine.WSA' {

    import * as System from 'System';
    import * as UnityEngine from 'UnityEngine';
        
    /**
     * Delegate that can be invoked on specific thread.
     */
    type AppCallbackItem = () => void;
    var AppCallbackItem: {new (func: () => void): AppCallbackItem;}
    /**
     * This event occurs when window rendering size changes.
     */
    type WindowSizeChanged = (width: number, height: number) => void;
    var WindowSizeChanged: {new (func: (width: number, height: number) => void): WindowSizeChanged;}
    /**
     * Specifies the set of reasons that a windowActivated event was raised.
     */
    enum WindowActivationState { CodeActivated = 0, Deactivated = 1, PointerActivated = 2 }
    /**
     * This event occurs when window completes activation or deactivation, it also fires up when you snap and unsnap the application.
     */
    type WindowActivated = (state: WindowActivationState) => void;
    var WindowActivated: {new (func: (state: WindowActivationState) => void): WindowActivated;}
    /**
     * Provides essential methods related to Window Store application.
     */
    class Application extends System.Object {
        /**
         * Arguments passed to application.
         */
        public static get arguments(): string;
        /**
         * Advertising ID.
         */
        public static get advertisingIdentifier(): string;
        
        public constructor();
        
        public static add_windowSizeChanged($value: WindowSizeChanged):void;
        
        public static remove_windowSizeChanged($value: WindowSizeChanged):void;
        
        public static add_windowActivated($value: WindowActivated):void;
        
        public static remove_windowActivated($value: WindowActivated):void;
        /**
         * Executes callback item on application thread.
         * @param item Item to execute.
         * @param waitUntilDone Wait until item is executed.
         */
        public static InvokeOnAppThread($item: AppCallbackItem, $waitUntilDone: boolean):void;
        /**
         * Executes callback item on UI thread.
         * @param item Item to execute.
         * @param waitUntilDone Wait until item is executed.
         */
        public static InvokeOnUIThread($item: AppCallbackItem, $waitUntilDone: boolean):void;
        /**
         * Returns true if you're running on application thread.
         */
        public static RunningOnAppThread():boolean;
        /**
         * Returns true if you're running on UI thread.
         */
        public static RunningOnUIThread():boolean;
        /**
         * Fired when window size changes.
         */
        public static windowSizeChanged;
        /**
         * Fired when application window is activated.
         */
        public static windowActivated;
        
                    
    }
    /**
     * Cursor API for Windows Store Apps.
     */
    class Cursor extends System.Object {
        /**
         * Set a custom cursor.
         * @param id The cursor resource id.
         */
        public static SetCustomCursor($id: number):void;
        
                    
    }
    /**
     * List of accessible folders on Windows Store Apps.
     */
    enum Folder { Installation = 0, Temporary = 1, Local = 2, Roaming = 3, CameraRoll = 4, DocumentsLibrary = 5, HomeGroup = 6, MediaServerDevices = 7, MusicLibrary = 8, PicturesLibrary = 9, Playlists = 10, RemovableDevices = 11, SavedPictures = 12, VideosLibrary = 13 }
    /**
     * Class which is capable of launching user's default app for file type or a protocol. See also PlayerSettings where you can specify file or URI associations.
     */
    class Launcher extends System.Object {
        
        public constructor();
        /**
         * Launches the default app associated with specified file.
         * @param folder Folder type where the file is located.
         * @param relativeFilePath Relative file path inside the specified folder.
         * @param showWarning Shows user a warning that application will be switched.
         */
        public static LaunchFile($folder: Folder, $relativeFilePath: string, $showWarning: boolean):void;
        /**
         * Opens a dialog for picking the file.
         * @param fileExtension File extension.
         */
        public static LaunchFileWithPicker($fileExtension: string):void;
        /**
         * Starts the default app associated with the URI scheme name for the specified URI, using the specified options.
         * @param uri The URI.
         * @param showWarning Displays a warning that the URI is potentially unsafe.
         */
        public static LaunchUri($uri: string, $showWarning: boolean):void;
        
                    
    }
    /**
     * Templates for various tile styles.
     */
    enum TileTemplate { TileSquare150x150Image = 0, TileSquare150x150Block = 1, TileSquare150x150Text01 = 2, TileSquare150x150Text02 = 3, TileSquare150x150Text03 = 4, TileSquare150x150Text04 = 5, TileSquare150x150PeekImageAndText01 = 6, TileSquare150x150PeekImageAndText02 = 7, TileSquare150x150PeekImageAndText03 = 8, TileSquare150x150PeekImageAndText04 = 9, TileWide310x150Image = 10, TileWide310x150ImageCollection = 11, TileWide310x150ImageAndText01 = 12, TileWide310x150ImageAndText02 = 13, TileWide310x150BlockAndText01 = 14, TileWide310x150BlockAndText02 = 15, TileWide310x150PeekImageCollection01 = 16, TileWide310x150PeekImageCollection02 = 17, TileWide310x150PeekImageCollection03 = 18, TileWide310x150PeekImageCollection04 = 19, TileWide310x150PeekImageCollection05 = 20, TileWide310x150PeekImageCollection06 = 21, TileWide310x150PeekImageAndText01 = 22, TileWide310x150PeekImageAndText02 = 23, TileWide310x150PeekImage01 = 24, TileWide310x150PeekImage02 = 25, TileWide310x150PeekImage03 = 26, TileWide310x150PeekImage04 = 27, TileWide310x150PeekImage05 = 28, TileWide310x150PeekImage06 = 29, TileWide310x150SmallImageAndText01 = 30, TileWide310x150SmallImageAndText02 = 31, TileWide310x150SmallImageAndText03 = 32, TileWide310x150SmallImageAndText04 = 33, TileWide310x150SmallImageAndText05 = 34, TileWide310x150Text01 = 35, TileWide310x150Text02 = 36, TileWide310x150Text03 = 37, TileWide310x150Text04 = 38, TileWide310x150Text05 = 39, TileWide310x150Text06 = 40, TileWide310x150Text07 = 41, TileWide310x150Text08 = 42, TileWide310x150Text09 = 43, TileWide310x150Text10 = 44, TileWide310x150Text11 = 45, TileSquare310x310BlockAndText01 = 46, TileSquare310x310BlockAndText02 = 47, TileSquare310x310Image = 48, TileSquare310x310ImageAndText01 = 49, TileSquare310x310ImageAndText02 = 50, TileSquare310x310ImageAndTextOverlay01 = 51, TileSquare310x310ImageAndTextOverlay02 = 52, TileSquare310x310ImageAndTextOverlay03 = 53, TileSquare310x310ImageCollectionAndText01 = 54, TileSquare310x310ImageCollectionAndText02 = 55, TileSquare310x310ImageCollection = 56, TileSquare310x310SmallImagesAndTextList01 = 57, TileSquare310x310SmallImagesAndTextList02 = 58, TileSquare310x310SmallImagesAndTextList03 = 59, TileSquare310x310SmallImagesAndTextList04 = 60, TileSquare310x310Text01 = 61, TileSquare310x310Text02 = 62, TileSquare310x310Text03 = 63, TileSquare310x310Text04 = 64, TileSquare310x310Text05 = 65, TileSquare310x310Text06 = 66, TileSquare310x310Text07 = 67, TileSquare310x310Text08 = 68, TileSquare310x310TextList01 = 69, TileSquare310x310TextList02 = 70, TileSquare310x310TextList03 = 71, TileSquare310x310SmallImageAndText01 = 72, TileSquare310x310SmallImagesAndTextList05 = 73, TileSquare310x310Text09 = 74, TileSquare71x71IconWithBadge = 75, TileSquare150x150IconWithBadge = 76, TileWide310x150IconWithBadgeAndText = 77, TileSquare71x71Image = 78, TileTall150x310Image = 79, TileSquare99x99IconWithBadge = 1000, TileSquare210x210IconWithBadge = 1001, TileWide432x210IconWithBadgeAndText = 1002 }
    /**
     * Templates for various toast styles.
     */
    enum ToastTemplate { ToastImageAndText01 = 0, ToastImageAndText02 = 1, ToastImageAndText03 = 2, ToastImageAndText04 = 3, ToastText01 = 4, ToastText02 = 5, ToastText03 = 6, ToastText04 = 7 }
    /**
     * Style for foreground text on a secondary tile.
     */
    enum TileForegroundText { Default = -1, Dark = 0, Light = 1 }
    /**
     * Defines the default look of secondary tile.
     */
    class SecondaryTileData extends System.ValueType {
        /**
         * Arguments to be passed for application when secondary tile is activated.
         */
        public arguments: string;
        /**
         * Defines, whether backgroundColor should be used.
         */
        public backgroundColorSet: boolean;
        /**
         * Display name for secondary tile.
         */
        public displayName: string;
        /**
         * Defines the style for foreground text on a secondary tile.
         */
        public foregroundText: TileForegroundText;
        /**
         * Uri to logo, shown for secondary tile on lock screen.
         */
        public lockScreenBadgeLogo: string;
        /**
         * Whether to show secondary tile on lock screen.
         */
        public lockScreenDisplayBadgeAndTileText: boolean;
        /**
         * Phonetic name for secondary tile.
         */
        public phoneticName: string;
        /**
         * Defines whether secondary tile is copied to another device when application is installed by the same users account.
         */
        public roamingEnabled: boolean;
        /**
         * Defines whether the displayName should be shown on a medium secondary tile.
         */
        public showNameOnSquare150x150Logo: boolean;
        /**
         * Defines whether the displayName should be shown on a large secondary tile.
         */
        public showNameOnSquare310x310Logo: boolean;
        /**
         * Defines whether the displayName should be shown on a wide secondary tile.
         */
        public showNameOnWide310x150Logo: boolean;
        /**
         * Uri to the logo for medium size tile.
         */
        public square150x150Logo: string;
        /**
         * Uri to the logo shown on tile
         */
        public square30x30Logo: string;
        /**
         * Uri to the logo for large size tile.
         */
        public square310x310Logo: string;
        /**
         * Uri to the logo for small size tile.
         */
        public square70x70Logo: string;
        /**
         * Unique identifier within application for a secondary tile.
         */
        public tileId: string;
        /**
         * Uri to the logo for wide tile.
         */
        public wide310x150Logo: string;
        /**
         * Defines background color for secondary tile.
         */
        public get backgroundColor(): UnityEngine.Color32;
        public set backgroundColor(value: UnityEngine.Color32);
        /**
         * Constructor for SecondaryTileData, sets default values for all members.
         * @param id Unique identifier for secondary tile.
         * @param displayName A display name for a tile.
         */
        public constructor($id: string, $displayName: string);
        
                    
    }
    /**
     * Represents tile on Windows start screen
     */
    class Tile extends System.Object {
        /**
         * Returns applications main tile
         */
        public static get main(): Tile;
        /**
         * A unique string, identifying secondary tile
         */
        public get id(): string;
        /**
         * Whether secondary tile was approved (pinned to start screen) or rejected by user.
         */
        public get hasUserConsent(): boolean;
        /**
         * Whether secondary tile is pinned to start screen.
         */
        public get exists(): boolean;
        /**
         * Get template XML for tile notification.
         * @param templ A template identifier.
         * @returns String, which is an empty XML document to be filled and used for tile notification.
         */
        public static GetTemplate($templ: TileTemplate):string;
        /**
         * Send a notification for tile (update tiles look).
         * @param xml A string containing XML document for new tile look.
         * @param medium An uri to 150x150 image, shown on medium tile.
         * @param wide An uri to a 310x150 image to be shown on a wide tile (if such issupported).
         * @param large An uri to a 310x310 image to be shown on a large tile (if such is supported).
         * @param text A text to shown on a tile.
         */
        public Update($xml: string):void;
        /**
         * Send a notification for tile (update tiles look).
         * @param xml A string containing XML document for new tile look.
         * @param medium An uri to 150x150 image, shown on medium tile.
         * @param wide An uri to a 310x150 image to be shown on a wide tile (if such issupported).
         * @param large An uri to a 310x310 image to be shown on a large tile (if such is supported).
         * @param text A text to shown on a tile.
         */
        public Update($medium: string, $wide: string, $large: string, $text: string):void;
        /**
         * Starts periodic update of a tile.
         * @param uri a remote location fromwhere to retrieve tile update
         * @param interval a time interval in minutes, will be rounded to a value, supported by the system
         */
        public PeriodicUpdate($uri: string, $interval: number):void;
        /**
         * Stops previously started periodic update of a tile.
         */
        public StopPeriodicUpdate():void;
        /**
         * Sets or updates badge on a tile to an image.
         * @param image Image identifier.
         */
        public UpdateBadgeImage($image: string):void;
        /**
         * Set or update a badge on a tile to a number.
         * @param number Number to be shown on a badge.
         */
        public UpdateBadgeNumber($number: number):void;
        /**
         * Remove badge from tile.
         */
        public RemoveBadge():void;
        /**
         * Starts periodic update of a  badge on a tile.
         * @param uri A remote location from where to retrieve tile update
         * @param interval A time interval in minutes, will be rounded to a value, supported by the system
         */
        public PeriodicBadgeUpdate($uri: string, $interval: number):void;
        /**
         * Stops previously started periodic update of a tile.
         */
        public StopPeriodicBadgeUpdate():void;
        /**
         * Whether secondary tile is pinned to start screen.
         * @param tileId An identifier for secondary tile.
         */
        public static Exists($tileId: string):boolean;
        /**
         * Creates new or updates existing secondary tile.
         * @param data The data used to create or update secondary tile.
         * @param pos The coordinates for a request to create new tile.
         * @param area The area on the screen above which the request to create new tile will be displayed.
         * @returns New Tile object, that can be used for further work with the tile.
         */
        public static CreateOrUpdateSecondary($data: SecondaryTileData):Tile;
        /**
         * Creates new or updates existing secondary tile.
         * @param data The data used to create or update secondary tile.
         * @param pos The coordinates for a request to create new tile.
         * @param area The area on the screen above which the request to create new tile will be displayed.
         * @returns New Tile object, that can be used for further work with the tile.
         */
        public static CreateOrUpdateSecondary($data: SecondaryTileData, $pos: UnityEngine.Vector2):Tile;
        /**
         * Creates new or updates existing secondary tile.
         * @param data The data used to create or update secondary tile.
         * @param pos The coordinates for a request to create new tile.
         * @param area The area on the screen above which the request to create new tile will be displayed.
         * @returns New Tile object, that can be used for further work with the tile.
         */
        public static CreateOrUpdateSecondary($data: SecondaryTileData, $area: UnityEngine.Rect):Tile;
        /**
         * Returns the secondary tile, identified by tile id.
         * @param tileId A tile identifier.
         * @returns A Tile object or null if secondary tile does not exist (not pinned to start screen and user request is complete).
         */
        public static GetSecondary($tileId: string):Tile;
        /**
         * Gets all secondary tiles.
         * @returns An array of Tile objects.
         */
        public static GetSecondaries():Tile[];
        /**
         * Show a request to unpin secondary tile from start screen.
         * @param pos The coordinates for a request to unpin tile.
         * @param area The area on the screen above which the request to unpin tile will be displayed.
         */
        public Delete():void;
        /**
         * Show a request to unpin secondary tile from start screen.
         * @param tileId An identifier for secondary tile.
         * @param pos The coordinates for a request to unpin tile.
         * @param area The area on the screen above which the request to unpin tile will be displayed.
         */
        public static DeleteSecondary($tileId: string):void;
        /**
         * Show a request to unpin secondary tile from start screen.
         * @param pos The coordinates for a request to unpin tile.
         * @param area The area on the screen above which the request to unpin tile will be displayed.
         */
        public Delete($pos: UnityEngine.Vector2):void;
        /**
         * Show a request to unpin secondary tile from start screen.
         * @param tileId An identifier for secondary tile.
         * @param pos The coordinates for a request to unpin tile.
         * @param area The area on the screen above which the request to unpin tile will be displayed.
         */
        public static DeleteSecondary($tileId: string, $pos: UnityEngine.Vector2):void;
        /**
         * Show a request to unpin secondary tile from start screen.
         * @param pos The coordinates for a request to unpin tile.
         * @param area The area on the screen above which the request to unpin tile will be displayed.
         */
        public Delete($area: UnityEngine.Rect):void;
        /**
         * Show a request to unpin secondary tile from start screen.
         * @param tileId An identifier for secondary tile.
         * @param pos The coordinates for a request to unpin tile.
         * @param area The area on the screen above which the request to unpin tile will be displayed.
         */
        public static DeleteSecondary($tileId: string, $area: UnityEngine.Rect):void;
        
                    
    }
    /**
     * Represents a toast notification in Windows Store Apps.
     */
    class Toast extends System.Object {
        /**
         * Arguments to be passed for application when toast notification is activated.
         */
        public get arguments(): string;
        public set arguments(value: string);
        /**
         * true if toast was activated by user.
         */
        public get activated(): boolean;
        /**
         * true if toast notification was dismissed (for any reason).
         */
        public get dismissed(): boolean;
        /**
         * true if toast notification was explicitly dismissed by user.
         */
        public get dismissedByUser(): boolean;
        /**
         * Get template XML for toast notification.
         * @param templ A template identifier.
         * @returns string, which is an empty XML document to be filled and used for toast notification.
         */
        public static GetTemplate($templ: ToastTemplate):string;
        /**
         * Create toast notification.
         * @param xml XML document with tile data.
         * @param image Uri to image to show on a toast, can be empty, in that case text-only notification will be shown.
         * @param text A text to display on a toast notification.
         * @returns A toast object for further work with created notification or null, if creation of toast failed.
         */
        public static Create($xml: string):Toast;
        /**
         * Create toast notification.
         * @param xml XML document with tile data.
         * @param image Uri to image to show on a toast, can be empty, in that case text-only notification will be shown.
         * @param text A text to display on a toast notification.
         * @returns A toast object for further work with created notification or null, if creation of toast failed.
         */
        public static Create($image: string, $text: string):Toast;
        /**
         * Show toast notification.
         */
        public Show():void;
        /**
         * Hide displayed toast notification.
         */
        public Hide():void;
        
                    
    }
    
}
declare module 'UnityEngine.Serialization' {

    import * as System from 'System';
    import * as System_Runtime_Serialization from 'System.Runtime.Serialization';
        
    /**
     * Use this attribute to rename a field without losing its serialized value.
     */
    class FormerlySerializedAsAttribute extends System.Attribute {
        /**
         * The name of the field before the rename.
         */
        public get oldName(): string;
        /**
         * @param oldName The name of the field before renaming.
         */
        public constructor($oldName: string);
        
                    
    }
    
    class UnitySurrogateSelector extends System.Object {
        
        public constructor();
        
        public GetSurrogate($type: System.Type, $context: System_Runtime_Serialization.StreamingContext, $selector: $Ref<System_Runtime_Serialization.ISurrogateSelector>):System_Runtime_Serialization.ISerializationSurrogate;
        
        public ChainSelector($selector: System_Runtime_Serialization.ISurrogateSelector):void;
        
        public GetNextSelector():System_Runtime_Serialization.ISurrogateSelector;
        
                    
    }
    
}
declare module 'System.Runtime.Serialization' {

    import * as System from 'System';
        
    
    interface ISerializationSurrogate {
        
                    
    }
    
    interface StreamingContext extends System.ValueType {
        
                    
    }
    
    interface ISurrogateSelector {
        
                    
    }
    
}
declare module 'UnityEngine.SearchService' {

    import * as System from 'System';
        
    /**
     * A class attribute that allows you to define label constraints on a MonoBehavior or ScriptableObject's field in the object selector.
     */
    class ObjectSelectorHandlerWithLabelsAttribute extends System.Attribute {
        /**
         * The labels to match.
         */
        public get labels(): string[];
        /**
         * Boolean that indicates whether all labels, or only one of them, should match. Default is true.
         */
        public get matchAll(): boolean;
        /**
         * Constructor used to declare the SearchService.ObjectSelectorHandlerWithLabelsAttribute on a field.
         * @param labels An array of strings that represents the different labels to use as constraints.
         * @param matchAll This parameter specifies whether all labels must match, or only one of them must be present.
         */
        public constructor(...labels: string[]);
        /**
         * Constructor used to declare the SearchService.ObjectSelectorHandlerWithLabelsAttribute on a field.
         * @param labels An array of strings that represents the different labels to use as constraints.
         * @param matchAll This parameter specifies whether all labels must match, or only one of them must be present.
         */
        public constructor($matchAll: boolean, ...labels: string[]);
        
                    
    }
    /**
     * A class attribute that allows you to define tag constraints on a MonoBehavior or ScriptableObject's field in the object selector.
     */
    class ObjectSelectorHandlerWithTagsAttribute extends System.Attribute {
        /**
         * The tags to match. Because a GameObject can only have one tag, only one of them must be present.
         */
        public get tags(): string[];
        /**
         * Constructor used to declare the SearchService.ObjectSelectorHandlerWithTagsAttribute on a field.
         * @param tags An array of strings that represents the different tags to use as constraints.
         */
        public constructor(...tags: string[]);
        
                    
    }
    
}
declare module 'UnityEngine.Scripting.GarbageCollector' {

    import * as System from 'System';
        
    /**
     * Garbage collector operation mode.
     */
    enum Mode { Disabled = 0, Enabled = 1, Manual = 2 }
    
}
declare module 'UnityEngine.Scripting.APIUpdating' {

    import * as System from 'System';
        
    
    class MovedFromAttribute extends System.Attribute {
        
        public get IsInDifferentAssembly(): boolean;
        
        public constructor($autoUpdateAPI: boolean, $sourceNamespace?: string, $sourceAssembly?: string, $sourceClassName?: string);
        
        public constructor($sourceNamespace: string);
        
                    
    }
    
}
declare module 'UnityEngine.LowLevel' {

    import * as System from 'System';
    import * as UnityEngine_LowLevel_PlayerLoopSystem from 'UnityEngine.LowLevel.PlayerLoopSystem';
        
    /**
     * The representation of a single system being updated by the player loop in Unity.
     */
    class PlayerLoopSystem extends System.ValueType {
        /**
         * This property is used to identify which native system this belongs to, or to get the name of the managed system to show in the profiler.
         */
        public type: System.Type;
        /**
         * A list of sub systems which run as part of this item in the player loop.
         */
        public subSystemList: PlayerLoopSystem[];
        /**
         * A managed delegate. You can set this to create a new C# entrypoint in the player loop.
         */
        public updateDelegate: UnityEngine_LowLevel_PlayerLoopSystem.UpdateFunction;
        /**
         * A native engine system. To get a valid value for this, you must copy it from one of the PlayerLoopSystems returned by PlayerLoop.GetDefaultPlayerLoop.
         */
        public updateFunction: System.IntPtr;
        /**
         * The loop condition for a native engine system. To get a valid value for this, you must copy it from one of the PlayerLoopSystems returned by PlayerLoop.GetDefaultPlayerLoop.
         */
        public loopConditionFunction: System.IntPtr;
        
        public ToString():string;
        
                    
    }
    /**
     * The class representing the player loop in Unity.
     */
    class PlayerLoop extends System.Object {
        
        public constructor();
        /**
         * Returns the default update order of all engine systems in Unity.
         */
        public static GetDefaultPlayerLoop():PlayerLoopSystem;
        /**
         * Returns the current update order of all engine systems in Unity.
         */
        public static GetCurrentPlayerLoop():PlayerLoopSystem;
        /**
         * Set a new custom update order of all engine systems in Unity.
         */
        public static SetPlayerLoop($loop: PlayerLoopSystem):void;
        
                    
    }
    
}
declare module 'UnityEngine.LowLevel.PlayerLoopSystem' {

    import * as System from 'System';
        
    
    type UpdateFunction = () => void;
    var UpdateFunction: {new (func: () => void): UpdateFunction;}
    
}
declare module 'UnityEngine.PlayerLoop' {

    import * as System from 'System';
        
    /**
     * Update phase in the native player loop that waits for the operating system (OS) to flip the back buffer to the display and update the time in the engine.
     */
    class TimeUpdate extends System.ValueType {
        
        public get_Clone(): TimeUpdate;            
    }
    /**
     * Update phase in the native player loop.
     */
    class Initialization extends System.ValueType {
        
        public get_Clone(): Initialization;            
    }
    /**
     * Update phase in the native player loop.
     */
    class EarlyUpdate extends System.ValueType {
        
        public get_Clone(): EarlyUpdate;            
    }
    /**
     * Update phase in the native player loop.
     */
    class FixedUpdate extends System.ValueType {
        
        public get_Clone(): FixedUpdate;            
    }
    /**
     * Update phase in the native player loop.
     */
    class PreUpdate extends System.ValueType {
        
        public get_Clone(): PreUpdate;            
    }
    /**
     * Update phase in the native player loop.
     */
    class Update extends System.ValueType {
        
        public get_Clone(): Update;            
    }
    /**
     * Update phase in the native player loop.
     */
    class PreLateUpdate extends System.ValueType {
        
        public get_Clone(): PreLateUpdate;            
    }
    /**
     * Update phase in the native player loop.
     */
    class PostLateUpdate extends System.ValueType {
        
        public get_Clone(): PostLateUpdate;            
    }
    
}
declare module 'UnityEngine.PlayerLoop.TimeUpdate' {

    import * as System from 'System';
        
    /**
     * Waits for the operating system (OS) to flip the back buffer to the display and update the time in the engine.
     */
    class WaitForLastPresentationAndUpdateTime extends System.ValueType {
        
        public get_Clone(): WaitForLastPresentationAndUpdateTime;            
    }
    
}
declare module 'UnityEngine.PlayerLoop.Initialization' {

    import * as System from 'System';
        
    /**
     * Native engine system updated by the native player loop.
     */
    class UpdateCameraMotionVectors extends System.ValueType {
        
        public get_Clone(): UpdateCameraMotionVectors;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class DirectorSampleTime extends System.ValueType {
        
        public get_Clone(): DirectorSampleTime;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class AsyncUploadTimeSlicedUpdate extends System.ValueType {
        
        public get_Clone(): AsyncUploadTimeSlicedUpdate;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class SynchronizeState extends System.ValueType {
        
        public get_Clone(): SynchronizeState;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class SynchronizeInputs extends System.ValueType {
        
        public get_Clone(): SynchronizeInputs;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class XREarlyUpdate extends System.ValueType {
        
        public get_Clone(): XREarlyUpdate;            
    }
    
}
declare module 'UnityEngine.PlayerLoop.EarlyUpdate' {

    import * as System from 'System';
        
    /**
     * Native engine system updated by the native player loop.
     */
    class PollPlayerConnection extends System.ValueType {
        
        public get_Clone(): PollPlayerConnection;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class ProfilerStartFrame extends System.ValueType {
        
        public get_Clone(): ProfilerStartFrame;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class PollHtcsPlayerConnection extends System.ValueType {
        
        public get_Clone(): PollHtcsPlayerConnection;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class GpuTimestamp extends System.ValueType {
        
        public get_Clone(): GpuTimestamp;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class AnalyticsCoreStatsUpdate extends System.ValueType {
        
        public get_Clone(): AnalyticsCoreStatsUpdate;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class UnityWebRequestUpdate extends System.ValueType {
        
        public get_Clone(): UnityWebRequestUpdate;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class UpdateStreamingManager extends System.ValueType {
        
        public get_Clone(): UpdateStreamingManager;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class ExecuteMainThreadJobs extends System.ValueType {
        
        public get_Clone(): ExecuteMainThreadJobs;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class ProcessMouseInWindow extends System.ValueType {
        
        public get_Clone(): ProcessMouseInWindow;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class ClearIntermediateRenderers extends System.ValueType {
        
        public get_Clone(): ClearIntermediateRenderers;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class ClearLines extends System.ValueType {
        
        public get_Clone(): ClearLines;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class PresentBeforeUpdate extends System.ValueType {
        
        public get_Clone(): PresentBeforeUpdate;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class ResetFrameStatsAfterPresent extends System.ValueType {
        
        public get_Clone(): ResetFrameStatsAfterPresent;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class UpdateAsyncReadbackManager extends System.ValueType {
        
        public get_Clone(): UpdateAsyncReadbackManager;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class UpdateTextureStreamingManager extends System.ValueType {
        
        public get_Clone(): UpdateTextureStreamingManager;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class UpdatePreloading extends System.ValueType {
        
        public get_Clone(): UpdatePreloading;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class RendererNotifyInvisible extends System.ValueType {
        
        public get_Clone(): RendererNotifyInvisible;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class PlayerCleanupCachedData extends System.ValueType {
        
        public get_Clone(): PlayerCleanupCachedData;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class UpdateMainGameViewRect extends System.ValueType {
        
        public get_Clone(): UpdateMainGameViewRect;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class UpdateCanvasRectTransform extends System.ValueType {
        
        public get_Clone(): UpdateCanvasRectTransform;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class UpdateInputManager extends System.ValueType {
        
        public get_Clone(): UpdateInputManager;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class ProcessRemoteInput extends System.ValueType {
        
        public get_Clone(): ProcessRemoteInput;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class XRUpdate extends System.ValueType {
        
        public get_Clone(): XRUpdate;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class ScriptRunDelayedStartupFrame extends System.ValueType {
        
        public get_Clone(): ScriptRunDelayedStartupFrame;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class UpdateKinect extends System.ValueType {
        
        public get_Clone(): UpdateKinect;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class DeliverIosPlatformEvents extends System.ValueType {
        
        public get_Clone(): DeliverIosPlatformEvents;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class DispatchEventQueueEvents extends System.ValueType {
        
        public get_Clone(): DispatchEventQueueEvents;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class PhysicsResetInterpolatedTransformPosition extends System.ValueType {
        
        public get_Clone(): PhysicsResetInterpolatedTransformPosition;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class SpriteAtlasManagerUpdate extends System.ValueType {
        
        public get_Clone(): SpriteAtlasManagerUpdate;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class ARCoreUpdate extends System.ValueType {
        
        public get_Clone(): ARCoreUpdate;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class PerformanceAnalyticsUpdate extends System.ValueType {
        
        public get_Clone(): PerformanceAnalyticsUpdate;            
    }
    
}
declare module 'UnityEngine.PlayerLoop.FixedUpdate' {

    import * as System from 'System';
        
    /**
     * Native engine system updated by the native player loop.
     */
    class ClearLines extends System.ValueType {
        
        public get_Clone(): ClearLines;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class DirectorFixedSampleTime extends System.ValueType {
        
        public get_Clone(): DirectorFixedSampleTime;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class AudioFixedUpdate extends System.ValueType {
        
        public get_Clone(): AudioFixedUpdate;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class ScriptRunBehaviourFixedUpdate extends System.ValueType {
        
        public get_Clone(): ScriptRunBehaviourFixedUpdate;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class DirectorFixedUpdate extends System.ValueType {
        
        public get_Clone(): DirectorFixedUpdate;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class LegacyFixedAnimationUpdate extends System.ValueType {
        
        public get_Clone(): LegacyFixedAnimationUpdate;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class XRFixedUpdate extends System.ValueType {
        
        public get_Clone(): XRFixedUpdate;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class PhysicsFixedUpdate extends System.ValueType {
        
        public get_Clone(): PhysicsFixedUpdate;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class Physics2DFixedUpdate extends System.ValueType {
        
        public get_Clone(): Physics2DFixedUpdate;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class DirectorFixedUpdatePostPhysics extends System.ValueType {
        
        public get_Clone(): DirectorFixedUpdatePostPhysics;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class ScriptRunDelayedFixedFrameRate extends System.ValueType {
        
        public get_Clone(): ScriptRunDelayedFixedFrameRate;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class NewInputFixedUpdate extends System.ValueType {
        
        public get_Clone(): NewInputFixedUpdate;            
    }
    
}
declare module 'UnityEngine.PlayerLoop.PreUpdate' {

    import * as System from 'System';
        
    /**
     * Native engine system updated by the native player loop.
     */
    class PhysicsUpdate extends System.ValueType {
        
        public get_Clone(): PhysicsUpdate;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class Physics2DUpdate extends System.ValueType {
        
        public get_Clone(): Physics2DUpdate;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class CheckTexFieldInput extends System.ValueType {
        
        public get_Clone(): CheckTexFieldInput;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class IMGUISendQueuedEvents extends System.ValueType {
        
        public get_Clone(): IMGUISendQueuedEvents;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class SendMouseEvents extends System.ValueType {
        
        public get_Clone(): SendMouseEvents;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class AIUpdate extends System.ValueType {
        
        public get_Clone(): AIUpdate;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class WindUpdate extends System.ValueType {
        
        public get_Clone(): WindUpdate;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class UpdateVideo extends System.ValueType {
        
        public get_Clone(): UpdateVideo;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class NewInputUpdate extends System.ValueType {
        
        public get_Clone(): NewInputUpdate;            
    }
    
}
declare module 'UnityEngine.PlayerLoop.Update' {

    import * as System from 'System';
        
    /**
     * Native engine system updated by the native player loop.
     */
    class ScriptRunBehaviourUpdate extends System.ValueType {
        
        public get_Clone(): ScriptRunBehaviourUpdate;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class DirectorUpdate extends System.ValueType {
        
        public get_Clone(): DirectorUpdate;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class ScriptRunDelayedDynamicFrameRate extends System.ValueType {
        
        public get_Clone(): ScriptRunDelayedDynamicFrameRate;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class ScriptRunDelayedTasks extends System.ValueType {
        
        public get_Clone(): ScriptRunDelayedTasks;            
    }
    
}
declare module 'UnityEngine.PlayerLoop.PreLateUpdate' {

    import * as System from 'System';
        
    /**
     * Native engine system updated by the native player loop.
     */
    class Physics2DLateUpdate extends System.ValueType {
        
        public get_Clone(): Physics2DLateUpdate;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class AIUpdatePostScript extends System.ValueType {
        
        public get_Clone(): AIUpdatePostScript;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class DirectorUpdateAnimationBegin extends System.ValueType {
        
        public get_Clone(): DirectorUpdateAnimationBegin;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class LegacyAnimationUpdate extends System.ValueType {
        
        public get_Clone(): LegacyAnimationUpdate;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class DirectorUpdateAnimationEnd extends System.ValueType {
        
        public get_Clone(): DirectorUpdateAnimationEnd;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class DirectorDeferredEvaluate extends System.ValueType {
        
        public get_Clone(): DirectorDeferredEvaluate;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class UIElementsUpdatePanels extends System.ValueType {
        
        public get_Clone(): UIElementsUpdatePanels;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class UpdateNetworkManager extends System.ValueType {
        
        public get_Clone(): UpdateNetworkManager;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class UpdateMasterServerInterface extends System.ValueType {
        
        public get_Clone(): UpdateMasterServerInterface;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class UNetUpdate extends System.ValueType {
        
        public get_Clone(): UNetUpdate;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class EndGraphicsJobsAfterScriptUpdate extends System.ValueType {
        
        public get_Clone(): EndGraphicsJobsAfterScriptUpdate;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class ParticleSystemBeginUpdateAll extends System.ValueType {
        
        public get_Clone(): ParticleSystemBeginUpdateAll;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class ScriptRunBehaviourLateUpdate extends System.ValueType {
        
        public get_Clone(): ScriptRunBehaviourLateUpdate;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class ConstraintManagerUpdate extends System.ValueType {
        
        public get_Clone(): ConstraintManagerUpdate;            
    }
    
}
declare module 'UnityEngine.PlayerLoop.PostLateUpdate' {

    import * as System from 'System';
        
    /**
     * Native engine system updated by the native player loop.
     */
    class PlayerSendFrameStarted extends System.ValueType {
        
        public get_Clone(): PlayerSendFrameStarted;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class UpdateRectTransform extends System.ValueType {
        
        public get_Clone(): UpdateRectTransform;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class UpdateCanvasRectTransform extends System.ValueType {
        
        public get_Clone(): UpdateCanvasRectTransform;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class PlayerUpdateCanvases extends System.ValueType {
        
        public get_Clone(): PlayerUpdateCanvases;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class UpdateAudio extends System.ValueType {
        
        public get_Clone(): UpdateAudio;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class UpdateVideo extends System.ValueType {
        
        public get_Clone(): UpdateVideo;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class DirectorLateUpdate extends System.ValueType {
        
        public get_Clone(): DirectorLateUpdate;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class ScriptRunDelayedDynamicFrameRate extends System.ValueType {
        
        public get_Clone(): ScriptRunDelayedDynamicFrameRate;            
    }
    
    class VFXUpdate extends System.ValueType {
        
        public get_Clone(): VFXUpdate;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class ParticleSystemEndUpdateAll extends System.ValueType {
        
        public get_Clone(): ParticleSystemEndUpdateAll;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class EndGraphicsJobsAfterScriptLateUpdate extends System.ValueType {
        
        public get_Clone(): EndGraphicsJobsAfterScriptLateUpdate;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class UpdateSubstance extends System.ValueType {
        
        public get_Clone(): UpdateSubstance;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class UpdateCustomRenderTextures extends System.ValueType {
        
        public get_Clone(): UpdateCustomRenderTextures;            
    }
    /**
     * Native engine system updated by the Player loop.
     */
    class XRPostLateUpdate extends System.ValueType {
        
        public get_Clone(): XRPostLateUpdate;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class UpdateAllRenderers extends System.ValueType {
        
        public get_Clone(): UpdateAllRenderers;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class UpdateLightProbeProxyVolumes extends System.ValueType {
        
        public get_Clone(): UpdateLightProbeProxyVolumes;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class EnlightenRuntimeUpdate extends System.ValueType {
        
        public get_Clone(): EnlightenRuntimeUpdate;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class UpdateAllSkinnedMeshes extends System.ValueType {
        
        public get_Clone(): UpdateAllSkinnedMeshes;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class ProcessWebSendMessages extends System.ValueType {
        
        public get_Clone(): ProcessWebSendMessages;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class SortingGroupsUpdate extends System.ValueType {
        
        public get_Clone(): SortingGroupsUpdate;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class UpdateVideoTextures extends System.ValueType {
        
        public get_Clone(): UpdateVideoTextures;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class DirectorRenderImage extends System.ValueType {
        
        public get_Clone(): DirectorRenderImage;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class PlayerEmitCanvasGeometry extends System.ValueType {
        
        public get_Clone(): PlayerEmitCanvasGeometry;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class FinishFrameRendering extends System.ValueType {
        
        public get_Clone(): FinishFrameRendering;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class BatchModeUpdate extends System.ValueType {
        
        public get_Clone(): BatchModeUpdate;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class PlayerSendFrameComplete extends System.ValueType {
        
        public get_Clone(): PlayerSendFrameComplete;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class UpdateCaptureScreenshot extends System.ValueType {
        
        public get_Clone(): UpdateCaptureScreenshot;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class PresentAfterDraw extends System.ValueType {
        
        public get_Clone(): PresentAfterDraw;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class ClearImmediateRenderers extends System.ValueType {
        
        public get_Clone(): ClearImmediateRenderers;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class XRPostPresent extends System.ValueType {
        
        public get_Clone(): XRPostPresent;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class UpdateResolution extends System.ValueType {
        
        public get_Clone(): UpdateResolution;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class InputEndFrame extends System.ValueType {
        
        public get_Clone(): InputEndFrame;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class GUIClearEvents extends System.ValueType {
        
        public get_Clone(): GUIClearEvents;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class ShaderHandleErrors extends System.ValueType {
        
        public get_Clone(): ShaderHandleErrors;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class ResetInputAxis extends System.ValueType {
        
        public get_Clone(): ResetInputAxis;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class ThreadedLoadingDebug extends System.ValueType {
        
        public get_Clone(): ThreadedLoadingDebug;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class ProfilerSynchronizeStats extends System.ValueType {
        
        public get_Clone(): ProfilerSynchronizeStats;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class MemoryFrameMaintenance extends System.ValueType {
        
        public get_Clone(): MemoryFrameMaintenance;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class ExecuteGameCenterCallbacks extends System.ValueType {
        
        public get_Clone(): ExecuteGameCenterCallbacks;            
    }
    /**
     * Native engine system updated by the Player loop.
     */
    class XRPreEndFrame extends System.ValueType {
        
        public get_Clone(): XRPreEndFrame;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class ProfilerEndFrame extends System.ValueType {
        
        public get_Clone(): ProfilerEndFrame;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class PlayerSendFramePostPresent extends System.ValueType {
        
        public get_Clone(): PlayerSendFramePostPresent;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class PhysicsSkinnedClothBeginUpdate extends System.ValueType {
        
        public get_Clone(): PhysicsSkinnedClothBeginUpdate;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class PhysicsSkinnedClothFinishUpdate extends System.ValueType {
        
        public get_Clone(): PhysicsSkinnedClothFinishUpdate;            
    }
    /**
     * Native engine system updated by the native player loop.
     */
    class TriggerEndOfFrameCallbacks extends System.ValueType {
        
        public get_Clone(): TriggerEndOfFrameCallbacks;            
    }
    
}
declare module 'UnityEngine.Networking.PlayerConnection' {

    import * as System from 'System';
    import * as UnityEngine_Events from 'UnityEngine.Events';
    import * as UnityEngine from 'UnityEngine';
        
    /**
     * The type of the connected target.
     */
    enum ConnectionTarget { None = 0, Player = 1, Editor = 2 }
    /**
     * The state of an Editor-to-Player or Editor-to-Editor connection to be used in Networking.PlayerConnection.PlayerConnectionGUI.ConnectionTargetSelectionDropdown or Networking.PlayerConnection.PlayerConnectionGUILayout.ConnectionTargetSelectionDropdown.
     */
    interface IConnectionState {
        /**
         * Supplies the type of the established connection, as in whether the target is a Player or an Editor.
         */
        connectedToTarget: ConnectionTarget;
        /**
         * The name of the connected target.
         */
        connectionName: string;
        
                    
    }
    /**
     * Arguments passed to Action callbacks registered in PlayerConnection.
     */
    class MessageEventArgs extends System.Object {
        /**
         * The Player ID that the data is received from.
         */
        public playerId: number;
        /**
         * Data that is received.
         */
        public data: number[];
        
        public constructor();
        
                    
    }
    
    interface IEditorPlayerConnection {
        
        Register($messageId: System.Guid, $callback: UnityEngine_Events.UnityAction$1<MessageEventArgs>):void;
        
        Unregister($messageId: System.Guid, $callback: UnityEngine_Events.UnityAction$1<MessageEventArgs>):void;
        
        DisconnectAll():void;
        
        RegisterConnection($callback: UnityEngine_Events.UnityAction$1<number>):void;
        
        RegisterDisconnection($callback: UnityEngine_Events.UnityAction$1<number>):void;
        
        UnregisterConnection($callback: UnityEngine_Events.UnityAction$1<number>):void;
        
        UnregisterDisconnection($callback: UnityEngine_Events.UnityAction$1<number>):void;
        
        Send($messageId: System.Guid, $data: number[]):void;
        
        TrySend($messageId: System.Guid, $data: number[]):boolean;
        
                    
    }
    /**
     * Used for handling the network connection from the Player to the Editor.
     */
    class PlayerConnection extends UnityEngine.ScriptableObject {
        /**
         * Returns a singleton instance of a PlayerConnection.
         */
        public static get instance(): PlayerConnection;
        /**
         * Returns true when the Editor is connected to the Player.
         */
        public get isConnected(): boolean;
        
        public constructor();
        
        public OnEnable():void;
        
        public Register($messageId: System.Guid, $callback: UnityEngine_Events.UnityAction$1<MessageEventArgs>):void;
        
        public Unregister($messageId: System.Guid, $callback: UnityEngine_Events.UnityAction$1<MessageEventArgs>):void;
        
        public RegisterConnection($callback: UnityEngine_Events.UnityAction$1<number>):void;
        
        public RegisterDisconnection($callback: UnityEngine_Events.UnityAction$1<number>):void;
        
        public UnregisterConnection($callback: UnityEngine_Events.UnityAction$1<number>):void;
        
        public UnregisterDisconnection($callback: UnityEngine_Events.UnityAction$1<number>):void;
        /**
         * Sends data to the Editor.
         * @param messageId The type ID of the message that is sent to the Editor.
         */
        public Send($messageId: System.Guid, $data: number[]):void;
        /**
         * Attempt to sends data to the Editor.
         * @param messageId The type ID of the message that is sent to the Editor.
         * @returns Returns true when the Player sends data successfully, and false when there is no space in the socket ring buffer or sending fails.
         */
        public TrySend($messageId: System.Guid, $data: number[]):boolean;
        /**
         * Blocks the calling thread until either a message with the specified messageId is received or the specified time-out elapses.
         * @param messageId The type ID of the message that is sent to the Editor.
         * @param timeout The time-out specified in milliseconds.
         * @returns Returns true when the message is received and false if the call timed out.
         */
        public BlockUntilRecvMsg($messageId: System.Guid, $timeout: number):boolean;
        /**
         * This disconnects all of the active connections.
         */
        public DisconnectAll():void;
        
                    
    }
    
}
declare module 'UnityEngine.Lumin' {

    import * as System from 'System';
        
    /**
     * This attribute provides a way to declaratively define a Lumin platform level requirement that is automatically added to the manifest at build time.
     */
    class UsesLuminPlatformLevelAttribute extends System.Attribute {
        
        public get platformLevel(): number;
        /**
         * Minimum platform level that is required.
         */
        public constructor($platformLevel: number);
        
                    
    }
    /**
     * This attribute provides a way to declaratively define a Lumin privilege requirement that is automatically added to the manifest at build time.
     */
    class UsesLuminPrivilegeAttribute extends System.Attribute {
        
        public get privilege(): string;
        /**
         * Privilege identifer to request
         */
        public constructor($privilege: string);
        
                    
    }
    
}
declare module 'UnityEngine.Internal' {

    import * as System from 'System';
        
    
    class DefaultValueAttribute extends System.Attribute {
        
        public get Value(): any;
        
        public constructor($value: string);
        
        public Equals($obj: any):boolean;
        
        public GetHashCode():number;
        
                    
    }
    
    class ExcludeFromDocsAttribute extends System.Attribute {
        
        public constructor();
        
                    
    }
    
}
declare module 'UnityEngine.Rendering.SplashScreen' {

    import * as System from 'System';
        
    /**
     * The behavior to apply when calling ParticleSystem.Stop|Stop.
     */
    enum StopBehavior { StopImmediate = 0, FadeOut = 1 }
    
}
declare module 'UnityEngine.Rendering.SupportedRenderingFeatures' {

    import * as System from 'System';
        
    /**
     * Supported modes for ReflectionProbes.
     */
    enum ReflectionProbeModes { None = 0, Rotation = 1 }
    /**
     * Same as MixedLightingMode for baking, but is used to determine what is supported by the pipeline.
     */
    enum LightmapMixedBakeModes { None = 0, IndirectOnly = 1, Subtractive = 2, Shadowmask = 4 }
    
}
declare module 'UnityEngine.Rendering.BatchRendererGroup' {

    import * as Unity_Jobs from 'Unity.Jobs';
    import * as UnityEngine_Rendering from 'UnityEngine.Rendering';
    import * as System from 'System';
        
    /**
     * Culling callback function.
     * @param rendererGroup Group to cull.
     * @param cullingContext Culling context.
     */
    type OnPerformCulling = (rendererGroup: UnityEngine_Rendering.BatchRendererGroup, cullingContext: UnityEngine_Rendering.BatchCullingContext) => Unity_Jobs.JobHandle;
    var OnPerformCulling: {new (func: (rendererGroup: UnityEngine_Rendering.BatchRendererGroup, cullingContext: UnityEngine_Rendering.BatchCullingContext) => Unity_Jobs.JobHandle): OnPerformCulling;}
    
}
declare module 'UnityEngine.Playables.FrameData' {

    import * as System from 'System';
        
    /**
     * Describes the cause for the evaluation of a PlayableGraph.
     */
    enum EvaluationType { Evaluate = 0, Playback = 1 }
    
}
declare module 'UnityEngine.Diagnostics' {

    import * as System from 'System';
        
    /**
     * Specifies the category of crash to cause when calling ForceCrash().
     */
    enum ForcedCrashCategory { AccessViolation = 0, FatalError = 1, Abort = 2, PureVirtualFunction = 3, MonoAbort = 4 }
    /**
     * A utility class that you can use for diagnostic purposes.
     */
    class Utils extends System.Object {
        /**
         * Manually causes an application crash in the specified category.
         */
        public static ForceCrash($crashCategory: ForcedCrashCategory):void;
        /**
         * Manually causes an assert that outputs the specified message to the log and registers an error.
         */
        public static NativeAssert($message: string):void;
        /**
         * Manually causes a native error that outputs the specified message to the log and registers an error.
         */
        public static NativeError($message: string):void;
        /**
         * Manually causes a warning that outputs the specified message to the log and registers an error.
         */
        public static NativeWarning($message: string):void;
        
                    
    }
    
    class PlayerConnection extends System.Object {
        
                    
    }
    
}
declare module 'UnityEngine.Experimental.GlobalIllumination' {

    import * as System from 'System';
    import * as UnityEngine from 'UnityEngine';
    import * as UnityEngine_Experimental_GlobalIllumination_Lightmapping from 'UnityEngine.Experimental.GlobalIllumination.Lightmapping';
        
    /**
     * The light type.
     */
    enum LightType { Directional = 0, Point = 1, Spot = 2, Rectangle = 3, Disc = 4, SpotPyramidShape = 5, SpotBoxShape = 6 }
    /**
     * The lightmode. A light can be realtime, mixed, baked or unknown. Unknown lights will be ignored by the baking backends.
     */
    enum LightMode { Realtime = 0, Mixed = 1, Baked = 2, Unknown = 3 }
    /**
     * Available falloff models for baking.
     */
    enum FalloffType { InverseSquared = 0, InverseSquaredNoRangeAttenuation = 1, Linear = 2, Legacy = 3, Undefined = 4 }
    /**
     * Sets the method to use to compute the angular attenuation of spot lights.
     */
    enum AngularFalloffType { LUT = 0, AnalyticAndInnerAngle = 1 }
    /**
     * Contains normalized linear color values for red, green, blue in the range of 0 to 1, and an additional intensity value.
     */
    class LinearColor extends System.ValueType {
        /**
         * The red color value in the range of 0.0 to 1.0.
         */
        public get red(): number;
        public set red(value: number);
        /**
         * The green color value in the range of 0.0 to 1.0.
         */
        public get green(): number;
        public set green(value: number);
        /**
         * The blue color value in the range of 0.0 to 1.0.
         */
        public get blue(): number;
        public set blue(value: number);
        /**
         * The intensity value used to scale the red, green and blue values.
         */
        public get intensity(): number;
        public set intensity(value: number);
        /**
         * Converts a Light's color value to a normalized linear color value, automatically handling gamma conversion if necessary.
         * @param color Light color.
         * @param intensity Light intensity.
         * @returns Returns the normalized linear color value.
         */
        public static Convert($color: UnityEngine.Color, $intensity: number):LinearColor;
        /**
         * Returns a black color.
         * @returns Returns a black color.
         */
        public static Black():LinearColor;
        
        public get_Clone(): LinearColor;            
    }
    /**
     * A helper structure used to initialize a LightDataGI structure as a directional light.
     */
    class DirectionalLight extends System.ValueType {
        /**
         * The light's instanceID.
         */
        public instanceID: number;
        /**
         * True if the light casts shadows, otherwise False.
         */
        public shadow: boolean;
        /**
         * The lightmode.
         */
        public mode: LightMode;
        /**
         * The light's position. Only relevant for cookie placement.
         */
        public position: UnityEngine.Vector3;
        /**
         * The light's orientation. Only relevant for cookie placement.
         */
        public orientation: UnityEngine.Quaternion;
        /**
         * The direct light color.
         */
        public color: LinearColor;
        /**
         * The indirect light color.
         */
        public indirectColor: LinearColor;
        /**
         * The penumbra width for soft shadows in radians.
         */
        public penumbraWidthRadian: number;
        
                    
    }
    /**
     * A helper structure used to initialize a LightDataGI structure as a point light.
     */
    class PointLight extends System.ValueType {
        /**
         * The light's instanceID.
         */
        public instanceID: number;
        /**
         * True if the light casts shadows, otherwise False.
         */
        public shadow: boolean;
        /**
         * The lightmode.
         */
        public mode: LightMode;
        /**
         * The light's position.
         */
        public position: UnityEngine.Vector3;
        /**
         * The direct light color.
         */
        public color: LinearColor;
        /**
         * The indirect light color.
         */
        public indirectColor: LinearColor;
        /**
         * The light's range.
         */
        public range: number;
        /**
         * The light's sphere radius, influencing soft shadows.
         */
        public sphereRadius: number;
        /**
         * The falloff model to use for baking the point light.
         */
        public falloff: FalloffType;
        
                    
    }
    /**
     * A helper structure used to initialize a LightDataGI structure as a spot light.
     */
    class SpotLight extends System.ValueType {
        /**
         * The light's instanceID.
         */
        public instanceID: number;
        /**
         * True if the light casts shadows, otherwise False.
         */
        public shadow: boolean;
        /**
         * The lightmode.
         */
        public mode: LightMode;
        /**
         * The light's position.
         */
        public position: UnityEngine.Vector3;
        /**
         * The light's orientation.
         */
        public orientation: UnityEngine.Quaternion;
        /**
         * The direct light color.
         */
        public color: LinearColor;
        /**
         * The indirect light color.
         */
        public indirectColor: LinearColor;
        /**
         * The light's range.
         */
        public range: number;
        /**
         * The light's sphere radius, influencing soft shadows.
         */
        public sphereRadius: number;
        /**
         * The outer angle for the spot light.
         */
        public coneAngle: number;
        /**
         * The inner angle for the spot light.
         */
        public innerConeAngle: number;
        /**
         * The falloff model to use for baking the spot light.
         */
        public falloff: FalloffType;
        /**
         * The angular falloff model to use for baking the spot light.
         */
        public angularFalloff: AngularFalloffType;
        
                    
    }
    /**
     * A helper structure used to initialize a LightDataGI structure as a rectangle light.
     */
    class RectangleLight extends System.ValueType {
        /**
         * The light's instanceID.
         */
        public instanceID: number;
        /**
         * True if the light casts shadows, otherwise False.
         */
        public shadow: boolean;
        /**
         * The lightmode.
         */
        public mode: LightMode;
        /**
         * The light's position.
         */
        public position: UnityEngine.Vector3;
        /**
         * The light's orientation.
         */
        public orientation: UnityEngine.Quaternion;
        /**
         * The direct light color.
         */
        public color: LinearColor;
        /**
         * The indirect light color.
         */
        public indirectColor: LinearColor;
        /**
         * The light's range.
         */
        public range: number;
        /**
         * The width of the rectangle light.
         */
        public width: number;
        /**
         * The height of the rectangle light.
         */
        public height: number;
        /**
         * The falloff model to use for baking the rectangular light.
         */
        public falloff: FalloffType;
        
                    
    }
    /**
     * A helper structure used to initialize a LightDataGI structure as a disc light.
     */
    class DiscLight extends System.ValueType {
        /**
         * The light's instanceID.
         */
        public instanceID: number;
        /**
         * True if the light casts shadows, otherwise False.
         */
        public shadow: boolean;
        /**
         * The lightmode.
         */
        public mode: LightMode;
        /**
         * The light's position.
         */
        public position: UnityEngine.Vector3;
        /**
         * The light's orientation.
         */
        public orientation: UnityEngine.Quaternion;
        /**
         * The direct light color.
         */
        public color: LinearColor;
        /**
         * The indirect light color.
         */
        public indirectColor: LinearColor;
        /**
         * The light's range.
         */
        public range: number;
        /**
         * The radius of the disc light.
         */
        public radius: number;
        /**
         * The falloff model to use for baking the disc light.
         */
        public falloff: FalloffType;
        
                    
    }
    /**
     * Use this Struct to help initialize a LightDataGI structure as a box-shaped spot light.
     */
    class SpotLightBoxShape extends System.ValueType {
        /**
         * The light's instanceID.
         */
        public instanceID: number;
        /**
         * Specifies whether the light casts shadows or not. This is true if the light does cast shadows and false otherwise.
         */
        public shadow: boolean;
        /**
         * The lightmode.
         */
        public mode: LightMode;
        /**
         * The light's position.
         */
        public position: UnityEngine.Vector3;
        /**
         * The light's orientation.
         */
        public orientation: UnityEngine.Quaternion;
        /**
         * The direct light color.
         */
        public color: LinearColor;
        /**
         * The indirect light color.
         */
        public indirectColor: LinearColor;
        /**
         * The light's range.
         */
        public range: number;
        /**
         * The width of the box light.
         */
        public width: number;
        /**
         * The height of the box light.
         */
        public height: number;
        
                    
    }
    /**
     * Use this Struct to help initialize a LightDataGI structure as a pyramid-shaped spot light.
     */
    class SpotLightPyramidShape extends System.ValueType {
        /**
         * The light's instanceID.
         */
        public instanceID: number;
        /**
         * Specifies whether the light casts shadows or not. This is true if the light does cast shadows and false otherwise.
         */
        public shadow: boolean;
        /**
         * The lightmode.
         */
        public mode: LightMode;
        /**
         * The light's position.
         */
        public position: UnityEngine.Vector3;
        /**
         * The light's orientation.
         */
        public orientation: UnityEngine.Quaternion;
        /**
         * The direct light color.
         */
        public color: LinearColor;
        /**
         * The indirect light color.
         */
        public indirectColor: LinearColor;
        /**
         * The light's range.
         */
        public range: number;
        /**
         * The opening angle of the shorter side of the pyramid light.
         */
        public angle: number;
        /**
         * The aspect ratio for the pyramid shape. Values larger than 1 extend the width and values between 0 and 1 extend the height.
         */
        public aspectRatio: number;
        /**
         * The falloff model to use for baking the pyramid light.
         */
        public falloff: FalloffType;
        
                    
    }
    /**
     * A helper structure used to initialize a LightDataGI structure with cookie information.
     */
    class Cookie extends System.ValueType {
        /**
         * The cookie texture's instance id projected by the light.
         */
        public instanceID: number;
        /**
         * The uniform scale factor for downscaling cookies during lightmapping. Can be used as an optimization when full resolution cookies are not needed for indirect lighting.
         */
        public scale: number;
        /**
         * The scale factors controlling how the directional light's cookie is projected into the scene. This parameter should be set to 1 for all other light types.
         */
        public sizes: UnityEngine.Vector2;
        /**
         * Returns a default initialized cookie helper struct.
         */
        public static Defaults():Cookie;
        
        public get_Clone(): Cookie;            
    }
    /**
     * The interop structure to pass light information to the light baking backends. There are helper structures for Directional, Point, Spot and Rectangle lights to correctly initialize this structure.
     */
    class LightDataGI extends System.ValueType {
        /**
         * The light's instanceID.
         */
        public instanceID: number;
        /**
         * The cookie texture's instance id projected by the light.
         */
        public cookieID: number;
        /**
         * The uniform scale factor for downscaling cookies during lightmapping. Can be used as an optimization when full resolution cookies are not needed for indirect lighting.
         */
        public cookieScale: number;
        /**
         * The color of the light.
         */
        public color: LinearColor;
        /**
         * The indirect color of the light.
         */
        public indirectColor: LinearColor;
        /**
         * The orientation of the light.
         */
        public orientation: UnityEngine.Quaternion;
        /**
         * The position of the light.
         */
        public position: UnityEngine.Vector3;
        /**
         * The range of the light. Unused for directional lights.
         */
        public range: number;
        /**
         * The cone angle for spot lights.
         */
        public coneAngle: number;
        /**
         * The inner cone angle for spot lights.
         */
        public innerConeAngle: number;
        /**
         * The light's sphere radius for point and spot lights, or the width for rectangle lights.
         */
        public shape0: number;
        /**
         * The height for rectangle lights.
         */
        public shape1: number;
        /**
         * The type of the light.
         */
        public type: LightType;
        /**
         * The lightmap mode for the light.
         */
        public mode: LightMode;
        /**
         * Set to 1 for shadow casting lights, 0 otherwise.
         */
        public shadow: number;
        /**
         * The falloff model to use for baking point and spot lights.
         */
        public falloff: FalloffType;
        
        public Init($light: $Ref<DirectionalLight>, $cookie: $Ref<Cookie>):void;
        
        public Init($light: $Ref<PointLight>, $cookie: $Ref<Cookie>):void;
        
        public Init($light: $Ref<SpotLight>, $cookie: $Ref<Cookie>):void;
        
        public Init($light: $Ref<RectangleLight>, $cookie: $Ref<Cookie>):void;
        
        public Init($light: $Ref<DiscLight>, $cookie: $Ref<Cookie>):void;
        
        public Init($light: $Ref<SpotLightBoxShape>, $cookie: $Ref<Cookie>):void;
        
        public Init($light: $Ref<SpotLightPyramidShape>, $cookie: $Ref<Cookie>):void;
        /**
         * Initialize the struct with the parameters from the given light type.
         */
        public Init($light: $Ref<DirectionalLight>):void;
        /**
         * Initialize the struct with the parameters from the given light type.
         */
        public Init($light: $Ref<PointLight>):void;
        /**
         * Initialize the struct with the parameters from the given light type.
         */
        public Init($light: $Ref<SpotLight>):void;
        /**
         * Initialize the struct with the parameters from the given light type.
         */
        public Init($light: $Ref<RectangleLight>):void;
        
        public Init($light: $Ref<DiscLight>):void;
        /**
         * Initialize the struct with the parameters from the given light type.
         */
        public Init($light: $Ref<SpotLightBoxShape>):void;
        /**
         * Initialize the struct with the parameters from the given light type.
         */
        public Init($light: $Ref<SpotLightPyramidShape>):void;
        /**
         * Initialize a light so that the baking backends ignore it.
         */
        public InitNoBake($lightInstanceID: number):void;
        
        public get_Clone(): LightDataGI;            
    }
    /**
     * Utility class for converting Unity Lights to light types recognized by the baking backends.
     */
    class LightmapperUtils extends System.Object {
        /**
         * Extracts informations from Lights.
         * @param baketype The lights baketype.
         * @returns Returns the light's light mode.
         */
        public static Extract($baketype: UnityEngine.LightmapBakeType):LightMode;
        /**
         * Extracts the indirect color from a light.
         */
        public static ExtractIndirect($l: UnityEngine.Light):LinearColor;
        /**
         * Extracts the inner cone angle of spot lights.
         */
        public static ExtractInnerCone($l: UnityEngine.Light):number;
        /**
         * Extract type specific information from Lights.
         * @param l The input light.
         * @param dir Extracts directional light information.
         * @param point Extracts point light information.
         * @param spot Extracts spot light information.
         * @param rect Extracts rectangle light information.
         */
        public static Extract($l: UnityEngine.Light, $dir: $Ref<DirectionalLight>):void;
        /**
         * Extract type specific information from Lights.
         * @param l The input light.
         * @param dir Extracts directional light information.
         * @param point Extracts point light information.
         * @param spot Extracts spot light information.
         * @param rect Extracts rectangle light information.
         */
        public static Extract($l: UnityEngine.Light, $point: $Ref<PointLight>):void;
        /**
         * Extract type specific information from Lights.
         * @param l The input light.
         * @param dir Extracts directional light information.
         * @param point Extracts point light information.
         * @param spot Extracts spot light information.
         * @param rect Extracts rectangle light information.
         */
        public static Extract($l: UnityEngine.Light, $spot: $Ref<SpotLight>):void;
        /**
         * Extract type specific information from Lights.
         * @param l The input light.
         * @param dir Extracts directional light information.
         * @param point Extracts point light information.
         * @param spot Extracts spot light information.
         * @param rect Extracts rectangle light information.
         */
        public static Extract($l: UnityEngine.Light, $rect: $Ref<RectangleLight>):void;
        
        public static Extract($l: UnityEngine.Light, $disc: $Ref<DiscLight>):void;
        
        public static Extract($l: UnityEngine.Light, $cookie: $Ref<Cookie>):void;
        
                    
    }
    /**
     * Interface to the light baking backends.
     */
    class Lightmapping extends System.Object {
        /**
         * Set a delegate that converts a list of lights to a list of LightDataGI structures that are passed to the baking backends. Must be reset by calling ResetDelegate again.
         */
        public static SetDelegate($del: UnityEngine_Experimental_GlobalIllumination_Lightmapping.RequestLightsDelegate):void;
        /**
         * Get the currently set conversion delegate.
         * @returns Returns the currently set conversion delegate.
         */
        public static GetDelegate():UnityEngine_Experimental_GlobalIllumination_Lightmapping.RequestLightsDelegate;
        /**
         * Resets the light conversion delegate to Unity's default conversion function.
         */
        public static ResetDelegate():void;
        
                    
    }
    /**
     * Experimental render settings features.
     */
    class RenderSettings extends System.Object {
        /**
         * If enabled, ambient trilight will be sampled using the old radiance sampling method.
         */
        public static get useRadianceAmbientProbe(): boolean;
        public static set useRadianceAmbientProbe(value: boolean);
        
        public constructor();
        
                    
    }
    
}
declare module 'UnityEngine.Experimental.GlobalIllumination.Lightmapping' {

    import * as UnityEngine from 'UnityEngine';
    import * as Unity_Collections from 'Unity.Collections';
    import * as System from 'System';
        
    /**
     * Delegate called when converting lights into a form that the baking backends understand.
     * @param requests The list of lights to be converted.
     * @param lightsOutput The output generated by the delegate function. Lights that should be skipped must be added to the output, initialized with InitNoBake on the LightDataGI structure.
     */
    type RequestLightsDelegate = (requests: UnityEngine.Light[], lightsOutput: Unity_Collections.NativeArray$1<UnityEngine_Experimental_GlobalIllumination.LightDataGI>) => void;
    var RequestLightsDelegate: {new (func: (requests: UnityEngine.Light[], lightsOutput: Unity_Collections.NativeArray$1<UnityEngine_Experimental_GlobalIllumination.LightDataGI>) => void): RequestLightsDelegate;}
    
}
declare module 'UnityEngine.Experimental.Playables' {

    import * as System from 'System';
    import * as UnityEngine_Playables from 'UnityEngine.Playables';
    import * as UnityEngine from 'UnityEngine';
        
    /**
     * An implementation of IPlayable that produces a Camera texture.
     */
    class CameraPlayable extends System.ValueType {
        /**
         * Creates a CameraPlayable in the PlayableGraph.
         * @param graph The PlayableGraph object that will own the CameraPlayable.
         * @param camera Camera used to produce a texture in the PlayableGraph.
         * @returns A CameraPlayable linked to the PlayableGraph.
         */
        public static Create($graph: UnityEngine_Playables.PlayableGraph, $camera: UnityEngine.Camera):CameraPlayable;
        
        public GetHandle():UnityEngine_Playables.PlayableHandle;
        
        public static op_Implicit($playable: CameraPlayable):UnityEngine_Playables.Playable;
        
        public static op_Explicit($playable: UnityEngine_Playables.Playable):CameraPlayable;
        
        public Equals($other: CameraPlayable):boolean;
        
        public GetCamera():UnityEngine.Camera;
        
        public SetCamera($value: UnityEngine.Camera):void;
        
        public get_Clone(): CameraPlayable;            
    }
    /**
     * An implementation of IPlayable that allows application of a Material shader to one or many texture inputs to produce a texture output.
     */
    class MaterialEffectPlayable extends System.ValueType {
        
        public static Create($graph: UnityEngine_Playables.PlayableGraph, $material: UnityEngine.Material, $pass?: number):MaterialEffectPlayable;
        
        public GetHandle():UnityEngine_Playables.PlayableHandle;
        
        public static op_Implicit($playable: MaterialEffectPlayable):UnityEngine_Playables.Playable;
        
        public static op_Explicit($playable: UnityEngine_Playables.Playable):MaterialEffectPlayable;
        
        public Equals($other: MaterialEffectPlayable):boolean;
        
        public GetMaterial():UnityEngine.Material;
        
        public SetMaterial($value: UnityEngine.Material):void;
        
        public GetPass():number;
        
        public SetPass($value: number):void;
        
        public get_Clone(): MaterialEffectPlayable;            
    }
    /**
     * An implementation of IPlayable that allows mixing two textures.
     */
    class TextureMixerPlayable extends System.ValueType {
        /**
         * Creates a TextureMixerPlayable in the PlayableGraph.
         * @param graph The PlayableGraph object that will own the TextureMixerPlayable.
         * @returns A TextureMixerPlayable linked to the PlayableGraph.
         */
        public static Create($graph: UnityEngine_Playables.PlayableGraph):TextureMixerPlayable;
        
        public GetHandle():UnityEngine_Playables.PlayableHandle;
        
        public static op_Implicit($playable: TextureMixerPlayable):UnityEngine_Playables.Playable;
        
        public static op_Explicit($playable: UnityEngine_Playables.Playable):TextureMixerPlayable;
        
        public Equals($other: TextureMixerPlayable):boolean;
        
        public get_Clone(): TextureMixerPlayable;            
    }
    /**
     * A PlayableBinding that contains information representing a TexturePlayableOutput.
     */
    class TexturePlayableBinding extends System.Object {
        /**
         * Creates a PlayableBinding that contains information representing a TexturePlayableOutput.
         * @param key A reference to a UnityEngine.Object that acts as a key for this binding.
         * @param name The name of the TexturePlayableOutput.
         * @returns Returns a PlayableBinding that contains information that is used to create a TexturePlayableOutput.
         */
        public static Create($name: string, $key: UnityEngine.Object):UnityEngine_Playables.PlayableBinding;
        
                    
    }
    /**
     * An IPlayableOutput implementation that will be used to manipulate textures.
     */
    class TexturePlayableOutput extends System.ValueType {
        /**
         * Returns an invalid TexturePlayableOutput.
         */
        public static get Null(): TexturePlayableOutput;
        
        public static Create($graph: UnityEngine_Playables.PlayableGraph, $name: string, $target: UnityEngine.RenderTexture):TexturePlayableOutput;
        
        public GetHandle():UnityEngine_Playables.PlayableOutputHandle;
        
        public static op_Implicit($output: TexturePlayableOutput):UnityEngine_Playables.PlayableOutput;
        
        public static op_Explicit($output: UnityEngine_Playables.PlayableOutput):TexturePlayableOutput;
        
        public GetTarget():UnityEngine.RenderTexture;
        
        public SetTarget($value: UnityEngine.RenderTexture):void;
        
        public get_Clone(): TexturePlayableOutput;            
    }
    
}
declare module 'UnityEngine.Experimental.Rendering.RayTracingAccelerationStructure' {

    import * as System from 'System';
        
    /**
     * Defines whether a RayTracingAccelerationStructure is updated by the user or by the Engine, and whether to mask certain object layers or RayTracingModes.
     */
    class RASSettings extends System.ValueType {
        
        public managementMode: ManagementMode;
        
        public rayTracingModeMask: RayTracingModeMask;
        
        public layerMask: number;
        
        public constructor($sceneManagementMode: ManagementMode, $rayTracingModeMask: RayTracingModeMask, $layerMask: number);
        
        public get_Clone(): RASSettings;            
    }
    /**
     * An enum that controls which RayTracingAccelerationStructure.RayTracingModes a Renderer must have in order to be added to the RayTracingAccelerationStructure.
     */
    enum RayTracingModeMask { Nothing = 0, Static = 2, DynamicTransform = 4, DynamicGeometry = 8, Everything = 14 }
    /**
     * Defines whether Unity updates a RayTracingAccelerationStructure automatically, or if the user updates it manually via API.
     */
    enum ManagementMode { Manual = 0, Automatic = 1 }
    
}
declare module 'UnityEngine.Assertions' {

    import * as System from 'System';
    import * as System_Collections_Generic from 'System.Collections.Generic';
    import * as UnityEngine from 'UnityEngine';
        
    /**
     * The Assert class contains assertion methods for setting invariants in the code.
     */
    class Assert extends System.Object {
        /**
         * Asserts that the condition is true.
         * @param message The string used to describe the Assert.
         * @param condition true or false.
         */
        public static IsTrue($condition: boolean):void;
        /**
         * Asserts that the condition is true.
         * @param message The string used to describe the Assert.
         * @param condition true or false.
         */
        public static IsTrue($condition: boolean, $message: string):void;
        /**
         * Return true when the condition is false.  Otherwise return false.
         * @param condition true or false.
         * @param message The string used to describe the result of the Assert.
         */
        public static IsFalse($condition: boolean):void;
        /**
         * Return true when the condition is false.  Otherwise return false.
         * @param condition true or false.
         * @param message The string used to describe the result of the Assert.
         */
        public static IsFalse($condition: boolean, $message: string):void;
        /**
         * Assert the values are approximately equal.
         * @param tolerance Tolerance of approximation.
         * @param expected The assumed Assert value.
         * @param actual The exact Assert value.
         * @param message The string used to describe the Assert.
         */
        public static AreApproximatelyEqual($expected: number, $actual: number):void;
        /**
         * Assert the values are approximately equal.
         * @param tolerance Tolerance of approximation.
         * @param expected The assumed Assert value.
         * @param actual The exact Assert value.
         * @param message The string used to describe the Assert.
         */
        public static AreApproximatelyEqual($expected: number, $actual: number, $message: string):void;
        /**
         * Assert the values are approximately equal.
         * @param tolerance Tolerance of approximation.
         * @param expected The assumed Assert value.
         * @param actual The exact Assert value.
         * @param message The string used to describe the Assert.
         */
        public static AreApproximatelyEqual($expected: number, $actual: number, $tolerance: number):void;
        /**
         * Assert the values are approximately equal.
         * @param tolerance Tolerance of approximation.
         * @param expected The assumed Assert value.
         * @param actual The exact Assert value.
         * @param message The string used to describe the Assert.
         */
        public static AreApproximatelyEqual($expected: number, $actual: number, $tolerance: number, $message: string):void;
        /**
         * Asserts that the values are approximately not equal.
         * @param tolerance Tolerance of approximation.
         * @param expected The assumed Assert value.
         * @param actual The exact Assert value.
         * @param message The string used to describe the Assert.
         */
        public static AreNotApproximatelyEqual($expected: number, $actual: number):void;
        /**
         * Asserts that the values are approximately not equal.
         * @param tolerance Tolerance of approximation.
         * @param expected The assumed Assert value.
         * @param actual The exact Assert value.
         * @param message The string used to describe the Assert.
         */
        public static AreNotApproximatelyEqual($expected: number, $actual: number, $message: string):void;
        /**
         * Asserts that the values are approximately not equal.
         * @param tolerance Tolerance of approximation.
         * @param expected The assumed Assert value.
         * @param actual The exact Assert value.
         * @param message The string used to describe the Assert.
         */
        public static AreNotApproximatelyEqual($expected: number, $actual: number, $tolerance: number):void;
        /**
         * Asserts that the values are approximately not equal.
         * @param tolerance Tolerance of approximation.
         * @param expected The assumed Assert value.
         * @param actual The exact Assert value.
         * @param message The string used to describe the Assert.
         */
        public static AreNotApproximatelyEqual($expected: number, $actual: number, $tolerance: number, $message: string):void;
        
        public static AreEqual<T>($expected: T, $actual: T):void;
        
        public static AreEqual<T>($expected: T, $actual: T, $message: string):void;
        
        public static AreEqual<T>($expected: T, $actual: T, $message: string, $comparer: System_Collections_Generic.IEqualityComparer$1<T>):void;
        /**
         * Assert that the values are equal.
         * @param expected The assumed Assert value.
         * @param actual The exact Assert value.
         * @param message The string used to describe the Assert.
         * @param comparer Method to compare expected and actual arguments have the same value.
         */
        public static AreEqual($expected: UnityEngine.Object, $actual: UnityEngine.Object, $message: string):void;
        
        public static AreNotEqual<T>($expected: T, $actual: T):void;
        
        public static AreNotEqual<T>($expected: T, $actual: T, $message: string):void;
        
        public static AreNotEqual<T>($expected: T, $actual: T, $message: string, $comparer: System_Collections_Generic.IEqualityComparer$1<T>):void;
        /**
         * Assert that the values are not equal.
         * @param expected The assumed Assert value.
         * @param actual The exact Assert value.
         * @param message The string used to describe the Assert.
         * @param comparer Method to compare expected and actual arguments have the same value.
         */
        public static AreNotEqual($expected: UnityEngine.Object, $actual: UnityEngine.Object, $message: string):void;
        
        public static IsNull<T>($value: T):void;
        
        public static IsNull<T>($value: T, $message: string):void;
        /**
         * Assert the value is null.
         * @param value The Object or type being checked for.
         * @param message The string used to describe the Assert.
         */
        public static IsNull($value: UnityEngine.Object, $message: string):void;
        
        public static IsNotNull<T>($value: T):void;
        
        public static IsNotNull<T>($value: T, $message: string):void;
        /**
         * Assert that the value is not null.
         * @param value The Object or type being checked for.
         * @param message The string used to describe the Assert.
         */
        public static IsNotNull($value: UnityEngine.Object, $message: string):void;
        /**
         * Assert that the values are equal.
         * @param expected The assumed Assert value.
         * @param actual The exact Assert value.
         * @param message The string used to describe the Assert.
         * @param comparer Method to compare expected and actual arguments have the same value.
         */
        public static AreEqual($expected: number, $actual: number):void;
        /**
         * Assert that the values are equal.
         * @param expected The assumed Assert value.
         * @param actual The exact Assert value.
         * @param message The string used to describe the Assert.
         * @param comparer Method to compare expected and actual arguments have the same value.
         */
        public static AreEqual($expected: number, $actual: number, $message: string):void;
        /**
         * Assert that the values are not equal.
         * @param expected The assumed Assert value.
         * @param actual The exact Assert value.
         * @param message The string used to describe the Assert.
         * @param comparer Method to compare expected and actual arguments have the same value.
         */
        public static AreNotEqual($expected: number, $actual: number):void;
        /**
         * Assert that the values are not equal.
         * @param expected The assumed Assert value.
         * @param actual The exact Assert value.
         * @param message The string used to describe the Assert.
         * @param comparer Method to compare expected and actual arguments have the same value.
         */
        public static AreNotEqual($expected: number, $actual: number, $message: string):void;
        /**
         * Assert that the values are equal.
         * @param expected The assumed Assert value.
         * @param actual The exact Assert value.
         * @param message The string used to describe the Assert.
         * @param comparer Method to compare expected and actual arguments have the same value.
         */
        public static AreEqual($expected: number, $actual: number):void;
        /**
         * Assert that the values are equal.
         * @param expected The assumed Assert value.
         * @param actual The exact Assert value.
         * @param message The string used to describe the Assert.
         * @param comparer Method to compare expected and actual arguments have the same value.
         */
        public static AreEqual($expected: number, $actual: number, $message: string):void;
        /**
         * Assert that the values are not equal.
         * @param expected The assumed Assert value.
         * @param actual The exact Assert value.
         * @param message The string used to describe the Assert.
         * @param comparer Method to compare expected and actual arguments have the same value.
         */
        public static AreNotEqual($expected: number, $actual: number):void;
        /**
         * Assert that the values are not equal.
         * @param expected The assumed Assert value.
         * @param actual The exact Assert value.
         * @param message The string used to describe the Assert.
         * @param comparer Method to compare expected and actual arguments have the same value.
         */
        public static AreNotEqual($expected: number, $actual: number, $message: string):void;
        /**
         * Assert that the values are equal.
         * @param expected The assumed Assert value.
         * @param actual The exact Assert value.
         * @param message The string used to describe the Assert.
         * @param comparer Method to compare expected and actual arguments have the same value.
         */
        public static AreEqual($expected: number, $actual: number):void;
        /**
         * Assert that the values are equal.
         * @param expected The assumed Assert value.
         * @param actual The exact Assert value.
         * @param message The string used to describe the Assert.
         * @param comparer Method to compare expected and actual arguments have the same value.
         */
        public static AreEqual($expected: number, $actual: number, $message: string):void;
        /**
         * Assert that the values are not equal.
         * @param expected The assumed Assert value.
         * @param actual The exact Assert value.
         * @param message The string used to describe the Assert.
         * @param comparer Method to compare expected and actual arguments have the same value.
         */
        public static AreNotEqual($expected: number, $actual: number):void;
        /**
         * Assert that the values are not equal.
         * @param expected The assumed Assert value.
         * @param actual The exact Assert value.
         * @param message The string used to describe the Assert.
         * @param comparer Method to compare expected and actual arguments have the same value.
         */
        public static AreNotEqual($expected: number, $actual: number, $message: string):void;
        /**
         * Assert that the values are equal.
         * @param expected The assumed Assert value.
         * @param actual The exact Assert value.
         * @param message The string used to describe the Assert.
         * @param comparer Method to compare expected and actual arguments have the same value.
         */
        public static AreEqual($expected: number, $actual: number):void;
        /**
         * Assert that the values are equal.
         * @param expected The assumed Assert value.
         * @param actual The exact Assert value.
         * @param message The string used to describe the Assert.
         * @param comparer Method to compare expected and actual arguments have the same value.
         */
        public static AreEqual($expected: number, $actual: number, $message: string):void;
        /**
         * Assert that the values are not equal.
         * @param expected The assumed Assert value.
         * @param actual The exact Assert value.
         * @param message The string used to describe the Assert.
         * @param comparer Method to compare expected and actual arguments have the same value.
         */
        public static AreNotEqual($expected: number, $actual: number):void;
        /**
         * Assert that the values are not equal.
         * @param expected The assumed Assert value.
         * @param actual The exact Assert value.
         * @param message The string used to describe the Assert.
         * @param comparer Method to compare expected and actual arguments have the same value.
         */
        public static AreNotEqual($expected: number, $actual: number, $message: string):void;
        /**
         * Assert that the values are equal.
         * @param expected The assumed Assert value.
         * @param actual The exact Assert value.
         * @param message The string used to describe the Assert.
         * @param comparer Method to compare expected and actual arguments have the same value.
         */
        public static AreEqual($expected: number, $actual: number):void;
        /**
         * Assert that the values are equal.
         * @param expected The assumed Assert value.
         * @param actual The exact Assert value.
         * @param message The string used to describe the Assert.
         * @param comparer Method to compare expected and actual arguments have the same value.
         */
        public static AreEqual($expected: number, $actual: number, $message: string):void;
        /**
         * Assert that the values are not equal.
         * @param expected The assumed Assert value.
         * @param actual The exact Assert value.
         * @param message The string used to describe the Assert.
         * @param comparer Method to compare expected and actual arguments have the same value.
         */
        public static AreNotEqual($expected: number, $actual: number):void;
        /**
         * Assert that the values are not equal.
         * @param expected The assumed Assert value.
         * @param actual The exact Assert value.
         * @param message The string used to describe the Assert.
         * @param comparer Method to compare expected and actual arguments have the same value.
         */
        public static AreNotEqual($expected: number, $actual: number, $message: string):void;
        /**
         * Assert that the values are equal.
         * @param expected The assumed Assert value.
         * @param actual The exact Assert value.
         * @param message The string used to describe the Assert.
         * @param comparer Method to compare expected and actual arguments have the same value.
         */
        public static AreEqual($expected: number, $actual: number):void;
        /**
         * Assert that the values are equal.
         * @param expected The assumed Assert value.
         * @param actual The exact Assert value.
         * @param message The string used to describe the Assert.
         * @param comparer Method to compare expected and actual arguments have the same value.
         */
        public static AreEqual($expected: number, $actual: number, $message: string):void;
        /**
         * Assert that the values are not equal.
         * @param expected The assumed Assert value.
         * @param actual The exact Assert value.
         * @param message The string used to describe the Assert.
         * @param comparer Method to compare expected and actual arguments have the same value.
         */
        public static AreNotEqual($expected: number, $actual: number):void;
        /**
         * Assert that the values are not equal.
         * @param expected The assumed Assert value.
         * @param actual The exact Assert value.
         * @param message The string used to describe the Assert.
         * @param comparer Method to compare expected and actual arguments have the same value.
         */
        public static AreNotEqual($expected: number, $actual: number, $message: string):void;
        /**
         * Assert that the values are equal.
         * @param expected The assumed Assert value.
         * @param actual The exact Assert value.
         * @param message The string used to describe the Assert.
         * @param comparer Method to compare expected and actual arguments have the same value.
         */
        public static AreEqual($expected: number, $actual: number):void;
        /**
         * Assert that the values are equal.
         * @param expected The assumed Assert value.
         * @param actual The exact Assert value.
         * @param message The string used to describe the Assert.
         * @param comparer Method to compare expected and actual arguments have the same value.
         */
        public static AreEqual($expected: number, $actual: number, $message: string):void;
        /**
         * Assert that the values are not equal.
         * @param expected The assumed Assert value.
         * @param actual The exact Assert value.
         * @param message The string used to describe the Assert.
         * @param comparer Method to compare expected and actual arguments have the same value.
         */
        public static AreNotEqual($expected: number, $actual: number):void;
        /**
         * Assert that the values are not equal.
         * @param expected The assumed Assert value.
         * @param actual The exact Assert value.
         * @param message The string used to describe the Assert.
         * @param comparer Method to compare expected and actual arguments have the same value.
         */
        public static AreNotEqual($expected: number, $actual: number, $message: string):void;
        /**
         * Assert that the values are equal.
         * @param expected The assumed Assert value.
         * @param actual The exact Assert value.
         * @param message The string used to describe the Assert.
         * @param comparer Method to compare expected and actual arguments have the same value.
         */
        public static AreEqual($expected: bigint, $actual: bigint):void;
        /**
         * Assert that the values are equal.
         * @param expected The assumed Assert value.
         * @param actual The exact Assert value.
         * @param message The string used to describe the Assert.
         * @param comparer Method to compare expected and actual arguments have the same value.
         */
        public static AreEqual($expected: bigint, $actual: bigint, $message: string):void;
        /**
         * Assert that the values are not equal.
         * @param expected The assumed Assert value.
         * @param actual The exact Assert value.
         * @param message The string used to describe the Assert.
         * @param comparer Method to compare expected and actual arguments have the same value.
         */
        public static AreNotEqual($expected: bigint, $actual: bigint):void;
        /**
         * Assert that the values are not equal.
         * @param expected The assumed Assert value.
         * @param actual The exact Assert value.
         * @param message The string used to describe the Assert.
         * @param comparer Method to compare expected and actual arguments have the same value.
         */
        public static AreNotEqual($expected: bigint, $actual: bigint, $message: string):void;
        /**
         * Assert that the values are equal.
         * @param expected The assumed Assert value.
         * @param actual The exact Assert value.
         * @param message The string used to describe the Assert.
         * @param comparer Method to compare expected and actual arguments have the same value.
         */
        public static AreEqual($expected: bigint, $actual: bigint):void;
        /**
         * Assert that the values are equal.
         * @param expected The assumed Assert value.
         * @param actual The exact Assert value.
         * @param message The string used to describe the Assert.
         * @param comparer Method to compare expected and actual arguments have the same value.
         */
        public static AreEqual($expected: bigint, $actual: bigint, $message: string):void;
        /**
         * Assert that the values are not equal.
         * @param expected The assumed Assert value.
         * @param actual The exact Assert value.
         * @param message The string used to describe the Assert.
         * @param comparer Method to compare expected and actual arguments have the same value.
         */
        public static AreNotEqual($expected: bigint, $actual: bigint):void;
        /**
         * Assert that the values are not equal.
         * @param expected The assumed Assert value.
         * @param actual The exact Assert value.
         * @param message The string used to describe the Assert.
         * @param comparer Method to compare expected and actual arguments have the same value.
         */
        public static AreNotEqual($expected: bigint, $actual: bigint, $message: string):void;
        
                    
    }
    /**
     * An exception that is thrown on a failure. Assertions.Assert._raiseExceptions needs to be set to true.
     */
    class AssertionException extends System.Exception {
        
        public get Message(): string;
        
        public constructor($message: string, $userMessage: string);
        
                    
    }
    
}
declare module 'UnityEngine.Assertions.Comparers' {

    import * as System from 'System';
        
    /**
     * A float comparer used by Assertions.Assert performing approximate comparison.
     */
    class FloatComparer extends System.Object {
        /**
         * Default instance of a comparer class with deafult error epsilon and absolute error check.
         */
        public static s_ComparerWithDefaultTolerance: FloatComparer;
        /**
         * Default epsilon used by the comparer.
         */
        public static kEpsilon: number;
        /**
         * Creates an instance of the comparer.
         * @param relative Should a relative check be used when comparing values? By default, an absolute check will be used.
         * @param error Allowed comparison error. By default, the FloatComparer.kEpsilon is used.
         */
        public constructor();
        /**
         * Creates an instance of the comparer.
         * @param relative Should a relative check be used when comparing values? By default, an absolute check will be used.
         * @param error Allowed comparison error. By default, the FloatComparer.kEpsilon is used.
         */
        public constructor($relative: boolean);
        /**
         * Creates an instance of the comparer.
         * @param relative Should a relative check be used when comparing values? By default, an absolute check will be used.
         * @param error Allowed comparison error. By default, the FloatComparer.kEpsilon is used.
         */
        public constructor($error: number);
        /**
         * Creates an instance of the comparer.
         * @param relative Should a relative check be used when comparing values? By default, an absolute check will be used.
         * @param error Allowed comparison error. By default, the FloatComparer.kEpsilon is used.
         */
        public constructor($error: number, $relative: boolean);
        
        public Equals($a: number, $b: number):boolean;
        
        public GetHashCode($obj: number):number;
        /**
         * Performs equality check with absolute error check.
         * @param expected Expected value.
         * @param actual Actual value.
         * @param error Comparison error.
         * @returns Result of the comparison.
         */
        public static AreEqual($expected: number, $actual: number, $error: number):boolean;
        /**
         * Performs equality check with relative error check.
         * @param expected Expected value.
         * @param actual Actual value.
         * @param error Comparison error.
         * @returns Result of the comparison.
         */
        public static AreEqualRelative($expected: number, $actual: number, $error: number):boolean;
        
                    
    }
    
}
declare module 'UnityEngine.Apple' {

    import * as System from 'System';
        
    /**
     * Destination of Frame Capture
     * This is a wrapper for MTLCaptureDestination.
     */
    enum FrameCaptureDestination { DevTools = 1, GPUTraceDocument = 2 }
    /**
     * Interface to control XCode Frame Capture.
     */
    class FrameCapture extends System.Object {
        /**
         * Is Capture destination supported.
         */
        public static IsDestinationSupported($dest: FrameCaptureDestination):boolean;
        /**
         * Begin Capture in XCode frame debugger.
         */
        public static BeginCaptureToXcode():void;
        /**
         * Begin Capture to the specified file.
         */
        public static BeginCaptureToFile($path: string):void;
        /**
         * End Capture.
         */
        public static EndCapture():void;
        /**
         * Begin capture to Xcode at the beginning of the next frame, and end it at the end of the next frame.
         */
        public static CaptureNextFrameToXcode():void;
        /**
         * Begin capture to the specified file at the beginning of the next frame, and end it at the end of the next frame.
         */
        public static CaptureNextFrameToFile($path: string):void;
        
                    
    }
    
}
declare module 'UnityEngine.Apple.ReplayKit' {

    import * as System from 'System';
    import * as UnityEngine_Apple_ReplayKit_ReplayKit from 'UnityEngine.Apple.ReplayKit.ReplayKit';
        
    /**
     * ReplayKit is only available on certain iPhone, iPad and iPod Touch devices running iOS 9.0 or later.
     */
    class ReplayKit extends System.Object {
        /**
         * A boolean that indicates whether the ReplayKit API is available (where True means available). (Read Only)
         */
        public static get APIAvailable(): boolean;
        /**
         * A Boolean that indicates whether ReplayKit broadcasting API is available (true means available) (Read Only).
         * Check the value of this property before making ReplayKit broadcasting API calls. On iOS versions prior to iOS 10, this property will have a value of false.
         */
        public static get broadcastingAPIAvailable(): boolean;
        /**
         * A boolean value that indicates that a new recording is available for preview (where True means available). (Read Only)
         */
        public static get recordingAvailable(): boolean;
        /**
         * A boolean that indicates whether ReplayKit is making a recording (where True means a recording is in progress). (Read Only)
         */
        public static get isRecording(): boolean;
        /**
         * Boolean property that indicates whether a broadcast is currently in progress (Read Only).
         */
        public static get isBroadcasting(): boolean;
        /**
         * Boolean property that indicates whether a broadcast is currently paused (Read Only).
         */
        public static get isBroadcastingPaused(): boolean;
        /**
         * A boolean that indicates whether ReplayKit is currently displaying a preview controller. (Read Only)
         */
        public static get isPreviewControllerActive(): boolean;
        /**
         * Camera enabled status. True, if camera enabled; false otherwise.
         */
        public static get cameraEnabled(): boolean;
        public static set cameraEnabled(value: boolean);
        /**
         * Microphone enabled status. True, if microphone enabled; false otherwise.
         */
        public static get microphoneEnabled(): boolean;
        public static set microphoneEnabled(value: boolean);
        /**
         * A string property that contains an URL used to redirect the user to an on-going or completed broadcast (Read Only).
         */
        public static get broadcastURL(): string;
        /**
         * A string value of the last error incurred by the ReplayKit: Either 'Failed to get Screen Recorder' or 'No recording available'. (Read Only)
         */
        public static get lastError(): string;
        /**
         * Start a new recording.
         * @param enableMicrophone Enable or disable the microphone while making a recording. Enabling the microphone allows you to include user commentary while recording. The default value is false.
         * @param enableCamera Enable or disable the camera while making a recording. Enabling camera allows you to include user camera footage while recording. The default value is false. To actually include camera footage in your recording, you also have to call ShowCameraPreviewAt as well to position the preview view.
         * @returns A boolean value of True if recording started successfully or False if an error occurred.
         */
        public static StartRecording($enableMicrophone: boolean, $enableCamera: boolean):boolean;
        
        public static StartRecording($enableMicrophone: boolean):boolean;
        
        public static StartRecording():boolean;
        
        public static StartBroadcasting($callback: UnityEngine_Apple_ReplayKit_ReplayKit.BroadcastStatusCallback, $enableMicrophone: boolean, $enableCamera: boolean):void;
        
        public static StartBroadcasting($callback: UnityEngine_Apple_ReplayKit_ReplayKit.BroadcastStatusCallback, $enableMicrophone: boolean):void;
        
        public static StartBroadcasting($callback: UnityEngine_Apple_ReplayKit_ReplayKit.BroadcastStatusCallback):void;
        /**
         * Stop the current recording.
         * @returns A boolean value of True if recording stopped successfully or False if an error occurred.
         */
        public static StopRecording():boolean;
        /**
         * Stops current broadcast.
         * Will terminate currently on-going broadcast. If no broadcast is in progress, does nothing.
         */
        public static StopBroadcasting():void;
        /**
         * Pauses current broadcast.
         * Will pause currently on-going broadcast. If no broadcast is in progress, does nothing.
         */
        public static PauseBroadcasting():void;
        /**
         * Resumes current broadcast.
         * Will resume currently on-going broadcast. If no broadcast is in progress, does nothing.
         */
        public static ResumeBroadcasting():void;
        /**
         * Preview the current recording
         * @returns A boolean value of True if the video preview window opened successfully or False if an error occurred.
         */
        public static Preview():boolean;
        /**
         * Discard the current recording.
         * @returns A boolean value of True if the recording was discarded successfully or False if an error occurred.
         */
        public static Discard():boolean;
        
        public static ShowCameraPreviewAt($posX: number, $posY: number):boolean;
        /**
         * Shows camera preview at coordinates posX and posY. The preview is width by height in size.
         */
        public static ShowCameraPreviewAt($posX: number, $posY: number, $width: number, $height: number):boolean;
        /**
         * Hide the camera preview view.
         */
        public static HideCameraPreview():void;
        
                    
    }
    
}
declare module 'UnityEngine.Apple.ReplayKit.ReplayKit' {

    import * as System from 'System';
        
    /**
     * Function called at the completion of broadcast startup.
     * @param hasStarted This parameter will be true if the broadcast started successfully and false in the event of an error.
     * @param errorMessage In the event of failure to start a broadcast, this parameter contains the associated error message.
     */
    type BroadcastStatusCallback = (hasStarted: boolean, errorMessage: string) => void;
    var BroadcastStatusCallback: {new (func: (hasStarted: boolean, errorMessage: string) => void): BroadcastStatusCallback;}
    
}
declare module 'UnityEngine.TestTools' {

    import * as System from 'System';
    import * as System_Reflection from 'System.Reflection';
        
    /**
     * Allows you to exclude an Assembly, Class, Constructor, Method or Struct from TestTools.Coverage.
     */
    class ExcludeFromCoverageAttribute extends System.Attribute {
        
        public constructor();
        
                    
    }
    /**
     * Describes a covered sequence point used by TestTools.Coverage. For an example of typical usage, see TestTools.Coverage.GetSequencePointsFor.
     */
    class CoveredSequencePoint extends System.ValueType {
        /**
         * The method covered by the sequence point.
         */
        public method: System_Reflection.MethodBase;
        /**
         * The offset in bytes from the start of the method to the first Intermediate Language instruction of this sequence point.
         */
        public ilOffset: number;
        /**
         * The number of times the sequence point has been visited.
         */
        public hitCount: number;
        /**
         * The name of the file that contains the sequence point.
         */
        public filename: string;
        /**
         * The line number of the file that contains the sequence point.
         */
        public line: number;
        /**
         * The column number of the line of the file that contains the sequence point.
         */
        public column: number;
        
                    
    }
    /**
     * Describes the summary of the code coverage for the specified method used by TestTools.Coverage. For an example of typical usage, see TestTools.Coverage.GetStatsFor.
     */
    class CoveredMethodStats extends System.ValueType {
        /**
         * The covered method.
         */
        public method: System_Reflection.MethodBase;
        /**
         * The total number of sequence points in the method.
         */
        public totalSequencePoints: number;
        /**
         * The total number of uncovered sequence points in the method.
         */
        public uncoveredSequencePoints: number;
        
        public ToString():string;
        
                    
    }
    /**
     * Describes the interface for the code coverage data exposed by mono.
     */
    class Coverage extends System.Object {
        /**
         * Enables or disables code coverage. Note that Code Coverage can affect the performance.
         * @returns Returns true if code coverage is enabled; otherwise, returns false.
         */
        public static get enabled(): boolean;
        public static set enabled(value: boolean);
        /**
         * Returns the coverage sequence points for the method you specify. See CoveredSequencePoint for more information about the coverage data this method returns.
         * @param method The method to get the sequence points for.
         * @returns Array of sequence points.
         */
        public static GetSequencePointsFor($method: System_Reflection.MethodBase):CoveredSequencePoint[];
        /**
         * Returns the coverage summary for the specified method. See CoveredMethodStats for more information about the coverage statistics returned by this method.
         * @param method The method to get coverage statistics for.
         * @returns Coverage summary.
         */
        public static GetStatsFor($method: System_Reflection.MethodBase):CoveredMethodStats;
        /**
         * Returns an array of coverage summaries for the specified array of methods.
         * @param methods The array of methods.
         * @returns Array of coverage summaries.
         */
        public static GetStatsFor($methods: System_Reflection.MethodBase[]):CoveredMethodStats[];
        /**
         * Returns an array of coverage summaries for the specified type.
         * @param type The type.
         * @returns Array of coverage summaries.
         */
        public static GetStatsFor($type: System.Type):CoveredMethodStats[];
        /**
         * Returns the coverage summary for all methods that have been called since either the Unity process was started or Coverage.ResetAll() has been called.
         * @returns Array of coverage summaries.
         */
        public static GetStatsForAllCoveredMethods():CoveredMethodStats[];
        /**
         * Resets the coverage data for the specified method.
         * @param method The method.
         */
        public static ResetFor($method: System_Reflection.MethodBase):void;
        /**
         * Resets all coverage data.
         */
        public static ResetAll():void;
        
                    
    }
    
}

